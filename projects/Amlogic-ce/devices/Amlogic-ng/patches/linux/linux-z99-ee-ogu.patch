From 79538b9ad78f086a1fe9c2edf6e6391f8fbce5a2 Mon Sep 17 00:00:00 2001
From: 7Ji <pugokushin@gmail.com>
Date: Mon, 10 Oct 2022 15:47:13 +0800
Subject: [PATCH] OGU: introduce

---
 arch/arm64/Kconfig.platforms                  |    27 +
 arch/arm64/boot/dts/amlogic/Makefile          |     1 +
 .../amlogic/g12b_s922x_odroid_go_ultra.dts    |  1124 +
 .../boot/dts/amlogic/meson64_gou_joypad.dtsi  |   218 +
 .../boot/dts/amlogic/meson64_gou_panel.dtsi   |   214 +
 .../boot/dts/amlogic/meson64_gou_pmic.dtsi    |   474 +
 arch/arm64/kernel/setup.c                     |     9 +-
 drivers/amlogic/media/osd/osd_fb.c            |   104 +-
 .../vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c     |    10 +
 drivers/amlogic/media/vout/lcd/Makefile       |     2 +-
 .../amlogic/media/vout/lcd/lcd_clk_config.c   |  1373 +-
 .../amlogic/media/vout/lcd/lcd_clk_config.h   |    15 -
 drivers/amlogic/media/vout/lcd/lcd_clk_ctrl.h |    78 +-
 drivers/amlogic/media/vout/lcd/lcd_common.c   |   379 +-
 drivers/amlogic/media/vout/lcd/lcd_common.h   |    66 +-
 drivers/amlogic/media/vout/lcd/lcd_debug.c    |  2049 +-
 drivers/amlogic/media/vout/lcd/lcd_debug.h    |    42 -
 .../media/vout/lcd/lcd_extern/ext_default.c   |   432 +-
 .../media/vout/lcd/lcd_extern/i2c_CS602.c     |     6 +-
 .../media/vout/lcd/lcd_extern/lcd_extern.c    |   641 +-
 .../media/vout/lcd/lcd_extern/mipi_ST7701.c   |    66 +-
 drivers/amlogic/media/vout/lcd/lcd_notify.c   |    39 +-
 .../amlogic/media/vout/lcd/lcd_phy_config.c   |   880 +-
 .../amlogic/media/vout/lcd/lcd_phy_config.h   |     8 -
 drivers/amlogic/media/vout/lcd/lcd_reg.c      |   313 +-
 drivers/amlogic/media/vout/lcd/lcd_reg.h      |    51 +-
 .../media/vout/lcd/lcd_tablet/lcd_drv.c       |   211 +-
 .../media/vout/lcd/lcd_tablet/lcd_tablet.c    |   212 +-
 drivers/amlogic/media/vout/lcd/lcd_tcon.c     |  2489 +-
 drivers/amlogic/media/vout/lcd/lcd_tcon.h     |   176 +-
 drivers/amlogic/media/vout/lcd/lcd_tcon_hw.c  |  1316 -
 drivers/amlogic/media/vout/lcd/lcd_tcon_ref.h | 40993 ++++++++++++++++
 .../amlogic/media/vout/lcd/lcd_tv/lcd_drv.c   |   416 +-
 .../amlogic/media/vout/lcd/lcd_tv/lcd_tv.c    |   427 +-
 drivers/amlogic/media/vout/lcd/lcd_unifykey.c |   136 +-
 drivers/amlogic/media/vout/lcd/lcd_vout.c     |   260 +-
 .../amlogic/media/vout/vout_serve/Makefile    |     2 +-
 .../amlogic/media/vout/vout_serve/dummy_lcd.c |   661 +
 .../media/vout/vout_serve/dummy_venc.c        |  1691 -
 .../media/vout/vout_serve/vout2_notify.c      |    56 +-
 .../media/vout/vout_serve/vout2_serve.c       |   178 +-
 .../amlogic/media/vout/vout_serve/vout_func.c |   219 +-
 .../amlogic/media/vout/vout_serve/vout_func.h |    28 +-
 .../media/vout/vout_serve/vout_notify.c       |    62 +-
 .../amlogic/media/vout/vout_serve/vout_reg.c  |    93 -
 .../amlogic/media/vout/vout_serve/vout_reg.h  |   185 +-
 .../media/vout/vout_serve/vout_serve.c        |   452 +-
 .../media/vout/vout_serve/vout_sys_serve.c    |   212 -
 drivers/amlogic/mmc/aml_sd_emmc.c             |    26 +-
 drivers/base/dma-contiguous.c                 |     1 +
 drivers/clk/clk-rk808.c                       |    96 +-
 drivers/input/joystick/Kconfig                |     6 +
 drivers/input/joystick/Makefile               |     1 +
 drivers/input/joystick/odroid-gou-joypad.c    |   949 +
 drivers/input/misc/Kconfig                    |     6 +
 drivers/input/misc/Makefile                   |     1 +
 drivers/input/misc/rk8xx-pwrkey.c             |   173 +
 drivers/mfd/rk808.c                           |  1529 +-
 drivers/pinctrl/Kconfig                       |     9 +
 drivers/pinctrl/Makefile                      |     1 +
 drivers/pinctrl/pinctrl-rk805.c               |   689 +
 drivers/power/supply/Kconfig                  |    16 +
 drivers/power/supply/Makefile                 |     2 +
 drivers/power/supply/rk818_battery.c          |  3623 ++
 drivers/power/supply/rk818_battery.h          |   168 +
 drivers/power/supply/rk818_charger.c          |  1992 +
 drivers/regulator/rk808-regulator.c           |   968 +-
 drivers/rtc/rtc-rk808.c                       |    95 +-
 include/linux/amlogic/media/vout/lcd/aml_bl.h |    15 +-
 .../linux/amlogic/media/vout/lcd/aml_lcd.h    |    40 +-
 .../linux/amlogic/media/vout/lcd/aml_ldim.h   |   205 +-
 .../linux/amlogic/media/vout/lcd/lcd_extern.h |    24 +-
 .../linux/amlogic/media/vout/lcd/lcd_notify.h |    26 +-
 .../amlogic/media/vout/lcd/lcd_tcon_data.h    |   256 -
 .../amlogic/media/vout/lcd/lcd_unifykey.h     |     4 +-
 .../linux/amlogic/media/vout/lcd/lcd_vout.h   |    32 +-
 .../linux/amlogic/media/vout/lcd/ldim_alg.h   |    86 +-
 include/linux/clk-provider.h                  |     3 +-
 include/linux/extcon.h                        |     1 +
 include/linux/mfd/rk808.h                     |   856 +-
 include/linux/platform_data/emuelec.h         |    19 +
 include/linux/power/rk_usbbc.h                |    44 +
 include/linux/rk_keys.h                       |    19 +
 lib/radix-tree.c                              |     2 +
 mm/cma.c                                      |     2 +
 sound/soc/codecs/Kconfig                      |     6 +
 sound/soc/codecs/Makefile                     |     2 +
 sound/soc/codecs/rk817_codec.c                |  1291 +
 sound/soc/codecs/rk817_codec.h                |   220 +
 89 files changed, 59570 insertions(+), 13030 deletions(-)
 create mode 100644 arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts
 create mode 100755 arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
 create mode 100755 arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
 create mode 100755 arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
 delete mode 100644 drivers/amlogic/media/vout/lcd/lcd_tcon_hw.c
 create mode 100644 drivers/amlogic/media/vout/lcd/lcd_tcon_ref.h
 create mode 100644 drivers/amlogic/media/vout/vout_serve/dummy_lcd.c
 delete mode 100644 drivers/amlogic/media/vout/vout_serve/dummy_venc.c
 delete mode 100644 drivers/amlogic/media/vout/vout_serve/vout_reg.c
 delete mode 100644 drivers/amlogic/media/vout/vout_serve/vout_sys_serve.c
 create mode 100755 drivers/input/joystick/odroid-gou-joypad.c
 create mode 100755 drivers/input/misc/rk8xx-pwrkey.c
 create mode 100755 drivers/pinctrl/pinctrl-rk805.c
 create mode 100644 drivers/power/supply/rk818_battery.c
 create mode 100644 drivers/power/supply/rk818_battery.h
 create mode 100644 drivers/power/supply/rk818_charger.c
 delete mode 100644 include/linux/amlogic/media/vout/lcd/lcd_tcon_data.h
 create mode 100644 include/linux/platform_data/emuelec.h
 create mode 100755 include/linux/power/rk_usbbc.h
 create mode 100755 include/linux/rk_keys.h
 create mode 100755 sound/soc/codecs/rk817_codec.c
 create mode 100755 sound/soc/codecs/rk817_codec.h

diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 2f9c2a95c40e..37c8c198892b 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -232,4 +232,31 @@ config ARCH_ZYNQMP
 	help
 	  This enables support for Xilinx ZynqMP Family
 
+config ARCH_MESON64_ODROID_COMMON
+	bool "Hardkkernel's ODROID Single Board Computer Common"
+	help
+	  Common definitions for AMLogic, Inc.
+	  based boards from Hardkernel,
+	  such as the ODroid C4 or ODroid N2
+	  Single Board Computers.
+
+config ARCH_MESON64_ODROIDC4
+	bool "Hardkkernel's ODROID-C4 Single Board Computer"
+	select ARCH_MESON64_ODROID_COMMON
+	select AMLOGIC_POWER
+	help
+	  This enables support for the board ODROID-C4
+	  of Hardkernel which is based on
+	  ARMv8 SoC of
+	  AMLogic, Inc.
+
+config ARCH_MESON64_ODROIDN2
+	bool "Hardkkernel's ODROID-N2 Single Board Computer"
+	select ARCH_MESON64_ODROID_COMMON
+	select DRM_BIFROST if DRM_MESON
+	help
+	  This enables support for the board ODROID-N2 of Hardkernel
+	  which is based on ARMv8 SoC of AMLogic, Inc.
+
+
 endmenu
diff --git a/arch/arm64/boot/dts/amlogic/Makefile b/arch/arm64/boot/dts/amlogic/Makefile
index 3de9711b12b7..fa5a5e6fb0d4 100644
--- a/arch/arm64/boot/dts/amlogic/Makefile
+++ b/arch/arm64/boot/dts/amlogic/Makefile
@@ -22,6 +22,7 @@ dtb-$(CONFIG_ARM64) += g12b_s922x_minix_u22xj_max_rev_a.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_n2.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_n2plus.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_n2plus_rev_c.dtb
+dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_go_ultra.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_ugoos_am6_2g.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_ugoos_am6_4g.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_ugoos_am6_rev_a_2g.dtb
diff --git a/arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts b/arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts
new file mode 100644
index 000000000000..0d7b0fb1bfa3
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts
@@ -0,0 +1,1124 @@
+// All g12b devices should base on either coreelec_g12b.dtsi or coreelec_g12b_a.dtsi
+#include "coreelec_g12b.dtsi"
+// OGU specific: Power Management Integrated Controller
+#include "meson64_gou_pmic.dtsi"
+// OGU specific: LCD panel
+#include "meson64_gou_panel.dtsi"
+// OGU specific: GPIO Joypad
+#include "meson64_gou_joypad.dtsi"
+
+/ {
+    model = "Hardkernel ODROID-GOU";
+    coreelec-dt-id = "g12b_s922x_odroid_go_ultra"; // Yeah we will still use coreelec-dt-id, never re-invent the wheel huh?
+    amlogic-dt-id = "g12b_ogu";
+
+    // /delete-node/ memory@00000000; // Different from N2, we use that, since it's already 2G
+	/delete-node/ bt-dev; // No BT or Wi-Fi included
+	/delete-node/ wifi;
+	/delete-node/ wifi_pwm_conf;
+	/delete-node/ adc_keypad;
+	/delete-node/ unifykey;
+	// /delete-node/ rtc;
+    /delete-node/ videosync;
+    /delete-node/ dummy_venc;
+    /delete-node/ video_composer;
+    /delete-node/ meson_uvm;
+    /delete-node/ vcodec_dec;
+    /delete-node/ jpegenc;
+    /delete-node/ gpioleds;
+    /delete-node/ cvbsout;
+    /delete-node/ linux,picdec;
+    /delete-node/ picdec;
+    /delete-node/ multi-di;
+
+    vout {
+        /delete-property/ fr_policy;
+    };
+
+    vout2 { // This is not a label, so it can't be simply disabled at the end
+        /delete-property/ fr_policy;
+        status = "disabled";
+    };
+
+    gpiomem {
+		compatible = "amlogic, gpiomem";
+		reg = <0x0 0xff634000 0x0 0x1000>,	/* GPIO banks */
+			<0x0 0xff800000 0x0 0x1000>;	/* GPIO_AO bank */
+		status = "okay";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+        // /delete-node/ linux,ion-fb;
+        // /delete-node/ linux,vdin1_cma;
+        // /delete-node/ linux,galcore;
+        // /delete-node/ linux,isp_cma;
+        // /delete-node/ linux,adapt_cma;
+        // /delete-node/ linux,vdin0_cma;
+
+		/* global autoconfigured region for contiguous allocations */
+		ramoops@0x07400000 {
+			compatible = "ramoops";
+			reg = <0x0 0x07400000 0x0 0x00100000>;
+			record-size = <0x8000>;
+			console-size = <0x8000>;
+			ftrace-size = <0x40000>;
+            /delete-property/ pmsg-size;
+		};
+
+		secmon_reserved:linux,secmon {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x400000>;
+			alignment = <0x0 0x400000>;
+			alloc-ranges = <0x0 0x05000000 0x0 0x400000>;
+			clear-map;
+		};
+
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
+		logo_reserved:linux,meson-fb {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x800000>;
+			alignment = <0x0 0x400000>;
+			alloc-ranges = <0x0 0x3d800000 0x0 0x800000>;
+		};
+		ion_cma_reserved:linux,ion-dev {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x400000>;
+		};
+
+		/*di CMA pool */
+		di_cma_reserved:linux,di_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			/* buffer_size = 3621952(yuv422 8bit)
+			 *  | 4736064(yuv422 10bit)
+			 *  | 4074560(yuv422 10bit full pack mode)
+			 * 10x3621952=34.6M(0x23) support 8bit
+			 * 10x4736064=45.2M(0x2e) support 12bit
+			 * 10x4074560=40M(0x28) support 10bit
+			 */
+			size = <0x0 0x02800000>;
+			alignment = <0x0 0x400000>;
+		};
+		/*  POST PROCESS MANAGER */
+		ppmgr_reserved:linux,ppmgr {
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
+		};
+
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			/* ion_codec_mm max can alloc size 80M*/
+			size = <0x0 0x13400000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+			clear-map;
+		};
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x0>;
+			alignment = <0x0 0x100000>;
+			//no-map;
+		};
+	};
+
+	codec_mm {
+		compatible = "amlogic, codec, mm";
+		memory-region = <&codec_mm_cma &codec_mm_reserved>;
+		dev_name = "codec_mm";
+		status = "okay";
+	};
+
+	ppmgr {
+		compatible = "amlogic, ppmgr";
+		memory-region = <&ppmgr_reserved>;
+		dev_name = "ppmgr";
+		status = "okay";
+	};
+
+	deinterlace {
+		compatible = "amlogic, deinterlace";
+		status = "okay";
+		/* 0:use reserved; 1:use cma; 2:use cma as reserved */
+		flag_cma = <1>;
+		memory-region = <&di_cma_reserved>;
+		interrupts = <0 46 1
+				0 40 1>;
+		interrupt-names = "pre_irq", "post_irq";
+        clocks = <&clkc CLKID_VPU_CLKB_TMP_COMP>,
+			<&clkc CLKID_VPU_CLKB_COMP>;
+		clock-names = "vpu_clkb_tmp_composite",
+			"vpu_clkb_composite";
+		clock-range = <334 667>;
+		/* buffer-size = <3621952>;(yuv422 8bit) */
+		buffer-size = <4074560>;/*yuv422 fullpack*/
+		/* reserve-iomap = "true"; */
+		/* if enable nr10bit, set nr10bit-support to 1 */
+		post-wr-support = <1>;
+		nr10bit-support = <1>;
+		nrds-enable = <1>;
+		pps-enable = <1>;
+	};
+
+	ionvideo {
+		compatible = "amlogic, ionvideo";
+		dev_name = "ionvideo";
+		status = "okay";
+	};
+
+	efuse: efuse{
+		compatible = "amlogic, efuse";
+		read_cmd = <0x82000030>;
+		write_cmd = <0x82000031>;
+		get_max_cmd = <0x82000033>;
+		key = <&efusekey>;
+		clocks = <&clkc CLKID_EFUSE>;
+		clock-names = "efuse_clk";
+		status = "okay";
+	};
+
+	efusekey:efusekey{
+		keynum = <1>;
+		key0 = <&key_0>;
+        /delete-property/ key1;
+        /delete-property/ key2;
+        /delete-property/ key3;
+        /delete-node/ key_1;
+        /delete-node/ key_2;
+        /delete-node/ key_3;
+
+		key_0: key_0 {
+			keyname = "uuid";
+			offset = <0>;
+			size = <32>;
+		};
+	};//End efusekey
+
+	amlvecm {
+		compatible = "amlogic, vecm";
+		dev_name = "aml_vecm";
+		status = "okay";
+		gamma_en = <0>;/*1:enabel ;0:disable*/
+		wb_en = <0>;/*1:enabel ;0:disable*/
+		cm_en = <0>;/*1:enabel ;0:disable*/
+	};
+	amdolby_vision {
+		compatible = "amlogic, dolby_vision_g12a";
+		dev_name = "aml_amdolby_vision_driver";
+		status = "okay";
+		tv_mode = <0>;/*1:enabel ;0:disable*/
+	};
+
+	/* Audio Related start */
+	dummy_codec:dummy{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_dummy_codec";
+		status = "okay";
+	};
+	amlogic_codec:t9015{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_codec_T9015";
+		reg = <0x0 0xFF632000 0x0 0x2000>;
+		is_auge_used = <1>; /* meson or auge chipset used */
+		tdmout_index = <1>;
+		status = "okay";
+	};
+	audio_effect:eqdrc{
+		/*eq_enable = <1>;*/
+		/*drc_enable = <1>;*/
+		/*
+		 * 0:tdmout_a
+		 * 1:tdmout_b
+		 * 2:tdmout_c
+		 * 3:spdifout
+		 * 4:spdifout_b
+		 */
+		eqdrc_module = <1>;
+		/* max 0xf, each bit for one lane, usually one lane */
+		lane_mask = <0x1>;
+		/* max 0xff, each bit for one channel */
+		channel_mask = <0x3>;
+	};
+	auge_sound {
+
+		compatible = "amlogic, g12a-sound-card";
+		aml-audio-card,name = "AML-AUGESOUND";
+		aml-audio-card,effect = <&audio_effect>;
+		aml-audio-card,hp-det-gpio = <&gpio_ao GPIOAO_9 GPIO_ACTIVE_LOW>;
+
+        /delete-property/ avout_mute-gpios;
+        /delete-node/ aml-audio-card,dai-link@1;
+        /delete-node/ aml-audio-card,dai-link@2;
+        /delete-node/ aml-audio-card,dai-link@3;
+		aml-audio-card,dai-link@0 {
+			format = "i2s";
+			mclk-fs = <256>;
+			bitclock-master = <&aml_tdmb>;
+			frame-master = <&aml_tdmb>;
+			continuous-clock;
+            /delete-property/ bitclock-master;
+			/delete-property/ frame-master;
+
+			cpu {
+				sound-dai = <&aml_tdmb>;
+				dai-tdm-slot-tx-mask = <1 1>;
+				dai-tdm-slot-rx-mask = <1 1>;
+				dai-tdm-slot-num = <2>;
+				dai-tdm-slot-width = <32>;
+				system-clock-frequency = <12288000>;
+			};
+			codec {
+				sound-dai = <&rk817_codec>;
+			};
+		};
+	};
+	audiolocker: locker {
+		compatible = "amlogic, audiolocker";
+		clocks = <&clkaudio CLKID_AUDIO_LOCKER_OUT
+				&clkaudio CLKID_AUDIO_LOCKER_IN
+				&clkaudio CLKID_AUDIO_MCLK_D
+				&clkaudio CLKID_AUDIO_MCLK_E
+				&clkc CLKID_MPLL1
+				&clkc CLKID_MPLL2>;
+		clock-names = "lock_out", "lock_in", "out_src",
+					"in_src", "out_calc", "in_ref";
+		interrupts = <GIC_SPI 1 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "irq";
+		frequency = <49000000>; /* pll */
+		dividor = <49>; /* locker's parent */
+		status = "okay";
+	};
+	/* Audio Related end */
+
+	cpu_opp_table0: cpu_opp_table0 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp00 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <730000>;
+		};
+		opp01 {
+			opp-hz = /bits/ 64 <667000000>;
+			opp-microvolt = <730000>;
+		};
+		opp02 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <760000>;
+		};
+		opp03 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <780000>;
+		};
+		opp04 {
+			opp-hz = /bits/ 64 <1398000000>;
+			opp-microvolt = <810000>;
+		};
+		opp05 {
+			opp-hz = /bits/ 64 <1512000000>;
+			opp-microvolt = <860000>;
+		};
+		opp06 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <900000>;
+		};
+		opp07 {
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <960000>;
+		};
+		opp08 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <1020000>;
+		};
+		opp09 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <1030000>;
+		};
+		opp10 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <1040000>;
+		};
+	};
+
+	cpu_opp_table1: cpu_opp_table1 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp00 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <730000>;
+		};
+		opp01 {
+			opp-hz = /bits/ 64 <667000000>;
+			opp-microvolt = <730000>;
+		};
+		opp02 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <730000>;
+		};
+		opp03 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <750000>;
+		};
+		opp04 {
+			opp-hz = /bits/ 64 <1398000000>;
+			opp-microvolt = <770000>;
+		};
+		opp05 {
+			opp-hz = /bits/ 64 <1512000000>;
+			opp-microvolt = <770000>;
+		};
+		opp06 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <780000>;
+		};
+		opp07 {
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <790000>;
+		};
+		opp08 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <830000>;
+		};
+		opp09 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <860000>;
+		};
+		opp10 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <910000>;
+		};
+		opp11 {
+			opp-hz = /bits/ 64 <2100000000>;
+			opp-microvolt = <960000>;
+		};
+		opp12 {
+			opp-hz = /bits/ 64 <2208000000>;
+			opp-microvolt = <1030000>;
+		};
+		opp13 {
+			opp-hz = /bits/ 64 <2304000000>;
+			opp-microvolt = <1030000>;
+		};
+		opp14 {
+			opp-hz = /bits/ 64 <2400000000>;
+			opp-microvolt = <1040000>;
+		};
+	};
+
+	cpufreq-meson {
+		compatible = "amlogic, cpufreq-meson";
+		status = "okay";
+	};
+
+	gpio_keypad {
+		compatible = "amlogic, gpio_keypad";
+		status = "disabled";
+		scan_period = <20>;
+		key_num = <1>;
+		key_name = "power";
+		key_code = <116>;
+		/delete-property/ key-gpios;
+		/delete-property/ detect_mode;
+		/delete-property/ reg;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		status = "okay";
+		sys_led {
+			label="sys_led";
+			gpios=<&gpio_ao GPIOAO_11 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+    soc {
+        ion_dev {
+            memory-region = <&ion_cma_reserved>;
+        };
+    };
+
+    remote:rc@0xff808040 {
+        compatible = "amlogic, aml_remote";
+        dev_name = "meson-remote";
+        reg = <0x0 0xff808040 0x00 0x44>,
+        <0x0 0xff808000 0x00 0x20>;
+        status = "okay";
+        protocol = <0x01>;
+        interrupts = <0 196 1>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&remote_pins>;
+        map = <&custom_maps>;
+        max_frame_time = <200>;
+    };
+
+    custom_maps:custom_maps {
+        mapnum = <3>;
+        map0 = <&map_0>;
+        map1 = <&map_1>;
+        map2 = <&map_2>;
+        map_0: map_0{
+            mapname = "amlogic-remote-1";
+            customcode = <0xfb04>;
+            release_delay = <80>;
+            size = <50>;
+            keymap = <((((0x47) & 0xFFFF)<<16) | ((11) & 0xFFFF))
+                ((((0x13) & 0xFFFF)<<16) | ((2) & 0xFFFF))
+                ((((0x10) & 0xFFFF)<<16) | ((3) & 0xFFFF))
+                ((((0x11) & 0xFFFF)<<16) | ((4) & 0xFFFF))
+                ((((0x0F) & 0xFFFF)<<16) | ((5) & 0xFFFF))
+                ((((0x0C) & 0xFFFF)<<16) | ((6) & 0xFFFF))
+                ((((0x0D) & 0xFFFF)<<16) | ((7) & 0xFFFF))
+                ((((0x0B) & 0xFFFF)<<16) | ((8) & 0xFFFF))
+                ((((0x08) & 0xFFFF)<<16) | ((9) & 0xFFFF))
+                ((((0x09) & 0xFFFF)<<16) | ((10) & 0xFFFF))
+                ((((0x5C) & 0xFFFF)<<16) | ((97) & 0xFFFF))
+                ((((0x51) & 0xFFFF)<<16) | ((61) & 0xFFFF))
+                ((((0x50) & 0xFFFF)<<16) | ((62) & 0xFFFF))
+                ((((0x40) & 0xFFFF)<<16) | ((63) & 0xFFFF))
+                ((((0x4d) & 0xFFFF)<<16) | ((64) & 0xFFFF))
+                ((((0x43) & 0xFFFF)<<16) | ((65) & 0xFFFF))
+                ((((0x17) & 0xFFFF)<<16) | ((66) & 0xFFFF))
+                ((((0x00) & 0xFFFF)<<16) | ((67) & 0xFFFF))
+                ((((0x01) & 0xFFFF)<<16) | ((68) & 0xFFFF))
+                ((((0x16) & 0xFFFF)<<16) | ((87) & 0xFFFF))
+                ((((0x49) & 0xFFFF)<<16) | ((14) & 0xFFFF))
+                ((((0x06) & 0xFFFF)<<16) | ((130) & 0xFFFF))
+                ((((0x14) & 0xFFFF)<<16) | ((131) & 0xFFFF))
+                ((((0x44) & 0xFFFF)<<16) | ((103) & 0xFFFF))
+                ((((0x1D) & 0xFFFF)<<16) | ((108) & 0xFFFF))
+                ((((0x1C) & 0xFFFF)<<16) | ((105) & 0xFFFF))
+                ((((0x48) & 0xFFFF)<<16) | ((106) & 0xFFFF))
+                ((((0x53) & 0xFFFF)<<16) | ((125) & 0xFFFF))
+                ((((0x45) & 0xFFFF)<<16) | ((104) & 0xFFFF))
+                ((((0x19) & 0xFFFF)<<16) | ((109) & 0xFFFF))
+                ((((0x52) & 0xFFFF)<<16) | ((119) & 0xFFFF))
+                ((((0x05) & 0xFFFF)<<16) | ((122) & 0xFFFF))
+                ((((0x59) & 0xFFFF)<<16) | ((123) & 0xFFFF))
+                ((((0x1b) & 0xFFFF)<<16) | ((120) & 0xFFFF))
+                ((((0x04) & 0xFFFF)<<16) | ((121) & 0xFFFF))
+                ((((0x1A) & 0xFFFF)<<16) | ((116) & 0xFFFF))
+                ((((0x0A) & 0xFFFF)<<16) | ((15) & 0xFFFF))
+                ((((0x0e) & 0xFFFF)<<16) | ((113) & 0xFFFF))
+                ((((0x1F) & 0xFFFF)<<16) | ((102) & 0xFFFF))
+                ((((0x1e) & 0xFFFF)<<16) | ((132) & 0xFFFF))
+                ((((0x07) & 0xFFFF)<<16) | ((133) & 0xFFFF))
+                ((((0x12) & 0xFFFF)<<16) | ((134) & 0xFFFF))
+                ((((0x54) & 0xFFFF)<<16) | ((135) & 0xFFFF))
+                ((((0x02) & 0xFFFF)<<16) | ((136) & 0xFFFF))
+                ((((0x4f) & 0xFFFF)<<16) | ((30) & 0xFFFF))
+                ((((0x42) & 0xFFFF)<<16) | ((48) & 0xFFFF))
+                ((((0x5d) & 0xFFFF)<<16) | ((46) & 0xFFFF))
+                ((((0x4c) & 0xFFFF)<<16) | ((32) & 0xFFFF))
+                ((((0x58) & 0xFFFF)<<16) | ((137) & 0xFFFF))
+                ((((0x55) & 0xFFFF)<<16) | ((140) & 0xFFFF))>;
+        };
+        map_1: map_1{
+            mapname = "amlogic-remote-2";
+            customcode = <0xfe01>;
+            release_delay = <80>;
+            size = <53>;
+            keymap = <((((0x01) & 0xFFFF)<<16) | ((2) & 0xFFFF))
+                ((((0x02) & 0xFFFF)<<16) | ((3) & 0xFFFF))
+                ((((0x03) & 0xFFFF)<<16) | ((4) & 0xFFFF))
+                ((((0x04) & 0xFFFF)<<16) | ((5) & 0xFFFF))
+                ((((0x05) & 0xFFFF)<<16) | ((6) & 0xFFFF))
+                ((((0x06) & 0xFFFF)<<16) | ((7) & 0xFFFF))
+                ((((0x07) & 0xFFFF)<<16) | ((8) & 0xFFFF))
+                ((((0x08) & 0xFFFF)<<16) | ((9) & 0xFFFF))
+                ((((0x09) & 0xFFFF)<<16) | ((10) & 0xFFFF))
+                ((((0x0a) & 0xFFFF)<<16) | ((11) & 0xFFFF))
+                ((((0x1F) & 0xFFFF)<<16) | ((0x1d2) & 0xFFFF))
+                ((((0x15) & 0xFFFF)<<16) | ((139) & 0xFFFF))
+                ((((0x16) & 0xFFFF)<<16) | ((15) & 0xFFFF))
+                ((((0x0c) & 0xFFFF)<<16) | ((0x192) & 0xFFFF))
+                ((((0x0d) & 0xFFFF)<<16) | ((0x193) & 0xFFFF))
+                ((((0x0e) & 0xFFFF)<<16) | ((115) & 0xFFFF))
+                ((((0x0f) & 0xFFFF)<<16) | ((114) & 0xFFFF))
+                ((((0x11) & 0xFFFF)<<16) | ((102) & 0xFFFF))
+                ((((0x1c) & 0xFFFF)<<16) | ((106) & 0xFFFF))
+                ((((0x1b) & 0xFFFF)<<16) | ((105) & 0xFFFF))
+                ((((0x19) & 0xFFFF)<<16) | ((103) & 0xFFFF))
+                ((((0x1a) & 0xFFFF)<<16) | ((108) & 0xFFFF))
+                ((((0x1d) & 0xFFFF)<<16) | ((28) & 0xFFFF))
+                ((((0x17) & 0xFFFF)<<16) | ((113) & 0xFFFF))
+                ((((0x49) & 0xFFFF)<<16) | ((219) & 0xFFFF))
+                ((((0x43) & 0xFFFF)<<16) | ((158) & 0xFFFF))
+                ((((0x12) & 0xFFFF)<<16) | ((0x1d5) & 0xFFFF))
+                ((((0x14) & 0xFFFF)<<16) | ((0x1d6) & 0xFFFF))
+                ((((0x18) & 0xFFFF)<<16) | ((0x1d7) & 0xFFFF))
+                ((((0x59) & 0xFFFF)<<16) | ((0x166) & 0xFFFF))
+                ((((0x5a) & 0xFFFF)<<16) | ((166) & 0xFFFF))
+                ((((0x10) & 0xFFFF)<<16) | ((116) & 0xFFFF))
+                ((((0x42) & 0xFFFF)<<16) | ((165) & 0xFFFF))
+                ((((0x44) & 0xFFFF)<<16) | ((163) & 0xFFFF))
+                ((((0x1e) & 0xFFFF)<<16) | ((168) & 0xFFFF))
+                ((((0x4b) & 0xFFFF)<<16) | ((208) & 0xFFFF))
+                ((((0x58) & 0xFFFF)<<16) | ((164) & 0xFFFF))
+                ((((0x46) & 0xFFFF)<<16) | ((130) & 0xFFFF))
+                ((((0x40) & 0xFFFF)<<16) | ((131) & 0xFFFF))
+                ((((0x38) & 0xFFFF)<<16) | ((70) & 0xFFFF))
+                ((((0x57) & 0xFFFF)<<16) | ((0x1d0) & 0xFFFF))
+                ((((0x5b) & 0xFFFF)<<16) | ((0x1d1) & 0xFFFF))
+                ((((0x54) & 0xFFFF)<<16) | ((0x18e) & 0xFFFF))
+                ((((0x4c) & 0xFFFF)<<16) | ((0x18f) & 0xFFFF))
+                ((((0x4e) & 0xFFFF)<<16) | ((0x190) & 0xFFFF))
+                ((((0x55) & 0xFFFF)<<16) | ((0x191) & 0xFFFF))
+                ((((0x53) & 0xFFFF)<<16) | ((237) & 0xFFFF))
+                ((((0x52) & 0xFFFF)<<16) | ((238) & 0xFFFF))
+                ((((0x39) & 0xFFFF)<<16) | ((212) & 0xFFFF))
+                ((((0x41) & 0xFFFF)<<16) | ((213) & 0xFFFF))
+                ((((0x0b) & 0xFFFF)<<16) | ((214) & 0xFFFF))
+                ((((0x00) & 0xFFFF)<<16) | ((216) & 0xFFFF))
+                ((((0x13) & 0xFFFF)<<16) | ((217) & 0xFFFF))>;
+        };
+        map_2: map_2{
+            mapname = "amlogic-remote-3";
+            customcode = <0xbd02>;
+            release_delay = <80>;
+            size = <17>;
+            keymap = <((((0xca) & 0xFFFF)<<16) | ((103) & 0xFFFF))
+            ((((0xd2) & 0xFFFF)<<16) | ((108) & 0xFFFF))
+            ((((0x99) & 0xFFFF)<<16) | ((105) & 0xFFFF))
+            ((((0xc1) & 0xFFFF)<<16) | ((106) & 0xFFFF))
+            ((((0xce) & 0xFFFF)<<16) | ((97) & 0xFFFF))
+            ((((0x45) & 0xFFFF)<<16) | ((116) & 0xFFFF))
+            ((((0xc5) & 0xFFFF)<<16) | ((133) & 0xFFFF))
+            ((((0x80) & 0xFFFF)<<16) | ((113) & 0xFFFF))
+            ((((0xd0) & 0xFFFF)<<16) | ((15) & 0xFFFF))
+            ((((0xd6) & 0xFFFF)<<16) | ((125) & 0xFFFF))
+            ((((0x95) & 0xFFFF)<<16) | ((102) & 0xFFFF))
+            ((((0xdd) & 0xFFFF)<<16) | ((104) & 0xFFFF))
+            ((((0x8c) & 0xFFFF)<<16) | ((109) & 0xFFFF))
+            ((((0x89) & 0xFFFF)<<16) | ((131) & 0xFFFF))
+            ((((0x9c) & 0xFFFF)<<16) | ((130) & 0xFFFF))
+            ((((0x9a) & 0xFFFF)<<16) | ((120) & 0xFFFF))
+            ((((0xcd) & 0xFFFF)<<16) | ((121) & 0xFFFF))>;
+        };
+    };
+
+    galcore {
+        status = "disabled";
+        /delete-property/ memory-region;
+    };
+
+    nand: nfc@0 {
+        compatible = "amlogic, aml_mtd_nand";
+        dev_name = "mtdnand";
+        status = "disabled";
+        reg = <0x0 0xFFE07800 0x0 0x200>;
+        interrupts = <0 34 1>;
+        pinctrl-names = "nand_rb_mod","nand_norb_mod", "nand_cs_only";
+        pinctrl-0 = <&all_nand_pins>;
+        pinctrl-1 = <&all_nand_pins>;
+        pinctrl-2 = <&nand_cs_pins>;
+        clock-names = "core", "clkin";
+        device_id = <0>;
+        bl_mode = <1>;
+        fip_copies = <4>;
+        fip_size = <0x200000>;
+        nand_clk_ctrl = <0xFFE07000>;
+    };
+
+    ddr_bandwidth {
+        /delete-property/ sec_base;
+    };
+}; /* end of / */
+
+&meson_fb {
+	status = "okay";
+	display_size_default = <480 854 480 1708 32>;
+	mem_size = <0x00800000 0x4b80000 0x100000 0x100000 0x800000>;
+	logo_addr = "0x3d800000";
+	mem_alloc = <1>;
+	pxp_mode = <0>; /** 0:normal mode 1:pxp mode */
+};
+
+&pwm_ab {
+	status = "okay";
+};
+
+&pwm_AO_cd {
+	status = "okay";
+};
+
+&audiobus {
+	/* tdmb to internal DAC output*/
+    /delete-node/ loopback@0;
+    /delete-node/ i2s2hdmi;
+	aml_tdmb: tdmb {
+		compatible = "amlogic, g12a-snd-tdmb";
+		#sound-dai-cells = <0>;
+		dai-tdm-lane-slot-mask-in = <0 1 0 0>;
+		dai-tdm-lane-slot-mask-out = <1 0 0 0>;
+		dai-tdm-clk-sel = <1>;
+		clocks = <&clkaudio CLKID_AUDIO_MCLK_B
+				&clkc CLKID_MPLL0>;
+		clock-names = "mclk", "clk_srcpll";
+		pinctrl-names = "tdm_pins";
+		pinctrl-0 = <&tdmb_mclk &tdmout_b &tdmin_b>;
+		mclk_pad = <0>;  /* 0: mclk_0; 1: mclk_1 */
+		i2s2hdmi = <0>;
+
+        /delete-property/ samesource_sel;
+	};
+	aml_spdif: spdif {
+		compatible = "amlogic, g12a-snd-spdif-a";
+		#sound-dai-cells = <0>;
+		clocks = <&clkc CLKID_MPLL0
+				&clkc CLKID_FCLK_DIV4
+				&clkaudio CLKID_AUDIO_SPDIFIN
+				&clkaudio CLKID_AUDIO_SPDIFOUT
+				&clkaudio CLKID_AUDIO_SPDIFIN_CTRL
+				&clkaudio CLKID_AUDIO_SPDIFOUT_CTRL>;
+		clock-names = "sysclk", "fixed_clk", "gate_spdifin",
+				"gate_spdifout", "clk_spdifin", "clk_spdifout";
+		interrupts =
+				<GIC_SPI 151 IRQ_TYPE_EDGE_RISING>;
+
+		interrupt-names = "irq_spdifin";
+		status = "disabled";
+
+        /delete-property/ pinctrl-names;
+	};
+	aml_spdif_b: spdif_b {
+		compatible = "amlogic, g12a-snd-spdif-b";
+		#sound-dai-cells = <0>;
+		clocks = <&clkc CLKID_MPLL0 /*CLKID_HIFI_PLL*/
+				&clkaudio CLKID_AUDIO_SPDIFOUTB
+				&clkaudio CLKID_AUDIO_SPDIFOUTB_CTRL>;
+		clock-names = "sysclk",
+				"gate_spdifout", "clk_spdifout";
+		status = "disabled";
+	};
+	aml_loopback: loopback {
+		compatible = "amlogic, snd-loopback";
+		/*
+		 * 0: out rate = in data rate;
+		 * 1: out rate = loopback data rate;
+		 */
+		lb_mode = <0>;
+
+		/* datain src
+		 * 0: tdmin_a;
+		 * 1: tdmin_b;
+		 * 2: tdmin_c;
+		 * 3: spdifin;
+		 * 4: pdmin;
+		 */
+		datain_src = <4>;
+		datain_chnum = <8>;
+		datain_chmask = <0x3f>;
+
+		/* tdmin_lb src
+		 * 0: tdmoutA
+		 * 1: tdmoutB
+		 * 2: tdmoutC
+		 * 3: PAD_tdminA
+		 * 4: PAD_tdminB
+		 * 5: PAD_tdminC
+		 */
+		datalb_src = <2>;
+		datalb_chnum = <8>;
+		datalb_chmask = <0x3>;
+
+		status = "disabled";
+	};
+
+	audioresample: resample {
+		compatible = "amlogic, g12a-resample";
+		clocks = <&clkc CLKID_MPLL3
+				&clkaudio CLKID_AUDIO_MCLK_F
+				&clkaudio CLKID_AUDIO_RESAMPLE_CTRL>;
+		clock-names = "resample_pll", "resample_src", "resample_clk";
+		/*same with toddr_src
+		 *	TDMIN_A, 0
+		 *	TDMIN_B, 1
+		 *	TDMIN_C, 2
+		 *	SPDIFIN, 3
+		 *	PDMIN,  4
+		 *	NONE,
+		 *	TDMIN_LB, 6
+		 *	LOOPBACK, 7
+		 */
+		resample_module = <4>;
+		status = "disabled";
+	};
+	aml_pwrdet: pwrdet {
+		compatible = "amlogic, g12a-power-detect";
+
+		interrupts = <GIC_SPI 155 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "pwrdet_irq";
+
+		/* pwrdet source sel
+		 * 7: loopback;
+		 * 6: tdmin_lb;
+		 * 5: reserved;
+		 * 4: pdmin;
+		 * 3: spdifin;
+		 * 2: tdmin_c;
+		 * 1: tdmin_b;
+		 * 0: tdmin_a;
+		 */
+		pwrdet_src = <4>;
+
+		hi_th = <0x70000>;
+		lo_th = <0x16000>;
+
+		status = "disabled";
+	};
+}; /* end of audiobus */
+
+&pinctrl_periphs {
+	tdmb_mclk: tdmb_mclk {
+		mux { /* GPIOA_0 */
+			groups = "mclk0_a";
+			function = "mclk0";
+			drive-strength = <2>;
+		};
+	};
+	tdmout_b: tdmout_b {
+		mux { /* GPIOA_1, GPIOA_2, GPIOA_3 */
+			groups = "tdmb_sclk",
+				"tdmb_fs",
+				"tdmb_dout0";
+			function = "tdmb_out";
+			drive-strength = <2>;
+		};
+	};
+	tdmin_b:tdmin_b {
+		mux { /* GPIOA_4 */
+			groups = "tdmb_din1";
+			function = "tdmb_in";
+			drive-strength = <2>;
+		};
+	};
+
+	bl_pwm_off_pins:bl_pwm_off_pin {
+		mux {
+			pins = "GPIOH_5";
+			function = "gpio_periphs";
+			output-high;
+		};
+	};
+
+	clk12_24_z_pins:clk12_24_z_pins {
+		mux {
+			groups = "clk12_24_z";
+			function = "clk12_24_ee";
+			drive-strength = <3>;
+		};
+	};
+
+    spifc_all_pins: spifc_all_pins {
+        mux {
+            groups = "nor_d",
+                "nor_q",
+                "nor_c";
+            function = "nor";
+            input-enable;
+            bias-pull-up;
+        };
+    };
+}; /* end of pinctrl_periphs */
+
+&a_uart_pins {
+    mux {
+        groups = "uart_tx_a",
+            "uart_rx_a",
+            "uart_rts_a";
+    };
+    mux1 {
+        groups = "uart_cts_a";
+        function = "uart_a";
+        bias-pull-down;
+    };
+};
+
+&audio_data {
+	status = "okay";
+};
+
+&sd_emmc_c {
+	status = "okay";
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vddio_ao1v8>;
+	emmc {
+        // /delete-property/ save_para;
+		// /delete-property/ compute_cmd_delay;
+		// /delete-property/ compute_coef;
+		caps = "MMC_CAP_8_BIT_DATA",
+			 "MMC_CAP_MMC_HIGHSPEED",
+			 "MMC_CAP_SD_HIGHSPEED",
+			 "MMC_CAP_NONREMOVABLE",
+			 "MMC_CAP_HW_RESET",
+			 "MMC_CAP_ERASE",
+			 "MMC_CAP_CMD23";
+		caps2 = "MMC_CAP2_HS200_1_8V_SDR",
+			"MMC_CAP2_BROKEN_VOLTAGE";
+		f_min = <400000>;
+		f_max = <200000000>;
+		hw_reset = <&gpio BOOT_12 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&sd_emmc_b {
+	status = "okay";
+	// sd-uhs-sdr25;
+	// sd-uhs-sdr50;
+	// sd-uhs-sdr104;
+	// max-frequency = <200000000>;
+	// vmmc-supply = <&vcc_sd>;
+	// vqmmc-supply = <&vddio_c>;
+	// sd {
+	// 	caps = "MMC_CAP_4_BIT_DATA",
+	// 		 "MMC_CAP_MMC_HIGHSPEED",
+	// 		 "MMC_CAP_SD_HIGHSPEED",
+	// 		 "MMC_CAP_UHS_SDR25",
+	// 		 "MMC_CAP_UHS_SDR50",
+	// 		 "MMC_CAP_UHS_SDR104",
+	// 		 "MMC_CAP_ERASE",
+	// 		 "MMC_CAP_CMD23";
+	// 	f_min = <400000>;
+	// 	f_max = <200000000>;
+    //     jtag_pin = <&gpio 42 0>;
+	// };
+};
+
+&sd_emmc_a {
+    status = "disabled";
+    sdio {
+        /delete-property/ caps;
+        /delete-property/ f_min;
+        /delete-property/ f_max;
+    };
+};
+
+&gpu {
+    min_clk = <4>;
+};
+
+&dvfs285_cfg {
+   threshold = <100 190>;
+};
+
+&dvfs500_cfg {
+   threshold = <180 220>;
+};
+
+&dvfs666_cfg {
+   threshold = <210 236>;
+};
+
+&dvfs850_cfg {
+   threshold = <230 255>;
+};
+
+&ethmac {
+    status = "disabled";
+    /delete-property/ mc_val;
+    /delete-property/ internal_phy;
+	/delete-property/ pinctrl-names;
+	/delete-property/ pinctrl-0;
+};
+
+&external_eth_pins {
+    mux {
+        groups = "eth_mdio",
+        "eth_mdc",
+        "eth_rgmii_rx_clk",
+        "eth_rx_dv",
+        "eth_rxd0",
+        "eth_rxd1",
+        "eth_rxd2_rgmii",
+        "eth_rxd3_rgmii",
+        "eth_rgmii_tx_clk",
+        "eth_txen",
+        "eth_txd0",
+        "eth_txd1",
+        "eth_txd2_rgmii",
+        "eth_txd3_rgmii";
+    };
+};
+
+&pinctrl_aobus {
+    /delete-node/ spdifout;
+    /delete-node/ spdifout_a_mute;
+};
+
+&aml_spdif {
+    /delete-property/ pinctrl-0;
+    /delete-property/ pinctrl-1;
+};
+
+&usb2_phy_v2 {
+	status = "okay";
+	portnum = <2>;
+};
+
+&dwc3 {
+	status = "okay";
+};
+
+&dwc2_a {
+	status = "okay";
+	/** 0: normal, 1: otg+dwc3 host only, 2: otg+dwc3 device only*/
+	controller-type = <3>;
+};
+
+&pcie_A {
+	reset-gpio = <&gpio GPIOX_7 GPIO_ACTIVE_HIGH>;
+	status = "disabled";
+    clock-names = "pcie_refpll",
+                "pcie",
+                "pcie_phy";
+};
+
+&usb3_phy_v2 {
+	status = "okay";
+	portnum = <1>;
+	otg = <1>;
+    /delete-property/ gpio-vbus-power;
+    /delete-property/ gpios;
+};
+
+&saradc {
+	status = "okay";
+};
+
+&i2c0 {
+	/delete-property/ pinctrl-names;
+	/delete-property/ pinctrl-0;
+	/delete-property/ clock-frequency;
+};
+
+&i2c2 {
+	/delete-property/ pinctrl-names;
+	/delete-property/ pinctrl-0;
+	/delete-property/ clock-frequency;
+};
+
+&isp {
+	status = "disabled";
+    temper-buf-size = <24>;
+    /delete-property/ temper-line-offset;
+	/delete-property/ temper-frame-num;
+	/delete-property/ temper-frame-size;
+	/delete-property/ memory-region;
+};
+
+&adapter {
+	status = "disabled";
+    mem_alloc = <48>;
+    /delete-property/ memory-region;
+};
+
+&amhdmitx {
+	status = "disabled";
+    interrupts = <0 57 1>;
+    interrupt-names = "hdmitx_hpd";
+};
+
+&aocec {
+	status = "disabled";
+    compatible = "amlogic, aocec-g12a";
+    ee_cec;
+    arc_port_mask = <0x02>;
+    /delete-property/ output;
+};
+
+&cbus {
+    spifc: spifc@14000 {
+        status = "disabled";
+        compatible = "amlogic,aml-spi-nor";
+        reg = <0x0 0x14000 0x0 0x80>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&spifc_all_pins>;
+        clocks = <&clkc 11>;
+        clock-names = "core";
+   };
+};
+
+&uart_A {
+    status = "disabled";
+};
+
+&vdin0 {
+    /delete-property/ cma_size;
+    /delete-property/ tv_bit_mode;
+};
+
+&vdin1 {
+    /delete-property/ memory-region;
+    /delete-property/ tv_bit_mode;
+};
+
+&meson_cooldev {
+    cooling_devices {
+        cpufreq_cool_cluster0 {
+            gpu_pp = <2>;
+        };
+        cpufreq_cool_cluster1 {
+            gpu_pp = <2>;
+        };
+        cpucore_cool_cluster {
+            dyn_coeff = <0>;
+            gpu_pp = <2>;
+        };
+        gpufreq_cool {
+            cluster_id = <0>;
+        };
+        gpucore_cool {
+            dyn_coeff = <0>;
+            cluster_id = <0>;
+            gpu_pp = <2>;
+        };
+    };
+};
+
+&pswitch_on {
+    temperature = <65000>;
+};
+
+&phot {
+    temperature = <95000>;
+};
+
+&soc_thermal {
+    cooling-maps {
+        /delete-node/ cpucore_cooling_map0;
+        cpufreq_cooling_map0 {
+            cooling-device = <&cpufreq_cool0 0 10>;
+        };
+        cpufreq_cooling_map1 {
+            cooling-device = <&cpufreq_cool1 0 9>;
+        };
+        cpucore_cooling_map {
+            trip = <&pcontrol>;
+            cooling-device = <&cpucore_cool 0 5>;
+            contribution = <1024>;
+        };
+        gpufreq_cooling_map {
+            cooling-device = <&gpufreq_cool0 0 4>;
+        };
+        gpucore_cooling_map {
+            cooling-device = <&gpucore_cool0 0 2>;
+        };
+    };
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi b/arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
new file mode 100755
index 000000000000..cd5c528a181e
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
@@ -0,0 +1,218 @@
+/*
+ * arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
+ *
+ * Copyright (C) 2021 Hardkernel Co,. Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/{
+	gpio_keys: gou-gpio-keys {
+		compatible = "gpio-keys-polled";
+		poll-interval = <200>;
+		autorepeat;
+
+		button@0 {
+			label = "GPIO BTN-VOLUP";
+			linux,code = <KEY_VOLUMEUP>;
+                        gpios = <&gpio GPIOX_8 GPIO_ACTIVE_LOW>;
+		};
+		button@1 {
+			label = "GPIO BTN-VOLDN";
+			linux,code = <KEY_VOLUMEDOWN>;
+                        gpios = <&gpio GPIOX_9 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	joypad: gou_joypad {
+                compatible = "odroidgou-joypad";
+		status = "okay";
+
+                joypad-name = "GO-Ultra Gamepad";
+                joypad-product = <0x1000>;
+                joypad-revision = <0x0100>;
+
+                /*
+                  - odroidgou-joypad sysfs list -
+		   * for poll device interval(ms)
+		   /sys/devices/platform/gou_joypad/poll_interval [rw]
+		   ex) echo 20 > poll_interval
+                   * for button-adc-fuzz
+		   /sys/devices/platform/gou_joypad/adc_fuzz [r]
+                   * for button-adc-flat
+		   /sys/devices/platform/gou_joypad/adc_flat [r]
+
+		   * for report control(1:enable, 0:disable)
+		   /sys/devices/platform/gou_joypad/enable [rw]
+		   * for adc calibration value setup(current adcs value -> cal value)
+		   /sys/devices/platform/gou_joypad/adc_cal [rw]
+		   ex) echo 0 > adc_cal
+                */
+
+		/* gpio pincontrol setup */
+                /* pinctrl-names = "default"; */
+                /* pinctrl-0 = <&key_all_pins>; */
+
+		/* Analog mux define */
+		io-channels = <&saradc SARADC_CH0>,
+			      <&saradc SARADC_CH1>,
+			      <&saradc SARADC_CH2>,
+			      <&saradc SARADC_CH3>;
+		io-channel-names = "key-RY", "key-RX", "key-LY", "key-LX";
+
+		/* adc calculate scale */
+		button-adc-scale = <4>;
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <64>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+		  Analog Stick data tuning value(precent)
+		  p = positive direction, n = negative direction
+		  report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <350>;
+		abs_x-n-tuning = <350>;
+
+		abs_y-p-tuning = <350>;
+		abs_y-n-tuning = <350>;
+
+		abs_rx-p-tuning = <350>;
+		abs_rx-n-tuning = <350>;
+
+		abs_ry-p-tuning = <350>;
+		abs_ry-n-tuning = <350>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+
+		/*    *** ODROID-GOU Switch layoout ***
+		|------------------------------------------------|
+		| sw15  sw20        sw10   sw9        sw19  sw16 |
+		|------------------------------------------------|
+		|      sw18                            sw17      |
+		|              |-------------------|             |
+		|     sw1      |                   |      sw8    |
+		|  sw3   sw4   |                   |   sw7   sw5 |
+		|     sw2      |    LCD Display    |      sw6    |
+		|              |                   |             |
+		|    Analog    |                   |    Analog   |
+		|              |-------------------|             |
+		|  sw11 sw12              |   |       sw13 sw14  |
+		|-------------------------|uSD|------------------| */
+                /*  joypad driver is poll-device driver.
+                    poll-device is does not support wakeup-source.
+		*/
+                sw1 {
+                        gpios = <&gpio GPIOX_0 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-UP";
+                        linux,code = <BTN_DPAD_UP>; // 0x220
+                };
+                sw2 {
+                        gpios = <&gpio GPIOX_1 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-DOWN";
+                        linux,code = <BTN_DPAD_DOWN>; // 0x221
+                };
+                sw3 {
+                        gpios = <&gpio GPIOX_2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-LEFT";
+                        linux,code = <BTN_DPAD_LEFT>; // 0x222
+                };
+                sw4 {
+                        gpios = <&gpio GPIOX_3 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-RIGHT";
+                        linux,code = <BTN_DPAD_RIGHT>; // 0x223
+                };
+                sw5 {
+                        gpios = <&gpio GPIOX_4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-A";
+                        linux,code = <BTN_EAST>; // 0x131
+                };
+                sw6 {
+                        gpios = <&gpio GPIOX_5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-B";
+                        linux,code = <BTN_SOUTH>; // 0x130
+                };
+                sw7 {
+                        gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-Y";
+                        linux,code = <BTN_WEST>; // 0x134
+                };
+                sw8 {
+                        gpios = <&gpio GPIOX_7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-X";
+                        linux,code = <BTN_NORTH>; // 0x133
+                };
+                sw11 {
+                        gpios = <&gpio GPIOX_10 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F2";
+                        linux,code = <BTN_TRIGGER_HAPPY2>; // 0x2c2
+                };
+                sw12 {
+                        gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F3";
+                        linux,code = <BTN_TRIGGER_HAPPY3>; // 0x2c3
+                };
+                sw13 {
+                        gpios = <&gpio GPIOX_12 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F4";
+                        linux,code = <BTN_TRIGGER_HAPPY4>; // 0x2c4
+                };
+                sw14 {
+                        gpios = <&gpio GPIOX_13 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F5";
+                        linux,code = <BTN_TRIGGER_HAPPY5>; // 0x13c
+                };
+                sw15 {
+                        gpios = <&gpio GPIOX_14 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT";
+                        linux,code = <BTN_TL>; // 0x02
+                };
+                sw16 {
+                        gpios = <&gpio GPIOX_15 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT";
+                        linux,code = <BTN_TR>; // 0x05
+                };
+                sw17 {
+                        gpios = <&gpio GPIOX_16 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F6";
+                        linux,code = <BTN_TRIGGER_HAPPY6>;
+                };
+                sw18 {
+                        gpios = <&gpio GPIOX_17 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F1";
+                        linux,code = <BTN_TRIGGER_HAPPY1>;
+                };
+                sw19 {
+                        gpios = <&gpio GPIOX_18 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT2";
+                        linux,code = <BTN_TR2>;
+                };
+                sw20 {
+                        gpios = <&gpio GPIOX_19 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT2";
+                        linux,code = <BTN_TL2>;
+                };
+        };
+};
diff --git a/arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi b/arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
new file mode 100755
index 000000000000..130be19fe034
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
@@ -0,0 +1,214 @@
+/*
+ * arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
+ *
+ * Copyright (C) 2021 Hardkernel Co,. Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/ {
+	lcd{
+		compatible = "amlogic, lcd-g12b";
+		mode = "tablet";
+		status = "okay";
+		key_valid = <0>;
+		clocks = <&clkc CLKID_MIPI_DSI_HOST
+			&clkc CLKID_MIPI_DSI_PHY
+			&clkc CLKID_DSI_MEAS_COMP
+			&clkc CLKID_VCLK2_ENCL
+			&clkc CLKID_VCLK2_VENCL
+			&clkc CLKID_GP0_PLL>;
+		clock-names = "dsi_host_gate",
+			"dsi_phy_gate",
+			"dsi_meas",
+			"encl_top_gate",
+			"encl_int_gate",
+			"gp0_pll";
+		reg = <0x0 0xffd07000 0x0 0x400    /* dsi_host */
+			0x0 0xff644000 0x0 0x200>; /* dsi_phy */
+		interrupts = <0 3 1
+			0 56 1>;
+		interrupt-names = "vsync","vsync2";
+		pinctrl_version = <2>; /* for uboot */
+		clk_path = <1>; /* default gp0 pll */
+
+		/* power type:
+		 *    (0=cpu_gpio, 1=pmu_gpio, 2=signal,3=extern, 0xff=ending)
+		 * power index:
+		 *    (point gpios_index, or extern_index,0xff=invalid)
+		 * power value:(0=output low, 1=output high, 2=input)
+		 * power delay:(unit in ms)
+		 */
+		lcd_cpu-gpios = <&gpio GPIOH_4 GPIO_ACTIVE_HIGH>;
+		lcd_cpu_gpio_names = "GPIOH_4";
+
+		lcd_0{
+			model_name = "kd50t048a";
+				/*interface(ttl,lvds,mipi)*/
+			interface = "mipi";
+			basic_setting = <
+				480 854 /*h_active, v_active*/
+				542 884 /*h_period=hfp+hbp+hsync-len, v_period=vfp+vbp+vsync-len*/
+				8 /*lcd_bits*/
+				7 14>; /*screen_widht, screen_height*/
+			lcd_timing = <
+				12 12 0 /*hs_width(hsync-len),hs_bp,hs_pol*/
+				4 8 0>; /*vs_width(vsync-len),vs_bp,vs_pol*/
+			clk_attr = <0 /*fr_adj_type(0=clock,1=htotal,2=vtotal)*/
+				0 /*clk_ss_level*/
+				1 /*clk_auto_generate*/
+				28747680>; /*pixel_clk(unit in Hz) h_period*v_period*60 */
+			mipi_attr = <2 /*lane_num*/
+				400 /*bit_rate_max(MHz)*/
+				0 /*factor(*100, default 0 for auto)*/
+				1 /*operation_mode_init(0=video, 1=command)*/
+				0 /*operation_mode_display(0=video, 1=command)*/
+				2 /*
+				   *video_mode_type
+				   *(0=sync_pulse,1=sync_event,2=burst)
+				   */
+				1 /*clk_always_hs(0=disable,1=enable)*/
+				0>; /*phy_switch(0=auto,1=standard,2=slow)*/
+				/* dsi_init: data_type, num, data... */
+			dsi_init_on = <0xff 0>; /* ending flag */
+			dsi_init_off = <0xff 0>; /* ending flag */
+				/* extern_init: 0xff for invalid */
+			extern_init = <0>;
+				/* power step: type,index,value,delay(ms) */
+			power_on_step = <0 0 1 1
+					0 0 0 1
+					0 0 1 120
+					2 0 0 0
+					0xff 0 0 0>;
+			power_off_step = <2 0 0 50
+					0 0 0 100
+					0xff 0 0 0>;
+		};
+	};
+
+	lcd_extern{
+		compatible = "amlogic, lcd_extern";
+		status = "okay";
+		i2c_bus = "i2c_bus_0";
+		key_valid = <0>;
+
+		extern_0{
+			index = <0>;
+			extern_name = "mipi_default";/*ST7701*/
+			status = "okay";
+			type = <2>; /* 0=i2c, 1=spi, 2=mipi */
+			cmd_size = <0xff>;
+			init_on = <
+				0x13  1 0x11
+				0xfd  1 120	/* delay (ms) */
+
+				0x29  6 0xFF 0x77 0x01 0x00 0x00 0x10
+				0x29  3 0xC0 0xE9 0x03
+				0x29  3 0xC1 0x11 0x02
+				0x29  3 0xC2 0x31 0x08
+				0x23  2 0xCC 0x10
+				0x29 17 0xB0 0x00 0x0D 0x14 0x0D 0x10 0x05 0x02 0x08
+				        0x08 0x1E 0x05 0x13 0x11 0xA3 0x29 0x18
+				0x29 17 0xB1 0x00 0x0C 0x14 0x0C 0x10 0x05 0x03 0x08
+				        0x07 0x20 0x05 0x13 0x11 0xA4 0x29 0x18
+				0x29  6 0xFF 0x77 0x01 0x00 0x00 0x11
+				0x23  2 0xB0 0x6C
+				0x23  2 0xB1 0x43
+				0x23  2 0xB2 0x07
+				0x23  2 0xB3 0x80
+				0x23  2 0xB5 0x47
+				0x23  2 0xB7 0x85
+				0x23  2 0xB8 0x20
+				0x23  2 0xB9 0x10
+				0x23  2 0xC1 0x78
+				0x23  2 0xC3 0x78
+				0x23  2 0xD0 0x88
+				0xfd  1 250 /* delay (ms) */
+
+				0x29  4 0xE0 0x00 0x00 0x02
+				0x29 12 0xE1 0x08 0x00 0x0A 0x00 0x07 0x00 0x09 0x00
+					0x00 0x33 0x33
+				0x29 15 0xE2 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
+					0x00 0x00 0x00 0x00 0x00 0x00
+				0x29  5 0xE3 0x00 0x00 0x33 0x33
+				0x29  3 0xE4 0x44 0x44
+				0x29 17 0xE5 0x0E 0x60 0xA0 0xA0 0x10 0x60 0xA0 0xA0
+				        0x0A 0x60 0xA0 0xA0 0x0C 0x60 0xA0 0xA0
+				0x29  5 0xE6 0x00 0x00 0x33 0x33
+				0x29  3 0xE7 0x44 0x44
+				0x29 17 0xE8 0x0D 0x60 0xA0 0xA0 0x0F 0x60 0xA0 0xA0
+				        0x09 0x60 0xA0 0xA0 0x0B 0x60 0xA0 0xA0
+				0x29  8 0xEB 0x02 0x01 0xE4 0xE4 0x44 0x00 0x40
+				0x29  3 0xEC 0x02 0x01
+				0x29 17 0xED 0xAB 0x89 0x76 0x54 0x01 0xFF 0xFF 0xFF
+				        0xFF 0xFF 0xFF 0x10 0x45 0x67 0x98 0xBA
+				0x29  6 0xFF 0x77 0x01 0x00 0x00 0x00
+				0x23  2 0x3A 0x70
+				0x23  2 0x53 0xEC
+				0x23  2 0x55 0xB3
+				0x23  2 0x5E 0xFF
+				0x13  1 0x29
+				0xfd  1 50	/* delay (ms) */
+				0xff  0>; /*ending*/
+			init_off = <
+				0x05 1 0x28 /* display off */
+				0xfd 1 10   /* delay 10ms */
+				0x05 1 0x10 /* sleep in */
+				0xfd 1 150  /* delay 150ms */
+				0xff 0>;    /*ending*/
+		};
+	};
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm_ef MESON_PWM_1 40000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <200>;
+	};
+};/* end of panel */
+
+&pwm_ef {
+	status = "okay";
+	pinctrl-names = "pwm_pins";
+	pinctrl-0 = <&pwm_f_pins2>;
+};
diff --git a/arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi b/arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
new file mode 100755
index 000000000000..a244975e5f95
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
@@ -0,0 +1,474 @@
+/*
+ * arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
+ *
+ * Copyright (C) 2021 Hardkernel Co,. Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/{
+	vcc_sys_817: sys_3v8_817 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys_817";
+		regulator-always-on;
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+	};
+	vcc_sys_818: sys_3v8_818 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys_818";
+		regulator-always-on;
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+	};
+	codec_clk: codec-clk {
+		compatible = "fixed-clock";
+		clock-frequency = <12288000>;
+		clock-output-names = "codec_clk";
+		#clock-cells = <0>;
+	};
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&ao_i2c_master_pins1>;
+	clock-frequency = <400000>;
+
+	rk818: pmic@1c {
+		compatible = "rockchip,rk818";
+		reg = <0x1c>;
+		status = "okay";
+		gpio-irq = <&gpio_ao GPIOAO_7 GPIO_ACTIVE_LOW>;
+		rockchip,system-power-controller;
+		//wakeup-source;
+		clock-output-names = "rk818-clkout1", "wifibt_32kin";
+		#clock-cells = <1>;
+
+		vcc1-supply = <&vcc_sys_818>;
+		vcc2-supply = <&vcc_sys_818>;
+		vcc3-supply = <&vcc_sys_818>;
+		vcc4-supply = <&vcc_sys_818>;
+		vcc6-supply = <&vcc_sys_818>;
+		vcc7-supply = <&vcc_2v3>;
+		vcc8-supply = <&vcc_2v3>;
+		vcc9-supply = <&vddao_3v3>;
+
+		regulators {
+			vddcpu_a: DCDC_REG1 {
+				regulator-name = "vdd_cpu_a";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1450000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+
+			vdd_ee: DCDC_REG2 {
+				regulator-name = "vdd_ee";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+
+			vddq_1v1: DCDC_REG3 {
+				regulator-name = "vcc_ddr";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vddao_3v3: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vddao_3v3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vdd_ldo1: LDO_REG1 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO1";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_ldo2: LDO_REG2 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO2";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_ldo3: LDO_REG3 {
+				regulator-boot-off;
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-name = "rk818_LDO3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_ldo4: LDO_REG4 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO4";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vddio_ao1v8: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vddio_ao1v8";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			LDO_REG6 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO6";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <2500000>;
+				};
+			};
+
+			vddq_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_18";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdd_ldo8: LDO_REG8 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vddio_c: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vddio_c";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_sd: SWITCH_REG {
+				regulator-name = "vcc_sd";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			boost_otg: DCDC_BOOST {
+				regulator-name = "boost_otg";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			rk818_otg_switch: OTG_SWITCH {
+				regulator-name = "rk818_otg_switch";
+			};
+		};
+		battery {
+			compatible = "rk818-battery";
+			ocv_table = <
+				3470 3599 3671 3701 3728 3746 3762
+				3772 3781 3792 3816 3836 3866 3910
+				3942 3971 4002 4050 4088 4132 4200>;
+			design_capacity = <4000>;
+			design_qmax = <4100>;
+			bat_res = <180>;
+			max_input_current = <2000>;
+			max_chrg_current = <1500>;
+			max_chrg_voltage = <4250>;
+			sleep_enter_current = <300>;
+			sleep_exit_current = <300>;
+			power_off_thresd = <3450>;
+			zero_algorithm_vol = <3700>;
+			fb_temperature = <105>;
+			sample_res = <10>;
+			max_soc_offset = <60>;
+			energy_mode = <0>;
+			monitor_sec = <5>;
+			virtual_power = <0>;
+			power_dc2otg = <0>;
+			otg_switch-supply = <&rk818_otg_switch>;
+			otg5v_suspend_enable = <0>;
+			dc_det_gpio = <&gpio_ao GPIOAO_8 GPIO_ACTIVE_LOW>;
+			chg_led_gpio = <&gpio_ao GPIOAO_6 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c3_master_pins2>;
+	clock-frequency = <400000>;
+
+	rk817: pmic@20 {
+		compatible = "rockchip,rk817";
+		reg = <0x20>;
+		status = "okay";
+		gpio-irq = <&gpio_ao GPIOAO_5 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "pmic-sleep",
+				"pmic-power-off", "pmic-reset";
+		pinctrl-0 = <&rk817_slppin_null>;
+		pinctrl-1 = <&rk817_slppin_slp>;
+		pinctrl-2 = <&rk817_slppin_pwrdn>;
+		pinctrl-3 = <&rk817_slppin_rst>;
+
+		//rockchip,system-power-controller;
+		wakeup-source;
+		/* #clock-cells = <1>; */
+		/* clock-output-names = "rk808-clkout1", "rk808-clkout2"; */
+		fb-inner-reg-idxs = <2>;
+
+		/* 1: rst regs (default in codes), 0: rst the pmic */
+		pmic-reset-func = <0>;
+
+		vcc1-supply = <&vcc_sys_817>;
+		vcc2-supply = <&vcc_sys_817>;
+		vcc3-supply = <&vcc_sys_817>;
+		vcc4-supply = <&vcc_sys_817>;
+		vcc5-supply = <&vcc_sys_817>;
+		vcc6-supply = <&vcc_sys_817>;
+		vcc7-supply = <&vcc_sys_817>;
+		vcc8-supply = <&vcc_sys_817>;
+		vcc9-supply = <&rk817_boost>;
+
+		pinctrl_rk8xx: pinctrl_rk8xx {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk817_ts_gpio1: rk817_ts_gpio1 {
+				pins = "gpio_ts";
+				function = "pin_fun1";
+				/* output-low; */
+				/* input-enable; */
+			};
+
+			rk817_gt_gpio2: rk817_gt_gpio2 {
+				pins = "gpio_gt";
+				function = "pin_fun1";
+			};
+
+			rk817_pin_ts: rk817_pin_ts {
+				pins = "gpio_ts";
+				function = "pin_fun0";
+			};
+
+			rk817_pin_gt: rk817_pin_gt {
+				pins = "gpio_gt";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_null: rk817_slppin_null {
+				pins = "gpio_slp";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_slp: rk817_slppin_slp {
+				pins = "gpio_slp";
+				function = "pin_fun1";
+			};
+
+			rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+				pins = "gpio_slp";
+				function = "pin_fun2";
+			};
+
+			rk817_slppin_rst: rk817_slppin_rst {
+				pins = "gpio_slp";
+				function = "pin_fun3";
+			};
+		};
+
+		regulators {
+			/* Not Used */
+			DCDC_REG1 {
+				regulator-boot-off;
+				regulator-name = "rk817_BUCK1";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vddcpu_b: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1450000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_cpu_b";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+			vcc_2v3: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_2v3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+			DCDC_REG4 {
+				regulator-boot-off;
+				regulator-name = "rk817_BUCK4";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG1 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO1";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG2 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO2";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG3 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_codec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vdd_codec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG5 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO5";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG6 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO6";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG7 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO7";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vcc_lcd: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcc_lcd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG9 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO9";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			rk817_boost: BOOST {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5400000>;
+				regulator-name = "boost";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			OTG_SWITCH {
+				regulator-name = "rk817_otg_switch";
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+
+		rk817_codec: codec {
+			#sound-dai-cells = <0>;
+			compatible = "rockchip,rk817-codec";
+			clocks = <&codec_clk>;
+			clock-names = "mclk";
+			hp-volume = <20>;
+			spk-volume = <3>;
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index 5b15911709aa..e41f68ad0832 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -69,6 +69,8 @@ phys_addr_t __fdt_pointer __initdata;
 const char *machine_name;
 EXPORT_SYMBOL(machine_name);
 
+bool emuelec_is_ogu = false;
+
 /*
  * Standard memory resources
  */
@@ -198,8 +200,13 @@ static void __init setup_machine_fdt(phys_addr_t dt_phys)
 	}
 	
 	name_dtid = of_flat_dt_get_coreelec_dt_id();
-	if (name_dtid)
+	if (name_dtid) {
 		pr_info("CoreELEC dt-id: %s\n", name_dtid);
+        if (!strcmp(name_dtid, "g12b_s922x_odroid_go_ultra")) {
+            emuelec_is_ogu = true;
+            pr_info("EmuELEC OGU: Warning, OGU on CE kernel is still under heavy development, prepare for major breaks :) - 7Ji");
+        }
+    }
 
 	name = of_flat_dt_get_machine_name();
 	if (!name)
diff --git a/drivers/amlogic/media/osd/osd_fb.c b/drivers/amlogic/media/osd/osd_fb.c
index 192948b9c0b9..2e64bc5a9225 100644
--- a/drivers/amlogic/media/osd/osd_fb.c
+++ b/drivers/amlogic/media/osd/osd_fb.c
@@ -56,6 +56,8 @@
 #ifdef CONFIG_AMLOGIC_VPU
 #include <linux/amlogic/media/vpu/vpu.h>
 #endif
+#include <linux/platform_data/emuelec.h>
+#define CONFIG_ARCH_MESON64_ODROID_COMMON
 /* Local Headers */
 #include "osd.h"
 #include "osd_fb.h"
@@ -388,6 +390,35 @@ struct ion_handle *fb_ion_handle[OSD_COUNT][OSD_MAX_BUF_NUM];
 
 static int osd_cursor(struct fb_info *fbi, struct fb_cursor *var);
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+extern int  soft_cursor(struct fb_info *info, struct fb_cursor *cursor);
+
+static int osd_set_fb_var(int index, const struct vinfo_s *vinfo)
+{
+	if ((vinfo->width < 0) || (vinfo->height < 0)) {
+		pr_err("invalid vinfo\n");
+		return 1;
+	}
+
+	fb_def_var[index].xres = vinfo->width;
+	fb_def_var[index].yres = vinfo->height;
+	fb_def_var[index].xres_virtual = vinfo->width;
+	fb_def_var[index].yres_virtual = vinfo->height * 2;
+	fb_def_var[index].bits_per_pixel = 32;
+
+	return 0;
+}
+
+static void osd_set_fb_parameters(int index, const struct vinfo_s *vinfo)
+{
+	osd_set_free_scale_enable_hw(index, 0);
+	osd_set_free_scale_mode_hw(index, 1);
+	osd_set_free_scale_axis_hw(index, 0, 0, vinfo->width, vinfo->height);
+	osd_set_window_axis_hw(index, 0, 0, vinfo->width, vinfo->height);
+	osd_enable_hw(index, 1);
+}
+#endif /*CONFIG_ARCH_MESON64_ODROID_COMMON*/
+
 phys_addr_t get_fb_rmem_paddr(int index)
 {
 	if (index < 0 || index > 1)
@@ -1913,9 +1944,46 @@ static int osd_release(struct fb_info *info, int arg)
 	return err;
 }
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+extern void control_hdmiphy(bool on);
+
+static bool monitor_onoff_action;
+
+static int __init osd_setup_monitor_onoff(char *str)
+{
+	if (!strcmp(str, "true") || !strcmp(str, "1"))
+		monitor_onoff_action = true;
+	else
+		monitor_onoff_action = false;
+
+	return 0;
+}
+__setup("monitor_onoff=", osd_setup_monitor_onoff);
+#endif
+
 int osd_blank(int blank_mode, struct fb_info *info)
 {
 	osd_enable_hw(info->node, (blank_mode != 0) ? 0 : 1);
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	if (!monitor_onoff_action)
+		return 0;
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		control_hdmiphy(true);
+		break;
+	case FB_BLANK_POWERDOWN:
+		control_hdmiphy(false);
+		break;
+	case FB_BLANK_NORMAL:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_VSYNC_SUSPEND:
+	default:
+		break;
+	}
+#endif
+
 	return 0;
 }
 
@@ -4597,7 +4665,36 @@ static int osd_probe(struct platform_device *pdev)
 					&var_screeninfo[0], 5);
 			if (ret)
 				osd_log_info("not found display_size_default\n");
-			else {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+			else if  (emuelec_is_ogu) {
+                if (osd_set_fb_var(index, vinfo)) {
+					/* no available vinfo, set default */
+					fb_def_var[index].xres =
+						var_screeninfo[0];
+					fb_def_var[index].yres =
+						var_screeninfo[1];
+					fb_def_var[index].xres_virtual =
+						var_screeninfo[2];
+					fb_def_var[index].yres_virtual =
+						var_screeninfo[3];
+					fb_def_var[index].bits_per_pixel =
+						var_screeninfo[4];
+				}
+				pr_info("fb def : %d %d %d %d %d\n",
+					fb_def_var[index].xres,
+					fb_def_var[index].yres,
+					fb_def_var[index].xres_virtual,
+					fb_def_var[index].yres_virtual,
+					fb_def_var[index].bits_per_pixel);
+				pr_info("init fbdev bpp is:%d\n",
+					fb_def_var[index].bits_per_pixel);
+
+				if (fb_def_var[index].bits_per_pixel > 32)
+					fb_def_var[index].bits_per_pixel = 32;
+            } else {
+#else
+            else {
+#endif
 				fb_def_var[index].xres = var_screeninfo[0];
 				fb_def_var[index].yres = var_screeninfo[1];
 				fb_def_var[index].xres_virtual =
@@ -4657,6 +4754,11 @@ static int osd_probe(struct platform_device *pdev)
 			for (i = 0; i < ARRAY_SIZE(osd_attrs_viu2); i++)
 			ret = device_create_file(fbi->dev, &osd_attrs_viu2[i]);
 		}
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+		if (index == DEV_OSD0)
+			osd_set_fb_parameters(DEV_OSD0, vinfo);
+#endif
 	}
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 	early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING;
diff --git a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
index c66d30e2d696..4c6d0c8971ad 100644
--- a/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/media/vout/hdmitx/hdmi_tx_20/hdmi_tx_main.c
@@ -68,6 +68,8 @@
 #include "hdmi_tx_hdcp.h"
 #include "hdmi_tx_calibration.h"
 
+#define CONFIG_ARCH_MESON64_ODROID_COMMON
+
 #define HDMI_TX_COUNT 32
 #define HDMI_TX_POOL_NUM  6
 #define HDMI_TX_RESOURCE_NUM 4
@@ -7309,6 +7311,14 @@ static int __init hdmitx_get_phy_idx(char *str)
 
 __setup("phy_idx=", hdmitx_get_phy_idx);
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+void control_hdmiphy(bool on)
+{
+	hdmitx_device.hwop.cntlmisc(&hdmitx_device, MISC_TMDS_PHY_OP,
+			on ?  TMDS_PHY_ENABLE : TMDS_PHY_DISABLE);
+}
+#endif
+
 MODULE_PARM_DESC(log_level, "\n log_level\n");
 module_param(log_level, int, 0644);
 
diff --git a/drivers/amlogic/media/vout/lcd/Makefile b/drivers/amlogic/media/vout/lcd/Makefile
index 56e115d739fd..8b3baf15ebf1 100644
--- a/drivers/amlogic/media/vout/lcd/Makefile
+++ b/drivers/amlogic/media/vout/lcd/Makefile
@@ -1,6 +1,6 @@
 obj-$(CONFIG_AMLOGIC_LCD) += lcd_vout.o lcd_reg.o lcd_common.o lcd_notify.o \
                              lcd_debug.o lcd_clk_config.o lcd_phy_config.o \
-                             lcd_unifykey.o lcd_tcon.o lcd_tcon_hw.o
+                             lcd_unifykey.o lcd_tcon.o
 obj-$(CONFIG_AMLOGIC_LCD_TV) += lcd_tv/
 obj-$(CONFIG_AMLOGIC_LCD_TABLET) += lcd_tablet/
 obj-$(CONFIG_AMLOGIC_LCD_EXTERN) += lcd_extern/
diff --git a/drivers/amlogic/media/vout/lcd/lcd_clk_config.c b/drivers/amlogic/media/vout/lcd/lcd_clk_config.c
index 57af23be31c9..762351acdbdf 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_clk_config.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_clk_config.c
@@ -49,7 +49,6 @@ static struct lcd_clk_config_s clk_conf = { /* unit: kHz */
 	.pll_od3_sel = 0,
 	.pll_tcon_div_sel = 0,
 	.pll_level = 0,
-	.pll_frac_half_shift = 0,
 	.ss_level = 0,
 	.ss_freq = 0,
 	.ss_mode = 0,
@@ -62,7 +61,6 @@ static struct lcd_clk_config_s clk_conf = { /* unit: kHz */
 	.xd_max = 0,
 
 	.data = NULL,
-	.ppm_adj = 0,
 };
 
 static struct lcd_clktree_s lcd_clktree = {
@@ -91,30 +89,6 @@ struct lcd_clk_config_s *get_lcd_clk_config(void)
  * lcd pll & clk operation
  * ****************************************************
  */
-static unsigned int error_abs(unsigned int a, unsigned int b)
-{
-	if (a >= b)
-		return (a - b);
-	else
-		return (b - a);
-}
-
-#define PLL_CLK_CHECK_MAX    2000000 /* Hz */
-static int lcd_clk_msr_check(struct lcd_clk_config_s *cconf)
-{
-	unsigned int encl_clk_msr;
-
-	encl_clk_msr = lcd_encl_clk_msr();
-	if (error_abs((cconf->fout * 1000), encl_clk_msr) >=
-	    PLL_CLK_CHECK_MAX) {
-		LCDERR("%s: expected:%d, msr:%d\n",
-		       __func__, (cconf->fout * 1000), encl_clk_msr);
-		return -1;
-	}
-
-	return 0;
-}
-
 static int lcd_pll_wait_lock(unsigned int reg, unsigned int lock_bit)
 {
 	unsigned int pll_lock;
@@ -123,14 +97,13 @@ static int lcd_pll_wait_lock(unsigned int reg, unsigned int lock_bit)
 
 	do {
 		udelay(50);
-		pll_lock = lcd_ana_getb(reg, lock_bit, 1);
+		pll_lock = lcd_hiu_getb(reg, lock_bit, 1);
 		wait_loop--;
 	} while ((pll_lock == 0) && (wait_loop > 0));
 	if (pll_lock == 0)
 		ret = -1;
 	LCDPR("%s: pll_lock=%d, wait_loop=%d\n",
 		__func__, pll_lock, (PLL_WAIT_LOCK_CNT - wait_loop));
-
 	return ret;
 }
 
@@ -210,7 +183,7 @@ static void lcd_set_pll_ss_level_txl(unsigned int level)
 	LCDPR("set pll spread spectrum: %s\n", lcd_ss_level_table_txl[level]);
 }
 
-static void lcd_set_pll_txl(struct lcd_clk_config_s *cconf)
+static void lcd_set_pll_txl(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl2, pll_ctrl3;
 	int ret, cnt = 0;
@@ -218,20 +191,20 @@ static void lcd_set_pll_txl(struct lcd_clk_config_s *cconf)
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s\n", __func__);
 	pll_ctrl = ((1 << LCD_PLL_EN_TXL) |
-		(cconf->pll_n << LCD_PLL_N_TXL) |
-		(cconf->pll_m << LCD_PLL_M_TXL));
+		(cConf->pll_n << LCD_PLL_N_TXL) |
+		(cConf->pll_m << LCD_PLL_M_TXL));
 	pll_ctrl2 = 0x800ca000;
-	pll_ctrl2 |= ((1 << 12) | (cconf->pll_frac << 0));
-	pll_ctrl3 = 0x860330c4 | (cconf->pll_od_fb << 30);
-	pll_ctrl3 |= ((cconf->pll_od3_sel << LCD_PLL_OD3_TXL) |
-		(cconf->pll_od2_sel << LCD_PLL_OD2_TXL) |
-		(cconf->pll_od1_sel << LCD_PLL_OD1_TXL));
+	pll_ctrl2 |= ((1 << 12) | (cConf->pll_frac << 0));
+	pll_ctrl3 = 0x860330c4 | (cConf->pll_od_fb << 30);
+	pll_ctrl3 |= ((cConf->pll_od3_sel << LCD_PLL_OD3_TXL) |
+		(cConf->pll_od2_sel << LCD_PLL_OD2_TXL) |
+		(cConf->pll_od1_sel << LCD_PLL_OD1_TXL));
 
 set_pll_retry_txl:
 	lcd_hiu_write(HHI_HDMI_PLL_CNTL, pll_ctrl);
 	lcd_hiu_write(HHI_HDMI_PLL_CNTL2, pll_ctrl2);
 	lcd_hiu_write(HHI_HDMI_PLL_CNTL3, pll_ctrl3);
-	if (cconf->pll_mode & LCD_PLL_MODE_SPECIAL_CNTL)
+	if (cConf->pll_mode)
 		lcd_hiu_write(HHI_HDMI_PLL_CNTL4, 0x0d160000);
 	else
 		lcd_hiu_write(HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
@@ -247,8 +220,8 @@ static void lcd_set_pll_txl(struct lcd_clk_config_s *cconf)
 		LCDERR("hpll lock failed\n");
 	}
 
-	if (cconf->ss_level > 0)
-		lcd_set_pll_ss_level_txl(cconf->ss_level);
+	if (cConf->ss_level > 0)
+		lcd_set_pll_ss_level_txl(cConf->ss_level);
 }
 
 static void lcd_set_pll_ss_level_txlx(unsigned int level)
@@ -273,7 +246,7 @@ static void lcd_set_pll_ss_level_txlx(unsigned int level)
 	LCDPR("set pll spread spectrum: %s\n", lcd_ss_level_table_txlx[level]);
 }
 
-static void lcd_set_pll_txlx(struct lcd_clk_config_s *cconf)
+static void lcd_set_pll_txlx(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl2, pll_ctrl3;
 	int ret, cnt = 0;
@@ -281,14 +254,14 @@ static void lcd_set_pll_txlx(struct lcd_clk_config_s *cconf)
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s\n", __func__);
 	pll_ctrl = ((1 << LCD_PLL_EN_TXL) |
-		(cconf->pll_n << LCD_PLL_N_TXL) |
-		(cconf->pll_m << LCD_PLL_M_TXL));
+		(cConf->pll_n << LCD_PLL_N_TXL) |
+		(cConf->pll_m << LCD_PLL_M_TXL));
 	pll_ctrl2 = 0x800ca000;
-	pll_ctrl2 |= ((1 << 12) | (cconf->pll_frac << 0));
-	pll_ctrl3 = 0x860030c4 | (cconf->pll_od_fb << 30);
-	pll_ctrl3 |= ((cconf->pll_od3_sel << LCD_PLL_OD3_TXL) |
-		(cconf->pll_od2_sel << LCD_PLL_OD2_TXL) |
-		(cconf->pll_od1_sel << LCD_PLL_OD1_TXL));
+	pll_ctrl2 |= ((1 << 12) | (cConf->pll_frac << 0));
+	pll_ctrl3 = 0x860030c4 | (cConf->pll_od_fb << 30);
+	pll_ctrl3 |= ((cConf->pll_od3_sel << LCD_PLL_OD3_TXL) |
+		(cConf->pll_od2_sel << LCD_PLL_OD2_TXL) |
+		(cConf->pll_od1_sel << LCD_PLL_OD1_TXL));
 
 set_pll_retry_txlx:
 	lcd_hiu_write(HHI_HDMI_PLL_CNTL, pll_ctrl);
@@ -307,11 +280,11 @@ static void lcd_set_pll_txlx(struct lcd_clk_config_s *cconf)
 		LCDERR("hpll lock failed\n");
 	}
 
-	if (cconf->ss_level > 0)
-		lcd_set_pll_ss_level_txlx(cconf->ss_level);
+	if (cConf->ss_level > 0)
+		lcd_set_pll_ss_level_txlx(cConf->ss_level);
 }
 
-static void lcd_set_pll_axg(struct lcd_clk_config_s *cconf)
+static void lcd_set_pll_axg(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl1, pll_ctrl2;
 	int ret, cnt = 0;
@@ -320,12 +293,12 @@ static void lcd_set_pll_axg(struct lcd_clk_config_s *cconf)
 		LCDPR("%s\n", __func__);
 
 	pll_ctrl = ((1 << LCD_PLL_EN_AXG) |
-		(cconf->pll_n << LCD_PLL_N_AXG) |
-		(cconf->pll_m << LCD_PLL_M_AXG) |
-		(cconf->pll_od1_sel << LCD_PLL_OD_AXG));
+		(cConf->pll_n << LCD_PLL_N_AXG) |
+		(cConf->pll_m << LCD_PLL_M_AXG) |
+		(cConf->pll_od1_sel << LCD_PLL_OD_AXG));
 	pll_ctrl1 = 0xc084a000;
-	pll_ctrl1 |= ((1 << 12) | (cconf->pll_frac << 0));
-	pll_ctrl2 = 0xb75020be | (cconf->pll_od_fb << 19);
+	pll_ctrl1 |= ((1 << 12) | (cConf->pll_frac << 0));
+	pll_ctrl2 = 0xb75020be | (cConf->pll_od_fb << 19);
 
 set_pll_retry_axg:
 	lcd_hiu_write(HHI_GP0_PLL_CNTL_AXG, pll_ctrl);
@@ -333,7 +306,7 @@ static void lcd_set_pll_axg(struct lcd_clk_config_s *cconf)
 	lcd_hiu_write(HHI_GP0_PLL_CNTL2_AXG, pll_ctrl2);
 	lcd_hiu_write(HHI_GP0_PLL_CNTL3_AXG, 0x0a59a288);
 	lcd_hiu_write(HHI_GP0_PLL_CNTL4_AXG, 0xc000004d);
-	if (cconf->pll_fvco >= 1632000)
+	if (cConf->pll_fvco >= 1632000)
 		lcd_hiu_write(HHI_GP0_PLL_CNTL5_AXG, 0x00058000);
 	else
 		lcd_hiu_write(HHI_GP0_PLL_CNTL5_AXG, 0x00078000);
@@ -348,7 +321,7 @@ static void lcd_set_pll_axg(struct lcd_clk_config_s *cconf)
 	}
 }
 
-static void lcd_set_gp0_pll_g12a(struct lcd_clk_config_s *cconf)
+static void lcd_set_gp0_pll_g12a(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl1, pll_ctrl3, pll_ctrl4, pll_ctrl6;
 	int ret, cnt = 0;
@@ -357,11 +330,11 @@ static void lcd_set_gp0_pll_g12a(struct lcd_clk_config_s *cconf)
 		LCDPR("%s\n", __func__);
 
 	pll_ctrl = ((1 << LCD_PLL_EN_GP0_G12A) |
-		(cconf->pll_n << LCD_PLL_N_GP0_G12A) |
-		(cconf->pll_m << LCD_PLL_M_GP0_G12A) |
-		(cconf->pll_od1_sel << LCD_PLL_OD_GP0_G12A));
-	pll_ctrl1 = (cconf->pll_frac << 0);
-	if (cconf->pll_frac) {
+		(cConf->pll_n << LCD_PLL_N_GP0_G12A) |
+		(cConf->pll_m << LCD_PLL_M_GP0_G12A) |
+		(cConf->pll_od1_sel << LCD_PLL_OD_GP0_G12A));
+	pll_ctrl1 = (cConf->pll_frac << 0);
+	if (cConf->pll_frac) {
 		pll_ctrl |= (1 << 27);
 		pll_ctrl3 = 0x6a285c00;
 		pll_ctrl4 = 0x65771290;
@@ -392,7 +365,7 @@ static void lcd_set_gp0_pll_g12a(struct lcd_clk_config_s *cconf)
 	}
 }
 
-static void lcd_set_hpll_g12a(struct lcd_clk_config_s *cconf)
+static void lcd_set_hpll_g12a(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl2, pll_ctrl4, pll_ctrl5, pll_ctrl7;
 	int ret, cnt = 0;
@@ -402,13 +375,13 @@ static void lcd_set_hpll_g12a(struct lcd_clk_config_s *cconf)
 
 	pll_ctrl = ((1 << LCD_PLL_EN_HPLL_G12A) |
 		(1 << 25) | /* clk out gate */
-		(cconf->pll_n << LCD_PLL_N_HPLL_G12A) |
-		(cconf->pll_m << LCD_PLL_M_HPLL_G12A) |
-		(cconf->pll_od1_sel << LCD_PLL_OD1_HPLL_G12A) |
-		(cconf->pll_od2_sel << LCD_PLL_OD2_HPLL_G12A) |
-		(cconf->pll_od3_sel << LCD_PLL_OD3_HPLL_G12A));
-	pll_ctrl2 = (cconf->pll_frac << 0);
-	if (cconf->pll_frac) {
+		(cConf->pll_n << LCD_PLL_N_HPLL_G12A) |
+		(cConf->pll_m << LCD_PLL_M_HPLL_G12A) |
+		(cConf->pll_od1_sel << LCD_PLL_OD1_HPLL_G12A) |
+		(cConf->pll_od2_sel << LCD_PLL_OD2_HPLL_G12A) |
+		(cConf->pll_od3_sel << LCD_PLL_OD3_HPLL_G12A));
+	pll_ctrl2 = (cConf->pll_frac << 0);
+	if (cConf->pll_frac) {
 		pll_ctrl |= (1 << 27);
 		pll_ctrl4 = 0x6a285c00;
 		pll_ctrl5 = 0x65771290;
@@ -439,7 +412,7 @@ static void lcd_set_hpll_g12a(struct lcd_clk_config_s *cconf)
 	}
 }
 
-static void lcd_set_gp0_pll_g12b(struct lcd_clk_config_s *cconf)
+static void lcd_set_gp0_pll_g12b(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl1, pll_ctrl3, pll_ctrl4, pll_ctrl6;
 	int ret, cnt = 0;
@@ -448,11 +421,11 @@ static void lcd_set_gp0_pll_g12b(struct lcd_clk_config_s *cconf)
 		LCDPR("%s\n", __func__);
 
 	pll_ctrl = ((1 << LCD_PLL_EN_GP0_G12A) |
-		(cconf->pll_n << LCD_PLL_N_GP0_G12A) |
-		(cconf->pll_m << LCD_PLL_M_GP0_G12A) |
-		(cconf->pll_od1_sel << LCD_PLL_OD_GP0_G12A));
-	pll_ctrl1 = (cconf->pll_frac << 0);
-	if (cconf->pll_frac) {
+		(cConf->pll_n << LCD_PLL_N_GP0_G12A) |
+		(cConf->pll_m << LCD_PLL_M_GP0_G12A) |
+		(cConf->pll_od1_sel << LCD_PLL_OD_GP0_G12A));
+	pll_ctrl1 = (cConf->pll_frac << 0);
+	if (cConf->pll_frac) {
 		pll_ctrl |= (1 << 27);
 		pll_ctrl3 = 0x6a285c00;
 		pll_ctrl4 = 0x65771290;
@@ -483,7 +456,7 @@ static void lcd_set_gp0_pll_g12b(struct lcd_clk_config_s *cconf)
 	}
 }
 
-static void lcd_set_hpll_g12b(struct lcd_clk_config_s *cconf)
+static void lcd_set_hpll_g12b(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl2, pll_ctrl4, pll_ctrl5, pll_ctrl7;
 	int ret, cnt = 0;
@@ -493,13 +466,13 @@ static void lcd_set_hpll_g12b(struct lcd_clk_config_s *cconf)
 
 	pll_ctrl = ((1 << LCD_PLL_EN_HPLL_G12A) |
 		(1 << 25) | /* clk out gate */
-		(cconf->pll_n << LCD_PLL_N_HPLL_G12A) |
-		(cconf->pll_m << LCD_PLL_M_HPLL_G12A) |
-		(cconf->pll_od1_sel << LCD_PLL_OD1_HPLL_G12A) |
-		(cconf->pll_od2_sel << LCD_PLL_OD2_HPLL_G12A) |
-		(cconf->pll_od3_sel << LCD_PLL_OD3_HPLL_G12A));
-	pll_ctrl2 = (cconf->pll_frac << 0);
-	if (cconf->pll_frac) {
+		(cConf->pll_n << LCD_PLL_N_HPLL_G12A) |
+		(cConf->pll_m << LCD_PLL_M_HPLL_G12A) |
+		(cConf->pll_od1_sel << LCD_PLL_OD1_HPLL_G12A) |
+		(cConf->pll_od2_sel << LCD_PLL_OD2_HPLL_G12A) |
+		(cConf->pll_od3_sel << LCD_PLL_OD3_HPLL_G12A));
+	pll_ctrl2 = (cConf->pll_frac << 0);
+	if (cConf->pll_frac) {
 		pll_ctrl |= (1 << 27);
 		pll_ctrl4 = 0x6a285c00;
 		pll_ctrl5 = 0x65771290;
@@ -535,7 +508,7 @@ static void lcd_set_pll_ss_level_tl1(unsigned int level)
 	unsigned int pll_ctrl2;
 	unsigned int dep_sel, str_m;
 
-	pll_ctrl2 = lcd_ana_read(HHI_TCON_PLL_CNTL2);
+	pll_ctrl2 = lcd_hiu_read(HHI_TCON_PLL_CNTL2);
 	pll_ctrl2 &= ~((1 << 15) | (0xf << 16) | (0xf << 28));
 
 	if (level > 0) {
@@ -545,7 +518,7 @@ static void lcd_set_pll_ss_level_tl1(unsigned int level)
 		str_m = (str_m > 10) ? 10 : str_m;
 		pll_ctrl2 |= ((1 << 15) | (dep_sel << 28) | (str_m << 16));
 	}
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, pll_ctrl2);
+	lcd_hiu_write(HHI_TCON_PLL_CNTL2, pll_ctrl2);
 
 	LCDPR("set pll spread spectrum: %s\n", lcd_ss_level_table_tl1[level]);
 }
@@ -554,17 +527,17 @@ static void lcd_set_pll_ss_advance_tl1(unsigned int freq, unsigned int mode)
 {
 	unsigned int pll_ctrl2;
 
-	pll_ctrl2 = lcd_ana_read(HHI_TCON_PLL_CNTL2);
+	pll_ctrl2 = lcd_hiu_read(HHI_TCON_PLL_CNTL2);
 	pll_ctrl2 &= ~(0x7 << 24); /* ss_freq */
 	pll_ctrl2 |= (freq << 24);
 	pll_ctrl2 &= ~(0x3 << 22); /* ss_mode */
 	pll_ctrl2 |= (mode << 22);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, pll_ctrl2);
+	lcd_hiu_write(HHI_TCON_PLL_CNTL2, pll_ctrl2);
 
 	LCDPR("set pll spread spectrum: freq=%d, mode=%d\n", freq, mode);
 }
 
-static void lcd_set_pll_tl1(struct lcd_clk_config_s *cconf)
+static void lcd_set_pll_tl1(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl1;
 	unsigned int tcon_div[5][3] = {
@@ -575,46 +548,46 @@ static void lcd_set_pll_tl1(struct lcd_clk_config_s *cconf)
 		{0, 0, 0},  /* div8 */
 		{0, 1, 0},  /* div16 */
 	};
-	unsigned int tcon_div_sel = cconf->pll_tcon_div_sel;
+	unsigned int tcon_div_sel = cConf->pll_tcon_div_sel;
 	int ret, cnt = 0;
 
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s\n", __func__);
 	pll_ctrl = ((0x3 << 17) | /* gate ctrl */
 		(tcon_div[tcon_div_sel][2] << 16) |
-		(cconf->pll_n << LCD_PLL_N_TL1) |
-		(cconf->pll_m << LCD_PLL_M_TL1) |
-		(cconf->pll_od3_sel << LCD_PLL_OD3_TL1) |
-		(cconf->pll_od2_sel << LCD_PLL_OD2_TL1) |
-		(cconf->pll_od1_sel << LCD_PLL_OD1_TL1));
+		(cConf->pll_n << LCD_PLL_N_TL1) |
+		(cConf->pll_m << LCD_PLL_M_TL1) |
+		(cConf->pll_od3_sel << LCD_PLL_OD3_TL1) |
+		(cConf->pll_od2_sel << LCD_PLL_OD2_TL1) |
+		(cConf->pll_od1_sel << LCD_PLL_OD1_TL1));
 	pll_ctrl1 = (1 << 28) |
 		(tcon_div[tcon_div_sel][0] << 22) |
 		(tcon_div[tcon_div_sel][1] << 21) |
 		((1 << 20) | /* sdm_en */
-		(cconf->pll_frac << 0));
+		(cConf->pll_frac << 0));
 
 set_pll_retry_tl1:
-	lcd_ana_write(HHI_TCON_PLL_CNTL0, pll_ctrl);
+	lcd_hiu_write(HHI_TCON_PLL_CNTL0, pll_ctrl);
 	udelay(10);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 1, LCD_PLL_RST_TL1, 1);
+	lcd_hiu_setb(HHI_TCON_PLL_CNTL0, 1, LCD_PLL_RST_TL1, 1);
 	udelay(10);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 1, LCD_PLL_EN_TL1, 1);
+	lcd_hiu_setb(HHI_TCON_PLL_CNTL0, 1, LCD_PLL_EN_TL1, 1);
 	udelay(10);
-	lcd_ana_write(HHI_TCON_PLL_CNTL1, pll_ctrl1);
+	lcd_hiu_write(HHI_TCON_PLL_CNTL1, pll_ctrl1);
 	udelay(10);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x0000110c);
+	lcd_hiu_write(HHI_TCON_PLL_CNTL2, 0x0000110c);
 	udelay(10);
-	lcd_ana_write(HHI_TCON_PLL_CNTL3, 0x10051400);
+	lcd_hiu_write(HHI_TCON_PLL_CNTL3, 0x10051400);
 	udelay(10);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL4, 0x0100c0, 0, 24);
+	lcd_hiu_setb(HHI_TCON_PLL_CNTL4, 0x0100c0, 0, 24);
 	udelay(10);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL4, 0x8300c0, 0, 24);
+	lcd_hiu_setb(HHI_TCON_PLL_CNTL4, 0x8300c0, 0, 24);
 	udelay(10);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 1, 26, 1);
+	lcd_hiu_setb(HHI_TCON_PLL_CNTL0, 1, 26, 1);
 	udelay(10);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 0, LCD_PLL_RST_TL1, 1);
+	lcd_hiu_setb(HHI_TCON_PLL_CNTL0, 0, LCD_PLL_RST_TL1, 1);
 	udelay(10);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x0000300c);
+	lcd_hiu_write(HHI_TCON_PLL_CNTL2, 0x0000300c);
 
 	ret = lcd_pll_wait_lock(HHI_TCON_PLL_CNTL0, LCD_PLL_LOCK_TL1);
 	if (ret) {
@@ -623,177 +596,16 @@ static void lcd_set_pll_tl1(struct lcd_clk_config_s *cconf)
 		LCDERR("hpll lock failed\n");
 	} else {
 		udelay(100);
-		lcd_ana_setb(HHI_TCON_PLL_CNTL2, 1, 5, 1);
+		lcd_hiu_setb(HHI_TCON_PLL_CNTL2, 1, 5, 1);
 	}
 
-	if (cconf->ss_level > 0) {
-		lcd_set_pll_ss_level_tl1(cconf->ss_level);
-		lcd_set_pll_ss_advance_tl1(cconf->ss_freq, cconf->ss_mode);
+	if (cConf->ss_level > 0) {
+		lcd_set_pll_ss_level_tl1(cConf->ss_level);
+		lcd_set_pll_ss_advance_tl1(cConf->ss_freq, cConf->ss_mode);
 	}
 }
 
-static void lcd_prbs_set_pll_vx1_tl1(void)
-{
-	int cnt = 0, ret;
-
-	LCDPR("%s\n", __func__);
-
-lcd_prbs_retry_pll_vx1_tl1:
-	lcd_ana_write(HHI_TCON_PLL_CNTL0, 0x000f04f7);
-	usleep_range(10, 12);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 1, LCD_PLL_RST_TL1, 1);
-	usleep_range(10, 12);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 1, LCD_PLL_EN_TL1, 1);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL1, 0x10110000);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x00001108);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL3, 0x10051400);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL4, 0x010100c0);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL4, 0x038300c0);
-	usleep_range(10, 12);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 1, 26, 1);
-	usleep_range(10, 12);
-	lcd_ana_setb(HHI_TCON_PLL_CNTL0, 0, LCD_PLL_RST_TL1, 1);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x00003008);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x00003028);
-	usleep_range(10, 12);
-
-	ret = lcd_pll_wait_lock(HHI_TCON_PLL_CNTL0, LCD_PLL_LOCK_TL1);
-	if (ret) {
-		if (cnt++ < PLL_RETRY_MAX)
-			goto lcd_prbs_retry_pll_vx1_tl1;
-		LCDERR("hpll lock failed\n");
-	}
-
-	/* pll_div */
-	lcd_ana_setb(HHI_VIID_CLK_CNTL, 0, VCLK2_EN, 1);
-	usleep_range(5, 10);
-
-	/* Disable the div output clock */
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 19, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
-
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 18, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 16, 2);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 0, 14);
-
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 2, 16, 2);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 15, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0x739c, 0, 15);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
-
-	/* Enable the final output clock */
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 19, 1);
-}
-
-static void lcd_prbs_set_pll_lvds_tl1(void)
-{
-	int cnt = 0, ret;
-
-	LCDPR("%s\n", __func__);
-
-lcd_prbs_retry_pll_lvds_tl1:
-	lcd_ana_write(HHI_TCON_PLL_CNTL0, 0x008e049f);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL0, 0x208e049f);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL0, 0x3006049f);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL1, 0x10000000);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x00001102);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL3, 0x10051400);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL4, 0x010100c0);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL4, 0x038300c0);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL0, 0x348e049f);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL0, 0x148e049f);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x00003002);
-	usleep_range(10, 12);
-	lcd_ana_write(HHI_TCON_PLL_CNTL2, 0x00003022);
-	usleep_range(10, 12);
-
-	ret = lcd_pll_wait_lock(HHI_TCON_PLL_CNTL0, LCD_PLL_LOCK_TL1);
-	if (ret) {
-		if (cnt++ < PLL_RETRY_MAX)
-			goto lcd_prbs_retry_pll_lvds_tl1;
-		LCDERR("hpll lock failed\n");
-	}
-
-	/* pll_div */
-	lcd_ana_setb(HHI_VIID_CLK_CNTL, 0, VCLK2_EN, 1);
-	usleep_range(5, 10);
-
-	/* Disable the div output clock */
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 19, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
-
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 18, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 16, 2);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 0, 14);
-
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 16, 2);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 15, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0x3c78, 0, 15);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
-
-	/* Enable the final output clock */
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 19, 1);
-}
-
-static void lcd_prbs_config_clk_tl1(unsigned int lcd_prbs_mode)
-{
-	if (lcd_prbs_mode == LCD_PRBS_MODE_VX1) {
-		lcd_prbs_set_pll_vx1_tl1();
-	} else if (lcd_prbs_mode == LCD_PRBS_MODE_LVDS) {
-		lcd_prbs_set_pll_lvds_tl1();
-	} else {
-		LCDERR("%s: unsupport lcd_prbs_mode %d\n",
-		       __func__, lcd_prbs_mode);
-		return;
-	}
-
-	lcd_hiu_setb(HHI_VIID_CLK_DIV, 0, VCLK2_XD, 8);
-	usleep_range(5, 10);
-
-	/* select vid_pll_clk */
-	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 0, VCLK2_CLK_IN_SEL, 3);
-	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 1, VCLK2_EN, 1);
-	usleep_range(5, 10);
-
-	/* [15:12] encl_clk_sel, select vclk2_div1 */
-	lcd_hiu_setb(HHI_VIID_CLK_DIV, 8, ENCL_CLK_SEL, 4);
-	/* release vclk2_div_reset and enable vclk2_div */
-	lcd_hiu_setb(HHI_VIID_CLK_DIV, 1, VCLK2_XD_EN, 2);
-	usleep_range(5, 10);
-
-	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 1, VCLK2_DIV1_EN, 1);
-	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 1, VCLK2_SOFT_RST, 1);
-	usleep_range(10, 12);
-	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 0, VCLK2_SOFT_RST, 1);
-	usleep_range(5, 10);
-
-	/* enable CTS_ENCL clk gate */
-	lcd_hiu_setb(HHI_VID_CLK_CNTL2, 1, ENCL_GATE_VCLK, 1);
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s ok\n", __func__);
-}
-
-static void lcd_set_vid_pll_div(struct lcd_clk_config_s *cconf)
+static void lcd_set_vid_pll_div(struct lcd_clk_config_s *cConf)
 {
 	unsigned int shift_val, shift_sel;
 	int i;
@@ -805,12 +617,12 @@ static void lcd_set_vid_pll_div(struct lcd_clk_config_s *cconf)
 	udelay(5);
 
 	/* Disable the div output clock */
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 19, 1);
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+	lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+	lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
 
 	i = 0;
 	while (lcd_clk_div_table[i][0] != CLK_DIV_SEL_MAX) {
-		if (cconf->div_sel == lcd_clk_div_table[i][0])
+		if (cConf->div_sel == lcd_clk_div_table[i][0])
 			break;
 		i++;
 	}
@@ -820,44 +632,34 @@ static void lcd_set_vid_pll_div(struct lcd_clk_config_s *cconf)
 	shift_sel = lcd_clk_div_table[i][2];
 
 	if (shift_val == 0xffff) { /* if divide by 1 */
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 1, 18, 1);
 	} else {
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 18, 1);
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 16, 2);
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 0, 18, 1);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 0, 0, 14);
 
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 15, 1);
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, shift_val, 0, 15);
-		lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, shift_val, 0, 15);
+		lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
 	}
 	/* Enable the final output clock */
-	lcd_ana_setb(HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+	lcd_hiu_setb(HHI_VID_PLL_CLK_DIV, 1, 19, 1);
 }
 
-static void lcd_set_vclk_crt(int lcd_type, struct lcd_clk_config_s *cconf)
+static void lcd_set_vclk_crt(int lcd_type, struct lcd_clk_config_s *cConf)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s\n", __func__);
 
-	if (lcd_drv->lcd_pxp) {
-		/* setup the XD divider value */
-		lcd_hiu_setb(HHI_VIID_CLK_DIV, (cconf->xd), VCLK2_XD, 8);
-		udelay(5);
-		/* select vid_pll_clk */
-		lcd_hiu_setb(HHI_VIID_CLK_CNTL, 7, VCLK2_CLK_IN_SEL, 3);
-	} else {
-		/* setup the XD divider value */
-		lcd_hiu_setb(HHI_VIID_CLK_DIV, (cconf->xd - 1), VCLK2_XD, 8);
-		udelay(5);
-		/* select vid_pll_clk */
-		lcd_hiu_setb(HHI_VIID_CLK_CNTL, cconf->data->vclk_sel,
-			     VCLK2_CLK_IN_SEL, 3);
-	}
+	/* setup the XD divider value */
+	lcd_hiu_setb(HHI_VIID_CLK_DIV, (cConf->xd-1), VCLK2_XD, 8);
+	udelay(5);
 
+	/* select vid_pll_clk */
+	lcd_hiu_setb(HHI_VIID_CLK_CNTL, cConf->data->vclk_sel,
+		VCLK2_CLK_IN_SEL, 3);
 	lcd_hiu_setb(HHI_VIID_CLK_CNTL, 1, VCLK2_EN, 1);
 	udelay(2);
 
@@ -897,9 +699,9 @@ static void lcd_set_tcon_clk(struct lcd_config_s *pconf)
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_MLVDS:
 		val = pconf->lcd_control.mlvds_config->clk_phase & 0xfff;
-		lcd_ana_setb(HHI_TCON_PLL_CNTL1, (val & 0xf), 24, 4);
-		lcd_ana_setb(HHI_TCON_PLL_CNTL4, ((val >> 4) & 0xf), 28, 4);
-		lcd_ana_setb(HHI_TCON_PLL_CNTL4, ((val >> 8) & 0xf), 24, 4);
+		lcd_hiu_setb(HHI_TCON_PLL_CNTL1, (val & 0xf), 24, 4);
+		lcd_hiu_setb(HHI_TCON_PLL_CNTL4, ((val >> 4) & 0xf), 28, 4);
+		lcd_hiu_setb(HHI_TCON_PLL_CNTL4, ((val >> 8) & 0xf), 24, 4);
 
 		/* tcon_clk */
 		if (pconf->lcd_timing.lcd_clk >= 100000000) /* 25M */
@@ -922,23 +724,18 @@ static void lcd_set_tcon_clk(struct lcd_config_s *pconf)
 	}
 }
 
-static void lcd_set_tcon_clk_t5(struct lcd_config_s *pconf)
-{
-	lcd_set_tcon_clk(pconf);
-
-	/* global reset tcon */
-	lcd_reset_setb(RESET1_MASK_T5, 0, 4, 1);
-	lcd_reset_setb(RESET1_LEVEL_T5, 0, 4, 1);
-	udelay(1);
-	lcd_reset_setb(RESET1_LEVEL_T5, 1, 4, 1);
-	udelay(2);
-	LCDPR("reset tcon\n");
-}
-
 /* ****************************************************
  * lcd clk parameters calculate
  * ****************************************************
  */
+static int error_abs(int a, int b)
+{
+	if (a >= b)
+		return (a - b);
+	else
+		return (b - a);
+}
+
 static unsigned int clk_vid_pll_div_calc(unsigned int clk,
 		unsigned int div_sel, int dir)
 {
@@ -1072,14 +869,15 @@ static unsigned int clk_vid_pll_div_get(unsigned int clk_div)
 	return div_sel;
 }
 
-static int check_pll_txl(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
+static int check_pll_txl(struct lcd_clk_config_s *cConf,
+		unsigned int pll_fout)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct lcd_clk_data_s *data = cconf->data;
+	struct lcd_clk_data_s *data = cConf->data;
 	unsigned int m, n;
 	unsigned int od1_sel, od2_sel, od3_sel, od1, od2, od3;
 	unsigned int pll_fod2_in, pll_fod3_in, pll_fvco;
-	unsigned int od_fb = 0, frac_range, pll_frac;
+	unsigned int od_fb = 0, pll_frac;
 	int done;
 
 	done = 0;
@@ -1087,7 +885,6 @@ static int check_pll_txl(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
 		(pll_fout < data->pll_out_fmin)) {
 		return done;
 	}
-	frac_range = data->pll_frac_range;
 	for (od3_sel = data->pll_od_sel_max; od3_sel > 0; od3_sel--) {
 		od3 = od_table[od3_sel - 1];
 		pll_fod3_in = pll_fout * od3;
@@ -1101,43 +898,34 @@ static int check_pll_txl(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
 					(pll_fvco > data->pll_vco_fmax)) {
 					continue;
 				}
-				cconf->pll_od1_sel = od1_sel - 1;
-				cconf->pll_od2_sel = od2_sel - 1;
-				cconf->pll_od3_sel = od3_sel - 1;
-				cconf->pll_fout = pll_fout;
+				cConf->pll_od1_sel = od1_sel - 1;
+				cConf->pll_od2_sel = od2_sel - 1;
+				cConf->pll_od3_sel = od3_sel - 1;
+				cConf->pll_fout = pll_fout;
 				if (lcd_debug_print_flag == 2) {
 					LCDPR("od1=%d, od2=%d, od3=%d\n",
 						(od1_sel - 1), (od2_sel - 1),
 						(od3_sel - 1));
 					LCDPR("pll_fvco=%d\n", pll_fvco);
 				}
-				cconf->pll_fvco = pll_fvco;
+				cConf->pll_fvco = pll_fvco;
 				n = 1;
 				if (lcd_drv->data->chip_type == LCD_CHIP_TXL) {
 					if (pll_fvco < 3700000)
 						od_fb = 0;
 					else
 						od_fb = 1;
-					cconf->pll_od_fb = od_fb;
+					cConf->pll_od_fb = od_fb;
 				} else {
-					od_fb = cconf->pll_od_fb;
+					od_fb = cConf->pll_od_fb;
 				}
 				pll_fvco = pll_fvco / od_fb_table[od_fb];
-				m = pll_fvco / cconf->fin;
-				pll_frac = (pll_fvco % cconf->fin) *
-					frac_range / cconf->fin;
-				if (cconf->pll_mode & LCD_PLL_MODE_FRAC_SHIFT) {
-					if ((pll_frac == (frac_range >> 1)) ||
-					    (pll_frac == (frac_range >> 2))) {
-						pll_frac |= 0x66;
-						cconf->pll_frac_half_shift = 1;
-					} else {
-						cconf->pll_frac_half_shift = 0;
-					}
-				}
-				cconf->pll_m = m;
-				cconf->pll_n = n;
-				cconf->pll_frac = pll_frac;
+				m = pll_fvco / cConf->fin;
+				pll_frac = (pll_fvco % cConf->fin) *
+					data->pll_frac_range / cConf->fin;
+				cConf->pll_m = m;
+				cConf->pll_n = n;
+				cConf->pll_frac = pll_frac;
 				if (lcd_debug_print_flag == 2) {
 					LCDPR("m=%d, n=%d, frac=0x%x\n",
 						m, n, pll_frac);
@@ -1150,9 +938,9 @@ static int check_pll_txl(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
 	return done;
 }
 
-static int check_pll_vco(struct lcd_clk_config_s *cconf, unsigned int pll_fvco)
+static int check_pll_vco(struct lcd_clk_config_s *cConf, unsigned int pll_fvco)
 {
-	struct lcd_clk_data_s *data = cconf->data;
+	struct lcd_clk_data_s *data = cConf->data;
 	unsigned int m, n;
 	unsigned int od_fb = 0, pll_frac;
 	int done = 0;
@@ -1164,24 +952,15 @@ static int check_pll_vco(struct lcd_clk_config_s *cconf, unsigned int pll_fvco)
 		return done;
 	}
 
-	cconf->pll_fvco = pll_fvco;
+	cConf->pll_fvco = pll_fvco;
 	n = 1;
-	od_fb = cconf->pll_od_fb;
+	od_fb = cConf->pll_od_fb;
 	pll_fvco = pll_fvco / od_fb_table[od_fb];
-	m = pll_fvco / cconf->fin;
-	pll_frac = (pll_fvco % cconf->fin) * data->pll_frac_range / cconf->fin;
-	cconf->pll_m = m;
-	cconf->pll_n = n;
-	cconf->pll_frac = pll_frac;
-	if (cconf->pll_mode & LCD_PLL_MODE_FRAC_SHIFT) {
-		if ((pll_frac == (data->pll_frac_range >> 1)) ||
-		    (pll_frac == (data->pll_frac_range >> 2))) {
-			pll_frac |= 0x66;
-			cconf->pll_frac_half_shift = 1;
-		} else {
-			cconf->pll_frac_half_shift = 0;
-		}
-	}
+	m = pll_fvco / cConf->fin;
+	pll_frac = (pll_fvco % cConf->fin) * data->pll_frac_range / cConf->fin;
+	cConf->pll_m = m;
+	cConf->pll_n = n;
+	cConf->pll_frac = pll_frac;
 	if (lcd_debug_print_flag == 2) {
 		LCDPR("m=%d, n=%d, frac=0x%x, pll_fvco=%d\n",
 			m, n, pll_frac, pll_fvco);
@@ -1192,9 +971,9 @@ static int check_pll_vco(struct lcd_clk_config_s *cconf, unsigned int pll_fvco)
 }
 
 #define PLL_FVCO_ERR_MAX    2 /* kHz */
-static int check_pll_od(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
+static int check_pll_od(struct lcd_clk_config_s *cConf, unsigned int pll_fout)
 {
-	struct lcd_clk_data_s *data = cconf->data;
+	struct lcd_clk_data_s *data = cConf->data;
 	unsigned int od1_sel, od2_sel, od3_sel, od1, od2, od3;
 	unsigned int pll_fod2_in, pll_fod3_in, pll_fvco;
 	int done = 0;
@@ -1216,12 +995,12 @@ static int check_pll_od(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
 					(pll_fvco > data->pll_vco_fmax)) {
 					continue;
 				}
-				if (error_abs(pll_fvco, cconf->pll_fvco) <
+				if (error_abs(pll_fvco, cConf->pll_fvco) <
 					PLL_FVCO_ERR_MAX) {
-					cconf->pll_od1_sel = od1_sel - 1;
-					cconf->pll_od2_sel = od2_sel - 1;
-					cconf->pll_od3_sel = od3_sel - 1;
-					cconf->pll_fout = pll_fout;
+					cConf->pll_od1_sel = od1_sel - 1;
+					cConf->pll_od2_sel = od2_sel - 1;
+					cConf->pll_od3_sel = od3_sel - 1;
+					cConf->pll_fout = pll_fout;
 
 					if (lcd_debug_print_flag == 2) {
 						LCDPR(
@@ -1245,48 +1024,51 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 	unsigned int clk_div_in, clk_div_out;
 	unsigned int clk_div_sel, xd, tcon_div_sel = 0, phy_div = 1;
 	unsigned int od1, od2, od3;
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
+	struct lcd_clk_config_s *cConf = get_lcd_clk_config();
 	int done;
 
 	done = 0;
-	cconf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
-	cconf->err_fmin = MAX_ERROR;
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	cConf->err_fmin = MAX_ERROR;
 
-	if (cconf->fout > cconf->data->xd_out_fmax) {
+	if (cConf->fout > cConf->data->xd_out_fmax) {
 		LCDERR("%s: wrong lcd_clk value %dkHz\n",
-			__func__, cconf->fout);
+			__func__, cConf->fout);
 		goto generate_clk_done_txl;
 	}
 
 	bit_rate = pconf->lcd_timing.bit_rate / 1000;
 
-	cconf->pll_mode = pconf->lcd_timing.clk_auto;
+	if (pconf->lcd_timing.clk_auto == 2)
+		cConf->pll_mode = 1;
+	else
+		cConf->pll_mode = 0;
 
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_TTL:
 		clk_div_sel = CLK_DIV_SEL_1;
-		cconf->xd_max = CRT_VID_DIV_MAX;
-		for (xd = 1; xd <= cconf->xd_max; xd++) {
-			clk_div_out = cconf->fout * xd;
-			if (clk_div_out > cconf->data->div_out_fmax)
+		cConf->xd_max = CRT_VID_DIV_MAX;
+		for (xd = 1; xd <= cConf->xd_max; xd++) {
+			clk_div_out = cConf->fout * xd;
+			if (clk_div_out > cConf->data->div_out_fmax)
 				continue;
 			if (lcd_debug_print_flag == 2) {
 				LCDPR("fout=%d, xd=%d, clk_div_out=%d\n",
-					cconf->fout, xd, clk_div_out);
+					cConf->fout, xd, clk_div_out);
 			}
 			clk_div_in = clk_vid_pll_div_calc(clk_div_out,
 					clk_div_sel, CLK_DIV_O2I);
-			if (clk_div_in > cconf->data->div_in_fmax)
+			if (clk_div_in > cConf->data->div_in_fmax)
 				continue;
-			cconf->xd = xd;
-			cconf->div_sel = clk_div_sel;
+			cConf->xd = xd;
+			cConf->div_sel = clk_div_sel;
 			pll_fout = clk_div_in;
 			if (lcd_debug_print_flag == 2) {
 				LCDPR("clk_div_sel=%s(index %d), pll_fout=%d\n",
 					lcd_clk_div_sel_table[clk_div_sel],
 					clk_div_sel, pll_fout);
 			}
-			done = check_pll_txl(cconf, pll_fout);
+			done = check_pll_txl(cConf, pll_fout);
 			if (done)
 				goto generate_clk_done_txl;
 		}
@@ -1294,26 +1076,26 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 	case LCD_LVDS:
 		clk_div_sel = CLK_DIV_SEL_7;
 		xd = 1;
-		clk_div_out = cconf->fout * xd;
-		if (clk_div_out > cconf->data->div_out_fmax)
+		clk_div_out = cConf->fout * xd;
+		if (clk_div_out > cConf->data->div_out_fmax)
 			goto generate_clk_done_txl;
 		if (lcd_debug_print_flag == 2) {
 			LCDPR("fout=%d, xd=%d, clk_div_out=%d\n",
-				cconf->fout, xd, clk_div_out);
+				cConf->fout, xd, clk_div_out);
 		}
 		clk_div_in = clk_vid_pll_div_calc(clk_div_out,
 				clk_div_sel, CLK_DIV_O2I);
-		if (clk_div_in > cconf->data->div_in_fmax)
+		if (clk_div_in > cConf->data->div_in_fmax)
 			goto generate_clk_done_txl;
-		cconf->xd = xd;
-		cconf->div_sel = clk_div_sel;
+		cConf->xd = xd;
+		cConf->div_sel = clk_div_sel;
 		pll_fout = clk_div_in;
 		if (lcd_debug_print_flag == 2) {
 			LCDPR("clk_div_sel=%s(index %d), pll_fout=%d\n",
 				lcd_clk_div_sel_table[clk_div_sel],
 				clk_div_sel, pll_fout);
 		}
-		done = check_pll_txl(cconf, pll_fout);
+		done = check_pll_txl(cConf, pll_fout);
 		if (done == 0)
 			goto generate_clk_done_txl;
 		done = 0;
@@ -1321,61 +1103,61 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 			phy_div = 2;
 		else
 			phy_div = 1;
-		od1 = od_table[cconf->pll_od1_sel];
-		od2 = od_table[cconf->pll_od2_sel];
-		od3 = od_table[cconf->pll_od3_sel];
+		od1 = od_table[cConf->pll_od1_sel];
+		od2 = od_table[cConf->pll_od2_sel];
+		od3 = od_table[cConf->pll_od3_sel];
 		for (tcon_div_sel = 0; tcon_div_sel < 5; tcon_div_sel++) {
 			if (tcon_div_table[tcon_div_sel] ==
 				phy_div * od1 * od2 * od3) {
-				cconf->pll_tcon_div_sel = tcon_div_sel;
+				cConf->pll_tcon_div_sel = tcon_div_sel;
 				done = 1;
 				break;
 			}
 		}
 		break;
 	case LCD_VBYONE:
-		cconf->div_sel_max = CLK_DIV_SEL_MAX;
-		cconf->xd_max = CRT_VID_DIV_MAX;
+		cConf->div_sel_max = CLK_DIV_SEL_MAX;
+		cConf->xd_max = CRT_VID_DIV_MAX;
 		pll_fout = bit_rate;
 		clk_div_in = pll_fout;
-		if (clk_div_in > cconf->data->div_in_fmax)
+		if (clk_div_in > cConf->data->div_in_fmax)
 			goto generate_clk_done_txl;
 		if (lcd_debug_print_flag == 2)
 			LCDPR("pll_fout=%d\n", pll_fout);
-		if ((clk_div_in / cconf->fout) > 15)
-			cconf->xd = 4;
+		if ((clk_div_in / cConf->fout) > 15)
+			cConf->xd = 4;
 		else
-			cconf->xd = 1;
-		clk_div_out = cconf->fout * cconf->xd;
+			cConf->xd = 1;
+		clk_div_out = cConf->fout * cConf->xd;
 		if (lcd_debug_print_flag == 2) {
 			LCDPR("clk_div_in=%d, fout=%d, xd=%d, clk_div_out=%d\n",
-				clk_div_in, cconf->fout,
-				cconf->xd, clk_div_out);
+				clk_div_in, cConf->fout,
+				cConf->xd, clk_div_out);
 		}
-		if (clk_div_out > cconf->data->div_out_fmax)
+		if (clk_div_out > cConf->data->div_out_fmax)
 			goto generate_clk_done_txl;
 		clk_div_sel = clk_vid_pll_div_get(
 				clk_div_in * 100 / clk_div_out);
 		if (clk_div_sel == CLK_DIV_SEL_MAX) {
 			clk_div_sel = CLK_DIV_SEL_1;
-			cconf->xd *= clk_div_in / clk_div_out;
+			cConf->xd *= clk_div_in / clk_div_out;
 		} else
-			cconf->div_sel = clk_div_sel;
+			cConf->div_sel = clk_div_sel;
 		if (lcd_debug_print_flag == 2) {
 			LCDPR("clk_div_sel=%s(index %d), xd=%d\n",
 				lcd_clk_div_sel_table[clk_div_sel],
-				cconf->div_sel, cconf->xd);
+				cConf->div_sel, cConf->xd);
 		}
-		done = check_pll_txl(cconf, pll_fout);
+		done = check_pll_txl(cConf, pll_fout);
 		if (done == 0)
 			goto generate_clk_done_txl;
 		done = 0;
-		od1 = od_table[cconf->pll_od1_sel];
-		od2 = od_table[cconf->pll_od2_sel];
-		od3 = od_table[cconf->pll_od3_sel];
+		od1 = od_table[cConf->pll_od1_sel];
+		od2 = od_table[cConf->pll_od2_sel];
+		od3 = od_table[cConf->pll_od3_sel];
 		for (tcon_div_sel = 0; tcon_div_sel < 5; tcon_div_sel++) {
 			if (tcon_div_table[tcon_div_sel] == od1 * od2 * od3) {
-				cconf->pll_tcon_div_sel = tcon_div_sel;
+				cConf->pll_tcon_div_sel = tcon_div_sel;
 				done = 1;
 				break;
 			}
@@ -1385,18 +1167,18 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 		/* must go through div4 for clk phase */
 		for (tcon_div_sel = 3; tcon_div_sel < 5; tcon_div_sel++) {
 			pll_fvco = bit_rate * tcon_div_table[tcon_div_sel];
-			done = check_pll_vco(cconf, pll_fvco);
+			done = check_pll_vco(cConf, pll_fvco);
 			if (done == 0)
 				continue;
-			cconf->xd_max = CRT_VID_DIV_MAX;
-			for (xd = 1; xd <= cconf->xd_max; xd++) {
-				clk_div_out = cconf->fout * xd;
-				if (clk_div_out > cconf->data->div_out_fmax)
+			cConf->xd_max = CRT_VID_DIV_MAX;
+			for (xd = 1; xd <= cConf->xd_max; xd++) {
+				clk_div_out = cConf->fout * xd;
+				if (clk_div_out > cConf->data->div_out_fmax)
 					continue;
 				if (lcd_debug_print_flag == 2) {
 					LCDPR(
 					"fout=%d, xd=%d, clk_div_out=%d\n",
-						cconf->fout, xd, clk_div_out);
+						cConf->fout, xd, clk_div_out);
 				}
 				for (clk_div_sel = CLK_DIV_SEL_1;
 					clk_div_sel < CLK_DIV_SEL_MAX;
@@ -1405,11 +1187,11 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 						clk_div_out, clk_div_sel,
 						CLK_DIV_O2I);
 					if (clk_div_in >
-						cconf->data->div_in_fmax)
+						cConf->data->div_in_fmax)
 						continue;
-					cconf->xd = xd;
-					cconf->div_sel = clk_div_sel;
-					cconf->pll_tcon_div_sel = tcon_div_sel;
+					cConf->xd = xd;
+					cConf->div_sel = clk_div_sel;
+					cConf->pll_tcon_div_sel = tcon_div_sel;
 					pll_fout = clk_div_in;
 					if (lcd_debug_print_flag == 2) {
 						LCDPR("clk_div_sel=%s(%d)\n",
@@ -1419,7 +1201,7 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 					"pll_fout=%d, tcon_div_sel=%d\n",
 							pll_fout, tcon_div_sel);
 					}
-					done = check_pll_od(cconf, pll_fout);
+					done = check_pll_od(cConf, pll_fout);
 					if (done)
 						goto generate_clk_done_txl;
 				}
@@ -1429,18 +1211,18 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 	case LCD_P2P:
 		for (tcon_div_sel = 0; tcon_div_sel < 5; tcon_div_sel++) {
 			pll_fvco = bit_rate * tcon_div_table[tcon_div_sel];
-			done = check_pll_vco(cconf, pll_fvco);
+			done = check_pll_vco(cConf, pll_fvco);
 			if (done == 0)
 				continue;
-			cconf->xd_max = CRT_VID_DIV_MAX;
-			for (xd = 1; xd <= cconf->xd_max; xd++) {
-				clk_div_out = cconf->fout * xd;
-				if (clk_div_out > cconf->data->div_out_fmax)
+			cConf->xd_max = CRT_VID_DIV_MAX;
+			for (xd = 1; xd <= cConf->xd_max; xd++) {
+				clk_div_out = cConf->fout * xd;
+				if (clk_div_out > cConf->data->div_out_fmax)
 					continue;
 				if (lcd_debug_print_flag == 2) {
 					LCDPR(
 					"fout=%d, xd=%d, clk_div_out=%d\n",
-						cconf->fout, xd, clk_div_out);
+						cConf->fout, xd, clk_div_out);
 				}
 				for (clk_div_sel = CLK_DIV_SEL_1;
 					clk_div_sel < CLK_DIV_SEL_MAX;
@@ -1449,11 +1231,11 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 						clk_div_out, clk_div_sel,
 						CLK_DIV_O2I);
 					if (clk_div_in >
-						cconf->data->div_in_fmax)
+						cConf->data->div_in_fmax)
 						continue;
-					cconf->xd = xd;
-					cconf->div_sel = clk_div_sel;
-					cconf->pll_tcon_div_sel = tcon_div_sel;
+					cConf->xd = xd;
+					cConf->div_sel = clk_div_sel;
+					cConf->pll_tcon_div_sel = tcon_div_sel;
 					pll_fout = clk_div_in;
 					if (lcd_debug_print_flag == 2) {
 						LCDPR("clk_div_sel=%s(%d)\n",
@@ -1463,7 +1245,7 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 					"pll_fout=%d, tcon_div_sel=%d\n",
 							pll_fout, tcon_div_sel);
 					}
-					done = check_pll_od(cconf, pll_fout);
+					done = check_pll_od(cConf, pll_fout);
 					if (done)
 						goto generate_clk_done_txl;
 				}
@@ -1479,17 +1261,15 @@ static void lcd_clk_generate_txl(struct lcd_config_s *pconf)
 generate_clk_done_txl:
 	if (done) {
 		pconf->lcd_timing.pll_ctrl =
-			(cconf->pll_od1_sel << PLL_CTRL_OD1) |
-			(cconf->pll_od2_sel << PLL_CTRL_OD2) |
-			(cconf->pll_od3_sel << PLL_CTRL_OD3) |
-			(cconf->pll_n << PLL_CTRL_N)         |
-			(cconf->pll_m << PLL_CTRL_M);
+			(cConf->pll_od1_sel << PLL_CTRL_OD1) |
+			(cConf->pll_od2_sel << PLL_CTRL_OD2) |
+			(cConf->pll_od3_sel << PLL_CTRL_OD3) |
+			(cConf->pll_n << PLL_CTRL_N)         |
+			(cConf->pll_m << PLL_CTRL_M);
 		pconf->lcd_timing.div_ctrl =
-			(cconf->div_sel << DIV_CTRL_DIV_SEL) |
-			(cconf->xd << DIV_CTRL_XD);
-		pconf->lcd_timing.clk_ctrl =
-			(cconf->pll_frac << CLK_CTRL_FRAC) |
-			(cconf->pll_frac_half_shift << CLK_CTRL_FRAC_SHIFT);
+			(cConf->div_sel << DIV_CTRL_DIV_SEL) |
+			(cConf->xd << DIV_CTRL_XD);
+		pconf->lcd_timing.clk_ctrl = (cConf->pll_frac << CLK_CTRL_FRAC);
 	} else {
 		pconf->lcd_timing.pll_ctrl =
 			(1 << PLL_CTRL_OD1) |
@@ -1510,37 +1290,36 @@ static void lcd_pll_frac_generate_txl(struct lcd_config_s *pconf)
 	unsigned int pll_fout;
 	unsigned int clk_div_in, clk_div_out, clk_div_sel;
 	unsigned int od1, od2, od3, pll_fvco;
-	unsigned int m, n, od_fb, frac_range, frac, offset, temp;
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
-
-	cconf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
-	clk_div_sel = cconf->div_sel;
-	od1 = od_table[cconf->pll_od1_sel];
-	od2 = od_table[cconf->pll_od2_sel];
-	od3 = od_table[cconf->pll_od3_sel];
-	m = cconf->pll_m;
-	n = cconf->pll_n;
-	od_fb = cconf->pll_od_fb;
-	frac_range = cconf->data->pll_frac_range;
+	unsigned int m, n, od_fb, frac, offset, temp;
+	struct lcd_clk_config_s *cConf = get_lcd_clk_config();
+
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	clk_div_sel = cConf->div_sel;
+	od1 = od_table[cConf->pll_od1_sel];
+	od2 = od_table[cConf->pll_od2_sel];
+	od3 = od_table[cConf->pll_od3_sel];
+	m = cConf->pll_m;
+	n = cConf->pll_n;
+	od_fb = cConf->pll_od_fb;
 
 	if (lcd_debug_print_flag == 2) {
 		LCDPR("m=%d, n=%d, od1=%d, od2=%d, od3=%d\n",
-			m, n, cconf->pll_od1_sel, cconf->pll_od2_sel,
-			cconf->pll_od3_sel);
+			m, n, cConf->pll_od1_sel, cConf->pll_od2_sel,
+			cConf->pll_od3_sel);
 		LCDPR("clk_div_sel=%s(index %d), xd=%d\n",
 			lcd_clk_div_sel_table[clk_div_sel],
-			clk_div_sel, cconf->xd);
+			clk_div_sel, cConf->xd);
 	}
-	if (cconf->fout > cconf->data->xd_out_fmax) {
+	if (cConf->fout > cConf->data->xd_out_fmax) {
 		LCDERR("%s: wrong lcd_clk value %dkHz\n",
-			__func__, cconf->fout);
+			__func__, cConf->fout);
 		return;
 	}
 	if (lcd_debug_print_flag == 2)
-		LCDPR("%s pclk=%d\n", __func__, cconf->fout);
+		LCDPR("%s pclk=%d\n", __func__, cConf->fout);
 
-	clk_div_out = cconf->fout * cconf->xd;
-	if (clk_div_out > cconf->data->div_out_fmax) {
+	clk_div_out = cConf->fout * cConf->xd;
+	if (clk_div_out > cConf->data->div_out_fmax) {
 		LCDERR("%s: wrong clk_div_out value %dkHz\n",
 			__func__, clk_div_out);
 		return;
@@ -1548,15 +1327,15 @@ static void lcd_pll_frac_generate_txl(struct lcd_config_s *pconf)
 
 	clk_div_in =
 		clk_vid_pll_div_calc(clk_div_out, clk_div_sel, CLK_DIV_O2I);
-	if (clk_div_in > cconf->data->div_in_fmax) {
+	if (clk_div_in > cConf->data->div_in_fmax) {
 		LCDERR("%s: wrong clk_div_in value %dkHz\n",
 			__func__, clk_div_in);
 		return;
 	}
 
 	pll_fout = clk_div_in;
-	if ((pll_fout > cconf->data->pll_out_fmax) ||
-	    (pll_fout < cconf->data->pll_out_fmin)) {
+	if ((pll_fout > cConf->data->pll_out_fmax) ||
+		(pll_fout < cConf->data->pll_out_fmin)) {
 		LCDERR("%s: wrong pll_fout value %dkHz\n", __func__, pll_fout);
 		return;
 	}
@@ -1564,17 +1343,17 @@ static void lcd_pll_frac_generate_txl(struct lcd_config_s *pconf)
 		LCDPR("%s pll_fout=%d\n", __func__, pll_fout);
 
 	pll_fvco = pll_fout * od1 * od2 * od3;
-	if ((pll_fvco < cconf->data->pll_vco_fmin) ||
-	    (pll_fvco > cconf->data->pll_vco_fmax)) {
+	if ((pll_fvco < cConf->data->pll_vco_fmin) ||
+		(pll_fvco > cConf->data->pll_vco_fmax)) {
 		LCDERR("%s: wrong pll_fvco value %dkHz\n", __func__, pll_fvco);
 		return;
 	}
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s pll_fvco=%d\n", __func__, pll_fvco);
 
-	cconf->pll_fvco = pll_fvco;
+	cConf->pll_fvco = pll_fvco;
 	pll_fvco = pll_fvco / od_fb_table[od_fb];
-	temp = cconf->fin * m / n;
+	temp = cConf->fin * m / n;
 	if (pll_fvco >= temp) {
 		temp = pll_fvco - temp;
 		offset = 0;
@@ -1582,81 +1361,21 @@ static void lcd_pll_frac_generate_txl(struct lcd_config_s *pconf)
 		temp = temp - pll_fvco;
 		offset = 1;
 	}
-	if (temp >= (2 * cconf->fin)) {
+	if (temp >= (2 * cConf->fin)) {
 		LCDERR("%s: pll changing %dkHz is too much\n",
 			__func__, temp);
 		return;
 	}
-	frac = temp * frac_range * n / cconf->fin;
-	if (cconf->pll_mode & LCD_PLL_MODE_FRAC_SHIFT) {
-		if ((frac == (frac_range >> 1)) ||
-		    (frac == (frac_range >> 2))) {
-			frac |= 0x66;
-			cconf->pll_frac_half_shift = 1;
-		} else {
-			cconf->pll_frac_half_shift = 0;
-		}
-	}
-	cconf->pll_frac = frac | (offset << cconf->data->pll_frac_sign_bit);
+	frac = temp * cConf->data->pll_frac_range * n / cConf->fin;
+	cConf->pll_frac = frac | (offset << 11);
 	if (lcd_debug_print_flag)
 		LCDPR("lcd_pll_frac_generate: frac=0x%x\n", frac);
 }
 
-static void lcd_pll_finetune_tm2(struct lcd_config_s *pconf, int ppm)
+static int check_pll_axg(struct lcd_clk_config_s *cConf,
+		unsigned int pll_fout)
 {
-	unsigned int pll_fvco, ppm_adj;
-	unsigned int m, n, od_fb, frac_range, frac, sign, temp;
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
-
-	m = cconf->pll_m;
-	n = cconf->pll_n;
-	od_fb = cconf->pll_od_fb;
-	frac_range = cconf->data->pll_frac_range;
-	pll_fvco = cconf->pll_fvco / od_fb_table[od_fb];
-	ppm_adj = pll_fvco / 1000000;
-	if (!ppm_adj)
-		ppm_adj = ppm;
-	else
-		ppm_adj *= ppm;
-
-	temp = cconf->fin * m / n;
-	if (pll_fvco + ppm_adj >= temp) {
-		temp = pll_fvco + ppm_adj - temp;
-		sign = 0;
-	} else {
-		temp = temp - (pll_fvco + ppm_adj);
-		sign = 1;
-	}
-	if (temp >= (2 * cconf->fin)) {
-		LCDERR("%s: pll changing %dkHz is too much\n",
-			__func__, temp);
-		return;
-	}
-	if (lcd_debug_print_flag == 2) {
-		LCDPR("clk_src=%d, clk_tgt=%d, ppm_adj=%d, adj=%d\n",
-			cconf->fin * m / n, pll_fvco, ppm_adj, temp);
-	}
-	frac = temp * frac_range * n / cconf->fin;
-	if (cconf->pll_mode & LCD_PLL_MODE_FRAC_SHIFT) {
-		if ((frac == (frac_range >> 1)) ||
-		    (frac == (frac_range >> 2))) {
-			frac |= 0x66;
-			cconf->pll_frac_half_shift = 1;
-		} else {
-			cconf->pll_frac_half_shift = 0;
-		}
-	}
-	cconf->pll_frac = frac | (sign << cconf->data->pll_frac_sign_bit);
-	cconf->ppm_adj = ppm;
-	if (lcd_debug_print_flag) {
-		LCDPR("lcd_pll_finetune: frac=%s0x%x\n",
-			sign ? "-" : "+", frac);
-	}
-}
-
-static int check_pll_axg(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
-{
-	struct lcd_clk_data_s *data = cconf->data;
+	struct lcd_clk_data_s *data = cConf->data;
 	unsigned int m, n, od_sel, od;
 	unsigned int pll_fvco;
 	unsigned int od_fb = 0, pll_frac;
@@ -1673,23 +1392,23 @@ static int check_pll_axg(struct lcd_clk_config_s *cconf, unsigned int pll_fout)
 			(pll_fvco > data->pll_vco_fmax)) {
 			continue;
 		}
-		cconf->pll_od1_sel = od_sel - 1;
-		cconf->pll_fout = pll_fout;
+		cConf->pll_od1_sel = od_sel - 1;
+		cConf->pll_fout = pll_fout;
 		if (lcd_debug_print_flag == 2) {
 			LCDPR("od_sel=%d, pll_fvco=%d\n",
 				(od_sel - 1), pll_fvco);
 		}
 
-		cconf->pll_fvco = pll_fvco;
+		cConf->pll_fvco = pll_fvco;
 		n = 1;
-		od_fb = cconf->pll_od_fb;
+		od_fb = cConf->pll_od_fb;
 		pll_fvco = pll_fvco / od_fb_table[od_fb];
-		m = pll_fvco / cconf->fin;
-		pll_frac = (pll_fvco % cconf->fin) *
-				data->pll_frac_range / cconf->fin;
-		cconf->pll_m = m;
-		cconf->pll_n = n;
-		cconf->pll_frac = pll_frac;
+		m = pll_fvco / cConf->fin;
+		pll_frac = (pll_fvco % cConf->fin) *
+				data->pll_frac_range / cConf->fin;
+		cConf->pll_m = m;
+		cConf->pll_n = n;
+		cConf->pll_frac = pll_frac;
 		if (lcd_debug_print_flag == 2) {
 			LCDPR("pll_m=%d, pll_n=%d, pll_frac=0x%x\n",
 				m, n, pll_frac);
@@ -1706,39 +1425,39 @@ static void lcd_clk_generate_axg(struct lcd_config_s *pconf)
 	unsigned int xd;
 	unsigned int dsi_bit_rate_max = 0, dsi_bit_rate_min = 0;
 	unsigned int tmp;
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
+	struct lcd_clk_config_s *cConf = get_lcd_clk_config();
 	int done;
 
 	done = 0;
-	cconf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
-	cconf->err_fmin = MAX_ERROR;
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	cConf->err_fmin = MAX_ERROR;
 
-	if (cconf->fout > cconf->data->xd_out_fmax) {
+	if (cConf->fout > cConf->data->xd_out_fmax) {
 		LCDERR("%s: wrong lcd_clk value %dkHz\n",
-			__func__, cconf->fout);
+			__func__, cConf->fout);
 		goto generate_clk_done_axg;
 	}
 
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_MIPI:
-		cconf->xd_max = CRT_VID_DIV_MAX;
+		cConf->xd_max = CRT_VID_DIV_MAX;
 		tmp = pconf->lcd_control.mipi_config->bit_rate_max;
 		dsi_bit_rate_max = tmp * 1000; /* change to kHz */
-		dsi_bit_rate_min = dsi_bit_rate_max - cconf->fout;
+		dsi_bit_rate_min = dsi_bit_rate_max - cConf->fout;
 
-		for (xd = 1; xd <= cconf->xd_max; xd++) {
-			pll_fout = cconf->fout * xd;
+		for (xd = 1; xd <= cConf->xd_max; xd++) {
+			pll_fout = cConf->fout * xd;
 			if ((pll_fout > dsi_bit_rate_max) ||
 				(pll_fout < dsi_bit_rate_min)) {
 				continue;
 			}
 			if (lcd_debug_print_flag == 2)
-				LCDPR("fout=%d, xd=%d\n", cconf->fout, xd);
+				LCDPR("fout=%d, xd=%d\n", cConf->fout, xd);
 
 			pconf->lcd_timing.bit_rate = pll_fout * 1000;
 			pconf->lcd_control.mipi_config->clk_factor = xd;
-			cconf->xd = xd;
-			done = check_pll_axg(cconf, pll_fout);
+			cConf->xd = xd;
+			done = check_pll_axg(cConf, pll_fout);
 			if (done)
 				goto generate_clk_done_axg;
 		}
@@ -1750,13 +1469,13 @@ static void lcd_clk_generate_axg(struct lcd_config_s *pconf)
 generate_clk_done_axg:
 	if (done) {
 		pconf->lcd_timing.pll_ctrl =
-			(cconf->pll_od1_sel << PLL_CTRL_OD1) |
-			(cconf->pll_n << PLL_CTRL_N) |
-			(cconf->pll_m << PLL_CTRL_M);
+			(cConf->pll_od1_sel << PLL_CTRL_OD1) |
+			(cConf->pll_n << PLL_CTRL_N) |
+			(cConf->pll_m << PLL_CTRL_M);
 		pconf->lcd_timing.div_ctrl =
 			(CLK_DIV_SEL_1 << DIV_CTRL_DIV_SEL) |
-			(cconf->xd << DIV_CTRL_XD);
-		pconf->lcd_timing.clk_ctrl = (cconf->pll_frac << CLK_CTRL_FRAC);
+			(cConf->xd << DIV_CTRL_XD);
+		pconf->lcd_timing.clk_ctrl = (cConf->pll_frac << CLK_CTRL_FRAC);
 	} else {
 		pconf->lcd_timing.pll_ctrl =
 			(1 << PLL_CTRL_OD1) |
@@ -1775,29 +1494,29 @@ static void lcd_pll_frac_generate_axg(struct lcd_config_s *pconf)
 	unsigned int pll_fout;
 	unsigned int od, pll_fvco;
 	unsigned int m, n, od_fb, frac, offset, temp;
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
+	struct lcd_clk_config_s *cConf = get_lcd_clk_config();
 
-	cconf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
-	od = od_table[cconf->pll_od1_sel];
-	m = cconf->pll_m;
-	n = cconf->pll_n;
-	od_fb = cconf->pll_od_fb;
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	od = od_table[cConf->pll_od1_sel];
+	m = cConf->pll_m;
+	n = cConf->pll_n;
+	od_fb = cConf->pll_od_fb;
 
 	if (lcd_debug_print_flag == 2) {
 		LCDPR("m=%d, n=%d, od=%d, xd=%d\n",
-			m, n, cconf->pll_od1_sel, cconf->xd);
+			m, n, cConf->pll_od1_sel, cConf->xd);
 	}
-	if (cconf->fout > cconf->data->xd_out_fmax) {
+	if (cConf->fout > cConf->data->xd_out_fmax) {
 		LCDERR("%s: wrong lcd_clk value %dkHz\n",
-			__func__, cconf->fout);
+			__func__, cConf->fout);
 		return;
 	}
 	if (lcd_debug_print_flag == 2)
-		LCDPR("%s pclk=%d\n", __func__, cconf->fout);
+		LCDPR("%s pclk=%d\n", __func__, cConf->fout);
 
-	pll_fout = cconf->fout * cconf->xd;
-	if ((pll_fout > cconf->data->pll_out_fmax) ||
-	    (pll_fout < cconf->data->pll_out_fmin)) {
+	pll_fout = cConf->fout * cConf->xd;
+	if ((pll_fout > cConf->data->pll_out_fmax) ||
+		(pll_fout < cConf->data->pll_out_fmin)) {
 		LCDERR("%s: wrong pll_fout value %dkHz\n", __func__, pll_fout);
 		return;
 	}
@@ -1805,17 +1524,17 @@ static void lcd_pll_frac_generate_axg(struct lcd_config_s *pconf)
 		LCDPR("%s pll_fout=%d\n", __func__, pll_fout);
 
 	pll_fvco = pll_fout * od;
-	if ((pll_fvco < cconf->data->pll_vco_fmin) ||
-	    (pll_fvco > cconf->data->pll_vco_fmax)) {
+	if ((pll_fvco < cConf->data->pll_vco_fmin) ||
+		(pll_fvco > cConf->data->pll_vco_fmax)) {
 		LCDERR("%s: wrong pll_fvco value %dkHz\n", __func__, pll_fvco);
 		return;
 	}
 	if (lcd_debug_print_flag == 2)
 		LCDPR("%s pll_fvco=%d\n", __func__, pll_fvco);
 
-	cconf->pll_fvco = pll_fvco;
+	cConf->pll_fvco = pll_fvco;
 	pll_fvco = pll_fvco / od_fb_table[od_fb];
-	temp = cconf->fin * m / n;
+	temp = cConf->fin * m / n;
 	if (pll_fvco >= temp) {
 		temp = pll_fvco - temp;
 		offset = 0;
@@ -1823,13 +1542,13 @@ static void lcd_pll_frac_generate_axg(struct lcd_config_s *pconf)
 		temp = temp - pll_fvco;
 		offset = 1;
 	}
-	if (temp >= (2 * cconf->fin)) {
+	if (temp >= (2 * cConf->fin)) {
 		LCDERR("%s: pll changing %dkHz is too much\n",
 			__func__, temp);
 		return;
 	}
-	frac = temp * cconf->data->pll_frac_range * n / cconf->fin;
-	cconf->pll_frac = frac | (offset << 11);
+	frac = temp * cConf->data->pll_frac_range * n / cConf->fin;
+	cConf->pll_frac = frac | (offset << 11);
 	if (lcd_debug_print_flag)
 		LCDPR("lcd_pll_frac_generate: frac=0x%x\n", frac);
 }
@@ -1840,40 +1559,40 @@ static void lcd_clk_generate_hpll_g12a(struct lcd_config_s *pconf)
 	unsigned int clk_div_sel, xd;
 	unsigned int dsi_bit_rate_max = 0, dsi_bit_rate_min = 0;
 	unsigned int tmp;
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
+	struct lcd_clk_config_s *cConf = get_lcd_clk_config();
 	int done;
 
 	done = 0;
-	cconf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
-	cconf->err_fmin = MAX_ERROR;
+	cConf->fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+	cConf->err_fmin = MAX_ERROR;
 
-	if (cconf->fout > cconf->data->xd_out_fmax) {
+	if (cConf->fout > cConf->data->xd_out_fmax) {
 		LCDERR("%s: wrong lcd_clk value %dkHz\n",
-			__func__, cconf->fout);
+			__func__, cConf->fout);
 	}
 
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_MIPI:
-		cconf->xd_max = CRT_VID_DIV_MAX;
+		cConf->xd_max = CRT_VID_DIV_MAX;
 		tmp = pconf->lcd_control.mipi_config->bit_rate_max;
 		dsi_bit_rate_max = tmp * 1000; /* change to kHz */
-		dsi_bit_rate_min = dsi_bit_rate_max - cconf->fout;
+		dsi_bit_rate_min = dsi_bit_rate_max - cConf->fout;
 
 		clk_div_sel = CLK_DIV_SEL_1;
-		for (xd = 1; xd <= cconf->xd_max; xd++) {
-			pll_fout = cconf->fout * xd;
+		for (xd = 1; xd <= cConf->xd_max; xd++) {
+			pll_fout = cConf->fout * xd;
 			if ((pll_fout > dsi_bit_rate_max) ||
 				(pll_fout < dsi_bit_rate_min)) {
 				continue;
 			}
 			if (lcd_debug_print_flag == 2)
-				LCDPR("fout=%d, xd=%d\n", cconf->fout, xd);
+				LCDPR("fout=%d, xd=%d\n", cConf->fout, xd);
 
 			pconf->lcd_timing.bit_rate = pll_fout * 1000;
 			pconf->lcd_control.mipi_config->clk_factor = xd;
-			cconf->xd = xd;
-			cconf->div_sel = clk_div_sel;
-			done = check_pll_txl(cconf, pll_fout);
+			cConf->xd = xd;
+			cConf->div_sel = clk_div_sel;
+			done = check_pll_txl(cConf, pll_fout);
 			if (done)
 				goto generate_clk_done_g12a;
 		}
@@ -1885,15 +1604,15 @@ static void lcd_clk_generate_hpll_g12a(struct lcd_config_s *pconf)
 generate_clk_done_g12a:
 	if (done) {
 		pconf->lcd_timing.pll_ctrl =
-			(cconf->pll_od1_sel << PLL_CTRL_OD1) |
-			(cconf->pll_od2_sel << PLL_CTRL_OD2) |
-			(cconf->pll_od3_sel << PLL_CTRL_OD3) |
-			(cconf->pll_n << PLL_CTRL_N)         |
-			(cconf->pll_m << PLL_CTRL_M);
+			(cConf->pll_od1_sel << PLL_CTRL_OD1) |
+			(cConf->pll_od2_sel << PLL_CTRL_OD2) |
+			(cConf->pll_od3_sel << PLL_CTRL_OD3) |
+			(cConf->pll_n << PLL_CTRL_N)         |
+			(cConf->pll_m << PLL_CTRL_M);
 		pconf->lcd_timing.div_ctrl =
-			(cconf->div_sel << DIV_CTRL_DIV_SEL) |
-			(cconf->xd << DIV_CTRL_XD);
-		pconf->lcd_timing.clk_ctrl = (cconf->pll_frac << CLK_CTRL_FRAC);
+			(cConf->div_sel << DIV_CTRL_DIV_SEL) |
+			(cConf->xd << DIV_CTRL_XD);
+		pconf->lcd_timing.clk_ctrl = (cConf->pll_frac << CLK_CTRL_FRAC);
 	} else {
 		pconf->lcd_timing.pll_ctrl =
 			(1 << PLL_CTRL_OD1) |
@@ -1967,13 +1686,6 @@ static void lcd_clk_set_tl1(struct lcd_config_s *pconf)
 	lcd_set_vid_pll_div(&clk_conf);
 }
 
-static void lcd_clk_set_t5(struct lcd_config_s *pconf)
-{
-	lcd_set_tcon_clk_t5(pconf);
-	lcd_set_pll_tl1(&clk_conf);
-	lcd_set_vid_pll_div(&clk_conf);
-}
-
 static void lcd_clk_gate_switch_dft(struct aml_lcd_drv_s *lcd_drv, int status)
 {
 	if (status) {
@@ -2403,43 +2115,31 @@ static int lcd_clk_config_print_dft(char *buf, int offset)
 	n = lcd_debug_info_len(len + offset);
 	len += snprintf((buf+len), n,
 		"lcd clk config:\n"
-		"pll_mode:             %d\n"
-		"pll_m:                %d\n"
-		"pll_n:                %d\n"
-		"pll_frac:             0x%03x\n"
-		"pll_frac_half_shift:  %d\n"
-		"pll_fvco:             %d\n"
-		"pll_od1:              %d\n"
-		"pll_od2:              %d\n"
-		"pll_od3:              %d\n"
-		"pll_tcon_div_sel:     %d\n"
-		"pll_out:              %d\n"
-		"div_sel:              %s(index %d)\n"
-		"xd:                   %d\n"
-		"fin:                  %d\n"
-		"fout:                 %d\n"
-		"ss_level:             %d\n"
-		"ss_freq:              %d\n"
-		"ss_mode:              %d\n\n",
-		clk_conf.pll_mode,
-		clk_conf.pll_m,
-		clk_conf.pll_n,
-		clk_conf.pll_frac,
-		clk_conf.pll_frac_half_shift,
-		clk_conf.pll_fvco,
-		clk_conf.pll_od1_sel,
-		clk_conf.pll_od2_sel,
-		clk_conf.pll_od3_sel,
-		clk_conf.pll_tcon_div_sel,
+		"pll_mode:         %d\n"
+		"pll_m:            %d\n"
+		"pll_n:            %d\n"
+		"pll_frac:         0x%03x\n"
+		"pll_fvco:         %dkHz\n"
+		"pll_od1:          %d\n"
+		"pll_od2:          %d\n"
+		"pll_od3:          %d\n"
+		"pll_tcon_div_sel: %d\n"
+		"pll_out:          %dkHz\n"
+		"div_sel:          %s(index %d)\n"
+		"xd:               %d\n"
+		"fout:             %dkHz\n"
+		"ss_level:         %d\n"
+		"ss_freq:          %d\n"
+		"ss_mode:          %d\n\n",
+		clk_conf.pll_mode, clk_conf.pll_m, clk_conf.pll_n,
+		clk_conf.pll_frac, clk_conf.pll_fvco,
+		clk_conf.pll_od1_sel, clk_conf.pll_od2_sel,
+		clk_conf.pll_od3_sel, clk_conf.pll_tcon_div_sel,
 		clk_conf.pll_fout,
 		lcd_clk_div_sel_table[clk_conf.div_sel],
-		clk_conf.div_sel,
-		clk_conf.xd,
-		clk_conf.fin,
-		clk_conf.fout,
-		clk_conf.ss_level,
-		clk_conf.ss_freq,
-		clk_conf.ss_mode);
+		clk_conf.div_sel, clk_conf.xd,
+		clk_conf.fout, clk_conf.ss_level,
+		clk_conf.ss_freq, clk_conf.ss_mode);
 
 	return len;
 }
@@ -2800,78 +2500,23 @@ void lcd_clk_update(struct lcd_config_s *pconf)
 	LCDPR("%s\n", __func__);
 }
 
-/* for increasing/decreasing clock in ppm */
-void lcd_clk_finetune(struct lcd_config_s *pconf, int ppm)
-{
-	struct lcd_clk_ctrl_s *table;
-	int i = 0;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_clk_lock, flags);
-
-	if (!clk_conf.data) {
-		LCDERR("%s: clk config data is null\n", __func__);
-		goto lcd_clk_finetune_end;
-	}
-
-	if (clk_conf.data->clk_finetune)
-		clk_conf.data->clk_finetune(pconf, ppm);
-
-	if (!clk_conf.data->pll_ctrl_table)
-		goto lcd_clk_finetune_end;
-	table = clk_conf.data->pll_ctrl_table;
-	while (i < LCD_CLK_CTRL_CNT_MAX) {
-		if (table[i].flag == LCD_CLK_CTRL_END)
-			break;
-		if (table[i].flag == LCD_CLK_CTRL_FRAC) {
-			lcd_hiu_setb(table[i].reg, clk_conf.pll_frac,
-				table[i].bit, table[i].len);
-			if (lcd_debug_print_flag == 2)
-				LCDPR("%s, reg[0x%x]%d:%d=0x%x\n",
-					__func__,
-					table[i].reg,
-					table[i].bit + table[i].len - 1,
-					table[i].bit,
-					clk_conf.pll_frac);
-		}
-		i++;
-	}
-
-lcd_clk_finetune_end:
-	spin_unlock_irqrestore(&lcd_clk_lock, flags);
-	LCDPR("%s\n", __func__);
-}
-
 /* for timing change */
 void lcd_clk_set(struct lcd_config_s *pconf)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	unsigned long flags = 0;
-	int cnt = 0;
 
 	if (clk_conf.data == NULL) {
 		LCDERR("%s: clk config data is null\n", __func__);
 		return;
 	}
 
-lcd_clk_set_retry:
 	spin_lock_irqsave(&lcd_clk_lock, flags);
 	if (clk_conf.data->clk_set)
 		clk_conf.data->clk_set(pconf);
 
 	lcd_set_vclk_crt(pconf->lcd_basic.lcd_type, &clk_conf);
-	spin_unlock_irqrestore(&lcd_clk_lock, flags);
-	if (lcd_drv->lcd_pxp)
-		return;
 	mdelay(10);
-
-	while (lcd_clk_msr_check(&clk_conf)) {
-		if (cnt++ >= 10) {
-			LCDERR("%s timeout\n", __func__);
-			break;
-		}
-		goto lcd_clk_set_retry;
-	}
+	spin_unlock_irqrestore(&lcd_clk_lock, flags);
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
@@ -2897,10 +2542,10 @@ void lcd_clk_disable(void)
 		if (table[i].flag == LCD_CLK_CTRL_END)
 			break;
 		if (table[i].flag == LCD_CLK_CTRL_EN) {
-			lcd_ana_setb(table[i].reg, 0,
+			lcd_hiu_setb(table[i].reg, 0,
 				table[i].bit, table[i].len);
 		} else if (table[i].flag == LCD_CLK_CTRL_RST) {
-			lcd_ana_setb(table[i].reg, 1,
+			lcd_hiu_setb(table[i].reg, 1,
 				table[i].bit, table[i].len);
 		}
 		i++;
@@ -3005,15 +2650,14 @@ int lcd_clk_config_print(char *buf, int offset)
  */
 static struct lcd_clk_data_s lcd_clk_data_gxl = {
 	.pll_od_fb = PLL_OD_FB_GXL,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_GXL,
+	.pll_m_min = PLL_M_MIN_GXL,
+	.pll_n_max = PLL_N_MAX_GXL,
+	.pll_n_min = PLL_N_MIN_GXL,
 	.pll_frac_range = PLL_FRAC_RANGE_GXL,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_GXL,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_GXL,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_GXL,
+	.pll_ref_fmin = PLL_FREF_MIN_GXL,
 	.pll_vco_fmax = PLL_VCO_MAX_GXL,
 	.pll_vco_fmin = PLL_VCO_MIN_GXL,
 	.pll_out_fmax = CLK_DIV_IN_MAX_GXL,
@@ -3044,21 +2688,18 @@ static struct lcd_clk_data_s lcd_clk_data_gxl = {
 	.clktree_remove = lcd_clktree_remove_dft,
 	.clk_config_init_print = lcd_clk_config_init_print_dft,
 	.clk_config_print = lcd_clk_config_print_dft,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_txl = {
 	.pll_od_fb = PLL_OD_FB_TXL,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_TXL,
+	.pll_m_min = PLL_M_MIN_TXL,
+	.pll_n_max = PLL_N_MAX_TXL,
+	.pll_n_min = PLL_N_MIN_TXL,
 	.pll_frac_range = PLL_FRAC_RANGE_TXL,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_TXL,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_TXL,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_TXL,
+	.pll_ref_fmin = PLL_FREF_MIN_TXL,
 	.pll_vco_fmax = PLL_VCO_MAX_TXL,
 	.pll_vco_fmin = PLL_VCO_MIN_TXL,
 	.pll_out_fmax = CLK_DIV_IN_MAX_TXL,
@@ -3089,21 +2730,18 @@ static struct lcd_clk_data_s lcd_clk_data_txl = {
 	.clktree_remove = lcd_clktree_remove_dft,
 	.clk_config_init_print = lcd_clk_config_init_print_dft,
 	.clk_config_print = lcd_clk_config_print_dft,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_txlx = {
 	.pll_od_fb = PLL_OD_FB_TXLX,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_TXLX,
+	.pll_m_min = PLL_M_MIN_TXLX,
+	.pll_n_max = PLL_N_MAX_TXLX,
+	.pll_n_min = PLL_N_MIN_TXLX,
 	.pll_frac_range = PLL_FRAC_RANGE_TXLX,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_TXLX,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_TXLX,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_TXLX,
+	.pll_ref_fmin = PLL_FREF_MIN_TXLX,
 	.pll_vco_fmax = PLL_VCO_MAX_TXLX,
 	.pll_vco_fmin = PLL_VCO_MIN_TXLX,
 	.pll_out_fmax = CLK_DIV_IN_MAX_TXLX,
@@ -3134,21 +2772,18 @@ static struct lcd_clk_data_s lcd_clk_data_txlx = {
 	.clktree_remove = lcd_clktree_remove_dft,
 	.clk_config_init_print = lcd_clk_config_init_print_dft,
 	.clk_config_print = lcd_clk_config_print_dft,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_axg = {
 	.pll_od_fb = PLL_OD_FB_AXG,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_AXG,
+	.pll_m_min = PLL_M_MIN_AXG,
+	.pll_n_max = PLL_N_MAX_AXG,
+	.pll_n_min = PLL_N_MIN_AXG,
 	.pll_frac_range = PLL_FRAC_RANGE_AXG,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_AXG,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_AXG,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_AXG,
+	.pll_ref_fmin = PLL_FREF_MIN_AXG,
 	.pll_vco_fmax = PLL_VCO_MAX_AXG,
 	.pll_vco_fmin = PLL_VCO_MIN_AXG,
 	.pll_out_fmax = CRT_VID_CLK_IN_MAX_AXG,
@@ -3179,21 +2814,18 @@ static struct lcd_clk_data_s lcd_clk_data_axg = {
 	.clktree_remove = lcd_clktree_remove_axg,
 	.clk_config_init_print = lcd_clk_config_init_print_axg,
 	.clk_config_print = lcd_clk_config_print_axg,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_g12a_path0 = {
 	.pll_od_fb = PLL_OD_FB_HPLL_G12A,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_G12A,
+	.pll_m_min = PLL_M_MIN_G12A,
+	.pll_n_max = PLL_N_MAX_G12A,
+	.pll_n_min = PLL_N_MIN_G12A,
 	.pll_frac_range = PLL_FRAC_RANGE_HPLL_G12A,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_HPLL_G12A,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_HPLL_G12A,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_G12A,
+	.pll_ref_fmin = PLL_FREF_MIN_G12A,
 	.pll_vco_fmax = PLL_VCO_MAX_HPLL_G12A,
 	.pll_vco_fmin = PLL_VCO_MIN_HPLL_G12A,
 	.pll_out_fmax = CRT_VID_CLK_IN_MAX_G12A,
@@ -3224,21 +2856,18 @@ static struct lcd_clk_data_s lcd_clk_data_g12a_path0 = {
 	.clktree_remove = lcd_clktree_remove_g12a,
 	.clk_config_init_print = lcd_clk_config_init_print_axg,
 	.clk_config_print = lcd_clk_config_print_g12a,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_g12a_path1 = {
 	.pll_od_fb = PLL_OD_FB_GP0_G12A,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_G12A,
+	.pll_m_min = PLL_M_MIN_G12A,
+	.pll_n_max = PLL_N_MAX_G12A,
+	.pll_n_min = PLL_N_MIN_G12A,
 	.pll_frac_range = PLL_FRAC_RANGE_GP0_G12A,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_GP0_G12A,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_GP0_G12A,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_G12A,
+	.pll_ref_fmin = PLL_FREF_MIN_G12A,
 	.pll_vco_fmax = PLL_VCO_MAX_GP0_G12A,
 	.pll_vco_fmin = PLL_VCO_MIN_GP0_G12A,
 	.pll_out_fmax = CRT_VID_CLK_IN_MAX_G12A,
@@ -3269,21 +2898,18 @@ static struct lcd_clk_data_s lcd_clk_data_g12a_path1 = {
 	.clktree_remove = lcd_clktree_remove_g12a,
 	.clk_config_init_print = lcd_clk_config_init_print_axg,
 	.clk_config_print = lcd_clk_config_print_g12a,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_g12b_path0 = {
 	.pll_od_fb = PLL_OD_FB_HPLL_G12A,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_G12A,
+	.pll_m_min = PLL_M_MIN_G12A,
+	.pll_n_max = PLL_N_MAX_G12A,
+	.pll_n_min = PLL_N_MIN_G12A,
 	.pll_frac_range = PLL_FRAC_RANGE_HPLL_G12A,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_HPLL_G12A,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_HPLL_G12A,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_G12A,
+	.pll_ref_fmin = PLL_FREF_MIN_G12A,
 	.pll_vco_fmax = PLL_VCO_MAX_HPLL_G12A,
 	.pll_vco_fmin = PLL_VCO_MIN_HPLL_G12A,
 	.pll_out_fmax = CRT_VID_CLK_IN_MAX_G12A,
@@ -3314,21 +2940,18 @@ static struct lcd_clk_data_s lcd_clk_data_g12b_path0 = {
 	.clktree_remove = lcd_clktree_remove_g12a,
 	.clk_config_init_print = lcd_clk_config_init_print_axg,
 	.clk_config_print = lcd_clk_config_print_g12a,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_g12b_path1 = {
 	.pll_od_fb = PLL_OD_FB_GP0_G12A,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_G12A,
+	.pll_m_min = PLL_M_MIN_G12A,
+	.pll_n_max = PLL_N_MAX_G12A,
+	.pll_n_min = PLL_N_MIN_G12A,
 	.pll_frac_range = PLL_FRAC_RANGE_GP0_G12A,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_GP0_G12A,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_GP0_G12A,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_G12A,
+	.pll_ref_fmin = PLL_FREF_MIN_G12A,
 	.pll_vco_fmax = PLL_VCO_MAX_GP0_G12A,
 	.pll_vco_fmin = PLL_VCO_MIN_GP0_G12A,
 	.pll_out_fmax = CRT_VID_CLK_IN_MAX_G12A,
@@ -3359,21 +2982,18 @@ static struct lcd_clk_data_s lcd_clk_data_g12b_path1 = {
 	.clktree_remove = lcd_clktree_remove_g12a,
 	.clk_config_init_print = lcd_clk_config_init_print_axg,
 	.clk_config_print = lcd_clk_config_print_g12a,
-	.prbs_clk_config = NULL,
-	.clk_finetune = NULL,
 };
 
 static struct lcd_clk_data_s lcd_clk_data_tl1 = {
 	.pll_od_fb = PLL_OD_FB_TL1,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
+	.pll_m_max = PLL_M_MAX_TL1,
+	.pll_m_min = PLL_M_MIN_TL1,
+	.pll_n_max = PLL_N_MAX_TL1,
+	.pll_n_min = PLL_N_MIN_TL1,
 	.pll_frac_range = PLL_FRAC_RANGE_TL1,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_TL1,
 	.pll_od_sel_max = PLL_OD_SEL_MAX_TL1,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
+	.pll_ref_fmax = PLL_FREF_MAX_TL1,
+	.pll_ref_fmin = PLL_FREF_MIN_TL1,
 	.pll_vco_fmax = PLL_VCO_MAX_TL1,
 	.pll_vco_fmin = PLL_VCO_MIN_TL1,
 	.pll_out_fmax = CLK_DIV_IN_MAX_TL1,
@@ -3404,210 +3024,65 @@ static struct lcd_clk_data_s lcd_clk_data_tl1 = {
 	.clktree_remove = lcd_clktree_remove_tl1,
 	.clk_config_init_print = lcd_clk_config_init_print_dft,
 	.clk_config_print = lcd_clk_config_print_dft,
-	.prbs_clk_config = lcd_prbs_config_clk_tl1,
-	.clk_finetune = NULL,
-};
-
-static struct lcd_clk_data_s lcd_clk_data_tm2 = {
-	.pll_od_fb = PLL_OD_FB_TL1,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
-	.pll_frac_range = PLL_FRAC_RANGE_TL1,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_TL1,
-	.pll_od_sel_max = PLL_OD_SEL_MAX_TL1,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
-	.pll_vco_fmax = PLL_VCO_MAX_TM2,
-	.pll_vco_fmin = PLL_VCO_MIN_TM2,
-	.pll_out_fmax = CLK_DIV_IN_MAX_TL1,
-	.pll_out_fmin = PLL_VCO_MIN_TL1 / 16,
-	.div_in_fmax = CLK_DIV_IN_MAX_TL1,
-	.div_out_fmax = CRT_VID_CLK_IN_MAX_TL1,
-	.xd_out_fmax = ENCL_CLK_IN_MAX_TL1,
-
-	.clk_path_valid = 0,
-	.vclk_sel = 0,
-	.pll_ctrl_table = pll_ctrl_table_tl1,
-
-	.ss_level_max = sizeof(lcd_ss_level_table_tl1) / sizeof(char *),
-	.ss_freq_max = sizeof(lcd_ss_freq_table_tl1) / sizeof(char *),
-	.ss_mode_max = sizeof(lcd_ss_mode_table_tl1) / sizeof(char *),
-	.ss_level_table = lcd_ss_level_table_tl1,
-	.ss_freq_table = lcd_ss_freq_table_tl1,
-	.ss_mode_table = lcd_ss_mode_table_tl1,
-
-	.clk_generate_parameter = lcd_clk_generate_txl,
-	.pll_frac_generate = lcd_pll_frac_generate_txl,
-	.set_ss_level = lcd_set_pll_ss_level_tl1,
-	.set_ss_advance = lcd_set_pll_ss_advance_tl1,
-	.clk_set = lcd_clk_set_tl1,
-	.clk_gate_switch = lcd_clk_gate_switch_dft,
-	.clk_gate_optional_switch = lcd_clk_gate_optional_switch_tl1,
-	.clktree_probe = lcd_clktree_probe_tl1,
-	.clktree_remove = lcd_clktree_remove_tl1,
-	.clk_config_init_print = lcd_clk_config_init_print_dft,
-	.clk_config_print = lcd_clk_config_print_dft,
-	.prbs_clk_config = lcd_prbs_config_clk_tl1,
-	.clk_finetune = lcd_pll_finetune_tm2,
-};
-
-static struct lcd_clk_data_s lcd_clk_data_t5 = {
-	.pll_od_fb = PLL_OD_FB_TL1,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
-	.pll_frac_range = PLL_FRAC_RANGE_TL1,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_TL1,
-	.pll_od_sel_max = PLL_OD_SEL_MAX_TL1,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
-	.pll_vco_fmax = PLL_VCO_MAX_TM2,
-	.pll_vco_fmin = PLL_VCO_MIN_TM2,
-	.pll_out_fmax = CLK_DIV_IN_MAX_TL1,
-	.pll_out_fmin = PLL_VCO_MIN_TL1 / 16,
-	.div_in_fmax = CLK_DIV_IN_MAX_TL1,
-	.div_out_fmax = CRT_VID_CLK_IN_MAX_TL1,
-	.xd_out_fmax = ENCL_CLK_IN_MAX_TL1,
-
-	.clk_path_valid = 0,
-	.vclk_sel = 0,
-	.pll_ctrl_table = pll_ctrl_table_tl1,
-
-	.ss_level_max = sizeof(lcd_ss_level_table_tl1) / sizeof(char *),
-	.ss_freq_max = sizeof(lcd_ss_freq_table_tl1) / sizeof(char *),
-	.ss_mode_max = sizeof(lcd_ss_mode_table_tl1) / sizeof(char *),
-	.ss_level_table = lcd_ss_level_table_tl1,
-	.ss_freq_table = lcd_ss_freq_table_tl1,
-	.ss_mode_table = lcd_ss_mode_table_tl1,
-
-	.clk_generate_parameter = lcd_clk_generate_txl,
-	.pll_frac_generate = lcd_pll_frac_generate_txl,
-	.set_ss_level = lcd_set_pll_ss_level_tl1,
-	.set_ss_advance = lcd_set_pll_ss_advance_tl1,
-	.clk_set = lcd_clk_set_t5,
-	.clk_gate_switch = lcd_clk_gate_switch_dft,
-	.clk_gate_optional_switch = lcd_clk_gate_optional_switch_tl1,
-	.clktree_probe = lcd_clktree_probe_tl1,
-	.clktree_remove = lcd_clktree_remove_tl1,
-	.clk_config_init_print = lcd_clk_config_init_print_dft,
-	.clk_config_print = lcd_clk_config_print_dft,
-	.prbs_clk_config = lcd_prbs_config_clk_tl1,
-	.clk_finetune = NULL,
 };
 
-static struct lcd_clk_data_s lcd_clk_data_t5d = {
-	.pll_od_fb = PLL_OD_FB_TL1,
-	.pll_m_max = PLL_M_MAX,
-	.pll_m_min = PLL_M_MIN,
-	.pll_n_max = PLL_N_MAX,
-	.pll_n_min = PLL_N_MIN,
-	.pll_frac_range = PLL_FRAC_RANGE_TL1,
-	.pll_frac_sign_bit = PLL_FRAC_SIGN_BIT_TL1,
-	.pll_od_sel_max = PLL_OD_SEL_MAX_TL1,
-	.pll_ref_fmax = PLL_FREF_MAX,
-	.pll_ref_fmin = PLL_FREF_MIN,
-	.pll_vco_fmax = PLL_VCO_MAX_TM2,
-	.pll_vco_fmin = PLL_VCO_MIN_TM2,
-	.pll_out_fmax = CLK_DIV_IN_MAX_T5D,
-	.pll_out_fmin = PLL_VCO_MIN_TL1 / 16,
-	.div_in_fmax = CLK_DIV_IN_MAX_T5D,
-	.div_out_fmax = CRT_VID_CLK_IN_MAX_T5D,
-	.xd_out_fmax = ENCL_CLK_IN_MAX_T5D,
-
-	.clk_path_valid = 0,
-	.vclk_sel = 0,
-	.pll_ctrl_table = pll_ctrl_table_tl1,
-
-	.ss_level_max = sizeof(lcd_ss_level_table_tl1) / sizeof(char *),
-	.ss_freq_max = sizeof(lcd_ss_freq_table_tl1) / sizeof(char *),
-	.ss_mode_max = sizeof(lcd_ss_mode_table_tl1) / sizeof(char *),
-	.ss_level_table = lcd_ss_level_table_tl1,
-	.ss_freq_table = lcd_ss_freq_table_tl1,
-	.ss_mode_table = lcd_ss_mode_table_tl1,
-
-	.clk_generate_parameter = lcd_clk_generate_txl,
-	.pll_frac_generate = lcd_pll_frac_generate_txl,
-	.set_ss_level = lcd_set_pll_ss_level_tl1,
-	.set_ss_advance = lcd_set_pll_ss_advance_tl1,
-	.clk_set = lcd_clk_set_t5,
-	.clk_gate_switch = lcd_clk_gate_switch_dft,
-	.clk_gate_optional_switch = lcd_clk_gate_optional_switch_tl1,
-	.clktree_probe = lcd_clktree_probe_tl1,
-	.clktree_remove = lcd_clktree_remove_tl1,
-	.clk_config_init_print = lcd_clk_config_init_print_dft,
-	.clk_config_print = lcd_clk_config_print_dft,
-	.prbs_clk_config = lcd_prbs_config_clk_tl1,
-	.clk_finetune = NULL,
-};
-
-static void lcd_clk_config_chip_init(struct lcd_clk_config_s *cconf)
+static void lcd_clk_config_chip_init(struct lcd_clk_config_s *cConf)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_GXL:
 	case LCD_CHIP_GXM:
-		cconf->data = &lcd_clk_data_gxl;
+		cConf->data = &lcd_clk_data_gxl;
 		break;
 	case LCD_CHIP_TXL:
-		cconf->data = &lcd_clk_data_txl;
+		cConf->data = &lcd_clk_data_txl;
 		break;
 	case LCD_CHIP_TXLX:
-		cconf->data = &lcd_clk_data_txlx;
+		cConf->data = &lcd_clk_data_txlx;
 		break;
 	case LCD_CHIP_AXG:
-		cconf->data = &lcd_clk_data_axg;
+		cConf->data = &lcd_clk_data_axg;
 		break;
 	case LCD_CHIP_G12A:
 	case LCD_CHIP_SM1:
 		if (lcd_drv->lcd_clk_path)
-			cconf->data = &lcd_clk_data_g12a_path1;
+			cConf->data = &lcd_clk_data_g12a_path1;
 		else
-			cconf->data = &lcd_clk_data_g12a_path0;
+			cConf->data = &lcd_clk_data_g12a_path0;
 		break;
 	case LCD_CHIP_G12B:
 		if (lcd_drv->lcd_clk_path)
-			cconf->data = &lcd_clk_data_g12b_path1;
+			cConf->data = &lcd_clk_data_g12b_path1;
 		else
-			cconf->data = &lcd_clk_data_g12b_path0;
+			cConf->data = &lcd_clk_data_g12b_path0;
 		break;
 	case LCD_CHIP_TL1:
-		cconf->data = &lcd_clk_data_tl1;
-		break;
 	case LCD_CHIP_TM2:
-		cconf->data = &lcd_clk_data_tm2;
-		break;
-	case LCD_CHIP_T5:
-		cconf->data = &lcd_clk_data_t5;
-		break;
-	case LCD_CHIP_T5D:
-		cconf->data = &lcd_clk_data_t5d;
+		cConf->data = &lcd_clk_data_tl1;
 		break;
 	default:
 		LCDPR("%s: invalid chip type\n", __func__);
 		break;
 	}
 
-	if (cconf->data)
-		cconf->pll_od_fb = cconf->data->pll_od_fb;
+	if (cConf->data)
+		cConf->pll_od_fb = cConf->data->pll_od_fb;
 	if (lcd_debug_print_flag > 0)
 		lcd_clk_config_init_print();
 }
 
 int lcd_clk_path_change(int sel)
 {
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
+	struct lcd_clk_config_s *cConf = get_lcd_clk_config();
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!cconf->data) {
+	if (cConf->data == NULL) {
 		LCDERR("%s: clk config data is null\n", __func__);
 		return -1;
 	}
 
-	if (cconf->data->clk_path_valid == 0) {
+	if (cConf->data->clk_path_valid == 0) {
 		LCDPR("%s: current chip not support\n", __func__);
 		return -1;
 	}
@@ -3617,10 +3092,10 @@ int lcd_clk_path_change(int sel)
 	case LCD_CHIP_G12B:
 	case LCD_CHIP_SM1:
 		if (sel)
-			cconf->data = &lcd_clk_data_g12a_path1;
+			cConf->data = &lcd_clk_data_g12a_path1;
 		else
-			cconf->data = &lcd_clk_data_g12a_path0;
-		cconf->pll_od_fb = cconf->data->pll_od_fb;
+			cConf->data = &lcd_clk_data_g12a_path0;
+		cConf->pll_od_fb = cConf->data->pll_od_fb;
 
 		if (lcd_debug_print_flag > 0)
 			lcd_clk_config_init_print();
diff --git a/drivers/amlogic/media/vout/lcd/lcd_clk_config.h b/drivers/amlogic/media/vout/lcd/lcd_clk_config.h
index f640ff33ffea..ec2c15a4a038 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_clk_config.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_clk_config.h
@@ -25,10 +25,6 @@
  * clk config
  * **********************************
  */
-#define LCD_PLL_MODE_DEFAULT         BIT(0)
-#define LCD_PLL_MODE_SPECIAL_CNTL    BIT(1)
-#define LCD_PLL_MODE_FRAC_SHIFT      BIT(2)
-
 #define PLL_RETRY_MAX		20
 #define LCD_CLK_CTRL_EN      0
 #define LCD_CLK_CTRL_RST     1
@@ -45,9 +41,6 @@ struct lcd_clk_ctrl_s {
 	unsigned int len;
 };
 
-#define LCD_PRBS_MODE_LVDS    BIT(0)
-#define LCD_PRBS_MODE_VX1     BIT(1)
-#define LCD_PRBS_MODE_MAX     2
 struct lcd_clk_data_s {
 	/* clk path node parameters */
 	unsigned int pll_od_fb;
@@ -56,7 +49,6 @@ struct lcd_clk_data_s {
 	unsigned int pll_n_max;
 	unsigned int pll_n_min;
 	unsigned int pll_frac_range;
-	unsigned int pll_frac_sign_bit;
 	unsigned int pll_od_sel_max;
 	unsigned int pll_ref_fmax;
 	unsigned int pll_ref_fmin;
@@ -90,11 +82,7 @@ struct lcd_clk_data_s {
 	void (*clktree_probe)(void);
 	void (*clktree_remove)(void);
 	void (*clk_config_init_print)(void);
-	void (*prbs_clk_config)(unsigned int prbs_mode);
 	int (*clk_config_print)(char *buf, int offset);
-
-	int ppm;
-	void (*clk_finetune)(struct lcd_config_s *pconf, int ppm);
 };
 
 struct lcd_clk_config_s { /* unit: kHz */
@@ -114,7 +102,6 @@ struct lcd_clk_config_s { /* unit: kHz */
 	unsigned int pll_tcon_div_sel;
 	unsigned int pll_level;
 	unsigned int pll_frac;
-	unsigned int pll_frac_half_shift;
 	unsigned int pll_fout;
 	unsigned int ss_level;
 	unsigned int ss_freq;
@@ -126,7 +113,6 @@ struct lcd_clk_config_s { /* unit: kHz */
 	unsigned int err_fmin;
 
 	struct lcd_clk_data_s *data;
-	int ppm_adj;
 };
 
 struct lcd_clktree_s {
@@ -157,7 +143,6 @@ extern void lcd_pll_reset(void);
 extern int lcd_get_ss(char *buf);
 extern int lcd_set_ss(unsigned int level, unsigned int freq, unsigned int mode);
 extern void lcd_clk_update(struct lcd_config_s *pconf);
-void lcd_clk_finetune(struct lcd_config_s *pconf, int ppm);
 extern void lcd_clk_set(struct lcd_config_s *pconf);
 extern void lcd_clk_disable(void);
 extern void lcd_clk_generate_parameter(struct lcd_config_s *pconf);
diff --git a/drivers/amlogic/media/vout/lcd/lcd_clk_ctrl.h b/drivers/amlogic/media/vout/lcd/lcd_clk_ctrl.h
index 248be61310c8..041d6b65a6ea 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_clk_ctrl.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_clk_ctrl.h
@@ -21,17 +21,6 @@
 #include "lcd_reg.h"
 #include "lcd_clk_config.h"
 
-/* **********************************
- * COMMON
- * **********************************
- */
-#define PLL_M_MIN                   2
-#define PLL_M_MAX                   511
-#define PLL_N_MIN                   1
-#define PLL_N_MAX                   1
-#define PLL_FREF_MIN                (5 * 1000)
-#define PLL_FREF_MAX                (25 * 1000)
-
 /* **********************************
  * GXL
  * **********************************
@@ -50,9 +39,14 @@
 
 /* ******** frequency limit (unit: kHz) ******** */
 #define PLL_OD_FB_GXL               1
+#define PLL_M_MIN_GXL               2
+#define PLL_M_MAX_GXL               511
+#define PLL_N_MIN_GXL               1
+#define PLL_N_MAX_GXL               1
 #define PLL_FRAC_RANGE_GXL          (1 << 10)
-#define PLL_FRAC_SIGN_BIT_GXL       11
 #define PLL_OD_SEL_MAX_GXL          3
+#define PLL_FREF_MIN_GXL            (5 * 1000)
+#define PLL_FREF_MAX_GXL            (25 * 1000)
 #define PLL_VCO_MIN_GXL             (3000 * 1000)
 #define PLL_VCO_MAX_GXL             (6000 * 1000)
 
@@ -79,9 +73,14 @@
 
 /* ******** frequency limit (unit: kHz) ******** */
 #define PLL_OD_FB_TXL               1 /* update od_fb to 1 for ss width */
+#define PLL_M_MIN_TXL               2
+#define PLL_M_MAX_TXL               511
+#define PLL_N_MIN_TXL               1
+#define PLL_N_MAX_TXL               1
 #define PLL_FRAC_RANGE_TXL          (1 << 10)
-#define PLL_FRAC_SIGN_BIT_TXL       11
 #define PLL_OD_SEL_MAX_TXL          3
+#define PLL_FREF_MIN_TXL            (5 * 1000)
+#define PLL_FREF_MAX_TXL            (25 * 1000)
 #define PLL_VCO_MIN_TXL             (2950 * 1000)
 #define PLL_VCO_MAX_TXL             (5900 * 1000)
 
@@ -108,9 +107,14 @@
 
 /* ******** frequency limit (unit: kHz) ******** */
 #define PLL_OD_FB_TXLX               0
+#define PLL_M_MIN_TXLX               2
+#define PLL_M_MAX_TXLX               511
+#define PLL_N_MIN_TXLX               1
+#define PLL_N_MAX_TXLX               1
 #define PLL_FRAC_RANGE_TXLX          (1 << 10)
-#define PLL_FRAC_SIGN_BIT_TXLX       11
 #define PLL_OD_SEL_MAX_TXLX          3
+#define PLL_FREF_MIN_TXLX            (5 * 1000)
+#define PLL_FREF_MAX_TXLX            (25 * 1000)
 #define PLL_VCO_MIN_TXLX             (3000 * 1000)
 #define PLL_VCO_MAX_TXLX             (6000 * 1000)
 
@@ -134,9 +138,14 @@
 
 /* ******** frequency limit (unit: kHz) ******** */
 #define PLL_OD_FB_AXG               0
+#define PLL_M_MIN_AXG               2
+#define PLL_M_MAX_AXG               511
+#define PLL_N_MIN_AXG               1
+#define PLL_N_MAX_AXG               1
 #define PLL_FRAC_RANGE_AXG          (1 << 10)
-#define PLL_FRAC_SIGN_BIT_AXG       11
 #define PLL_OD_SEL_MAX_AXG          3
+#define PLL_FREF_MIN_AXG            (5 * 1000)
+#define PLL_FREF_MAX_AXG            (25 * 1000)
 #define PLL_VCO_MIN_AXG             (960 * 1000)
 #define PLL_VCO_MAX_AXG             (1920 * 1000)
 
@@ -157,7 +166,6 @@
 /* ******** frequency limit (unit: kHz) ******** */
 #define PLL_OD_FB_GP0_G12A          0
 #define PLL_FRAC_RANGE_GP0_G12A     (1 << 17)
-#define PLL_FRAC_SIGN_BIT_GP0_G12A  18
 #define PLL_OD_SEL_MAX_GP0_G12A     5
 #define PLL_VCO_MIN_GP0_G12A        (3000 * 1000)
 #define PLL_VCO_MAX_GP0_G12A        (6000 * 1000)
@@ -176,11 +184,18 @@
 /* ******** frequency limit (unit: kHz) ******** */
 #define PLL_OD_FB_HPLL_G12A         0
 #define PLL_FRAC_RANGE_HPLL_G12A    (1 << 17)
-#define PLL_FRAC_SIGN_BIT_HPLL_G12A 18
 #define PLL_OD_SEL_MAX_HPLL_G12A    3
 #define PLL_VCO_MIN_HPLL_G12A       (3000 * 1000)
 #define PLL_VCO_MAX_HPLL_G12A       (6000 * 1000)
 
+/* gp0 & hpll common */
+#define PLL_M_MIN_G12A              2
+#define PLL_M_MAX_G12A              511
+#define PLL_N_MIN_G12A              1
+#define PLL_N_MAX_G12A              1
+#define PLL_FREF_MIN_G12A           (5 * 1000)
+#define PLL_FREF_MAX_G12A           (25 * 1000)
+
 /* video */
 #define CRT_VID_CLK_IN_MAX_G12A     (6000 * 1000)
 #define ENCL_CLK_IN_MAX_G12A        (200 * 1000)
@@ -203,33 +218,22 @@
 
 /* ******** frequency limit (unit: kHz) ******** */
 #define PLL_OD_FB_TL1               0
+#define PLL_M_MIN_TL1               2
+#define PLL_M_MAX_TL1               511
+#define PLL_N_MIN_TL1               1
+#define PLL_N_MAX_TL1               1
 #define PLL_FRAC_RANGE_TL1          (1 << 17)
-#define PLL_FRAC_SIGN_BIT_TL1       18
 #define PLL_OD_SEL_MAX_TL1          3
-#define PLL_VCO_MIN_TL1             (3384 * 1000)
-#define PLL_VCO_MAX_TL1             (6024 * 1000)
+#define PLL_FREF_MIN_TL1            (5 * 1000)
+#define PLL_FREF_MAX_TL1            (25 * 1000)
+#define PLL_VCO_MIN_TL1             (3000 * 1000)
+#define PLL_VCO_MAX_TL1             (6000 * 1000)
 
 /* video */
 #define CLK_DIV_IN_MAX_TL1          (3100 * 1000)
 #define CRT_VID_CLK_IN_MAX_TL1      (3100 * 1000)
 #define ENCL_CLK_IN_MAX_TL1         (750 * 1000)
 
-/* **********************************
- * TM2
- * **********************************
- */
-#define PLL_VCO_MIN_TM2             (3000 * 1000)
-#define PLL_VCO_MAX_TM2             (6000 * 1000)
-
-/* **********************************
- * TM2
- * **********************************
- */
-/* video */
-#define CLK_DIV_IN_MAX_T5D          (3100 * 1000)
-#define CRT_VID_CLK_IN_MAX_T5D      (3100 * 1000)
-#define ENCL_CLK_IN_MAX_T5D         (400 * 1000)
-
 
 /* **********************************
  * Spread Spectrum
@@ -419,7 +423,7 @@ struct lcd_clk_ctrl_s pll_ctrl_table_tl1[] = {
 	{LCD_CLK_CTRL_EN,   HHI_TCON_PLL_CNTL0, LCD_PLL_EN_TL1,   1},
 	{LCD_CLK_CTRL_RST,  HHI_TCON_PLL_CNTL0, LCD_PLL_RST_TL1,  1},
 	{LCD_CLK_CTRL_M,    HHI_TCON_PLL_CNTL0, LCD_PLL_M_TL1,    8},
-	{LCD_CLK_CTRL_FRAC, HHI_TCON_PLL_CNTL1,               0, 19},
+	{LCD_CLK_CTRL_FRAC, HHI_TCON_PLL_CNTL1,               0, 17},
 	{LCD_CLK_CTRL_END,  LCD_CLK_REG_END,                  0,  0},
 };
 
diff --git a/drivers/amlogic/media/vout/lcd/lcd_common.c b/drivers/amlogic/media/vout/lcd/lcd_common.c
index 49ea64c9c982..76e4e03dfc96 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_common.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_common.c
@@ -28,12 +28,10 @@
 #include <linux/reset.h>
 #include <linux/clk.h>
 #include <linux/amlogic/media/vout/lcd/lcd_vout.h>
-#include <linux/amlogic/media/vout/lcd/lcd_extern.h>
 #include <linux/amlogic/media/vout/lcd/lcd_notify.h>
 #include <linux/amlogic/media/vout/lcd/lcd_unifykey.h>
 #include <linux/amlogic/media/vout/vinfo.h>
-#include <linux/page-flags.h>
-#include <linux/mm.h>
+
 #include "lcd_common.h"
 #include "lcd_reg.h"
 
@@ -90,58 +88,6 @@ static char *lcd_mode_table[] = {
 	"invalid",
 };
 
-u8 *lcd_vmap(ulong addr, u32 size)
-{
-	u8 *vaddr = NULL;
-	struct page **pages = NULL;
-	u32 i, npages, offset = 0;
-	ulong phys, page_start;
-	/*pgprot_t pgprot = pgprot_noncached(PAGE_KERNEL);*/
-	pgprot_t pgprot = PAGE_KERNEL;
-
-	if (!PageHighMem(phys_to_page(addr)))
-		return phys_to_virt(addr);
-
-	offset = offset_in_page(addr);
-	page_start = addr - offset;
-	npages = DIV_ROUND_UP(size + offset, PAGE_SIZE);
-
-	pages = kmalloc_array(npages, sizeof(struct page *), GFP_KERNEL);
-	if (!pages)
-		return NULL;
-	for (i = 0; i < npages; i++) {
-		phys = page_start + i * PAGE_SIZE;
-		pages[i] = pfn_to_page(phys >> PAGE_SHIFT);
-	}
-
-	vaddr = vmap(pages, npages, VM_MAP, pgprot);
-	if (!vaddr) {
-		LCDERR("the phy(%lx) vmaped fail, size: %d\n",
-			page_start, npages << PAGE_SHIFT);
-		kfree(pages);
-		return NULL;
-	}
-	kfree(pages);
-
-	if (lcd_debug_print_flag) {
-		LCDPR("[lcd HIGH-MEM-MAP] %s, pa(%lx) to va(%p), size: %d\n",
-			 __func__, page_start, vaddr, npages << PAGE_SHIFT);
-	}
-
-	return vaddr + offset;
-}
-
-void lcd_unmap_phyaddr(u8 *vaddr)
-{
-	void *addr = (void *)(PAGE_MASK & (ulong)vaddr);
-
-	if (is_vmalloc_or_module_addr(vaddr)) {
-		if (lcd_debug_print_flag)
-			LCDPR("----lcd unmap v: %p\n", addr);
-		vunmap(addr);
-	}
-}
-
 unsigned char lcd_mode_str_to_mode(const char *str)
 {
 	unsigned char mode;
@@ -360,7 +306,7 @@ void lcd_ttl_pinmux_set(int status)
 
 	if (pconf->pinmux_flag == index) {
 		LCDPR("pinmux %s is already selected\n",
-		      lcd_ttl_pinmux_str[index]);
+			lcd_ttl_pinmux_str[index]);
 		return;
 	}
 
@@ -371,8 +317,8 @@ void lcd_ttl_pinmux_set(int status)
 		LCDERR("set ttl pinmux %s error\n", lcd_ttl_pinmux_str[index]);
 	else {
 		if (lcd_debug_print_flag) {
-			LCDPR("set ttl pinmux %s: 0x%p\n",
-			      lcd_ttl_pinmux_str[index], pconf->pin);
+			LCDPR("set ttl pinmux %s: %p\n",
+				lcd_ttl_pinmux_str[index], pconf->pin);
 		}
 	}
 	pconf->pinmux_flag = index;
@@ -399,7 +345,7 @@ void lcd_vbyone_pinmux_set(int status)
 
 	if (pconf->pinmux_flag == index) {
 		LCDPR("pinmux %s is already selected\n",
-		      lcd_vbyone_pinmux_str[index]);
+			lcd_vbyone_pinmux_str[index]);
 		return;
 	}
 
@@ -407,135 +353,49 @@ void lcd_vbyone_pinmux_set(int status)
 		lcd_vbyone_pinmux_str[index]);
 	if (IS_ERR(pconf->pin)) {
 		LCDERR("set vbyone pinmux %s error\n",
-		       lcd_vbyone_pinmux_str[index]);
+			lcd_vbyone_pinmux_str[index]);
 	} else {
 		if (lcd_debug_print_flag) {
-			LCDPR("set vbyone pinmux %s: 0x%p\n",
-			      lcd_vbyone_pinmux_str[index], pconf->pin);
+			LCDPR("set vbyone pinmux %s: %p\n",
+				lcd_vbyone_pinmux_str[index], pconf->pin);
 		}
 	}
 	pconf->pinmux_flag = index;
 }
 
 static char *lcd_tcon_pinmux_str[] = {
-	"tcon_p2p",       /* 0 */
-	"tcon_p2p_usit",  /* 1 */
-	"tcon_p2p_off",   /* 2 */
-	"tcon_mlvds",     /* 3 */
-	"tcon_mlvds_off", /* 4 */
-	"none",           /* 5 */
+	"tcon",
+	"tcon_off",
+	"none",
 };
 
-void lcd_mlvds_pinmux_set(int status)
+void lcd_tcon_pinmux_set(int status)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lcd_config_s *pconf;
 	unsigned int index;
 
-	if (!lcd_drv)
-		return;
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	pconf = lcd_drv->lcd_config;
-	index = (status) ? 3 : 4;
-
-	if (pconf->pinmux_flag == index) {
-		LCDPR("pinmux %s is already selected\n",
-		      lcd_tcon_pinmux_str[index]);
-		return;
-	}
-
-	pconf->pin = devm_pinctrl_get_select(lcd_drv->dev,
-		lcd_tcon_pinmux_str[index]);
-	if (IS_ERR(pconf->pin)) {
-		LCDERR("set mlvds pinmux %s error\n",
-		       lcd_tcon_pinmux_str[index]);
-	} else {
-		if (lcd_debug_print_flag) {
-			LCDPR("set mlvds pinmux %s: 0x%p\n",
-			      lcd_tcon_pinmux_str[index], pconf->pin);
-		}
-	}
-	pconf->pinmux_flag = index;
-}
-
-void lcd_p2p_pinmux_set(int status)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct lcd_config_s *pconf;
-	unsigned int index, p2p_type;
-
-	if (!lcd_drv)
-		return;
 	if (lcd_debug_print_flag)
 		LCDPR("%s: %d\n", __func__, status);
 
 	pconf = lcd_drv->lcd_config;
-	p2p_type = pconf->lcd_control.p2p_config->p2p_type & 0x1f;
-	if (p2p_type == P2P_USIT)
-		index = (status) ? 1 : 2;
-	else
-		index = (status) ? 0 : 2;
+	index = (status) ? 0 : 1;
 
 	if (pconf->pinmux_flag == index) {
 		LCDPR("pinmux %s is already selected\n",
-		      lcd_tcon_pinmux_str[index]);
+			lcd_tcon_pinmux_str[index]);
 		return;
 	}
 
 	pconf->pin = devm_pinctrl_get_select(lcd_drv->dev,
 		lcd_tcon_pinmux_str[index]);
 	if (IS_ERR(pconf->pin)) {
-		LCDERR("set p2p pinmux %s error\n",
-		       lcd_tcon_pinmux_str[index]);
-	} else {
-		if (lcd_debug_print_flag) {
-			LCDPR("set p2p pinmux %s: 0x%p\n",
-			      lcd_tcon_pinmux_str[index], pconf->pin);
-		}
-	}
-	pconf->pinmux_flag = index;
-}
-
-void lcd_customer_pinmux_set(int status)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct lcd_config_s *pconf;
-	unsigned int index;
-	char pinmux_str[35];
-
-	if (!lcd_drv)
-		return;
-
-	pconf = lcd_drv->lcd_config;
-	if (!pconf)
-		return;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	memset(pinmux_str, 0, sizeof(pinmux_str));
-	if (status) {
-		index = 0;
-		sprintf(pinmux_str, "%s", pconf->lcd_basic.model_name);
-	} else {
-		index = 1;
-		sprintf(pinmux_str, "%s_off", pconf->lcd_basic.model_name);
-	}
-
-	if (pconf->pinmux_flag == index) {
-		LCDPR("pinmux %s is already selected\n", pinmux_str);
-		return;
-	}
-
-	pconf->pin = devm_pinctrl_get_select(lcd_drv->dev, pinmux_str);
-	if (IS_ERR(pconf->pin)) {
-		LCDERR("set custome pinmux %s error\n", pinmux_str);
+		LCDERR("set tcon pinmux %s error\n",
+			lcd_tcon_pinmux_str[index]);
 	} else {
 		if (lcd_debug_print_flag) {
-			LCDPR("set custome pinmux %s: 0x%p\n",
-			      pinmux_str, pconf->pin);
+			LCDPR("set tcon pinmux %s: %p\n",
+				lcd_tcon_pinmux_str[index], pconf->pin);
 		}
 	}
 	pconf->pinmux_flag = index;
@@ -594,11 +454,9 @@ int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 				if (index < LCD_CPU_GPIO_NUM_MAX)
 					lcd_cpu_gpio_probe(index);
 				break;
-#ifdef CONFIG_AMLOGIC_LCD_EXTERN
 			case LCD_POWER_TYPE_EXTERN:
-				lcd_extern_index_lut_add(index);
+				pconf->extern_index = index;
 				break;
-#endif
 			case LCD_POWER_TYPE_CLK_SS:
 				temp = pconf->lcd_power->power_on_step[i].value;
 				pconf->lcd_timing.ss_level |= temp << 8;
@@ -655,11 +513,10 @@ int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 				if (index < LCD_CPU_GPIO_NUM_MAX)
 					lcd_cpu_gpio_probe(index);
 				break;
-#ifdef CONFIG_AMLOGIC_LCD_EXTERN
 			case LCD_POWER_TYPE_EXTERN:
-				lcd_extern_index_lut_add(index);
+				if (pconf->extern_index == 0xff)
+					pconf->extern_index = index;
 				break;
-#endif
 			default:
 				break;
 			}
@@ -729,11 +586,9 @@ int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
 			if (index < LCD_CPU_GPIO_NUM_MAX)
 				lcd_cpu_gpio_probe(index);
 			break;
-#ifdef CONFIG_AMLOGIC_LCD_EXTERN
 		case LCD_POWER_TYPE_EXTERN:
-			lcd_extern_index_lut_add(index);
+			pconf->extern_index = index;
 			break;
-#endif
 		case LCD_POWER_TYPE_CLK_SS:
 			temp = pconf->lcd_power->power_on_step[i].value;
 			pconf->lcd_timing.ss_level |= temp << 8;
@@ -788,11 +643,10 @@ int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
 			if (index < LCD_CPU_GPIO_NUM_MAX)
 				lcd_cpu_gpio_probe(index);
 			break;
-#ifdef CONFIG_AMLOGIC_LCD_EXTERN
 		case LCD_POWER_TYPE_EXTERN:
-			lcd_extern_index_lut_add(index);
+			if (pconf->extern_index == 0xff)
+				pconf->extern_index = index;
 			break;
-#endif
 		default:
 			break;
 		}
@@ -943,6 +797,66 @@ void lcd_timing_init_config(struct lcd_config_s *pconf)
 	}
 }
 
+#if 0
+/* change frame_rate for different vmode */
+int lcd_vmode_change(struct lcd_config_s *pconf)
+{
+	unsigned int pclk = pconf->lcd_timing.lcd_clk_dft; /* avoid offset */
+	unsigned char type = pconf->lcd_timing.fr_adjust_type;
+	unsigned int h_period = pconf->lcd_basic.h_period;
+	unsigned int v_period = pconf->lcd_basic.v_period;
+	unsigned int sync_duration_num = pconf->lcd_timing.sync_duration_num;
+	unsigned int sync_duration_den = pconf->lcd_timing.sync_duration_den;
+
+	/* frame rate adjust */
+	switch (type) {
+	case 1: /* htotal adjust */
+		h_period = ((pclk / v_period) * sync_duration_den * 10) /
+				sync_duration_num;
+		h_period = (h_period + 5) / 10; /* round off */
+		if (pconf->lcd_basic.h_period != h_period) {
+			LCDPR("%s: adjust h_period %u -> %u\n",
+				__func__, pconf->lcd_basic.h_period, h_period);
+			pconf->lcd_basic.h_period = h_period;
+			/* check clk frac update */
+			pclk = (h_period * v_period) / sync_duration_den *
+				sync_duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk)
+				pconf->lcd_timing.lcd_clk = pclk;
+		}
+		break;
+	case 2: /* vtotal adjust */
+		v_period = ((pclk / h_period) * sync_duration_den * 10) /
+				sync_duration_num;
+		v_period = (v_period + 5) / 10; /* round off */
+		if (pconf->lcd_basic.v_period != v_period) {
+			LCDPR("%s: adjust v_period %u -> %u\n",
+				__func__, pconf->lcd_basic.v_period, v_period);
+			pconf->lcd_basic.v_period = v_period;
+			/* check clk frac update */
+			pclk = (h_period * v_period) / sync_duration_den *
+				sync_duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk)
+				pconf->lcd_timing.lcd_clk = pclk;
+		}
+		break;
+	case 0: /* pixel clk adjust */
+	default:
+		pclk = (h_period * v_period) / sync_duration_den *
+			sync_duration_num;
+		if (pconf->lcd_timing.lcd_clk != pclk) {
+			LCDPR("%s: adjust pclk %u.%03uMHz -> %u.%03uMHz\n",
+				__func__, (pconf->lcd_timing.lcd_clk / 1000000),
+				((pconf->lcd_timing.lcd_clk / 1000) % 1000),
+				(pclk / 1000000), ((pclk / 1000) % 1000));
+			pconf->lcd_timing.lcd_clk = pclk;
+		}
+		break;
+	}
+
+	return 0;
+}
+#else
 int lcd_vmode_change(struct lcd_config_s *pconf)
 {
 	unsigned char type = pconf->lcd_timing.fr_adjust_type;
@@ -954,30 +868,24 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 	unsigned int pclk_max = pconf->lcd_basic.lcd_clk_max;
 	unsigned int duration_num = pconf->lcd_timing.sync_duration_num;
 	unsigned int duration_den = pconf->lcd_timing.sync_duration_den;
-	unsigned long long temp;
 	char str[100];
 	int len = 0;
 
 	pconf->lcd_timing.clk_change = 0; /* clear clk flag */
 	switch (type) {
 	case 0: /* pixel clk adjust */
-		temp = duration_num;
-		temp = temp * h_period * v_period;
-		pclk = lcd_do_div(temp, duration_den);
+		pclk = (h_period * v_period) / duration_den * duration_num;
 		if (pconf->lcd_timing.lcd_clk != pclk)
 			pconf->lcd_timing.clk_change = LCD_CLK_PLL_CHANGE;
 		break;
 	case 1: /* htotal adjust */
-		temp = pclk;
-		temp =  temp * duration_den * 100;
-		h_period = v_period * duration_num;
-		h_period = lcd_do_div(temp, h_period);
+		h_period = ((pclk / v_period) * duration_den * 100) /
+				duration_num;
 		h_period = (h_period + 99) / 100; /* round off */
 		if (pconf->lcd_basic.h_period != h_period) {
 			/* check clk frac update */
-			temp = duration_num;
-			temp = temp * h_period * v_period;
-			pclk = lcd_do_div(temp, duration_den);
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
 			if (pconf->lcd_timing.lcd_clk != pclk) {
 				pconf->lcd_timing.clk_change =
 					LCD_CLK_FRAC_UPDATE;
@@ -985,38 +893,57 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 		}
 		break;
 	case 2: /* vtotal adjust */
-		temp = pclk;
-		temp = temp * duration_den * 100;
-		v_period = h_period * duration_num;
-		v_period = lcd_do_div(temp, v_period);
+		v_period = ((pclk / h_period) * duration_den * 100) /
+				duration_num;
 		v_period = (v_period + 99) / 100; /* round off */
 		if (pconf->lcd_basic.v_period != v_period) {
 			/* check clk frac update */
-			temp = duration_num;
-			temp = temp * h_period * v_period;
-			pclk = lcd_do_div(temp, duration_den);
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
 			if (pconf->lcd_timing.lcd_clk != pclk) {
 				pconf->lcd_timing.clk_change =
 					LCD_CLK_FRAC_UPDATE;
 			}
 		}
 		break;
+	case 4: /* hdmi mode */
+		if ((duration_num / duration_den) == 59) {
+			/* pixel clk adjust */
+			pclk = (h_period * v_period) /
+				duration_den * duration_num;
+			if (pconf->lcd_timing.lcd_clk != pclk)
+				pconf->lcd_timing.clk_change =
+					LCD_CLK_PLL_CHANGE;
+		} else {
+			/* htotal adjust */
+			h_period = ((pclk / v_period) * duration_den * 100) /
+					duration_num;
+			h_period = (h_period + 99) / 100; /* round off */
+			if (pconf->lcd_basic.h_period != h_period) {
+				/* check clk frac update */
+				pclk = (h_period * v_period) / duration_den *
+					duration_num;
+				if (pconf->lcd_timing.lcd_clk != pclk) {
+					pconf->lcd_timing.clk_change =
+						LCD_CLK_FRAC_UPDATE;
+				}
+			}
+		}
+		break;
 	case 3: /* free adjust, use min/max range to calculate */
-		temp = pclk;
-		temp = temp * duration_den * 100;
-		v_period = h_period * duration_num;
-		v_period = lcd_do_div(temp, v_period);
+	default:
+		v_period = ((pclk / h_period) * duration_den * 100) /
+			duration_num;
 		v_period = (v_period + 99) / 100; /* round off */
 		if (v_period > pconf->lcd_basic.v_period_max) {
 			v_period = pconf->lcd_basic.v_period_max;
-			h_period = v_period * duration_num;
-			h_period = lcd_do_div(temp, h_period);
+			h_period = ((pclk / v_period) * duration_den * 100) /
+				duration_num;
 			h_period = (h_period + 99) / 100; /* round off */
 			if (h_period > pconf->lcd_basic.h_period_max) {
 				h_period = pconf->lcd_basic.h_period_max;
-				temp = duration_num;
-				temp = temp * h_period * v_period;
-				pclk = lcd_do_div(temp, duration_den);
+				pclk = (h_period * v_period) / duration_den *
+					duration_num;
 				if (pconf->lcd_timing.lcd_clk != pclk) {
 					if (pclk > pclk_max) {
 						pclk = pclk_max;
@@ -1029,14 +956,13 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 			}
 		} else if (v_period < pconf->lcd_basic.v_period_min) {
 			v_period = pconf->lcd_basic.v_period_min;
-			h_period = v_period * duration_num;
-			h_period = lcd_do_div(temp, h_period);
+			h_period = ((pclk / v_period) * duration_den * 100) /
+				duration_num;
 			h_period = (h_period + 99) / 100; /* round off */
 			if (h_period < pconf->lcd_basic.h_period_min) {
 				h_period = pconf->lcd_basic.h_period_min;
-				temp = duration_num;
-				temp = temp * h_period * v_period;
-				pclk = lcd_do_div(temp, duration_den);
+				pclk = (h_period * v_period) / duration_den *
+					duration_num;
 				if (pconf->lcd_timing.lcd_clk != pclk) {
 					if (pclk < pclk_min) {
 						pclk = pclk_min;
@@ -1050,46 +976,14 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 		}
 		/* check clk frac update */
 		if ((pconf->lcd_timing.clk_change & LCD_CLK_PLL_CHANGE) == 0) {
-			temp = duration_num;
-			temp = temp * h_period * v_period;
-			pclk = lcd_do_div(temp, duration_den);
+			pclk = (h_period * v_period) / duration_den *
+				duration_num;
 			if (pconf->lcd_timing.lcd_clk != pclk) {
 				pconf->lcd_timing.clk_change =
 					LCD_CLK_FRAC_UPDATE;
 			}
 		}
 		break;
-	case 4: /* hdmi mode */
-		if ((duration_num / duration_den) == 59) {
-			/* pixel clk adjust */
-			temp = duration_num;
-			temp = temp * h_period * v_period;
-			pclk = lcd_do_div(temp, duration_den);
-			if (pconf->lcd_timing.lcd_clk != pclk)
-				pconf->lcd_timing.clk_change =
-					LCD_CLK_PLL_CHANGE;
-		} else {
-			/* htotal adjust */
-			temp = pclk;
-			temp = temp * duration_den * 100;
-			h_period = v_period * duration_num;
-			h_period = lcd_do_div(temp, h_period);
-			h_period = (h_period + 99) / 100; /* round off */
-			if (pconf->lcd_basic.h_period != h_period) {
-				/* check clk frac update */
-				temp = duration_num;
-				temp = temp * h_period * v_period;
-				pclk = lcd_do_div(temp, duration_den);
-				if (pconf->lcd_timing.lcd_clk != pclk) {
-					pconf->lcd_timing.clk_change =
-						LCD_CLK_FRAC_UPDATE;
-				}
-			}
-		}
-		break;
-	default:
-		LCDERR("%s: invalid fr_adjust_type: %d\n", __func__, type);
-		return 0;
 	}
 
 	if (pconf->lcd_basic.v_period != v_period) {
@@ -1122,6 +1016,7 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 
 	return 0;
 }
+#endif
 
 void lcd_clk_change(struct lcd_config_s *pconf)
 {
@@ -1166,22 +1061,14 @@ void lcd_venc_change(struct lcd_config_s *pconf)
 
 void lcd_if_enable_retry(struct lcd_config_s *pconf)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
-	if (lcd_drv->boot_ctrl->lcd_init_level ==
-	    LCD_INIT_LEVEL_KERNEL_OFF)
-		return;
-
 	pconf->retry_enable_cnt = 0;
 	while (pconf->retry_enable_flag) {
 		if (pconf->retry_enable_cnt++ >= LCD_ENABLE_RETRY_MAX)
 			break;
 		LCDPR("retry enable...%d\n", pconf->retry_enable_cnt);
-		aml_lcd_notifier_call_chain(LCD_EVENT_IF_POWER_OFF,
-					    NULL);
+		aml_lcd_notifier_call_chain(LCD_EVENT_IF_POWER_OFF, NULL);
 		msleep(1000);
-		aml_lcd_notifier_call_chain(LCD_EVENT_IF_POWER_ON,
-					    NULL);
+		aml_lcd_notifier_call_chain(LCD_EVENT_IF_POWER_ON, NULL);
 	}
 	pconf->retry_enable_cnt = 0;
 }
diff --git a/drivers/amlogic/media/vout/lcd/lcd_common.h b/drivers/amlogic/media/vout/lcd/lcd_common.h
index e747f934bb07..4053855ac8be 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_common.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_common.h
@@ -42,23 +42,7 @@
 /* 20190520: add vbyone hw filter user define support */
 /* 20190911: add lcd_init_level for tl1 */
 /* 20191025: tcon chpi phy setting update */
-/* 20191115: tcon add demura and vac function  for tl1*/
-/* 20191227: vbyone hw filter disable support*/
-/* 20200102: support resume type to avoid dual display interfere each other*/
-/* 20200611: update tcon pinmux pre-lock*/
-/* 20200619: correct P2P CHPI tx low common setting*/
-/* 20200827: support T5 TV driver support */
-/* 20200927: add tcon support for T5 chip*/
-/* 20200930: optimize tcon data flow*/
-/* 20201019: optimize tcon axi reserved memory config and data crc32*/
-/* 20201105: optimize tcon pc tool adb api to double confirm reg read*/
-/* 20201116: optimize phy ctrl compatibility*/
-/* 20201230: add lcd_customer_pinmux ser api*/
-/* 20210311: add global reset to clear tcon last state*/
-/* 20210608: add tcon multi lut support*/
-/* 20210705: add lcd mute and test state protection*/
-/* 20211009: support 59 & 47 frame rate for tv mode*/
-#define LCD_DRV_VERSION    "20211009"
+#define LCD_DRV_VERSION    "20191025"
 
 #define VPP_OUT_SATURATE            (1 << 0)
 
@@ -66,31 +50,18 @@ extern struct mutex lcd_vout_mutex;
 extern unsigned char lcd_resume_flag;
 extern int lcd_vout_serve_bypass;
 
-static inline unsigned int lcd_do_div(unsigned long long num, unsigned int den)
-{
-	unsigned long long ret = num;
-
-	do_div(ret, den);
-
-	return (unsigned int)ret;
-}
-
 /* lcd common */
 extern int lcd_type_str_to_type(const char *str);
 extern char *lcd_type_type_to_str(int type);
 extern unsigned char lcd_mode_str_to_mode(const char *str);
 extern char *lcd_mode_mode_to_str(int mode);
-u8 *lcd_vmap(ulong addr, u32 size);
-void lcd_unmap_phyaddr(u8 *vaddr);
 
 extern void lcd_cpu_gpio_probe(unsigned int index);
 extern void lcd_cpu_gpio_set(unsigned int index, int value);
 extern unsigned int lcd_cpu_gpio_get(unsigned int index);
 extern void lcd_ttl_pinmux_set(int status);
 extern void lcd_vbyone_pinmux_set(int status);
-void lcd_mlvds_pinmux_set(int status);
-void lcd_p2p_pinmux_set(int status);
-void lcd_customer_pinmux_set(int status);
+extern void lcd_tcon_pinmux_set(int status);
 
 extern int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 		struct device_node *child);
@@ -110,8 +81,6 @@ extern void lcd_if_enable_retry(struct lcd_config_s *pconf);
 extern void lcd_vout_notify_mode_change_pre(void);
 extern void lcd_vout_notify_mode_change(void);
 
-unsigned int cal_crc32(unsigned int crc, const unsigned char *buf, int buf_len);
-
 /* lcd phy */
 extern void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status);
 extern void lcd_vbyone_phy_set(struct lcd_config_s *pconf, int status);
@@ -119,23 +88,24 @@ extern void lcd_mlvds_phy_set(struct lcd_config_s *pconf, int status);
 extern void lcd_p2p_phy_set(struct lcd_config_s *pconf, int status);
 extern void lcd_mipi_phy_set(struct lcd_config_s *pconf, int status);
 int lcd_phy_probe(void);
-void lcd_phy_tcon_chpi_bbc_init_tl1(struct lcd_config_s *pconf);
+void lcd_phy_tcon_chpi_bbc_init_tl1(int delay);
 
 /* lcd tcon */
-unsigned int lcd_tcon_reg_read(unsigned int addr);
-void lcd_tcon_reg_write(unsigned int addr, unsigned int val);
-int lcd_tcon_probe(struct aml_lcd_drv_s *lcd_drv);
-int lcd_tcon_gamma_set_pattern(unsigned int bit_width, unsigned int gamma_r,
-			       unsigned int gamma_g, unsigned int gamma_b);
-unsigned int lcd_tcon_table_read(unsigned int addr);
-unsigned int lcd_tcon_table_write(unsigned int addr, unsigned int val);
-int lcd_tcon_core_update(void);
-int lcd_tcon_od_set(int flag);
-int lcd_tcon_od_get(void);
-int lcd_tcon_core_reg_get(unsigned char *buf, unsigned int size);
-int lcd_tcon_enable(struct lcd_config_s *pconf);
-void lcd_tcon_disable(struct lcd_config_s *pconf);
-void lcd_tcon_vsync_isr(struct aml_lcd_drv_s *lcd_drv);
+extern unsigned int lcd_tcon_reg_read(unsigned int addr);
+extern void lcd_tcon_reg_write(unsigned int addr, unsigned int val);
+extern void lcd_tcon_reg_table_print(void);
+extern void lcd_tcon_reg_readback_print(void);
+extern int lcd_tcon_info_print(char *buf, int offset);
+extern int lcd_tcon_od_set(int flag);
+extern int lcd_tcon_od_get(void);
+extern int lcd_tcon_reg_table_size_get(void);
+extern unsigned char *lcd_tcon_reg_table_get(void);
+
+extern int lcd_tcon_core_reg_get(unsigned char *buf, unsigned int size);
+extern void lcd_tcon_core_reg_update(void);
+extern int lcd_tcon_enable(struct lcd_config_s *pconf);
+extern void lcd_tcon_disable(void);
+extern int lcd_tcon_probe(struct aml_lcd_drv_s *lcd_drv);
 
 /* lcd debug */
 extern int lcd_debug_info_len(int num);
diff --git a/drivers/amlogic/media/vout/lcd/lcd_debug.c b/drivers/amlogic/media/vout/lcd/lcd_debug.c
index 229b9530e91c..ddfbf6d56c7e 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_debug.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_debug.c
@@ -28,7 +28,6 @@
 #include <linux/uaccess.h>
 #include <linux/amlogic/media/vout/lcd/aml_bl.h>
 #include <linux/amlogic/media/vout/lcd/lcd_vout.h>
-#include <linux/amlogic/media/vout/lcd/lcd_tcon_data.h>
 #include <linux/amlogic/media/vout/lcd/lcd_notify.h>
 #include <linux/amlogic/media/vout/lcd/lcd_unifykey.h>
 #include "lcd_reg.h"
@@ -38,21 +37,11 @@
 #include "lcd_tablet/mipi_dsi_util.h"
 #endif
 #include "lcd_debug.h"
-#include "lcd_tcon.h"
 
-struct mutex lcd_tcon_adb_mutex;
 static struct lcd_debug_info_reg_s *lcd_debug_info_reg;
 static struct lcd_debug_info_if_s *lcd_debug_info_if;
 
-#define PR_BUF_MAX          (8 * 1024)
-
-/*for tconless reg adb use*/
-static struct lcd_tcon_adb_reg_s adb_reg = {
-	.rw_mode = LCD_ADB_TCON_REG_RW_MODE_NULL,
-	.bit_width = ADB_TCON_REG_8_bit,
-	.addr = 0,
-	.len = 0,
-};
+#define PR_BUF_MAX          4096
 
 static void lcd_debug_parse_param(char *buf_orig, char **parm)
 {
@@ -350,34 +339,6 @@ static int lcd_info_print_lvds(char *buf, int offset)
 	return len;
 }
 
-static int lcd_info_print_lvds_tl1(char *buf, int offset)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct lcd_config_s *pconf;
-	int n, len = 0;
-
-	pconf = lcd_drv->lcd_config;
-
-	n = lcd_debug_info_len(len + offset);
-	len += snprintf((buf + len), n,
-		"lvds_repack     %u\n"
-		"dual_port       %u\n"
-		"pn_swap         %u\n"
-		"port_swap       %u\n"
-		"lane_reverse    %u\n"
-		"phy_vswing      0x%x\n"
-		"phy_preem       0x%x\n\n",
-		pconf->lcd_control.lvds_config->lvds_repack,
-		pconf->lcd_control.lvds_config->dual_port,
-		pconf->lcd_control.lvds_config->pn_swap,
-		pconf->lcd_control.lvds_config->port_swap,
-		pconf->lcd_control.lvds_config->lane_reverse,
-		pconf->lcd_control.lvds_config->phy_vswing,
-		pconf->lcd_control.lvds_config->phy_preem);
-
-	return len;
-}
-
 static int lcd_info_print_vbyone(char *buf, int offset)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
@@ -394,7 +355,7 @@ static int lcd_info_print_vbyone(char *buf, int offset)
 		"region_num      %u\n"
 		"byte_mode       %u\n"
 		"color_fmt       %u\n"
-		"bit_rate        %uHz\n"
+		"bit_rate        %u\n"
 		"phy_vswing      0x%x\n"
 		"phy_preem       0x%x\n"
 		"intr_en         %u\n"
@@ -451,9 +412,7 @@ static int lcd_info_print_vbyone(char *buf, int offset)
 
 static int lcd_info_print_mipi(char *buf, int offset)
 {
-#ifdef CONFIG_AMLOGIC_LCD_TABLET
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-#endif
 	int len = 0;
 
 #ifdef CONFIG_AMLOGIC_LCD_TABLET
@@ -481,8 +440,8 @@ static int lcd_info_print_mlvds(char *buf, int offset)
 		"bit_swap          %u\n"
 		"phy_vswing        0x%x\n"
 		"phy_preem         0x%x\n"
-		"bit_rate          %uHz\n"
-		"pi_clk_sel        0x%03x\n",
+		"bit_rate          %dHz\n"
+		"pi_clk_sel        0x%03x\n\n",
 		pconf->lcd_control.mlvds_config->channel_num,
 		pconf->lcd_control.mlvds_config->channel_sel0,
 		pconf->lcd_control.mlvds_config->channel_sel1,
@@ -498,7 +457,7 @@ static int lcd_info_print_mlvds(char *buf, int offset)
 
 	n = lcd_debug_info_len(len + offset);
 	len += snprintf((buf+len), n,
-		"\npinmux_flag       %d\n"
+		"pinmux_flag       %d\n"
 		"pinmux_pointer    0x%p\n\n",
 		pconf->pinmux_flag,
 		pconf->pin);
@@ -522,7 +481,7 @@ static int lcd_info_print_p2p(char *buf, int offset)
 		"channel_sel1      0x%08x\n"
 		"pn_swap           %u\n"
 		"bit_swap          %u\n"
-		"bit_rate          %uHz\n"
+		"bit_rate          %dHz\n"
 		"phy_vswing        0x%x\n"
 		"phy_preem         0x%x\n\n",
 		pconf->lcd_control.p2p_config->p2p_type,
@@ -562,17 +521,15 @@ static int lcd_info_print(char *buf, int offset)
 	n = lcd_debug_info_len(len + offset);
 	len += snprintf((buf+len), n,
 		"driver version: %s\n"
-		"panel_type: %s, chip: %d, mode: %s, status: %d\n"
-		"viu_sel: %d, resume_type: %d, fr_auto_policy: %d\n"
+		"panel_type: %s, chip: %d, mode: %s, status: %d, viu_sel: %d\n"
 		"key_valid: %d, config_load: %d\n"
-		"fr_mode: %d, fr_duration: %d\n",
+		"fr_auto_policy: %d\n",
 		lcd_drv->version,
 		pconf->lcd_propname, lcd_drv->data->chip_type,
 		lcd_mode_mode_to_str(lcd_drv->lcd_mode),
 		lcd_drv->lcd_status, lcd_drv->viu_sel,
-		lcd_drv->lcd_resume_type, lcd_drv->fr_auto_policy,
 		lcd_drv->lcd_key_valid, lcd_drv->lcd_config_load,
-		lcd_drv->fr_mode, lcd_drv->fr_duration);
+		lcd_drv->fr_auto_policy);
 
 	n = lcd_debug_info_len(len + offset);
 	len += snprintf((buf+len), n,
@@ -655,8 +612,6 @@ static void lcd_reg_print_serializer(char *buf, int offset)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		reg0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
 		reg1 = HHI_LVDS_TX_PHY_CNTL1_TL1;
 		break;
@@ -671,10 +626,10 @@ static void lcd_reg_print_serializer(char *buf, int offset)
 	n = lcd_debug_info_len(len + offset);
 	len += snprintf((buf+len), n,
 		"HHI_LVDS_TX_PHY_CNTL0    [0x%04x] = 0x%08x\n",
-		reg0, lcd_ana_read(reg0));
+		reg0, lcd_hiu_read(reg0));
 	len += snprintf((buf+len), n,
 		"HHI_LVDS_TX_PHY_CNTL1    [0x%04x] = 0x%08x\n",
-		reg1, lcd_ana_read(reg1));
+		reg1, lcd_hiu_read(reg1));
 }
 
 static int lcd_reg_print_ttl(char *buf, int offset)
@@ -781,39 +736,6 @@ static int lcd_reg_print_lvds(char *buf, int offset)
 	return len;
 }
 
-static int lcd_reg_print_lvds_tl1(char *buf, int offset)
-{
-	unsigned int reg;
-	int n, len = 0;
-
-	lcd_reg_print_serializer((buf + len), (len + offset));
-
-	n = lcd_debug_info_len(len + offset);
-	len += snprintf((buf + len), n, "\nlvds regs:\n");
-	n = lcd_debug_info_len(len + offset);
-	reg = LVDS_PACK_CNTL_ADDR;
-	len += snprintf((buf + len), n,
-		"LVDS_PACK_CNTL  [0x%04x] = 0x%08x\n",
-		reg, lcd_vcbus_read(reg));
-	n = lcd_debug_info_len(len + offset);
-	reg = LVDS_GEN_CNTL;
-	len += snprintf((buf + len), n,
-		"LVDS_GEN_CNTL   [0x%04x] = 0x%08x\n",
-		reg, lcd_vcbus_read(reg));
-	n = lcd_debug_info_len(len + offset);
-	reg = P2P_CH_SWAP0;
-	len += snprintf((buf + len), n,
-		"P2P_CH_SWAP0    [0x%04x] = 0x%08x\n",
-		reg, lcd_vcbus_read(reg));
-	n = lcd_debug_info_len(len + offset);
-	reg = P2P_CH_SWAP1;
-	len += snprintf((buf + len), n,
-		"P2P_CH_SWAP1    [0x%04x] = 0x%08x\n",
-		reg, lcd_vcbus_read(reg));
-
-	return len;
-}
-
 static int lcd_reg_print_vbyone_txl(char *buf, int offset)
 {
 	unsigned int reg;
@@ -1010,7 +932,7 @@ static int lcd_reg_print_mipi(char *buf, int offset)
 	return len;
 }
 
-static int lcd_reg_print_tcon(char *buf, int offset)
+static int lcd_reg_print_mlvds(char *buf, int offset)
 {
 	unsigned int reg;
 	int n, len = 0;
@@ -1025,6 +947,21 @@ static int lcd_reg_print_tcon(char *buf, int offset)
 	len += snprintf((buf+len), n,
 		"HHI_TCON_CLK_CNTL   [0x%04x] = 0x%08x\n",
 		reg, lcd_hiu_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = HHI_DIF_TCON_CNTL0;
+	len += snprintf((buf+len), n,
+		"HHI_DIF_TCON_CNTL0  [0x%04x] = 0x%08x\n",
+		reg, lcd_hiu_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = HHI_DIF_TCON_CNTL1;
+	len += snprintf((buf+len), n,
+		"HHI_DIF_TCON_CNTL1  [0x%04x] = 0x%08x\n",
+		reg, lcd_hiu_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = HHI_DIF_TCON_CNTL2;
+	len += snprintf((buf+len), n,
+		"HHI_DIF_TCON_CNTL2  [0x%04x] = 0x%08x\n",
+		reg, lcd_hiu_read(reg));
 
 	n = lcd_debug_info_len(len + offset);
 	reg = TCON_TOP_CTRL;
@@ -1091,7 +1028,6 @@ static int lcd_reg_print_tcon(char *buf, int offset)
 	len += snprintf((buf+len), n,
 		"TCON_DDRIF_CTRL1    [0x%04x] = 0x%08x\n",
 		reg, lcd_tcon_read(reg));
-	n = lcd_debug_info_len(len + offset);
 	reg = TCON_DDRIF_CTRL2;
 	len += snprintf((buf+len), n,
 		"TCON_DDRIF_CTRL2    [0x%04x] = 0x%08x\n",
@@ -1101,22 +1037,108 @@ static int lcd_reg_print_tcon(char *buf, int offset)
 	len += snprintf((buf+len), n,
 		"TCON_INTR_MASKN     [0x%04x] = 0x%08x\n",
 		reg, lcd_tcon_read(reg));
-	n = lcd_debug_info_len(len + offset);
 	reg = TCON_INTR_RO;
 	len += snprintf((buf+len), n,
 		"TCON_INTR_RO        [0x%04x] = 0x%08x\n",
 		reg, lcd_tcon_read(reg));
 
+	return len;
+}
+
+static int lcd_reg_print_p2p(char *buf, int offset)
+{
+	unsigned int reg;
+	int n, len = 0;
+
+	lcd_reg_print_serializer((buf+len), (len+offset));
+
 	n = lcd_debug_info_len(len + offset);
-	reg = P2P_CH_SWAP0;
-	len += snprintf((buf + len), n,
-		"P2P_CH_SWAP0    [0x%04x] = 0x%08x\n",
-		reg, lcd_vcbus_read(reg));
+	len += snprintf((buf+len), n, "\np2p regs:\n");
+
 	n = lcd_debug_info_len(len + offset);
-	reg = P2P_CH_SWAP1;
-	len += snprintf((buf + len), n,
-		"P2P_CH_SWAP1    [0x%04x] = 0x%08x\n",
-		reg, lcd_vcbus_read(reg));
+	reg = HHI_TCON_CLK_CNTL;
+	len += snprintf((buf+len), n,
+		"HHI_TCON_CLK_CNTL   [0x%04x] = 0x%08x\n",
+		reg, lcd_hiu_read(reg));
+
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_TOP_CTRL;
+	len += snprintf((buf+len), n,
+		"TCON_TOP_CTRL       [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_RGB_IN_MUX;
+	len += snprintf((buf+len), n,
+		"TCON_RGB_IN_MUX     [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_OUT_CH_SEL0;
+	len += snprintf((buf+len), n,
+		"TCON_OUT_CH_SEL0    [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_OUT_CH_SEL1;
+	len += snprintf((buf+len), n,
+		"TCON_OUT_CH_SEL1    [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_STATUS0;
+	len += snprintf((buf+len), n,
+		"TCON_STATUS0        [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_PLLLOCK_CNTL;
+	len += snprintf((buf+len), n,
+		"TCON_PLLLOCK_CNTL   [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_RST_CTRL;
+	len += snprintf((buf+len), n,
+		"TCON_RST_CTRL       [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_AXI_OFST0;
+	len += snprintf((buf+len), n,
+		"TCON_AXI_OFST0      [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_AXI_OFST1;
+	len += snprintf((buf+len), n,
+		"TCON_AXI_OFST1      [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_AXI_OFST2;
+	len += snprintf((buf+len), n,
+		"TCON_AXI_OFST2      [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_CLK_CTRL;
+	len += snprintf((buf+len), n,
+		"TCON_CLK_CTRL       [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_STATUS1;
+	len += snprintf((buf+len), n,
+		"TCON_STATUS1        [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_DDRIF_CTRL1;
+	len += snprintf((buf+len), n,
+		"TCON_DDRIF_CTRL1    [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	reg = TCON_DDRIF_CTRL2;
+	len += snprintf((buf+len), n,
+		"TCON_DDRIF_CTRL2    [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	n = lcd_debug_info_len(len + offset);
+	reg = TCON_INTR_MASKN;
+	len += snprintf((buf+len), n,
+		"TCON_INTR_MASKN     [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
+	reg = TCON_INTR_RO;
+	len += snprintf((buf+len), n,
+		"TCON_INTR_RO        [0x%04x] = 0x%08x\n",
+		reg, lcd_tcon_read(reg));
 
 	return len;
 }
@@ -1154,91 +1176,81 @@ static int lcd_reg_print_phy_analog_tl1(char *buf, int offset)
 
 	n = lcd_debug_info_len(len + offset);
 	len += snprintf((buf+len), n, "\nphy analog regs:\n");
-	reg = HHI_LVDS_TX_PHY_CNTL0_TL1;
-	len += snprintf((buf + len), n,
-		"HHI_LVDS_TX_PHY_CNTL0  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
-	n = lcd_debug_info_len(len + offset);
-	reg = HHI_LVDS_TX_PHY_CNTL1_TL1;
-	len += snprintf((buf + len), n,
-		"HHI_LVDS_TX_PHY_CNTL1  [0x%02x] = 0x%08x\n\n",
-		reg, lcd_ana_read(reg));
-
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL1;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL1  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL2;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL2  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL3;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL3  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL4;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL4  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL6;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL6  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL7;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL7  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL8;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL8  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL9;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL9  [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL10;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL10 [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL11;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL11 [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL12;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL12 [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL13;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL13 [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL14;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL14 [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL15;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL15 [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_DIF_CSI_PHY_CNTL16;
 	len += snprintf((buf+len), n,
 		"HHI_DIF_CSI_PHY_CNTL16 [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 
 	return len;
 }
@@ -1254,17 +1266,17 @@ static int lcd_reg_print_mipi_phy_analog(char *buf, int offset)
 	reg = HHI_MIPI_CNTL0;
 	len += snprintf((buf+len), n,
 		"HHI_MIPI_CNTL0   [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_MIPI_CNTL1;
 	len += snprintf((buf+len), n,
 		"HHI_MIPI_CNTL1   [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 	n = lcd_debug_info_len(len + offset);
 	reg = HHI_MIPI_CNTL2;
 	len += snprintf((buf+len), n,
 		"HHI_MIPI_CNTL2   [0x%02x] = 0x%08x\n",
-		reg, lcd_ana_read(reg));
+		reg, lcd_hiu_read(reg));
 
 	return len;
 }
@@ -1281,20 +1293,6 @@ static int lcd_reg_print(char *buf, int offset)
 	n = lcd_debug_info_len(len + offset);
 	len += snprintf((buf+len), n, "\nclk regs:\n");
 	if (lcd_debug_info_reg) {
-		if (lcd_debug_info_reg->reg_ana_table) {
-			table = lcd_debug_info_reg->reg_ana_table;
-			i = 0;
-			while (i < LCD_DEBUG_REG_CNT_MAX) {
-				if (table[i] == LCD_DEBUG_REG_END)
-					break;
-				n = lcd_debug_info_len(len + offset);
-				len += snprintf((buf + len), n,
-						"ana     [0x%02x] = 0x%08x\n",
-					table[i], lcd_ana_read(table[i]));
-				i++;
-			}
-		}
-
 		if (lcd_debug_info_reg->reg_clk_table) {
 			table = lcd_debug_info_reg->reg_clk_table;
 			i = 0;
@@ -1303,10 +1301,12 @@ static int lcd_reg_print(char *buf, int offset)
 					break;
 				n = lcd_debug_info_len(len + offset);
 				len += snprintf((buf+len), n,
-					"clk     [0x%02x] = 0x%08x\n",
+					"hiu     [0x%02x] = 0x%08x\n",
 					table[i], lcd_hiu_read(table[i]));
 				i++;
 			}
+		} else {
+			LCDERR("%s: reg_clk_table is null\n", __func__);
 		}
 
 		if (lcd_debug_info_reg->reg_encl_table) {
@@ -1323,6 +1323,8 @@ static int lcd_reg_print(char *buf, int offset)
 					table[i], lcd_vcbus_read(table[i]));
 				i++;
 			}
+		} else {
+			LCDERR("%s: reg_encl_table is null\n", __func__);
 		}
 
 		if (lcd_debug_info_reg->reg_pinmux_table) {
@@ -1347,6 +1349,8 @@ static int lcd_reg_print(char *buf, int offset)
 		if (lcd_debug_info_if->reg_dump_interface) {
 			len += lcd_debug_info_if->reg_dump_interface((buf+len),
 				(len+offset));
+		} else {
+			LCDERR("%s: reg_dump_interface is null\n", __func__);
 		}
 
 		if (lcd_debug_info_if->reg_dump_phy) {
@@ -1491,7 +1495,6 @@ void lcd_mute_setting(unsigned char flag)
 		lcd_vcbus_setb(ENCL_VIDEO_MODE_ADV, 1, 3, 1);
 		lcd_vcbus_write(ENCL_TST_EN, 0);
 	}
-	LCDPR("mute: %d\n", flag);
 }
 
 static void lcd_screen_restore(void)
@@ -1529,65 +1532,14 @@ static void lcd_screen_black(void)
 	lcd_mute_setting(1);
 }
 
-#define CLK_CHK_MAX    2000000  /*Hz*/
-static unsigned int lcd_prbs_performed, lcd_prbs_err;
 static unsigned int lcd_prbs_flag;
-static unsigned long lcd_encl_clk_check_std = 121000000;
-static unsigned long lcd_fifo_clk_check_std = 42000000;
-
-static unsigned long lcd_abs(unsigned long a, unsigned long b)
-{
-	unsigned long val;
-
-	if (a >= b)
-		val = a - b;
-	else
-		val = b - a;
-
-	return val;
-}
-
-static int lcd_prbs_clk_check(unsigned long encl_clk, unsigned long fifo_clk,
-			      unsigned int cnt)
-{
-	unsigned long clk_check, temp;
-
-	clk_check = meson_clk_measure(9);
-	if (clk_check != encl_clk) {
-		temp = lcd_abs(clk_check, encl_clk);
-		if (temp >= CLK_CHK_MAX) {
-			if (lcd_debug_print_flag == 6) {
-				LCDERR("encl clkmsr error %ld, cnt:%d\n",
-				       clk_check, cnt);
-			}
-			return -1;
-		}
-	}
-
-	clk_check = meson_clk_measure(129);
-	if (clk_check != fifo_clk) {
-		temp = lcd_abs(clk_check, fifo_clk);
-		if (temp >= CLK_CHK_MAX) {
-			if (lcd_debug_print_flag == 6) {
-				LCDERR("fifo clkmsr error %ld, cnt:%d\n",
-				       clk_check, cnt);
-			}
-			return -1;
-		}
-	}
-
-	return 0;
-}
-
-static void aml_lcd_prbs_test(unsigned int s, unsigned int mode_flag)
+static unsigned int lcd_prbs_cnt;
+static void aml_lcd_prbs_test(unsigned int s)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct lcd_clk_config_s *cconf = get_lcd_clk_config();
-	unsigned int lcd_prbs_mode, lcd_prbs_cnt;
 	unsigned int reg0, reg1;
-	unsigned int val1, val2, timeout;
-	unsigned int clk_err_cnt = 0;
-	int i, j, ret;
+	unsigned int val1, val2, cnt = 0, timeout;
+	int i, ret;
 
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_GXL:
@@ -1596,8 +1548,8 @@ static void aml_lcd_prbs_test(unsigned int s, unsigned int mode_flag)
 	case LCD_CHIP_G12A:
 	case LCD_CHIP_G12B:
 	case LCD_CHIP_SM1:
-		LCDERR("%s: not support\n", __func__);
-		goto lcd_prbs_test_end;
+		LCDERR("not support\n");
+		return;
 	case LCD_CHIP_TXL:
 	case LCD_CHIP_TXLX:
 		reg0 = HHI_LVDS_TX_PHY_CNTL0;
@@ -1609,126 +1561,52 @@ static void aml_lcd_prbs_test(unsigned int s, unsigned int mode_flag)
 		break;
 	}
 
+	lcd_hiu_write(reg0, 0xfff20c4);
+	lcd_hiu_setb(reg0, 1, 12, 1);
+	val1 = lcd_hiu_getb(reg1, 12, 12);
+
 	s = (s > 1800) ? 1800 : s;
 	timeout = s * 200;
-
-	for (i = 0; i < LCD_PRBS_MODE_MAX; i++) {
-		if ((mode_flag & (1 << i)) == 0)
-			continue;
-
-		lcd_ana_write(reg0, 0);
-		lcd_ana_write(reg1, 0);
-
-		lcd_prbs_cnt = 0;
-		clk_err_cnt = 0;
-		lcd_prbs_mode = (1 << i);
-		if (lcd_prbs_mode == LCD_PRBS_MODE_LVDS) {
-			lcd_encl_clk_check_std = 136000000;
-			lcd_fifo_clk_check_std = 48000000;
-		} else if (lcd_prbs_mode == LCD_PRBS_MODE_VX1) {
-			lcd_encl_clk_check_std = 594000000;
-			lcd_fifo_clk_check_std = 297000000;
-		}
-		if (cconf->data->prbs_clk_config) {
-			cconf->data->prbs_clk_config(lcd_prbs_mode);
-		} else {
-			LCDERR("%s: prbs_clk_config is null\n", __func__);
-			goto lcd_prbs_test_end;
+	while (lcd_prbs_flag) {
+		if (s > 1) { /* when s=1, means always run */
+			if (cnt++ >= timeout)
+				break;
 		}
-		msleep(20);
-
-		lcd_ana_write(reg0, 0x000000c0);
-		lcd_ana_setb(reg0, 0xfff, 16, 12);
-		lcd_ana_setb(reg0, 1, 2, 1);
-		lcd_ana_write(reg1, 0x41000000);
-		lcd_ana_setb(reg1, 1, 31, 1);
-
-		lcd_ana_write(reg0, 0xfff20c4);
-		lcd_ana_setb(reg0, 1, 12, 1);
-		val1 = lcd_ana_getb(reg1, 12, 12);
-
-		while (lcd_prbs_flag) {
-			if (s > 1) { /* when s=1, means always run */
-				if (lcd_prbs_cnt++ >= timeout)
-					break;
-			}
-			usleep_range(5000, 5001);
-			ret = 1;
-			for (j = 0; j < 5; j++) {
-				val2 = lcd_ana_getb(reg1, 12, 12);
-				if (val2 != val1) {
-					ret = 0;
-					break;
-				}
-			}
-			if (ret) {
-				LCDERR(
-				"prbs check error 1, val:0x%03x, cnt:%d\n",
-				       val2, lcd_prbs_cnt);
-				goto lcd_prbs_test_err;
-			}
-			val1 = val2;
-			if (lcd_ana_getb(reg1, 0, 12)) {
-				LCDERR("prbs check error 2, cnt:%d\n",
-				       lcd_prbs_cnt);
-				goto lcd_prbs_test_err;
-			}
-
-			if (lcd_prbs_clk_check(lcd_encl_clk_check_std,
-					       lcd_fifo_clk_check_std,
-					       lcd_prbs_cnt))
-				clk_err_cnt++;
-			else
-				clk_err_cnt = 0;
-			if (clk_err_cnt >= 10) {
-				LCDERR("prbs check error 3(clkmsr), cnt: %d\n",
-				       lcd_prbs_cnt);
-				goto lcd_prbs_test_err;
+		usleep_range(5000, 5001);
+		ret = 1;
+		for (i = 0; i < 5; i++) {
+			val2 = lcd_hiu_getb(reg1, 12, 12);
+			if (val2 != val1) {
+				ret = 0;
+				break;
 			}
 		}
-
-		lcd_ana_write(reg0, 0);
-		lcd_ana_write(reg1, 0);
-
-		if (lcd_prbs_mode == LCD_PRBS_MODE_LVDS) {
-			lcd_prbs_performed |= LCD_PRBS_MODE_LVDS;
-			lcd_prbs_err &= ~(LCD_PRBS_MODE_LVDS);
-			LCDPR("lvds prbs check ok\n");
-		} else if (lcd_prbs_mode == LCD_PRBS_MODE_VX1) {
-			lcd_prbs_performed |= LCD_PRBS_MODE_VX1;
-			lcd_prbs_err &= ~(LCD_PRBS_MODE_VX1);
-			LCDPR("vx1 prbs check ok\n");
-		} else {
-			LCDPR("prbs check: unsupport mode\n");
+		if (ret) {
+			LCDERR("lcd prbs check error 1, val:0x%03x, cnt:%d\n",
+			       val2, lcd_prbs_cnt);
+			return;
 		}
-		continue;
-
-lcd_prbs_test_err:
-		if (lcd_prbs_mode == LCD_PRBS_MODE_LVDS) {
-			lcd_prbs_performed |= LCD_PRBS_MODE_LVDS;
-			lcd_prbs_err |= LCD_PRBS_MODE_LVDS;
-		} else if (lcd_prbs_mode == LCD_PRBS_MODE_VX1) {
-			lcd_prbs_performed |= LCD_PRBS_MODE_VX1;
-			lcd_prbs_err |= LCD_PRBS_MODE_VX1;
+		val1 = val2;
+		if (lcd_hiu_getb(reg1, 0, 12)) {
+			LCDERR("lcd prbs check error 2, cnt:%d\n",
+			       lcd_prbs_cnt);
+			return;
 		}
+		if (lcd_prbs_cnt >= 0xffffffff)
+			lcd_prbs_cnt = 0;
+		else
+			lcd_prbs_cnt++;
 	}
 
-lcd_prbs_test_end:
-	lcd_prbs_flag = 0;
+	lcd_prbs_cnt = 0;
+	LCDPR("lcd prbs check ok\n");
 }
 
 static ssize_t lcd_debug_prbs_show(struct class *class,
 				   struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf,
-		       "lvds prbs performed: %d, error: %d\n"
-		       "vx1 prbs performed: %d, error: %d\n"
-		       "lcd prbs flag: %d\n",
-		       (lcd_prbs_performed & LCD_PRBS_MODE_LVDS) ? 1 : 0,
-		       (lcd_prbs_err & LCD_PRBS_MODE_LVDS) ? 1 : 0,
-		       (lcd_prbs_performed & LCD_PRBS_MODE_VX1) ? 1 : 0,
-		       (lcd_prbs_err & LCD_PRBS_MODE_VX1) ? 1 : 0,
-		       lcd_prbs_flag);
+	return sprintf(buf, "lcd prbs flag: %d, cnt: %d\n",
+		       lcd_prbs_flag, lcd_prbs_cnt);
 }
 
 static ssize_t lcd_debug_prbs_store(struct class *class,
@@ -1736,44 +1614,21 @@ static ssize_t lcd_debug_prbs_store(struct class *class,
 				    const char *buf, size_t count)
 {
 	int ret = 0;
-	unsigned int temp;
-	unsigned int prbs_mode_flag;
+	unsigned int temp = 1;
 
-	switch (buf[0]) {
-	case 'v': /* vx1 */
-		ret = sscanf(buf, "vx1 %d", &temp);
-		if (ret) {
-			prbs_mode_flag = LCD_PRBS_MODE_VX1;
-		} else {
-			LCDERR("invalid data\n");
-			return -EINVAL;
-		}
-		break;
-	case 'l': /* lvds */
-		ret = sscanf(buf, "lvds %d", &temp);
-		if (ret) {
-			prbs_mode_flag = LCD_PRBS_MODE_LVDS;
-		} else {
-			LCDERR("invalid data\n");
-			return -EINVAL;
-		}
-		break;
-	default:
-		prbs_mode_flag = LCD_PRBS_MODE_LVDS | LCD_PRBS_MODE_VX1;
-		ret = kstrtouint(buf, 10, &temp);
-		if (ret) {
-			LCDERR("invalid data\n");
-			return -EINVAL;
-		}
-		break;
-	}
-	if (temp) {
-		if (lcd_prbs_flag) {
-			LCDPR("lcd prbs check is already running\n");
-			return count;
+	ret = kstrtouint(buf, 10, &temp);
+	if (ret) {
+		LCDERR("invalid data\n");
+		return -EINVAL;
+	}
+	if (temp) {
+		if (lcd_prbs_flag) {
+			LCDPR("lcd prbs check is already running\n");
+			return count;
 		}
+		lcd_prbs_cnt = 0;
 		lcd_prbs_flag = 1;
-		aml_lcd_prbs_test(temp, prbs_mode_flag);
+		aml_lcd_prbs_test(temp);
 	} else {
 		if (lcd_prbs_flag == 0) {
 			LCDPR("lcd prbs check is already stopped\n");
@@ -1883,12 +1738,11 @@ static void lcd_power_interface_ctrl(int state)
 static ssize_t lcd_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	int i, ret = 0;
+	int ret = 0;
 	unsigned int temp, val[6];
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lcd_config_s *pconf;
 	char *print_buf;
-	unsigned long flags = 0;
 
 	pconf = lcd_drv->lcd_config;
 	switch (buf[0]) {
@@ -1948,8 +1802,8 @@ static ssize_t lcd_debug_store(struct class *class,
 		} else if (buf[1] == 'i') { /* bit */
 			ret = sscanf(buf, "bit %d", &val[0]);
 			if (ret == 1) {
-				pconf->lcd_basic.lcd_bits = val[0];
-				pr_info("set lcd_bits=%d\n", val[0]);
+				pconf->lcd_basic.lcd_bits = val[4];
+				pr_info("set lcd_bits=%d\n", val[4]);
 				lcd_debug_config_update();
 			} else {
 				LCDERR("invalid data\n");
@@ -1981,16 +1835,8 @@ static ssize_t lcd_debug_store(struct class *class,
 	case 't': /* test */
 		ret = sscanf(buf, "test %d", &temp);
 		if (ret == 1) {
-			spin_lock_irqsave(&lcd_drv->isr_lock, flags);
-			lcd_drv->lcd_test_flag = (unsigned char)temp;
-			spin_unlock_irqrestore(&lcd_drv->isr_lock, flags);
-			LCDPR("%s: test %d\n", __func__, temp);
-			i = 0;
-			while (i++ < 5000) {
-				if (lcd_drv->lcd_test_state == temp)
-					break;
-				usleep_range(20, 30);
-			}
+			lcd_drv->lcd_test_flag =
+				(unsigned char)(temp | LCD_TEST_UPDATE);
 		} else {
 			LCDERR("invalid data\n");
 			return -EINVAL;
@@ -2462,11 +2308,7 @@ static ssize_t lcd_debug_enable_store(struct class *class,
 	}
 	if (temp) {
 		mutex_lock(&lcd_drv->power_mutex);
-		if (lcd_drv->boot_ctrl->lcd_init_level ==
-		    LCD_INIT_LEVEL_KERNEL_OFF)
-			aml_lcd_notifier_call_chain(LCD_EVENT_PREPARE, NULL);
-		else
-			aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
 		lcd_if_enable_retry(lcd_drv->lcd_config);
 		mutex_unlock(&lcd_drv->power_mutex);
 	} else {
@@ -2840,16 +2682,6 @@ static ssize_t lcd_debug_clk_store(struct class *class,
 			return -EINVAL;
 		}
 		break;
-	case 's':
-		ret = sscanf(buf, "set_ppm %d", &temp);
-		if (ret == 1) {
-			lcd_clk_finetune(lcd_drv->lcd_config, temp);
-			pr_info("set clk_drift %d ppm\n", temp);
-		} else {
-			pr_info("invalid data\n");
-			return -EINVAL;
-		}
-		break;
 	default:
 		pr_info("wrong command\n");
 		break;
@@ -2872,35 +2704,19 @@ static ssize_t lcd_debug_test_store(struct class *class,
 	int ret = 0;
 	unsigned int temp = 0, i = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned long flags = 0;
-
-	if (buf[0] == 'f') { /* force test pattern */
-		ret = sscanf(buf, "force %d", &temp);
-		if (ret == 0)
-			goto lcd_debug_test_store_next;
-		temp = (temp >= LCD_ENC_TST_NUM_MAX) ? 0 : temp;
-		lcd_drv->lcd_test_flag = (unsigned char)temp;
-		lcd_drv->lcd_test_state = (unsigned char)temp;
-		lcd_debug_test(lcd_drv->lcd_test_state);
-		return count;
-	}
 
-lcd_debug_test_store_next:
 	ret = kstrtouint(buf, 10, &temp);
 	if (ret) {
 		pr_info("invalid data\n");
 		return -EINVAL;
 	}
-	spin_lock_irqsave(&lcd_drv->isr_lock, flags);
 	temp = (temp >= LCD_ENC_TST_NUM_MAX) ? 0 : temp;
-	lcd_drv->lcd_test_flag = (unsigned char)temp;
-	spin_unlock_irqrestore(&lcd_drv->isr_lock, flags);
+	lcd_drv->lcd_test_flag = (unsigned char)(temp | LCD_TEST_UPDATE);
 
-	LCDPR("%s: %d\n", __func__, temp);
 	while (i++ < 5000) {
 		if (lcd_drv->lcd_test_state == temp)
 			break;
-		usleep_range(20, 30);
+		udelay(20);
 	}
 
 	return count;
@@ -2921,24 +2737,22 @@ static ssize_t lcd_debug_mute_store(struct class *class,
 	int ret = 0;
 	unsigned int temp = 0, i = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned long flags = 0;
 
 	ret = kstrtouint(buf, 10, &temp);
 	if (ret) {
 		pr_info("invalid data\n");
 		return -EINVAL;
 	}
-
-	spin_lock_irqsave(&lcd_drv->isr_lock, flags);
 	temp = temp ? 1 : 0;
-	lcd_drv->lcd_mute_flag = (unsigned char)temp;
-	spin_unlock_irqrestore(&lcd_drv->isr_lock, flags);
-
-	LCDPR("%s: %d\n", __func__, temp);
+	lcd_drv->lcd_mute_flag = (unsigned char)(temp | LCD_MUTE_UPDATE);
+	if (temp)
+		LCDPR("set mute\n");
+	else
+		LCDPR("clear mute\n");
 	while (i++ < 5000) {
 		if (lcd_drv->lcd_mute_state == temp)
 			break;
-		usleep_range(20, 30);
+		udelay(20);
 	}
 
 	return count;
@@ -2953,16 +2767,16 @@ static void lcd_debug_reg_write(unsigned int reg, unsigned int data,
 		pr_info("write vcbus [0x%04x] = 0x%08x, readback 0x%08x\n",
 			reg, data, lcd_vcbus_read(reg));
 		break;
-	case 1: /* ana */
-		lcd_ana_write(reg, data);
-		pr_info("write ana [0x%04x] = 0x%08x, readback 0x%08x\n",
-			reg, data, lcd_ana_read(reg));
-		break;
-	case 2: /* clk */
+	case 1: /* hiu */
 		lcd_hiu_write(reg, data);
-		pr_info("write clk [0x%04x] = 0x%08x, readback 0x%08x\n",
+		pr_info("write hiu [0x%04x] = 0x%08x, readback 0x%08x\n",
 			reg, data, lcd_hiu_read(reg));
 		break;
+	case 2: /* cbus */
+		lcd_cbus_write(reg, data);
+		pr_info("write cbus [0x%04x] = 0x%08x, readback 0x%08x\n",
+			reg, data, lcd_cbus_read(reg));
+		break;
 	case 3: /* periphs */
 		lcd_periphs_write(reg, data);
 		pr_info("write periphs [0x%04x] = 0x%08x, readback 0x%08x\n",
@@ -3000,14 +2814,14 @@ static void lcd_debug_reg_read(unsigned int reg, unsigned int bus)
 		pr_info("read vcbus [0x%04x] = 0x%08x\n",
 			reg, lcd_vcbus_read(reg));
 		break;
-	case 1: /* ana */
-		pr_info("read ana [0x%04x] = 0x%08x\n",
-			reg, lcd_ana_read(reg));
-		break;
-	case 2: /* clk */
-		pr_info("read clk [0x%04x] = 0x%08x\n",
+	case 1: /* hiu */
+		pr_info("read hiu [0x%04x] = 0x%08x\n",
 			reg, lcd_hiu_read(reg));
 		break;
+	case 2: /* cbus */
+		pr_info("read cbus [0x%04x] = 0x%08x\n",
+			reg, lcd_cbus_read(reg));
+		break;
 	case 3: /* periphs */
 		pr_info("read periphs [0x%04x] = 0x%08x\n",
 			reg, lcd_periphs_read(reg));
@@ -3020,7 +2834,7 @@ static void lcd_debug_reg_read(unsigned int reg, unsigned int bus)
 		pr_info("read mipi_dsi_phy [0x%04x] = 0x%08x\n",
 			reg, dsi_phy_read(reg));
 		break;
-	case 6: /* tcon */
+	case 6:
 		if (reg < TCON_TOP_BASE) {
 			pr_info("read tcon [0x%04x] = 0x%02x\n",
 				reg, lcd_tcon_reg_read(reg));
@@ -3047,18 +2861,18 @@ static void lcd_debug_reg_dump(unsigned int reg, unsigned int num,
 				(reg + i), lcd_vcbus_read(reg + i));
 		}
 		break;
-	case 1: /* ana */
-		pr_info("dump ana regs:\n");
+	case 1: /* hiu */
+		pr_info("dump hiu-bus regs:\n");
 		for (i = 0; i < num; i++) {
 			pr_info("[0x%04x] = 0x%08x\n",
-				(reg + i), lcd_ana_read(reg + i));
+				(reg + i), lcd_hiu_read(reg + i));
 		}
 		break;
-	case 2: /* clk */
-		pr_info("dump clk regs:\n");
+	case 2: /* cbus */
+		pr_info("dump cbus regs:\n");
 		for (i = 0; i < num; i++) {
 			pr_info("[0x%04x] = 0x%08x\n",
-				(reg + i), lcd_hiu_read(reg + i));
+				(reg + i), lcd_cbus_read(reg + i));
 		}
 		break;
 	case 3: /* periphs */
@@ -3082,7 +2896,7 @@ static void lcd_debug_reg_dump(unsigned int reg, unsigned int num,
 				(reg + i), dsi_phy_read(reg + i));
 		}
 		break;
-	case 6: /* tcon */
+	case 6:
 		pr_info("dump tcon regs:\n");
 		if (reg < TCON_TOP_BASE) {
 			for (i = 0; i < num; i++) {
@@ -3115,9 +2929,6 @@ static ssize_t lcd_debug_reg_store(struct class *class,
 			bus = 0;
 		} else if (buf[1] == 'h') {
 			ret = sscanf(buf, "wh %x %x", &reg32, &data32);
-			bus = 2;
-		} else if (buf[1] == 'a') {
-			ret = sscanf(buf, "wa %x %x", &reg32, &data32);
 			bus = 1;
 		} else if (buf[1] == 'c') {
 			ret = sscanf(buf, "wc %x %x", &reg32, &data32);
@@ -3150,9 +2961,6 @@ static ssize_t lcd_debug_reg_store(struct class *class,
 			bus = 0;
 		} else if (buf[1] == 'h') {
 			ret = sscanf(buf, "rh %x", &reg32);
-			bus = 2;
-		} else if (buf[1] == 'a') {
-			ret = sscanf(buf, "ra %x", &reg32);
 			bus = 1;
 		} else if (buf[1] == 'c') {
 			ret = sscanf(buf, "rc %x", &reg32);
@@ -3185,9 +2993,6 @@ static ssize_t lcd_debug_reg_store(struct class *class,
 			bus = 0;
 		} else if (buf[1] == 'h') {
 			ret = sscanf(buf, "dh %x %d", &reg32, &data32);
-			bus = 2;
-		} else if (buf[1] == 'a') {
-			ret = sscanf(buf, "da %x %d", &reg32, &data32);
 			bus = 1;
 		} else if (buf[1] == 'c') {
 			ret = sscanf(buf, "dc %x %d", &reg32, &data32);
@@ -3441,79 +3246,6 @@ static ssize_t lcd_debug_print_store(struct class *class,
 	return count;
 }
 
-static ssize_t lcd_init_level_show(struct class *class,
-				   struct class_attribute *attr, char *buf)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
-	return sprintf(buf, "get lcd_init_level: %d\n",
-		       lcd_drv->boot_ctrl->lcd_init_level);
-}
-
-static ssize_t lcd_init_level_store(struct class *class,
-		struct class_attribute *attr, const char *buf, size_t count)
-{
-	int ret = 0;
-	unsigned int temp = 0;
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
-	ret = kstrtouint(buf, 10, &temp);
-	if (ret) {
-		pr_info("invalid data\n");
-		return -EINVAL;
-	}
-	lcd_drv->boot_ctrl->lcd_init_level = (unsigned char)temp;
-	LCDPR("set lcd_init_level: %d\n",
-	      lcd_drv->boot_ctrl->lcd_init_level);
-
-	return count;
-}
-
-static ssize_t lcd_debug_vinfo_show(struct class *class,
-				    struct class_attribute *attr, char *buf)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct vinfo_s *info;
-	ssize_t len = 0;
-
-	if (!lcd_drv->lcd_info) {
-		len = sprintf(buf, "error: no lcd_info exist\n");
-		return len;
-	}
-	info = lcd_drv->lcd_info;
-
-	len = sprintf(buf, "lcd vinfo:\n"
-		      "    lcd_mode:              %s\n"
-		      "    name:                  %s\n"
-		      "    mode:                  %d\n"
-		      "    frac:                  %d\n"
-		      "    width:                 %d\n"
-		      "    height:                %d\n"
-		      "    field_height:          %d\n"
-		      "    aspect_ratio_num:      %d\n"
-		      "    aspect_ratio_den:      %d\n"
-		      "    sync_duration_num:     %d\n"
-		      "    sync_duration_den:     %d\n"
-		      "    screen_real_width:     %d\n"
-		      "    screen_real_height:    %d\n"
-		      "    htotal:                %d\n"
-		      "    vtotal:                %d\n"
-		      "    fr_adj_type:           %d\n"
-		      "    video_clk:             %d\n"
-		      "    viu_color_fmt:         %d\n"
-		      "    viu_mux:               %d\n\n",
-		      lcd_mode_mode_to_str(lcd_drv->lcd_mode),
-		      info->name, info->mode, info->frac,
-		      info->width, info->height, info->field_height,
-		      info->aspect_ratio_num, info->aspect_ratio_den,
-		      info->sync_duration_num, info->sync_duration_den,
-		      info->screen_real_width, info->screen_real_height,
-		      info->htotal, info->vtotal, info->fr_adj_type,
-		      info->video_clk, info->viu_color_fmt, info->viu_mux);
-
-	return len;
-}
-
 static struct class_attribute lcd_debug_class_attrs[] = {
 	__ATTR(help,        0444, lcd_debug_common_help, NULL),
 	__ATTR(debug,       0644, lcd_debug_show, lcd_debug_store),
@@ -3543,8 +3275,6 @@ static struct class_attribute lcd_debug_class_attrs[] = {
 	__ATTR(dump,        0644,
 		lcd_debug_dump_show, lcd_debug_dump_store),
 	__ATTR(print,       0644, lcd_debug_print_show, lcd_debug_print_store),
-	__ATTR(init_level, 0644, lcd_init_level_show, lcd_init_level_store),
-	__ATTR(vinfo,       0644, lcd_debug_vinfo_show, NULL),
 };
 
 static const char *lcd_ttl_debug_usage_str = {
@@ -3663,12 +3393,7 @@ static const char *lcd_p2p_debug_usage_str = {
 static const char *lcd_debug_tcon_usage_str = {
 	"Usage:\n"
 	"    echo reg > tcon ; print tcon system regs\n"
-	"    echo reg rb <reg> > tcon ; read tcon byte reg\n"
-	"    echo reg wb <reg> <val> > tcon ; write tcon byte reg\n"
-	"    echo reg db <reg> <cnt> > tcon ; dump tcon byte regs\n"
-	"    echo reg r <reg> > tcon ; write tcon reg\n"
-	"    echo reg w <reg> <val> > tcon ; write tcon reg\n"
-	"    echo reg d <reg> <cnt> > tcon ; dump tcon regs\n"
+	"    echo reg save <path> > tcon ; save tcon system regs to bin file\n"
 	"\n"
 	"    echo table > tcon ; print tcon reg table\n"
 	"    echo table r <index> > tcon ; read tcon reg table by specified index\n"
@@ -3680,20 +3405,11 @@ static const char *lcd_debug_tcon_usage_str = {
 	"    <len>      : dec number\n"
 	"\n"
 	"    echo table update > tcon ; update tcon reg table into tcon system regs\n"
+	"    echo table save <path> > tcon ; save tcon reg table to bin file\n"
 	"\n"
 	"    echo od <en> > tcon ; tcon over driver control\n"
 	"data format:\n"
 	"    <en>       : 0=disable, 1=enable\n"
-	"\n"
-	"    echo save <str> <path> > tcon ; tcon mem save to file\n"
-	"data format:\n"
-	"    <str>       : table, reg, vac, demura, acc\n"
-	"    <path>      : save file path\n"
-	"\n"
-	"    echo gamma <bit_width> <gamma_r> <gamma_g> <gamma_b> > tcon ; tcon gamma pattern\n"
-	"data format:\n"
-	"    <bit_width>    : 12, 10, 8\n"
-	"    <gamma_r/g/b>  : gamma value in hex\n"
 };
 
 static ssize_t lcd_ttl_debug_show(struct class *class,
@@ -3837,97 +3553,6 @@ static ssize_t lcd_tcon_status_show(struct class *class,
 	return sprintf(buf, "%d\n", lcd_drv->tcon_status);
 }
 
-static ssize_t lcd_tcon_adb_status_show(struct class *class,
-					struct class_attribute *attr,
-					char *buf)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	int len = 0;
-	unsigned int i, addr;
-
-	mutex_lock(&lcd_tcon_adb_mutex);
-
-	len += sprintf(buf + len, "for_tool:");
-	if ((lcd_drv->lcd_status & LCD_STATUS_IF_ON) == 0) {
-		len += sprintf(buf + len, "ERROR\n");
-		mutex_unlock(&lcd_tcon_adb_mutex);
-		return len;
-	}
-	switch (adb_reg.rw_mode) {
-	case LCD_ADB_TCON_REG_RW_MODE_NULL:
-		len += sprintf(buf + len, "NULL");
-		break;
-	case LCD_ADB_TCON_REG_RW_MODE_RN:
-		if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-			for (i = 0; i < adb_reg.len; i++) {
-				addr = adb_reg.addr + i;
-				len += sprintf(buf + len, "%04x=%08x ",
-					       addr, lcd_tcon_read(addr));
-			}
-		} else {
-			for (i = 0; i < adb_reg.len; i++) {
-				addr = adb_reg.addr + i;
-				len += sprintf(buf + len, "%04x=%02x ",
-					       addr, lcd_tcon_read_byte(addr));
-			}
-		}
-		break;
-	case LCD_ADB_TCON_REG_RW_MODE_WM:
-		if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-			addr = adb_reg.addr;
-			len += sprintf(buf + len, "%04x=%08x ",
-				       addr, lcd_tcon_read(addr));
-		} else {
-			addr = adb_reg.addr;
-			len += sprintf(buf + len, "%04x=%02x ",
-				       addr, lcd_tcon_read_byte(addr));
-		}
-		break;
-	case LCD_ADB_TCON_REG_RW_MODE_WN:
-		if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-			for (i = 0; i < adb_reg.len; i++) {
-				addr = adb_reg.addr + i;
-				len += sprintf(buf + len, "%04x=%08x ",
-					       addr, lcd_tcon_read(addr));
-			}
-		} else {
-			for (i = 0; i < adb_reg.len; i++) {
-				addr = adb_reg.addr + i;
-				len += sprintf(buf + len, "%04x=%02x ",
-					       addr, lcd_tcon_read_byte(addr));
-			}
-		}
-		break;
-	case LCD_ADB_TCON_REG_RW_MODE_WS:
-		if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-			addr = adb_reg.addr;
-			for (i = 0; i < adb_reg.len; i++) {
-				len += sprintf(buf + len, "%04x=%08x ",
-					       addr, lcd_tcon_read(addr));
-			}
-		} else {
-			addr = adb_reg.addr;
-			for (i = 0; i < adb_reg.len; i++) {
-				len += sprintf(buf + len, "%04x=%02x ",
-					       addr, lcd_tcon_read_byte(addr));
-			}
-		}
-		break;
-	case LCD_ADB_TCON_REG_RW_MODE_ERR:
-		len += sprintf(buf + len, "ERROR");
-		break;
-	default:
-		len += sprintf(buf + len, "ERROR");
-		adb_reg.rw_mode = LCD_ADB_TCON_REG_RW_MODE_NULL;
-		adb_reg.addr = 0;
-		adb_reg.len = 0;
-		break;
-	}
-	len += sprintf(buf + len, "\n");
-	mutex_unlock(&lcd_tcon_adb_mutex);
-	return len;
-}
-
 static ssize_t lcd_ttl_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
@@ -3995,19 +3620,6 @@ static ssize_t lcd_vx1_debug_store(struct class *class,
 #ifdef CONFIG_AMLOGIC_LCD_TV
 	int val[5];
 #endif
-	unsigned int reg_cntl0;
-
-	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TL1:
-	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
-		break;
-	default:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0;
-		break;
-	}
-
 
 	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
 	if (buf[0] == 'i') { /* intr */
@@ -4049,48 +3661,33 @@ static ssize_t lcd_vx1_debug_store(struct class *class,
 #endif
 	} else if (buf[0] == 'c') { /* ctrl */
 #ifdef CONFIG_AMLOGIC_LCD_TV
-		if (buf[1] == 't') { /* ctrl */
-			ret = sscanf(buf, "ctrl %x %d %d %d",
-				     &val[0], &val[1], &val[2], &val[3]);
-			if (ret == 4) {
-				pr_info("set vbyone ctrl_flag: 0x%x\n", val[0]);
-				pr_info("power_on_reset_delay: %dms\n", val[1]);
-				pr_info("hpd_data_delay: %dms\n", val[2]);
-				pr_info("cdr_training_hold: %dms\n", val[3]);
-				vx1_conf->ctrl_flag = val[0];
-				vx1_conf->power_on_reset_delay = val[1];
-				vx1_conf->hpd_data_delay = val[2];
-				vx1_conf->cdr_training_hold = val[3];
-				lcd_debug_config_update();
-			} else {
-				pr_info("vbyone ctrl_flag: 0x%x\n",
-					vx1_conf->ctrl_flag);
-				pr_info("power_on_reset_delay: %dms\n",
-					vx1_conf->power_on_reset_delay);
-				pr_info("hpd_data_delay: %dms\n",
-					vx1_conf->hpd_data_delay);
-				pr_info("cdr_training_hold: %dms\n",
-					vx1_conf->cdr_training_hold);
-				return -EINVAL;
-			}
-		} else if (buf[1] == 'd') { /* cdr */
-			/* disable vx1 interrupt and vx1 vsync interrupt */
-			vx1_conf->intr_en = 0;
-			vx1_conf->vsync_intr_en = 0;
-			lcd_vbyone_interrupt_enable(0);
-
-			/*[5:0]: vx1 fsm status*/
-			lcd_vcbus_setb(VBO_INSGN_CTRL, 7, 0, 4);
-			msleep(100);
-			LCDPR("vx1 fsm status: 0x%08x",
-			      lcd_vcbus_read(VBO_STATUS_L));
-
+		ret = sscanf(buf, "ctrl %x %d %d %d",
+			&val[0], &val[1], &val[2], &val[3]);
+		if (ret == 4) {
+			pr_info("set vbyone ctrl_flag: 0x%x\n", val[0]);
+			pr_info("power_on_reset_delay: %dms\n", val[1]);
+			pr_info("hpd_data_delay: %dms\n", val[2]);
+			pr_info("cdr_training_hold: %dms\n", val[3]);
+			vx1_conf->ctrl_flag = val[0];
+			vx1_conf->power_on_reset_delay = val[1];
+			vx1_conf->hpd_data_delay = val[2];
+			vx1_conf->cdr_training_hold = val[3];
+			lcd_debug_config_update();
+		} else {
+			pr_info("vbyone ctrl_flag: 0x%x\n",
+				vx1_conf->ctrl_flag);
+			pr_info("power_on_reset_delay: %dms\n",
+				vx1_conf->power_on_reset_delay);
+			pr_info("hpd_data_delay: %dms\n",
+				vx1_conf->hpd_data_delay);
+			pr_info("cdr_training_hold: %dms\n",
+				vx1_conf->cdr_training_hold);
+			return -EINVAL;
 		}
 #else
 		return -EINVAL;
 #endif
 	} else if (buf[0] == 'f') { /* filter */
-#ifdef CONFIG_AMLOGIC_LCD_TV
 		ret = sscanf(buf, "filter %x %x", &val[0], &val[1]);
 		if (ret == 2) {
 			pr_info("set vbyone hw_filter_time: 0x%x, hw_filter_cnt: 0x%x\n",
@@ -4104,36 +3701,6 @@ static ssize_t lcd_vx1_debug_store(struct class *class,
 				vx1_conf->hw_filter_cnt);
 			return -EINVAL;
 		}
-#else
-		return -EINVAL;
-#endif
-	} else if (buf[0] == 'r') { /* rst */
-#ifdef CONFIG_AMLOGIC_LCD_TV
-		/* disable vx1 interrupt and vx1 vsync interrupt */
-		val[0] = vx1_conf->intr_en;
-		val[1] = vx1_conf->vsync_intr_en;
-		vx1_conf->intr_en = 0;
-		vx1_conf->vsync_intr_en = 0;
-		lcd_vbyone_interrupt_enable(0);
-#endif
-		/* force PHY to 0 */
-		lcd_ana_setb(reg_cntl0, 3, 8, 2);
-		lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
-		udelay(5);
-		/* realease PHY */
-		if (lcd_vcbus_read(VBO_INSGN_CTRL) & 0x1) {
-			pr_info("clr force lockn input\n");
-			lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 0, 1);
-		}
-		lcd_ana_setb(reg_cntl0, 0, 8, 2);
-		lcd_vcbus_write(VBO_SOFT_RST, 0);
-#ifdef CONFIG_AMLOGIC_LCD_TV
-		/* recover vx1 interrupt and vx1 vsync interrupt */
-		vx1_conf->intr_en = val[0];
-		vx1_conf->vsync_intr_en = val[1];
-		lcd_vbyone_interrupt_enable(vx1_intr_state);
-#endif
-		pr_info("vybone reset\n");
 	} else {
 		ret = sscanf(buf, "%d %d %d", &vx1_conf->lane_count,
 			&vx1_conf->region_num, &vx1_conf->byte_mode);
@@ -4427,7 +3994,7 @@ static ssize_t lcd_vx1_status_show(struct class *class,
 		       ((lcd_vcbus_read(VBO_STATUS_L) >> 6) & 0x1));
 }
 
-static int lcd_tcon_buf_save(char *path, unsigned char *save_buf,
+static void lcd_tcon_reg_table_save(char *path, unsigned char *reg_table,
 		unsigned int size)
 {
 	struct file *filp = NULL;
@@ -4435,42 +4002,23 @@ static int lcd_tcon_buf_save(char *path, unsigned char *save_buf,
 	void *buf = NULL;
 	mm_segment_t old_fs = get_fs();
 
-	if (!save_buf) {
-		LCDERR("%s: save_buf is null\n", __func__);
-		return -1;
-	}
-	if (size == 0) {
-		LCDERR("%s: size is zero\n", __func__);
-		return -1;
-	}
-
 	set_fs(KERNEL_DS);
 	filp = filp_open(path, O_RDWR|O_CREAT, 0666);
 
 	if (IS_ERR(filp)) {
 		LCDERR("%s: create %s error\n", __func__, path);
 		set_fs(old_fs);
-		return -1;
+		return;
 	}
 
 	pos = 0;
-	buf = (void *)save_buf;
+	buf = (void *)reg_table;
 	vfs_write(filp, buf, size, &pos);
 
 	vfs_fsync(filp, 0);
 	filp_close(filp, NULL);
 	set_fs(old_fs);
 
-	return 0;
-}
-
-static void lcd_tcon_reg_table_save(char *path, unsigned char *reg_table,
-		unsigned int size)
-{
-	int ret;
-
-	ret = lcd_tcon_buf_save(path, reg_table, size);
-
 	LCDPR("save tcon reg table to %s finished\n", path);
 }
 
@@ -4520,403 +4068,34 @@ static void lcd_tcon_reg_save(char *path, unsigned int size)
 	LCDPR("save tcon reg to %s success\n", path);
 }
 
-static void lcd_tcon_axi_rmem_save(unsigned int index, char *path)
-{
-	unsigned int mem_size;
-	struct file *filp = NULL;
-	loff_t pos = 0;
-	mm_segment_t old_fs = get_fs();
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-	unsigned int span = 0, remain = 0, count = 0;
-	unsigned long paddr, phys;
-	void *vaddr = NULL;
-	unsigned int highmem_flag = 0;
-	int i;
-
-	if ((!tcon_rmem) || (!tcon_rmem->axi_rmem)) {
-		pr_info("axi_rmem is NULL\n");
-		return;
-	}
-	if (!tcon_conf)
-		return;
-	if (index > tcon_conf->axi_bank) {
-		pr_info("axi_rmem index %d invalid\n", index);
-		return;
-	}
-
-	mem_size = tcon_rmem->axi_rmem[index].mem_size;
-	pos = 0;
-
-	set_fs(KERNEL_DS);
-	filp = filp_open(path, O_RDWR | O_CREAT, 0666);
-	if (IS_ERR(filp)) {
-		pr_info("%s: create %s error\n", __func__, path);
-		set_fs(old_fs);
-		return;
-	}
-
-	paddr = tcon_rmem->axi_rmem[index].mem_paddr;
-	highmem_flag = PageHighMem(phys_to_page(paddr));
-	if (highmem_flag == 0) {
-		vaddr = phys_to_virt(paddr);
-		if (!vaddr)
-			goto lcd_tcon_axi_rmem_save_end;
-		vfs_write(filp, vaddr, mem_size, &pos);
-	} else {
-		span = SZ_1M;
-		count = mem_size / PAGE_ALIGN(span);
-		remain = mem_size % PAGE_ALIGN(span);
-
-		for (i = 0; i < count; i++) {
-			phys = paddr + i * span;
-			vaddr = lcd_vmap(phys, span);
-			if (!vaddr)
-				goto lcd_tcon_axi_rmem_save_end;
-			vfs_write(filp, vaddr, span, &pos);
-			lcd_unmap_phyaddr(vaddr);
-		}
-		if (remain) {
-			phys = paddr + count * span;
-			vaddr = lcd_vmap(phys, remain);
-			if (!vaddr)
-				goto lcd_tcon_axi_rmem_save_end;
-			vfs_write(filp, vaddr, remain, &pos);
-			lcd_unmap_phyaddr(vaddr);
-		}
-	}
-
-	vfs_fsync(filp, 0);
-	filp_close(filp, NULL);
-	set_fs(old_fs);
-	pr_info("save tcon vac to %s finished\n", path);
-	return;
-
-lcd_tcon_axi_rmem_save_end:
-	vfs_fsync(filp, 0);
-	filp_close(filp, NULL);
-	set_fs(old_fs);
-	pr_info("tcon axi_rmem[%d] mapping failed: 0x%lx\n", index, paddr);
-}
-
-static void lcd_tcon_rmem_save(char *path, unsigned int flag)
-{
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-	struct tcon_rmem_s *rmem = get_lcd_tcon_rmem();
-	struct tcon_mem_map_table_s *table = get_lcd_tcon_mm_table();
-	struct lcd_tcon_data_block_header_s *block_header;
-	char *str = NULL;
-	int ret, i;
-
-	if (!tcon_conf) {
-		LCDPR("%s: tcon_conf is null\n", __func__);
-		return;
-	}
-	if (!rmem) {
-		LCDPR("%s: tcon_rmem is null\n", __func__);
-		return;
-	}
-	if (!table) {
-		LCDPR("%s: tcon_mm_table is null\n", __func__);
-		return;
-	}
-
-	str = kcalloc(512, sizeof(char), GFP_KERNEL);
-	if (!str)
-		return;
-
-	switch (flag) {
-	case 0: /* bin path */
-		if (rmem->bin_path_rmem.mem_vaddr) {
-			sprintf(str, "%s.bin", path);
-			ret = lcd_tcon_buf_save(str,
-						rmem->bin_path_rmem.mem_vaddr,
-						rmem->bin_path_rmem.mem_size);
-			if (ret == 0) {
-				LCDPR("save tcon bin_path to %s finished\n",
-				      str);
-			}
-		} else {
-			pr_info("bin_path invalid\n");
-		}
-		break;
-	case 1: /* vac */
-		if (table->valid_flag & LCD_TCON_DATA_VALID_VAC) {
-			sprintf(str, "%s.bin", path);
-			ret = lcd_tcon_buf_save(str,
-						rmem->vac_rmem.mem_vaddr,
-						rmem->vac_rmem.mem_size);
-			if (ret == 0)
-				LCDPR("save tcon vac to %s finished\n", str);
-		} else {
-			pr_info("vac invalid\n");
-		}
-		break;
-	case 2: /* demura */
-		if (table->valid_flag & LCD_TCON_DATA_VALID_DEMURA) {
-			sprintf(str, "%s_set.bin", path);
-			ret = lcd_tcon_buf_save(str,
-						rmem->demura_set_rmem.mem_vaddr,
-						rmem->demura_set_rmem.mem_size);
-			if (ret == 0) {
-				LCDPR("save tcon demura_set to %s finished\n",
-				      str);
-			}
-			sprintf(str, "%s_lut.bin", path);
-			ret = lcd_tcon_buf_save(str,
-						rmem->demura_lut_rmem.mem_vaddr,
-						rmem->demura_lut_rmem.mem_size);
-			if (ret == 0) {
-				LCDPR("save tcon demura_lut to %s finished\n",
-				      str);
-			}
-		} else {
-			pr_info("demura invalid\n");
-		}
-		break;
-	case 3: /* acc */
-		if (table->valid_flag & LCD_TCON_DATA_VALID_ACC) {
-			sprintf(str, "%s.bin", path);
-			ret = lcd_tcon_buf_save(str,
-						rmem->acc_lut_rmem.mem_vaddr,
-						rmem->acc_lut_rmem.mem_size);
-			if (ret == 0) {
-				LCDPR("save tcon acc_lut to %s finished\n",
-				      str);
-			}
-		} else {
-			pr_info("acc invalid\n");
-		}
-		break;
-	case 4: /* tcon_data*/
-		if (table->version) {
-			pr_info("data_mem_block_cnt:   %d\n",
-				table->block_cnt);
-
-			for (i = 0; i < table->block_cnt; i++) {
-				sprintf(str, "%s_%d.bin", path, i);
-				if (!table->data_mem_vaddr[i]) {
-					LCDERR("%s: data_mem_vaddr[%d] is null",
-					       __func__, i);
-					continue;
-				}
-
-				block_header =
-					(struct lcd_tcon_data_block_header_s *)
-					table->data_mem_vaddr[i];
-				ret = lcd_tcon_buf_save
-					(str, table->data_mem_vaddr[i],
-					 block_header->block_size);
-				if (ret == 0) {
-					LCDPR
-				("save tcon_data to %s finish",
-				 str);
-				}
-			}
-		} else {
-			pr_info("tcon_data invalid\n");
-		}
-		break;
-	default:
-		break;
-	}
-
-	kfree(str);
-}
-
-static void lcd_tcon_reg_table_load(char *path, unsigned char *reg_table,
-				    unsigned int table_size)
-{
-	unsigned int size = 0;
-	struct file *filp = NULL;
-	loff_t pos = 0;
-	mm_segment_t old_fs = get_fs();
-
-	set_fs(KERNEL_DS);
-	filp = filp_open(path, O_RDONLY, 0);
-	if (IS_ERR_OR_NULL(filp)) {
-		pr_info("read %s error or filp is NULL.\n", path);
-		return;
-	}
-
-	size = vfs_read(filp, reg_table, table_size, &pos);
-	if (size < table_size) {
-		pr_info("%s read size %u < %u error.\n",
-			__func__, size, table_size);
-		return;
-	}
-	vfs_fsync(filp, 0);
-
-	filp_close(filp, NULL);
-	set_fs(old_fs);
-
-	pr_info("load bin file path: %s finish\n", path);
-}
-
-static void lcd_tcon_reg_setting_load(char *path)
-{
-	unsigned int size = 0, table_size = 0, len = 0;
-	char *reg_table;
-	struct file *filp = NULL;
-	loff_t pos = 0;
-	mm_segment_t old_fs = get_fs();
-	/*struct kstat stat;*/
-	unsigned int i, n;
-	char *ps, *token;
-	char str[4] = {',', ' ', '\n', '\0'};
-	unsigned int temp[2];
-
-	set_fs(KERNEL_DS);
-
-	/*vfs_stat(path, &stat);
-	 *table_size = stat.size;
-	 */
-
-	filp = filp_open(path, O_RDONLY, 0);
-	if (IS_ERR_OR_NULL(filp)) {
-		pr_info("read %s error or filp is NULL.\n", path);
-		return;
-	}
-	table_size = filp->f_inode->i_size;
-	reg_table = kzalloc((table_size + 2), GFP_KERNEL);
-	if (!reg_table) {
-		filp_close(filp, NULL);
-		set_fs(old_fs);
-		return;
-	}
-
-	size = vfs_read(filp, reg_table, table_size, &pos);
-	if (size < table_size) {
-		pr_info("%s read size %u < %u error.\n",
-			__func__, size, table_size);
-		filp_close(filp, NULL);
-		set_fs(old_fs);
-		kfree(reg_table);
-		return;
-	}
-	vfs_fsync(filp, 0);
-
-	filp_close(filp, NULL);
-	set_fs(old_fs);
-
-	ps = reg_table;
-	len = 0;
-	i = 0;
-	n = 0;
-	while (1) {
-		if (len >= table_size)
-			break;
-		if (!ps)
-			break;
-		token = strsep(&ps, str);
-		if (!token)
-			break;
-		if (*token == '\0') {
-			len++;
-			continue;
-		}
-		if (kstrtouint(token, 16, &temp[i % 2]) < 0) {
-			kfree(reg_table);
-			return;
-		}
-		if ((i % 2) == 1) {
-			if (lcd_debug_print_flag) {
-				pr_info("write tcon reg 0x%04x = 0x%08x\n",
-					temp[0], temp[1]);
-			}
-			lcd_tcon_reg_write(temp[0], temp[1]);
-			n++;
-		}
-		len += (strlen(token) + 1);
-		i++;
-	}
-
-	pr_info("load setting file path: %s finish, total line %d\n",
-		path, n);
-	kfree(reg_table);
-}
-
-static void lcd_tcon_axi_rmem_load(unsigned int index, char *path)
-{
-	unsigned int size = 0, mem_size;
-	struct file *filp = NULL;
-	loff_t pos = 0;
-	mm_segment_t old_fs = get_fs();
-	unsigned char *buf;
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-
-	if ((!tcon_rmem) || (!tcon_rmem->axi_rmem)) {
-		pr_info("axi_rmem is NULL\n");
-		return;
-	}
-	if (!tcon_conf)
-		return;
-	if (index > tcon_conf->axi_bank) {
-		pr_info("axi_rmem index %d invalid\n", index);
-		return;
-	}
-
-	mem_size = tcon_rmem->axi_rmem[index].mem_size;
-	buf = kcalloc(mem_size, sizeof(char), GFP_KERNEL);
-	if (!buf)
-		return;
-
-	set_fs(KERNEL_DS);
-	filp = filp_open(path, O_RDONLY, 0);
-	if (IS_ERR_OR_NULL(filp)) {
-		pr_info("read %s error or filp is NULL.\n", path);
-		kfree(buf);
-		return;
-	}
-
-	size = vfs_read(filp, buf, mem_size, &pos);
-	pr_info("%s read size %u\n", __func__, size);
-	vfs_fsync(filp, 0);
-
-	filp_close(filp, NULL);
-	set_fs(old_fs);
-
-	lcd_tcon_axi_rmem_lut_load(1, buf, size);
-	kfree(buf);
-
-	pr_info("load bin file path: %s finish\n", path);
-}
-
-static int lcd_tcon_reg_table_check(unsigned char *table, unsigned int size)
-{
-	if (size == 0)
-		return -1;
-	if (!table)
-		return -1;
-	return 0;
-}
-
 static ssize_t lcd_tcon_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
 	char *buf_orig;
 	char **parm = NULL;
-	unsigned int temp = 0, val, back_val, i, n, size = 0;
-	unsigned int gamma_r, gamma_g, gamma_b;
-	struct tcon_mem_map_table_s *mm_table = get_lcd_tcon_mm_table();
+	unsigned int temp = 0, val, i, n, size;
 	unsigned char data;
-	unsigned char *table = NULL;
+	unsigned char *table;
 	int ret = -1;
 
-	if (mm_table) {
-		size = mm_table->core_reg_table_size;
-		table = mm_table->core_reg_table;
-	}
+	size = lcd_tcon_reg_table_size_get();
+	if (size <= 0)
+		return count;
+	table = lcd_tcon_reg_table_get();
+	if (table == NULL)
+		return count;
 
 	if (!buf)
 		return count;
 	buf_orig = kstrdup(buf, GFP_KERNEL);
-	if (!buf_orig)
+	if (buf_orig == NULL) {
+		LCDERR("%s: buf malloc error\n", __func__);
 		return count;
+	}
 
 	parm = kcalloc(520, sizeof(char *), GFP_KERNEL);
-	if (!parm) {
+	if (parm == NULL) {
+		LCDERR("%s: parm malloc error\n", __func__);
 		kfree(buf_orig);
 		return count;
 	}
@@ -4924,284 +4103,226 @@ static ssize_t lcd_tcon_debug_store(struct class *class,
 	lcd_debug_parse_param(buf_orig, parm);
 
 	if (strcmp(parm[0], "reg") == 0) {
-		if (!parm[1]) {
+		if (parm[1] == NULL) {
 			lcd_tcon_reg_readback_print();
 			goto lcd_tcon_debug_store_end;
 		}
-		if (strcmp(parm[1], "dump") == 0) {
-			lcd_tcon_reg_readback_print();
-			goto lcd_tcon_debug_store_end;
+		if (strcmp(parm[1], "save") == 0) {
+			if (parm[2] != NULL)
+				lcd_tcon_reg_save(parm[2], size);
+			else
+				pr_info("invalid save path\n");
 		} else if (strcmp(parm[1], "rb") == 0) {
-			if (!parm[2])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			pr_info("read tcon byte [0x%04x] = 0x%02x\n",
-				temp, lcd_tcon_read_byte(temp));
+			if (parm[2] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				pr_info("read tcon byte [0x%04x] = 0x%02x\n",
+					temp, lcd_tcon_read_byte(temp));
+			}
 		} else if (strcmp(parm[1], "wb") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 16, &val);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			data = (unsigned char)val;
-			lcd_tcon_write_byte(temp, data);
-			pr_info("write tcon byte [0x%04x] = 0x%02x\n",
-				temp, data);
-		} else if (strcmp(parm[1], "wlb") == 0) { /*long write byte*/
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 16, &size);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-
-			if (!parm[3 + size]) {
-				pr_info("size and data is not match\n");
-				goto lcd_tcon_debug_store_err;
+			if (parm[3] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				ret = kstrtouint(parm[3], 16, &val);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				data = (unsigned char)val;
+				lcd_tcon_write_byte(temp, data);
+				pr_info(
+			"write tcon byte [0x%04x] = 0x%02x\n", temp, data);
 			}
+		} else if (strcmp(parm[1], "wlb") == 0) {
+			if (parm[3] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				ret = kstrtouint(parm[3], 16, &size);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
 
-			for (i = 0; i < size; i++) {
-				ret = kstrtouint(parm[4 + i], 16, &val);
-				if (ret)
+				if (parm[3 + size] == NULL) {
+					pr_info("size and data is not match\n");
 					goto lcd_tcon_debug_store_err;
-				data = (unsigned char)val;
-				lcd_tcon_write_byte((temp + i), data);
-				pr_info("write tcon byte [0x%04x] = 0x%02x\n",
+				}
+
+				for (i = 0; i < size; i++) {
+					ret = kstrtouint(parm[4 + i], 16, &val);
+					if (ret) {
+						pr_info("invalid parameters\n");
+						goto lcd_tcon_debug_store_err;
+					}
+					data = (unsigned char)val;
+					lcd_tcon_write_byte((temp + i), data);
+					pr_info(
+					"write tcon byte [0x%04x] = 0x%02x\n",
 					(temp + i), data);
-			}
-		} else if (strcmp(parm[1], "db") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 10, &size);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			pr_info("dump tcon byte:\n");
-			for (i = 0; i < size; i++) {
-				pr_info("  [0x%04x] = 0x%02x\n",
-					(temp + i),
-					lcd_tcon_read_byte(temp + i));
+				}
 			}
 		} else if (strcmp(parm[1], "r") == 0) {
-			if (!parm[2])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			pr_info("read tcon [0x%04x] = 0x%08x\n",
-				temp, lcd_tcon_read(temp));
+			if (parm[2] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				pr_info("read tcon [0x%04x] = 0x%08x\n",
+					temp, lcd_tcon_read(temp));
+			}
 		} else if (strcmp(parm[1], "w") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 16, &val);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			lcd_tcon_write(temp, val);
-			pr_info("write tcon [0x%04x] = 0x%08x\n",
-				temp, val);
-		} else if (strcmp(parm[1], "wl") == 0) { /*long write*/
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 16, &size);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-
-			if (!parm[3 + size]) {
-				pr_info("size and data is not match\n");
-				goto lcd_tcon_debug_store_err;
+			if (parm[3] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				ret = kstrtouint(parm[3], 16, &val);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				lcd_tcon_write(temp, val);
+				pr_info("write tcon [0x%04x] = 0x%08x\n",
+					temp, val);
 			}
+		} else if (strcmp(parm[1], "wl") == 0) {
+			if (parm[3] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				pr_info("temp = %d\n", temp);
+				ret = kstrtouint(parm[3], 16, &size);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
 
-			for (i = 0; i < size; i++) {
-				ret = kstrtouint(parm[4 + i], 16, &val);
-				if (ret)
+				if (parm[3 + size] == NULL) {
+					pr_info("size and data is not match\n");
 					goto lcd_tcon_debug_store_err;
-				lcd_tcon_write(temp + i, val);
-				pr_info("write tcon [0x%04x] = 0x%08x\n",
+				}
+
+				for (i = 0; i < size; i++) {
+					ret = kstrtouint(parm[4 + i], 16, &val);
+					if (ret) {
+						pr_info("invalid parameters\n");
+						goto lcd_tcon_debug_store_err;
+					}
+					lcd_tcon_write(temp + i, val);
+					pr_info(
+					"write tcon [0x%04x] = 0x%08x\n",
 					(temp + i), val);
-			}
-		} else if (strcmp(parm[1], "d") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 10, &size);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			pr_info("dump tcon:\n");
-			for (i = 0; i < size; i++) {
-				pr_info("  [0x%04x] = 0x%08x\n",
-					(temp + i),
-					lcd_tcon_read(temp + i));
+				}
 			}
 		}
-	} else if (strcmp(parm[0], "gamma") == 0) { /* save buf to bin */
-		if (!parm[4])
-			goto lcd_tcon_debug_store_err;
-		ret = kstrtouint(parm[1], 10, &temp);
-		if (ret)
-			goto lcd_tcon_debug_store_err;
-		ret = kstrtouint(parm[2], 16, &gamma_r);
-		if (ret)
-			goto lcd_tcon_debug_store_err;
-		ret = kstrtouint(parm[3], 16, &gamma_g);
-		if (ret)
-			goto lcd_tcon_debug_store_err;
-		ret = kstrtouint(parm[4], 16, &gamma_b);
-		if (ret)
-			goto lcd_tcon_debug_store_err;
-		lcd_tcon_gamma_set_pattern(temp, gamma_r, gamma_g, gamma_b);
 	} else if (strcmp(parm[0], "table") == 0) {
-		if (lcd_tcon_reg_table_check(table, size))
-			goto lcd_tcon_debug_store_end;
-		if (!parm[1]) {
+		if (parm[1] == NULL) {
 			lcd_tcon_reg_table_print();
 			goto lcd_tcon_debug_store_end;
 		}
-		if (strcmp(parm[1], "dump") == 0) {
-			lcd_tcon_reg_table_print();
-			goto lcd_tcon_debug_store_end;
-		} else if (strcmp(parm[1], "r") == 0) {
-			if (!parm[2])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			val = lcd_tcon_table_read(temp);
-			pr_info("read table 0x%x = 0x%x\n", temp, val);
+		if (strcmp(parm[1], "r") == 0) {
+			if (parm[2] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				if (temp < size) {
+					data = table[temp];
+					pr_info("read tcon table[%d]=0x%02x\n",
+						temp, data);
+				} else {
+					pr_info("invalid table index: %d\n",
+						temp);
+				}
+			}
 		} else if (strcmp(parm[1], "w") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 16, &val);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			back_val = lcd_tcon_table_write(temp, val);
-			pr_info("write table 0x%x = 0x%x, readback 0x%x\n",
-				temp, val, back_val);
+			if (parm[3] != NULL) {
+				ret = kstrtouint(parm[2], 16, &temp);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				ret = kstrtouint(parm[3], 16, &val);
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				data = (unsigned char)val;
+				if (temp < size) {
+					table[temp] = data;
+					pr_info("write tcon table[%d]=0x%02x\n",
+						temp, data);
+				} else {
+					pr_info("invalid table index: %d\n",
+						temp);
+				}
+			}
 		} else if (strcmp(parm[1], "d") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 16, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[3], 16, &n);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			pr_info("dump tcon table:\n");
-			for (i = temp; i < (temp + n); i++) {
-				if (i > size)
-					break;
-				data = table[i];
-				pr_info("  [0x%04x]=0x%02x\n", i, data);
+			if (parm[3] != NULL) {
+				ret = 0;
+				if (!kstrtouint(parm[2], 16, &val))
+					temp = (unsigned int)val;
+				else
+					ret = 1;
+				if (!kstrtouint(parm[3], 16, &val))
+					n = (unsigned char)val;
+				else
+					ret = 1;
+				if (ret) {
+					pr_info("invalid parameters\n");
+					goto lcd_tcon_debug_store_err;
+				}
+				pr_info("dump tcon table:\n");
+				for (i = temp; i < (temp + n); i++) {
+					if (i > size)
+						break;
+					data = table[i];
+					pr_info("  [%d]=0x%02x\n", temp, data);
+				}
 			}
 		} else if (strcmp(parm[1], "update") == 0) {
-			lcd_tcon_core_update();
-		} else if (strcmp(parm[1], "load") == 0) {
-			if (!parm[2]) {
-				pr_info("invalid load path\n");
-				goto lcd_tcon_debug_store_err;
-			}
-			lcd_tcon_reg_table_load(parm[2], table, size);
-		} else {
-			goto lcd_tcon_debug_store_err;
-		}
-	} else if (strcmp(parm[0], "od") == 0) { /* over drive */
-		if (!parm[1]) {
-			temp = lcd_tcon_od_get();
-			if (temp)
-				LCDPR("tcon od is enabled: %d\n", temp);
+			lcd_tcon_core_reg_update();
+		} else if (strcmp(parm[1], "save") == 0) {
+			if (parm[2] != NULL)
+				lcd_tcon_reg_table_save(parm[2], table, size);
 			else
-				LCDPR("tcon od is disabled: %d\n", temp);
-		} else {
-			ret = kstrtouint(parm[1], 10, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			if (temp)
-				lcd_tcon_od_set(1);
-			else
-				lcd_tcon_od_set(0);
-		}
-	} else if (strcmp(parm[0], "save") == 0) { /* save buf to bin */
-		if (!parm[2])
-			goto lcd_tcon_debug_store_err;
-
-		if (strcmp(parm[1], "table") == 0) {
-			if (lcd_tcon_reg_table_check(table, size))
-				goto lcd_tcon_debug_store_end;
-			lcd_tcon_reg_table_save(parm[2], table, size);
-		} else if (strcmp(parm[1], "reg") == 0) {
-			lcd_tcon_reg_save(parm[2], size);
-		} else if (strcmp(parm[1], "axi") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 10, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			/* parm[2]: axi index */
-			/* parm[3]: save path */
-			lcd_tcon_axi_rmem_save(temp, parm[3]);
-		} else if (strcmp(parm[1], "path") == 0) {
-			lcd_tcon_rmem_save(parm[2], 0);
-		} else if (strcmp(parm[1], "vac") == 0) {
-			lcd_tcon_rmem_save(parm[2], 1);
-		} else if (strcmp(parm[1], "demura") == 0) {
-			lcd_tcon_rmem_save(parm[2], 2);
-		} else if (strcmp(parm[1], "acc") == 0) {
-			lcd_tcon_rmem_save(parm[2], 3);
-		} else {
-			goto lcd_tcon_debug_store_err;
-		}
-	} else if (strcmp(parm[0], "tee") == 0) {
-		if (!parm[1])
-			goto lcd_tcon_debug_store_err;
-#ifdef CONFIG_AMLOGIC_TEE
-		if (strcmp(parm[1], "status") == 0) {
-			pr_info("tcon tee secure memory protect status %d\n",
-				lcd_tcon_mem_tee_get_status());
-		} else if (strcmp(parm[1], "off") == 0) {
-			ret = lcd_tcon_mem_tee_unprotect();
-			pr_info("%s: tcon tee unprotect %d\n", __func__, ret);
-		} else {
-			goto lcd_tcon_debug_store_err;
+				pr_info("invalid save path\n");
 		}
-#endif
-	} else if (strcmp(parm[0], "load") == 0) {
-		if (!parm[2])
-			goto lcd_tcon_debug_store_err;
-
-		if (strcmp(parm[1], "axi") == 0) {
-			if (!parm[3])
-				goto lcd_tcon_debug_store_err;
-			ret = kstrtouint(parm[2], 10, &temp);
-			if (ret)
-				goto lcd_tcon_debug_store_err;
-			lcd_tcon_axi_rmem_load(temp, parm[3]);
-		} else if (strcmp(parm[1], "table") == 0) {
-			lcd_tcon_reg_table_load(parm[2], table, size);
-		} else if (strcmp(parm[1], "setting") == 0) {
-			lcd_tcon_reg_setting_load(parm[2]);
-		} else {
-			goto lcd_tcon_debug_store_err;
+	} else if (strcmp(parm[0], "od") == 0) { /* over drive */
+		if (parm[1] != NULL) {
+			if (strcmp(parm[1], "status") == 0) {
+				temp = lcd_tcon_od_get();
+				if (temp) {
+					LCDPR("tcon od is enabled: %d\n", temp);
+				} else {
+					LCDPR("tcon od is disabled: %d\n",
+						temp);
+				}
+			} else {
+				if (!kstrtouint(parm[1], 10, &temp)) {
+					if (temp)
+						lcd_tcon_od_set(1);
+					else
+						lcd_tcon_od_set(0);
+				}
+			}
 		}
 	} else {
+		LCDERR("wrong command\n");
 		goto lcd_tcon_debug_store_err;
 	}
 
@@ -5211,211 +4332,11 @@ static ssize_t lcd_tcon_debug_store(struct class *class,
 	return count;
 
 lcd_tcon_debug_store_err:
-	pr_info("invalid parameters\n");
 	kfree(parm);
 	kfree(buf_orig);
 	return count;
 }
 
-static ssize_t lcd_tcon_adb_debug_store(struct class *class,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	char *buf_orig;
-	char **parm = NULL;
-	unsigned int  temp32 = 0, temp_reg = 0;
-	unsigned int  temp_len = 0, temp_mask = 0, temp_val = 0;
-	unsigned char temp8 = 0;
-	int ret = -1, i;
-
-	if ((lcd_drv->lcd_status & LCD_STATUS_IF_ON) == 0)
-		return count;
-
-	if (!buf)
-		return count;
-
-	mutex_lock(&lcd_tcon_adb_mutex);
-
-	buf_orig = kstrdup(buf, GFP_KERNEL);
-	if (!buf_orig) {
-		mutex_unlock(&lcd_tcon_adb_mutex);
-		return count;
-	}
-
-	parm = kcalloc(1500, sizeof(char *), GFP_KERNEL);
-	if (!parm) {
-		kfree(buf_orig);
-		mutex_unlock(&lcd_tcon_adb_mutex);
-		return count;
-	}
-
-	lcd_debug_parse_param(buf_orig, parm);
-
-	if (strcmp(parm[0], "wn") == 0) {
-		if (!parm[3])
-			goto lcd_tcon_adb_debug_store_err;
-		if (strcmp(parm[1], "8") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_8_bit;
-		else if (strcmp(parm[1], "32") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_32_bit;
-		else
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[2], 16, &temp_reg);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[3], 10, &temp_len);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		if (temp_len <= 0)
-			goto lcd_tcon_adb_debug_store_err;
-		if (!parm[4 + temp_len - 1])
-			goto lcd_tcon_adb_debug_store_err;
-		if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-		/*(4k - 9)/(8+1) ~=454*/
-		if (temp_len > 454)
-			goto lcd_tcon_adb_debug_store_err;
-		} else {
-			/*(4k - 9)/(2+1) ~=1362*/
-			if (temp_len > 1362)
-				goto lcd_tcon_adb_debug_store_err;
-		}
-		adb_reg.len = temp_len; /* for cat use */
-		adb_reg.addr = temp_reg;
-		adb_reg.rw_mode = LCD_ADB_TCON_REG_RW_MODE_WN;
-		for (i = 0; i < temp_len; i++) {
-			ret = kstrtouint(parm[i + 4], 16, &temp_val);
-			if (ret)
-				goto lcd_tcon_adb_debug_store_err;
-			if (adb_reg.bit_width == ADB_TCON_REG_32_bit)
-				lcd_tcon_write(temp_reg, temp_val);
-			else
-				lcd_tcon_write_byte(temp_reg, temp_val);
-			temp_reg++;
-		}
-	} else if (strcmp(parm[0], "wm") == 0) {
-		if (!parm[4])
-			goto lcd_tcon_adb_debug_store_err;
-		if (strcmp(parm[1], "8") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_8_bit;
-		else if (strcmp(parm[1], "32") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_32_bit;
-		else
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[2], 16, &temp_reg);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[3], 16, &temp_mask);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[4], 16, &temp_val);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		adb_reg.len = 1; /* for cat use */
-		adb_reg.addr = temp_reg;
-		adb_reg.rw_mode = LCD_ADB_TCON_REG_RW_MODE_WM;
-		if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-			temp32 = lcd_tcon_read(temp_reg);
-			temp32 &= ~temp_mask;
-			temp32 |= temp_val & temp_mask;
-			lcd_tcon_write(temp_reg, temp32);
-		} else {
-			temp8 = lcd_tcon_read_byte(temp_reg);
-			temp8 &= ~temp_mask;
-			temp8 |= temp_val & temp_mask;
-			lcd_tcon_write_byte(temp_reg, temp8);
-		}
-	} else if (strcmp(parm[0], "ws") == 0) {
-		if (!parm[3])
-			goto lcd_tcon_adb_debug_store_err;
-		if (strcmp(parm[1], "8") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_8_bit;
-		else if (strcmp(parm[1], "32") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_32_bit;
-		else
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[2], 16, &temp_reg);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[3], 10, &temp_len);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		if (temp_len <= 0)
-			goto lcd_tcon_adb_debug_store_err;
-		if (!parm[4 + temp_len - 1])
-			goto lcd_tcon_adb_debug_store_err;
-		if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-		/*(4k - 9)/(8+1) ~=454*/
-		if (temp_len > 454)
-			goto lcd_tcon_adb_debug_store_err;
-		} else {
-			/*(4k - 9)/(2+1) ~=1362*/
-			if (temp_len > 1362)
-				goto lcd_tcon_adb_debug_store_err;
-		}
-		adb_reg.len = temp_len; /* for cat use */
-		adb_reg.addr = temp_reg;
-		adb_reg.rw_mode = LCD_ADB_TCON_REG_RW_MODE_WS;
-		for (i = 0; i < temp_len; i++) {
-			ret = kstrtouint(parm[i + 4], 16, &temp_val);
-			if (ret)
-				goto lcd_tcon_adb_debug_store_err;
-			if (adb_reg.bit_width == ADB_TCON_REG_32_bit)
-				lcd_tcon_write(temp_reg, temp_val);
-			else
-				lcd_tcon_write_byte(temp_reg, temp_val);
-		}
-	} else if (strcmp(parm[0], "rn") == 0) {
-		if (!parm[2])
-			goto lcd_tcon_adb_debug_store_err;
-		if (strcmp(parm[1], "8") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_8_bit;
-		else if (strcmp(parm[1], "32") == 0)
-			adb_reg.bit_width = ADB_TCON_REG_32_bit;
-		else
-			goto lcd_tcon_adb_debug_store_err;
-		ret = kstrtouint(parm[2], 16, &temp_reg);
-		if (ret)
-			goto lcd_tcon_adb_debug_store_err;
-		if (parm[3]) {
-			ret = kstrtouint(parm[3], 10, &temp_len);
-			if (ret)
-				goto lcd_tcon_adb_debug_store_err;
-			if (adb_reg.bit_width == ADB_TCON_REG_32_bit) {
-				/*(4k - 9)/(8+1) ~=454*/
-				if (temp_len > 454)
-					goto lcd_tcon_adb_debug_store_err;
-			} else {
-				/*(4k - 9)/(2+1) ~=1362*/
-				if (temp_len > 1362)
-					goto lcd_tcon_adb_debug_store_err;
-			}
-			adb_reg.len = temp_len; /* for cat use */
-			adb_reg.addr = temp_reg;
-			adb_reg.rw_mode = LCD_ADB_TCON_REG_RW_MODE_RN;
-		} else {
-			adb_reg.len = 1; /* for cat use */
-			adb_reg.addr = temp_reg;
-			adb_reg.rw_mode = LCD_ADB_TCON_REG_RW_MODE_RN;
-		}
-	} else {
-		goto lcd_tcon_adb_debug_store_err;
-	}
-
-	kfree(parm);
-	kfree(buf_orig);
-	mutex_unlock(&lcd_tcon_adb_mutex);
-	return count;
-
-lcd_tcon_adb_debug_store_err:
-	adb_reg.rw_mode = LCD_ADB_TCON_REG_RW_MODE_ERR;
-
-	kfree(parm);
-	kfree(buf_orig);
-	mutex_unlock(&lcd_tcon_adb_mutex);
-	return count;
-}
-
 static ssize_t lcd_mipi_cmd_debug_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -5662,8 +4583,6 @@ static struct class_attribute lcd_debug_class_attrs_mlvds[] = {
 		lcd_tcon_debug_show, lcd_tcon_debug_store),
 	__ATTR(tcon_status,   0644,
 	       lcd_tcon_status_show, NULL),
-	__ATTR(tcon_reg,   0644,
-	       lcd_tcon_adb_status_show, lcd_tcon_adb_debug_store),
 	__ATTR(null,   0644, NULL, NULL),
 };
 
@@ -5676,8 +4595,6 @@ static struct class_attribute lcd_debug_class_attrs_p2p[] = {
 		lcd_tcon_debug_show, lcd_tcon_debug_store),
 	__ATTR(tcon_status,   0644,
 	       lcd_tcon_status_show, NULL),
-	__ATTR(tcon_reg,   0644,
-	       lcd_tcon_adb_status_show, lcd_tcon_adb_debug_store),
 	__ATTR(null,   0644, NULL, NULL),
 };
 
@@ -5780,61 +4697,47 @@ static int lcd_class_remove(void)
  */
 /* chip_type data */
 static struct lcd_debug_info_reg_s lcd_debug_info_reg_gxl = {
-	.reg_ana_table = NULL,
 	.reg_clk_table = lcd_reg_dump_clk_dft,
 	.reg_encl_table = lcd_reg_dump_encl_dft,
 	.reg_pinmux_table = lcd_reg_dump_pinmux_gxl,
 };
 
 static struct lcd_debug_info_reg_s lcd_debug_info_reg_txl = {
-	.reg_ana_table = NULL,
 	.reg_clk_table = lcd_reg_dump_clk_dft,
 	.reg_encl_table = lcd_reg_dump_encl_dft,
 	.reg_pinmux_table = lcd_reg_dump_pinmux_txl,
 };
 
 static struct lcd_debug_info_reg_s lcd_debug_info_reg_txlx = {
-	.reg_ana_table = NULL,
 	.reg_clk_table = lcd_reg_dump_clk_dft,
 	.reg_encl_table = lcd_reg_dump_encl_dft,
 	.reg_pinmux_table = lcd_reg_dump_pinmux_txlx,
 };
 
 static struct lcd_debug_info_reg_s lcd_debug_info_reg_axg = {
-	.reg_ana_table = NULL,
 	.reg_clk_table = lcd_reg_dump_clk_axg,
 	.reg_encl_table = lcd_reg_dump_encl_dft,
 	.reg_pinmux_table = NULL,
 };
 
 static struct lcd_debug_info_reg_s lcd_debug_info_reg_g12a_clk_path0 = {
-	.reg_ana_table = NULL,
 	.reg_clk_table = lcd_reg_dump_clk_hpll_g12a,
 	.reg_encl_table = lcd_reg_dump_encl_dft,
 	.reg_pinmux_table = NULL,
 };
 
 static struct lcd_debug_info_reg_s lcd_debug_info_reg_g12a_clk_path1 = {
-	.reg_ana_table = NULL,
 	.reg_clk_table = lcd_reg_dump_clk_gp0_g12a,
 	.reg_encl_table = lcd_reg_dump_encl_dft,
 	.reg_pinmux_table = NULL,
 };
 
 static struct lcd_debug_info_reg_s lcd_debug_info_reg_tl1 = {
-	.reg_ana_table = NULL,
 	.reg_clk_table = lcd_reg_dump_clk_tl1,
 	.reg_encl_table = lcd_reg_dump_encl_tl1,
 	.reg_pinmux_table = lcd_reg_dump_pinmux_tl1,
 };
 
-static struct lcd_debug_info_reg_s lcd_debug_info_reg_t5 = {
-	.reg_ana_table = lcd_reg_dump_ana_t5,
-	.reg_clk_table = lcd_reg_dump_clk_t5,
-	.reg_encl_table = lcd_reg_dump_encl_tl1,
-	.reg_pinmux_table = lcd_reg_dump_pinmux_t5,
-};
-
 /* interface data */
 static struct lcd_debug_info_if_s lcd_debug_info_if_ttl = {
 	.interface_print = lcd_info_print_ttl,
@@ -5866,14 +4769,14 @@ static struct lcd_debug_info_if_s lcd_debug_info_if_mipi = {
 
 static struct lcd_debug_info_if_s lcd_debug_info_if_mlvds = {
 	.interface_print = lcd_info_print_mlvds,
-	.reg_dump_interface = lcd_reg_print_tcon,
+	.reg_dump_interface = lcd_reg_print_mlvds,
 	.reg_dump_phy = lcd_reg_print_phy_analog,
 	.class_attrs = lcd_debug_class_attrs_mlvds,
 };
 
 static struct lcd_debug_info_if_s lcd_debug_info_if_p2p = {
 	.interface_print = lcd_info_print_p2p,
-	.reg_dump_interface = lcd_reg_print_tcon,
+	.reg_dump_interface = lcd_reg_print_p2p,
 	.reg_dump_phy = lcd_reg_print_phy_analog,
 	.class_attrs = lcd_debug_class_attrs_p2p,
 };
@@ -5889,28 +4792,6 @@ int lcd_debug_probe(void)
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
 		lcd_debug_info_reg = &lcd_debug_info_reg_tl1;
-		lcd_debug_info_if_lvds.interface_print =
-			lcd_info_print_lvds_tl1;
-		lcd_debug_info_if_lvds.reg_dump_interface =
-			lcd_reg_print_lvds_tl1;
-		lcd_debug_info_if_lvds.reg_dump_phy =
-			lcd_reg_print_phy_analog_tl1;
-		lcd_debug_info_if_vbyone.reg_dump_interface =
-			lcd_reg_print_vbyone_tl1;
-		lcd_debug_info_if_vbyone.reg_dump_phy =
-			lcd_reg_print_phy_analog_tl1;
-		lcd_debug_info_if_mlvds.reg_dump_phy =
-			lcd_reg_print_phy_analog_tl1;
-		lcd_debug_info_if_p2p.reg_dump_phy =
-			lcd_reg_print_phy_analog_tl1;
-		break;
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		lcd_debug_info_reg = &lcd_debug_info_reg_t5;
-		lcd_debug_info_if_lvds.interface_print =
-			lcd_info_print_lvds_tl1;
-		lcd_debug_info_if_lvds.reg_dump_interface =
-			lcd_reg_print_lvds_tl1;
 		lcd_debug_info_if_lvds.reg_dump_phy =
 			lcd_reg_print_phy_analog_tl1;
 		lcd_debug_info_if_vbyone.reg_dump_interface =
@@ -5962,11 +4843,9 @@ int lcd_debug_probe(void)
 		lcd_debug_info_if = &lcd_debug_info_if_mipi;
 		break;
 	case LCD_MLVDS:
-		mutex_init(&lcd_tcon_adb_mutex);
 		lcd_debug_info_if = &lcd_debug_info_if_mlvds;
 		break;
 	case LCD_P2P:
-		mutex_init(&lcd_tcon_adb_mutex);
 		lcd_debug_info_if = &lcd_debug_info_if_p2p;
 		break;
 	default:
diff --git a/drivers/amlogic/media/vout/lcd/lcd_debug.h b/drivers/amlogic/media/vout/lcd/lcd_debug.h
index eedcdf575074..af5bbf6612f3 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_debug.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_debug.h
@@ -22,26 +22,7 @@
 #define LCD_DEBUG_REG_CNT_MAX    30
 #define LCD_DEBUG_REG_END        0xffffffff
 
-/*tcon adb port use */
-#define LCD_ADB_TCON_REG_RW_MODE_NULL              0
-#define LCD_ADB_TCON_REG_RW_MODE_RN                1
-#define LCD_ADB_TCON_REG_RW_MODE_WM                2
-#define LCD_ADB_TCON_REG_RW_MODE_WN                3
-#define LCD_ADB_TCON_REG_RW_MODE_WS                4
-#define LCD_ADB_TCON_REG_RW_MODE_ERR               5
-
-#define ADB_TCON_REG_8_bit                         0
-#define ADB_TCON_REG_32_bit                        1
-
-struct lcd_tcon_adb_reg_s {
-	unsigned int rw_mode;
-	unsigned int bit_width;
-	unsigned int addr;
-	unsigned int len;
-};
-
 struct lcd_debug_info_reg_s {
-	unsigned int *reg_ana_table;
 	unsigned int *reg_clk_table;
 	unsigned int *reg_encl_table;
 	unsigned int *reg_pinmux_table;
@@ -125,23 +106,6 @@ static unsigned int lcd_reg_dump_clk_tl1[] = {
 	LCD_DEBUG_REG_END,
 };
 
-static unsigned int lcd_reg_dump_ana_t5[] = {
-	HHI_TCON_PLL_CNTL0,
-	HHI_TCON_PLL_CNTL1,
-	HHI_TCON_PLL_CNTL2,
-	HHI_TCON_PLL_CNTL3,
-	HHI_TCON_PLL_CNTL4,
-	HHI_VID_PLL_CLK_DIV,
-	LCD_DEBUG_REG_END,
-};
-
-static unsigned int lcd_reg_dump_clk_t5[] = {
-	HHI_VIID_CLK_DIV,
-	HHI_VIID_CLK_CNTL,
-	HHI_VID_CLK_CNTL2,
-	LCD_DEBUG_REG_END,
-};
-
 static unsigned int lcd_reg_dump_encl_dft[] = {
 	VPU_VIU_VENC_MUX_CTRL,
 	ENCL_VIDEO_EN,
@@ -220,10 +184,4 @@ static unsigned int lcd_reg_dump_pinmux_tl1[] = {
 	LCD_DEBUG_REG_END,
 };
 
-static unsigned int lcd_reg_dump_pinmux_t5[] = {
-	PERIPHS_PIN_MUX_5_TL1,
-	PERIPHS_PIN_MUX_6_TL1,
-	LCD_DEBUG_REG_END,
-};
-
 #endif
diff --git a/drivers/amlogic/media/vout/lcd/lcd_extern/ext_default.c b/drivers/amlogic/media/vout/lcd/lcd_extern/ext_default.c
index c66cc64d74a0..45e47ce91777 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_extern/ext_default.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_extern/ext_default.c
@@ -33,13 +33,7 @@
 static struct lcd_extern_config_s *ext_config;
 static struct aml_lcd_extern_i2c_dev_s *i2c0_dev;
 static struct aml_lcd_extern_i2c_dev_s *i2c1_dev;
-static struct aml_lcd_extern_i2c_dev_s *i2c2_dev;
-static struct aml_lcd_extern_i2c_dev_s *i2c3_dev;
 
-static unsigned char check_state[4] = {0, 0, 0, 0};
-static unsigned char check_flag;
-static unsigned char check_offset;
-static unsigned char check_len;
 
 static void set_lcd_csb(unsigned int v)
 {
@@ -167,106 +161,10 @@ static int lcd_extern_reg_write(unsigned char *buf, unsigned int len)
 	return ret;
 }
 
-static void lcd_extern_init_reg_check(struct i2c_client *i2client,
-				      unsigned char type,
-				      unsigned char *raw_table,
-				      unsigned char data_len)
-{
-	unsigned char *chk_table, *chk_buf, *raw_buf;
-	unsigned char index;
-	unsigned char temp_flag = check_flag;
-	int ret = 0;
-
-	/* if not need to check return */
-	if (check_flag == 0)
-		return;
-
-	index = type & 0x0f;
-	if ((index >= 4) || (data_len < 1) || (!raw_table))
-		goto parameter_err0;
-	check_state[index] = 0;
-	check_flag = 0;
-	chk_table = kcalloc(data_len, sizeof(unsigned char), GFP_KERNEL);
-	if (!chk_table)
-		goto parameter_err0;
-	if (((type & 0xf0) == LCD_EXT_CMD_TYPE_CMD) ||
-	    ((type & 0xf0) == LCD_EXT_CMD_TYPE_CMD_BIN)) {
-		if (data_len < 2)
-			goto parameter_err1;
-		chk_table[0] = raw_table[0];
-		data_len--;
-		raw_table++;
-	}
-	ret = lcd_extern_i2c_read(i2client, chk_table, data_len);
-
-	if (!check_len || (check_len > data_len))
-		check_len = data_len;
-	if (check_offset > data_len)
-		check_offset = 0;
-	if ((ret) || (check_offset + check_len) > data_len)
-		goto parameter_err1;
-	chk_buf = chk_table + check_offset;
-	raw_buf = raw_table + check_offset;
-	ret = memcmp(chk_buf, raw_buf, check_len);
-	if (ret == 0)
-		check_state[index] = temp_flag;
-	if (lcd_debug_print_flag)
-		EXTERR("%s: ret: %d\n", __func__, ret);
-	kfree(chk_table);
-	return;
-parameter_err1:
-	kfree(chk_table);
-parameter_err0:
-	EXTERR("%s: error parameters\n", __func__);
-}
-
-static void lcd_extern_init_reg_check2(struct i2c_client *i2client,
-				       unsigned char type,
-				       unsigned char *raw_table,
-				       unsigned char data_len)
-{
-	unsigned char *chk_table, *chk_buf, *raw_buf;
-	unsigned char index;
-	unsigned char temp_flag = check_flag;
-	int ret = 0;
-
-	/* if not need to check return */
-	if (check_flag == 0)
-		return;
-
-	index = type & 0x0f;
-	if ((index >= 4) || (data_len < 1) || (!raw_table))
-		goto parameter_err0;
-	check_state[index] = 0;
-	check_flag = 0;
-	chk_table = kcalloc(data_len, sizeof(unsigned char), GFP_KERNEL);
-	if (!chk_table)
-		goto parameter_err0;
-	ret = lcd_extern_i2c_read(i2client, chk_table, check_offset + data_len);
-
-	if (!check_len || (check_len > data_len))
-		check_len = data_len;
-	if (ret)
-		goto parameter_err1;
-	chk_buf = chk_table + check_offset;
-	raw_buf = raw_table + 1;
-	ret = memcmp(chk_buf, raw_buf, check_len);
-	if (ret == 0)
-		check_state[index] = temp_flag;
-	if (lcd_debug_print_flag)
-		EXTERR("%s: ret: %d\n", __func__, ret);
-	kfree(chk_table);
-	return;
-parameter_err1:
-	kfree(chk_table);
-parameter_err0:
-	EXTERR("%s: error parameters\n", __func__);
-}
-
 static int lcd_extern_power_cmd_dynamic_size(unsigned char *table, int flag)
 {
 	int i = 0, j, step = 0, max_len = 0;
-	unsigned char type, size;
+	unsigned char type, cmd_size;
 	int delay_ms, ret = 0;
 
 	if (flag)
@@ -278,277 +176,136 @@ static int lcd_extern_power_cmd_dynamic_size(unsigned char *table, int flag)
 	case LCD_EXTERN_I2C:
 		while ((i + 1) < max_len) {
 			type = table[i];
-			size = table[i + 1];
 			if (type == LCD_EXT_CMD_TYPE_END)
 				break;
 			if (lcd_debug_print_flag) {
-				EXTPR("%s: step %d: type=0x%02x, size=%d\n",
-				      __func__, step, type, size);
+				EXTPR("%s: step %d: type=0x%02x, cmd_size=%d\n",
+					__func__, step, type, table[i+1]);
 			}
-			if (size == 0)
+			cmd_size = table[i+1];
+			if (cmd_size == 0)
 				goto power_cmd_dynamic_i2c_next;
-			if ((i + 2 + size) > max_len)
+			if ((i + 2 + cmd_size) > max_len)
 				break;
 
 			if (type == LCD_EXT_CMD_TYPE_NONE) {
 				/* do nothing */
 			} else if (type == LCD_EXT_CMD_TYPE_GPIO) {
-				if (size < 2) {
+				if (cmd_size < 2) {
 					EXTERR(
-				"step %d: invalid size %d for GPIO\n",
-					       step, size);
+				"step %d: invalid cmd_size %d for GPIO\n",
+						step, cmd_size);
 					goto power_cmd_dynamic_i2c_next;
 				}
 				if (table[i+2] < LCD_GPIO_MAX) {
 					lcd_extern_gpio_set(table[i+2],
 						table[i+3]);
 				}
-				if (size > 2) {
+				if (cmd_size > 2) {
 					if (table[i+4] > 0)
 						mdelay(table[i+4]);
 				}
 			} else if (type == LCD_EXT_CMD_TYPE_DELAY) {
 				delay_ms = 0;
-				for (j = 0; j < size; j++)
+				for (j = 0; j < cmd_size; j++)
 					delay_ms += table[i+2+j];
 				if (delay_ms > 0)
 					mdelay(delay_ms);
-			} else if (type == LCD_EXT_CMD_TYPE_CHECK) {
-				if (size == 1) {
-					check_flag = table[i + 2];
-					check_offset = 0;
-					check_len = 0;
-				} else if (size == 3) {
-					check_flag = table[i + 2];
-					check_offset = table[i + 3];
-					check_len = table[i + 4];
-				} else {
-					check_flag = 0;
-				}
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN_DATA)) {
-				if (!i2c0_dev) {
-					EXTERR("invalid i2c0 device\n");
-					return -1;
-				}
-				lcd_extern_init_reg_check(i2c0_dev->client,
-							  type,
-							  &table[i + 2],
-							  size);
-				if (check_state[0] == 1)
-					goto power_cmd_dynamic_i2c_next;
-				ret = lcd_extern_i2c_write(i2c0_dev->client,
-							   &table[i + 2],
-							   size);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD_BIN2) {
-				if (!i2c0_dev) {
+			} else if (type == LCD_EXT_CMD_TYPE_CMD) {
+				if (i2c0_dev == NULL) {
 					EXTERR("invalid i2c0 device\n");
 					return -1;
 				}
-				lcd_extern_init_reg_check2(i2c0_dev->client,
-							   type,
-							   &table[i + 2],
-							   size);
-				if (check_state[0] == 1)
-					goto power_cmd_dynamic_i2c_next;
 				ret = lcd_extern_i2c_write(i2c0_dev->client,
-							   &table[i + 2],
-							   size);
-
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD2) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2_BIN_DATA)) {
-				if (!i2c1_dev) {
+					&table[i+2], cmd_size);
+			} else if (type == LCD_EXT_CMD_TYPE_CMD2) {
+				if (i2c1_dev == NULL) {
 					EXTERR("invalid i2c1 device\n");
 					return -1;
 				}
-				lcd_extern_init_reg_check(i2c1_dev->client,
-							  type,
-							  &table[i + 2],
-							  size);
-				if (check_state[1] == 1)
-					goto power_cmd_dynamic_i2c_next;
 				ret = lcd_extern_i2c_write(i2c1_dev->client,
-							   &table[i + 2],
-							   size);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD2_BIN2) {
-				if (!i2c1_dev) {
-					EXTERR("invalid i2c1 device\n");
-					return -1;
-				}
-				lcd_extern_init_reg_check2(i2c1_dev->client,
-							   type,
-							   &table[i + 2],
-							   size);
-				if (check_state[1] == 1)
-					goto power_cmd_dynamic_i2c_next;
-				ret = lcd_extern_i2c_write(i2c1_dev->client,
-							   &table[i + 2],
-							   size);
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD3) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3_BIN_DATA)) {
-				if (!i2c2_dev) {
-					EXTERR("invalid i2c2 device\n");
-					return -1;
-				}
-				lcd_extern_init_reg_check(i2c2_dev->client,
-							  type,
-							  &table[i + 2],
-							  size);
-				if (check_state[2] == 1)
-					goto power_cmd_dynamic_i2c_next;
-				ret = lcd_extern_i2c_write(i2c2_dev->client,
-							   &table[i + 2],
-							   size);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD3_BIN2) {
-				if (!i2c2_dev) {
-					EXTERR("invalid i2c2 device\n");
-					return -1;
-				}
-				lcd_extern_init_reg_check2(i2c2_dev->client,
-							   type,
-							   &table[i + 2],
-							   size);
-				if (check_state[2] == 1)
-					goto power_cmd_dynamic_i2c_next;
-				ret = lcd_extern_i2c_write(i2c2_dev->client,
-							   &table[i + 2],
-							   size);
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD4) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4_BIN_DATA)) {
-				if (!i2c3_dev) {
-					EXTERR("invalid i2c3 device\n");
-					return -1;
-				}
-				lcd_extern_init_reg_check(i2c3_dev->client,
-							  type,
-							  &table[i + 2],
-							  size);
-				if (check_state[3] == 1)
-					goto power_cmd_dynamic_i2c_next;
-				ret = lcd_extern_i2c_write(i2c3_dev->client,
-							   &table[i + 2],
-							   size);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD4_BIN2) {
-				if (!i2c3_dev) {
-					EXTERR("invalid i2c3 device\n");
-					return -1;
-				}
-				lcd_extern_init_reg_check2(i2c3_dev->client,
-							   type,
-							   &table[i + 2],
-							   size);
-				if (check_state[3] == 1)
-					goto power_cmd_dynamic_i2c_next;
-				ret = lcd_extern_i2c_write(i2c3_dev->client,
-							   &table[i + 2],
-							   size);
+					&table[i+2], cmd_size);
 			} else if (type == LCD_EXT_CMD_TYPE_CMD_DELAY) {
-				if (!i2c0_dev) {
+				if (i2c0_dev == NULL) {
 					EXTERR("invalid i2c0 device\n");
 					return -1;
 				}
 				ret = lcd_extern_i2c_write(i2c0_dev->client,
-							   &table[i + 2],
-							   (size - 1));
-				if (table[i + size + 1] > 0)
-					mdelay(table[i + size + 1]);
+					&table[i+2], (cmd_size-1));
+				if (table[i+cmd_size+1] > 0)
+					mdelay(table[i+cmd_size+1]);
 			} else if (type == LCD_EXT_CMD_TYPE_CMD2_DELAY) {
-				if (!i2c1_dev) {
+				if (i2c1_dev == NULL) {
 					EXTERR("invalid i2c1 device\n");
 					return -1;
 				}
 				ret = lcd_extern_i2c_write(i2c1_dev->client,
-							   &table[i + 2],
-							   (size - 1));
-				if (table[i + size + 1] > 0)
-					mdelay(table[i + size + 1]);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD3_DELAY) {
-				if (!i2c2_dev) {
-					EXTERR("invalid i2c2 device\n");
-					return -1;
-				}
-				ret = lcd_extern_i2c_write(i2c2_dev->client,
-							   &table[i + 2],
-							   (size - 1));
-				if (table[i + size + 1] > 0)
-					mdelay(table[i + size + 1]);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD4_DELAY) {
-				if (!i2c3_dev) {
-					EXTERR("invalid i2c3 device\n");
-					return -1;
-				}
-				ret = lcd_extern_i2c_write(i2c3_dev->client,
-							   &table[i + 2],
-							   (size - 1));
-				if (table[i + size + 1] > 0)
-					mdelay(table[i + size + 1]);
+					&table[i+2], (cmd_size-1));
+				if (table[i+cmd_size+1] > 0)
+					mdelay(table[i+cmd_size+1]);
 			} else {
 				EXTERR("%s: %s(%d): type 0x%02x invalid\n",
 					__func__, ext_config->name,
 					ext_config->index, type);
 			}
 power_cmd_dynamic_i2c_next:
-			i += (size + 2);
+			i += (cmd_size + 2);
 			step++;
 		}
 		break;
 	case LCD_EXTERN_SPI:
 		while ((i + 1) < max_len) {
 			type = table[i];
-			size = table[i + 1];
 			if (type == LCD_EXT_CMD_TYPE_END)
 				break;
 			if (lcd_debug_print_flag) {
-				EXTPR("%s: step %d: type=0x%02x, size=%d\n",
-				      __func__, step, type, size);
+				EXTPR("%s: step %d: type=0x%02x, cmd_size=%d\n",
+					__func__, step, type, table[i+1]);
 			}
-			if (size == 0)
+			cmd_size = table[i+1];
+			if (cmd_size == 0)
 				goto power_cmd_dynamic_spi_next;
-			if ((i + 2 + size) > max_len)
+			if ((i + 2 + cmd_size) > max_len)
 				break;
 
 			if (type == LCD_EXT_CMD_TYPE_NONE) {
 				/* do nothingy */
 			} else if (type == LCD_EXT_CMD_TYPE_GPIO) {
-				if (size < 2) {
+				if (cmd_size < 2) {
 					EXTERR(
-				"step %d: invalid size %d for GPIO\n",
-						step, size);
+				"step %d: invalid cmd_size %d for GPIO\n",
+						step, cmd_size);
 					goto power_cmd_dynamic_spi_next;
 				}
 				if (table[i+2] < LCD_GPIO_MAX) {
 					lcd_extern_gpio_set(table[i+2],
 						table[i+3]);
 				}
-				if (size > 2) {
+				if (cmd_size > 2) {
 					if (table[i+4] > 0)
 						mdelay(table[i+4]);
 				}
 			} else if (type == LCD_EXT_CMD_TYPE_DELAY) {
 				delay_ms = 0;
-				for (j = 0; j < size; j++)
+				for (j = 0; j < cmd_size; j++)
 					delay_ms += table[i+2+j];
 				if (delay_ms > 0)
 					mdelay(delay_ms);
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN)) {
-				ret = lcd_extern_spi_write(&table[i + 2], size);
+			} else if (type == LCD_EXT_CMD_TYPE_CMD) {
+				ret = lcd_extern_spi_write(&table[i+2],
+					cmd_size);
 			} else if (type == LCD_EXT_CMD_TYPE_CMD_DELAY) {
 				ret = lcd_extern_spi_write(&table[i+2],
-							   (size - 1));
-				if (table[i + size + 1] > 0)
-					mdelay(table[i + size + 1]);
+					(cmd_size-1));
+				if (table[i+cmd_size+1] > 0)
+					mdelay(table[i+cmd_size+1]);
 			} else {
 				EXTERR("%s: %s(%d): type 0x%02x invalid\n",
 					__func__, ext_config->name,
 					ext_config->index, type);
 			}
 power_cmd_dynamic_spi_next:
-			i += (size + 2);
+			i += (cmd_size + 2);
 			step++;
 		}
 		break;
@@ -606,90 +363,38 @@ static int lcd_extern_power_cmd_fixed_size(unsigned char *table, int flag)
 					delay_ms += table[i+1+j];
 				if (delay_ms > 0)
 					mdelay(delay_ms);
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN2) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN_DATA)) {
-				if (!i2c0_dev) {
+			} else if (type == LCD_EXT_CMD_TYPE_CMD) {
+				if (i2c0_dev == NULL) {
 					EXTERR("invalid i2c0 device\n");
 					return -1;
 				}
 				ret = lcd_extern_i2c_write(i2c0_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 1));
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD2) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2_BIN2) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2_BIN_DATA)) {
-				if (!i2c1_dev) {
+					&table[i+1], (cmd_size-1));
+			} else if (type == LCD_EXT_CMD_TYPE_CMD2) {
+				if (i2c1_dev == NULL) {
 					EXTERR("invalid i2c1 device\n");
 					return -1;
 				}
 				ret = lcd_extern_i2c_write(i2c1_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 1));
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD3) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3_BIN2) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3_BIN_DATA)) {
-				if (!i2c2_dev) {
-					EXTERR("invalid i2c2 device\n");
-					return -1;
-				}
-				ret = lcd_extern_i2c_write(i2c2_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 1));
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD4) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4_BIN2) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4_BIN_DATA)) {
-				if (!i2c3_dev) {
-					EXTERR("invalid i2c3 device\n");
-					return -1;
-				}
-				ret = lcd_extern_i2c_write(i2c3_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 1));
+					&table[i+1], (cmd_size-1));
 			} else if (type == LCD_EXT_CMD_TYPE_CMD_DELAY) {
-				if (!i2c0_dev) {
+				if (i2c0_dev == NULL) {
 					EXTERR("invalid i2c0 device\n");
 					return -1;
 				}
 				ret = lcd_extern_i2c_write(i2c0_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 2));
+					&table[i+1], (cmd_size-2));
 				if (table[i+cmd_size-1] > 0)
 					mdelay(table[i+cmd_size-1]);
 			} else if (type == LCD_EXT_CMD_TYPE_CMD2_DELAY) {
-				if (!i2c1_dev) {
+				if (i2c1_dev == NULL) {
 					EXTERR("invalid i2c1 device\n");
 					return -1;
 				}
 				ret = lcd_extern_i2c_write(i2c1_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 2));
+					&table[i+1], (cmd_size-2));
 				if (table[i+cmd_size-1] > 0)
 					mdelay(table[i+cmd_size-1]);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD3_DELAY) {
-				if (!i2c2_dev) {
-					EXTERR("invalid i2c2 device\n");
-					return -1;
-				}
-				ret = lcd_extern_i2c_write(i2c2_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 2));
-				if (table[i + cmd_size - 1] > 0)
-					mdelay(table[i + cmd_size - 1]);
-			} else if (type == LCD_EXT_CMD_TYPE_CMD4_DELAY) {
-				if (!i2c3_dev) {
-					EXTERR("invalid i2c3 device\n");
-					return -1;
-				}
-				ret = lcd_extern_i2c_write(i2c3_dev->client,
-							   &table[i + 1],
-							   (cmd_size - 2));
-				if (table[i + cmd_size - 1] > 0)
-					mdelay(table[i + cmd_size - 1]);
 			} else {
 				EXTERR("%s: %s(%d): type 0x%02x invalid\n",
 					__func__, ext_config->name,
@@ -841,7 +546,7 @@ int aml_lcd_extern_default_probe(struct aml_lcd_extern_driver_s *ext_drv)
 		if (ext_config->i2c_addr < LCD_EXT_I2C_ADDR_INVALID) {
 			i2c0_dev = lcd_extern_get_i2c_device(
 					ext_config->i2c_addr);
-			if (!i2c0_dev) {
+			if (i2c0_dev == NULL) {
 				EXTERR("invalid i2c0 device\n");
 				return -1;
 			}
@@ -851,7 +556,7 @@ int aml_lcd_extern_default_probe(struct aml_lcd_extern_driver_s *ext_drv)
 		if (ext_config->i2c_addr2 < LCD_EXT_I2C_ADDR_INVALID) {
 			i2c1_dev = lcd_extern_get_i2c_device(
 					ext_config->i2c_addr2);
-			if (!i2c1_dev) {
+			if (i2c1_dev == NULL) {
 				EXTERR("invalid i2c1 device\n");
 				i2c0_dev = NULL;
 				return -1;
@@ -859,31 +564,6 @@ int aml_lcd_extern_default_probe(struct aml_lcd_extern_driver_s *ext_drv)
 			EXTPR("get i2c1 device: %s, addr 0x%02x OK\n",
 				i2c1_dev->name, i2c1_dev->client->addr);
 		}
-		if (ext_config->i2c_addr3 < LCD_EXT_I2C_ADDR_INVALID) {
-			i2c2_dev = lcd_extern_get_i2c_device(
-					ext_config->i2c_addr3);
-			if (!i2c2_dev) {
-				EXTERR("invalid i2c2 device\n");
-				i2c0_dev = NULL;
-				i2c1_dev = NULL;
-				return -1;
-			}
-			EXTPR("get i2c2 device: %s, addr 0x%02x OK\n",
-			      i2c2_dev->name, i2c2_dev->client->addr);
-		}
-		if (ext_config->i2c_addr4 < LCD_EXT_I2C_ADDR_INVALID) {
-			i2c3_dev = lcd_extern_get_i2c_device(
-					ext_config->i2c_addr4);
-			if (!i2c3_dev) {
-				EXTERR("invalid i2c3 device\n");
-				i2c0_dev = NULL;
-				i2c1_dev = NULL;
-				i2c2_dev = NULL;
-				return -1;
-			}
-			EXTPR("get i2c3 device: %s, addr 0x%02x OK\n",
-			      i2c3_dev->name, i2c3_dev->client->addr);
-		}
 		break;
 	case LCD_EXTERN_SPI:
 		break;
@@ -902,8 +582,6 @@ int aml_lcd_extern_default_remove(void)
 {
 	i2c0_dev = NULL;
 	i2c1_dev = NULL;
-	i2c2_dev = NULL;
-	i2c3_dev = NULL;
 	ext_config = NULL;
 
 	return 0;
diff --git a/drivers/amlogic/media/vout/lcd/lcd_extern/i2c_CS602.c b/drivers/amlogic/media/vout/lcd/lcd_extern/i2c_CS602.c
index a7ce66296233..840ae1f60a89 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_extern/i2c_CS602.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_extern/i2c_CS602.c
@@ -145,8 +145,7 @@ static int lcd_extern_power_cmd_dynamic_size(unsigned char *table, int flag)
 				delay_ms += table[i+2+j];
 			if (delay_ms > 0)
 				mdelay(delay_ms);
-		} else if ((type == LCD_EXT_CMD_TYPE_CMD) ||
-			   (type == LCD_EXT_CMD_TYPE_CMD_BIN)) {
+		} else if (type == LCD_EXT_CMD_TYPE_CMD) {
 			if (i2c_dev == NULL) {
 				EXTERR("invalid i2c device\n");
 				return -1;
@@ -213,8 +212,7 @@ static int lcd_extern_power_cmd_fixed_size(unsigned char *table, int flag)
 				delay_ms += table[i+1+j];
 			if (delay_ms > 0)
 				mdelay(delay_ms);
-		} else if ((type == LCD_EXT_CMD_TYPE_CMD) ||
-			   (type == LCD_EXT_CMD_TYPE_CMD_BIN)) {
+		} else if (type == LCD_EXT_CMD_TYPE_CMD) {
 			if (i2c_dev == NULL) {
 				EXTERR("invalid i2c device\n");
 				return -1;
diff --git a/drivers/amlogic/media/vout/lcd/lcd_extern/lcd_extern.c b/drivers/amlogic/media/vout/lcd/lcd_extern/lcd_extern.c
index 27c38b6379fa..6369c67163c2 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_extern/lcd_extern.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_extern/lcd_extern.c
@@ -31,25 +31,12 @@
 #include "lcd_extern.h"
 
 static struct device *lcd_extern_dev;
-static struct aml_lcd_extern_driver_s *lcd_ext_driver[EXTERN_MUL_MAX];
+static struct aml_lcd_extern_driver_s *lcd_ext_driver;
 
-static int lcd_extern_drv_cnt;
-static int lcd_extern_index_lut[EXTERN_MUL_MAX];
 static unsigned char lcd_ext_config_load;
 static unsigned char *table_init_on_dft;
 static unsigned char *table_init_off_dft;
 
-struct lcd_ext_common_s lcd_ext_common = {
-	.key_valid = 0,
-	.i2c_bus = LCD_EXT_I2C_BUS_INVALID,
-	.i2c_sck_gpio = LCD_EXT_GPIO_INVALID,
-	.i2c_sda_gpio = LCD_EXT_GPIO_INVALID,
-
-	.pinmux_valid = 0,
-	.pinmux_gpio_off = 2,
-	.pinmux_flag = 0xff,
-};
-
 struct lcd_ext_gpio_s {
 	char name[15];
 	struct gpio_desc *gpio;
@@ -71,12 +58,16 @@ static struct lcd_extern_config_s lcd_extern_config = {
 	.name = "invalid",
 	.type = LCD_EXTERN_MAX,
 	.status = 0,
+	.pinmux_valid = 0,
+	.pinmux_gpio_off = 2,
+	.key_valid = 0,
 	.addr_sel = 0,
 
 	.i2c_addr = LCD_EXT_I2C_ADDR_INVALID,
 	.i2c_addr2 = LCD_EXT_I2C_ADDR_INVALID,
-	.i2c_addr3 = LCD_EXT_I2C_ADDR_INVALID,
-	.i2c_addr4 = LCD_EXT_I2C_ADDR_INVALID,
+	.i2c_bus = LCD_EXT_I2C_BUS_INVALID,
+	.i2c_sck_gpio = LCD_EXT_GPIO_INVALID,
+	.i2c_sda_gpio = LCD_EXT_GPIO_INVALID,
 
 	.spi_gpio_cs = LCD_EXT_GPIO_INVALID,
 	.spi_gpio_clk = LCD_EXT_GPIO_INVALID,
@@ -91,47 +82,26 @@ static struct lcd_extern_config_s lcd_extern_config = {
 	.table_init_off_cnt = 0,
 	.table_init_on = NULL,
 	.table_init_off = NULL,
-	.common_config = &lcd_ext_common,
 };
 
 struct aml_lcd_extern_driver_s *aml_lcd_extern_get_driver(int index)
 {
-	int i = 0;
+	if (lcd_ext_driver == NULL) {
+		EXTERR("invalid driver\n");
+		return NULL;
+	}
 
 	if (index >= LCD_EXTERN_INDEX_INVALID) {
 		EXTERR("invalid driver index: %d\n", index);
 		return NULL;
 	}
-
-	for (i = 0; i < lcd_extern_drv_cnt; i++) {
-		if (lcd_ext_driver[i] &&
-		    (lcd_ext_driver[i]->config->index == index))
-			return lcd_ext_driver[i];
-	}
+	if (lcd_ext_driver->config->index == index)
+		return lcd_ext_driver;
 
 	EXTERR("invalid driver index: %d\n", index);
 	return NULL;
 }
 
-void lcd_extern_index_lut_add(int index)
-{
-	int i;
-
-	if (lcd_extern_drv_cnt >= EXTERN_MUL_MAX) {
-		EXTERR("extern drv cnt(%d) is out of support(%d)\n",
-		       lcd_extern_drv_cnt, EXTERN_MUL_MAX);
-		return;
-	}
-
-	for (i = 0; i < lcd_extern_drv_cnt; i++) {
-		if (lcd_extern_index_lut[i] == index)
-			return;
-	}
-
-	lcd_extern_index_lut[lcd_extern_drv_cnt] = index;
-	lcd_extern_drv_cnt++;
-}
-
 #ifdef CONFIG_OF
 void lcd_extern_gpio_probe(unsigned char index)
 {
@@ -336,7 +306,10 @@ void lcd_extern_pinmux_set(int status)
 {
 	int index = 0xff;
 
-	if (lcd_ext_common.pinmux_valid == 0) {
+	if (lcd_ext_driver == NULL)
+		return;
+
+	if (lcd_ext_driver->config->pinmux_valid == 0) {
 		if (lcd_debug_print_flag)
 			EXTPR("%s: pinmux invalid, bypass\n", __func__);
 		return;
@@ -347,25 +320,31 @@ void lcd_extern_pinmux_set(int status)
 
 	index = (status) ? 0 : 1;
 
-	if (lcd_ext_common.pinmux_flag == index) {
-		EXTPR("pinmux %s is already selected\n",
-		      lcd_extern_pinmux_str[index]);
+	if (lcd_ext_driver->pinmux_flag == index) {
+		EXTPR("%s(%d) pinmux %s is already selected\n",
+			lcd_ext_driver->config->name,
+			lcd_ext_driver->config->index,
+			lcd_extern_pinmux_str[index]);
 		return;
 	}
 
 	/* request pinmux */
-	lcd_ext_common.pin = devm_pinctrl_get_select(lcd_extern_dev,
-				      lcd_extern_pinmux_str[index]);
-	if (IS_ERR(lcd_ext_common.pin)) {
-		EXTERR("set pinmux %s error\n",
-		       lcd_extern_pinmux_str[index]);
+	lcd_ext_driver->pin = devm_pinctrl_get_select(lcd_extern_dev,
+		lcd_extern_pinmux_str[index]);
+	if (IS_ERR(lcd_ext_driver->pin)) {
+		EXTERR("set %s(%d) pinmux %s error\n",
+			lcd_ext_driver->config->name,
+			lcd_ext_driver->config->index,
+			lcd_extern_pinmux_str[index]);
 	} else {
 		if (lcd_debug_print_flag) {
-			EXTPR("set pinmux %s ok\n",
-			      lcd_extern_pinmux_str[index]);
+			EXTPR("set %s(%d) pinmux %s ok\n",
+				lcd_ext_driver->config->name,
+				lcd_ext_driver->config->index,
+				lcd_extern_pinmux_str[index]);
 		}
 	}
-	lcd_ext_common.pinmux_flag = index;
+	lcd_ext_driver->pinmux_flag = index;
 }
 
 #ifdef CONFIG_OF
@@ -648,9 +627,9 @@ static int lcd_extern_init_table_fixed_size_load_dts(
 }
 
 static int lcd_extern_get_config_dts(struct device_node *of_node,
-				     struct lcd_extern_config_s *extconf,
-				     unsigned int ext_index)
+		struct lcd_extern_config_s *extconf)
 {
+	unsigned int ext_index = LCD_EXTERN_INDEX_INVALID;
 	char ext_propname[20];
 	struct device_node *child;
 	const char *str;
@@ -662,6 +641,11 @@ static int lcd_extern_get_config_dts(struct device_node *of_node,
 	extconf->status = 0;
 	extconf->table_init_loaded = 0;
 
+	aml_lcd_notifier_call_chain(LCD_EVENT_EXTERN_SEL, &ext_index);
+	if (ext_index == LCD_EXTERN_INDEX_INVALID) {
+		EXTPR("%s: invalid index\n", __func__);
+		return -1;
+	}
 	sprintf(ext_propname, "extern_%d", ext_index);
 	if (lcd_debug_print_flag)
 		EXTPR("%s: %s\n", __func__, ext_propname);
@@ -716,13 +700,11 @@ static int lcd_extern_get_config_dts(struct device_node *of_node,
 
 	switch (extconf->type) {
 	case LCD_EXTERN_I2C:
-		if (extconf->common_config->i2c_bus ==
-		    LCD_EXT_I2C_BUS_INVALID)
+		if (extconf->i2c_bus == LCD_EXT_I2C_BUS_INVALID)
 			EXTERR("%s: get i2c_bus failed\n", extconf->name);
 		if (lcd_debug_print_flag) {
 			EXTPR("%s: i2c_bus = %d\n",
-			      extconf->name,
-			      extconf->common_config->i2c_bus);
+				extconf->name, extconf->i2c_bus);
 		}
 		ret = of_property_read_u32(child, "i2c_address", &val);
 		if (ret) {
@@ -741,10 +723,8 @@ static int lcd_extern_get_config_dts(struct device_node *of_node,
 			ret = of_property_read_u32(child,
 				"i2c_second_address", &val);
 			if (ret) {
-				if (lcd_debug_print_flag) {
-					EXTPR("%s: no i2c_address2 exist\n",
-					      extconf->name);
-				}
+				EXTPR("%s: no i2c_address2 exist\n",
+					extconf->name);
 				extconf->i2c_addr2 = LCD_EXT_I2C_ADDR_INVALID;
 			} else {
 				extconf->i2c_addr2 = (unsigned char)val;
@@ -756,34 +736,6 @@ static int lcd_extern_get_config_dts(struct device_node *of_node,
 			EXTPR("%s: i2c_address2 = 0x%02x\n",
 				extconf->name, extconf->i2c_addr2);
 		}
-		ret = of_property_read_u32(child, "i2c_address3", &val);
-		if (ret) {
-			if (lcd_debug_print_flag) {
-				EXTPR("%s: no i2c_address3 exist\n",
-				      extconf->name);
-			}
-			extconf->i2c_addr3 = LCD_EXT_I2C_ADDR_INVALID;
-		} else {
-			extconf->i2c_addr3 = (unsigned char)val;
-		}
-		if (lcd_debug_print_flag) {
-			EXTPR("%s: i2c_address3 = 0x%02x\n",
-			      extconf->name, extconf->i2c_addr3);
-		}
-		ret = of_property_read_u32(child, "i2c_address4", &val);
-		if (ret) {
-			if (lcd_debug_print_flag) {
-				EXTPR("%s: no i2c_address4 exist\n",
-				      extconf->name);
-			}
-			extconf->i2c_addr4 = LCD_EXT_I2C_ADDR_INVALID;
-		} else {
-			extconf->i2c_addr4 = (unsigned char)val;
-		}
-		if (lcd_debug_print_flag) {
-			EXTPR("%s: i2c_address4 = 0x%02x\n",
-			      extconf->name, extconf->i2c_addr4);
-		}
 
 		ret = of_property_read_u32(child, "cmd_size", &val);
 		if (ret) {
@@ -1244,25 +1196,10 @@ static int lcd_extern_get_config_unifykey(struct lcd_extern_config_s *extconf)
 	/* type: 10byte */
 	switch (extconf->type) {
 	case LCD_EXTERN_I2C:
-		if (*(p + LCD_UKEY_EXT_TYPE_VAL_0))
-			extconf->i2c_addr = *(p + LCD_UKEY_EXT_TYPE_VAL_0);
-		else
-			extconf->i2c_addr = LCD_EXT_I2C_ADDR_INVALID;
-		if (*(p + LCD_UKEY_EXT_TYPE_VAL_1))
-			extconf->i2c_addr2 = *(p + LCD_UKEY_EXT_TYPE_VAL_1);
-		else
-			extconf->i2c_addr2 = LCD_EXT_I2C_ADDR_INVALID;
-		if (*(p + LCD_UKEY_EXT_TYPE_VAL_4))
-			extconf->i2c_addr3 = *(p + LCD_UKEY_EXT_TYPE_VAL_4);
-		else
-			extconf->i2c_addr3 = LCD_EXT_I2C_ADDR_INVALID;
-		if (*(p + LCD_UKEY_EXT_TYPE_VAL_5))
-			extconf->i2c_addr4 = *(p + LCD_UKEY_EXT_TYPE_VAL_5);
-		else
-			extconf->i2c_addr4 = LCD_EXT_I2C_ADDR_INVALID;
+		extconf->i2c_addr = *(p + LCD_UKEY_EXT_TYPE_VAL_0);
+		extconf->i2c_addr2 = *(p + LCD_UKEY_EXT_TYPE_VAL_1);
 		/*extconf->i2c_bus = *(p + LCD_UKEY_EXT_TYPE_VAL_2);*/
-		if (extconf->common_config->i2c_bus ==
-		    LCD_EXT_I2C_BUS_MAX)
+		if (extconf->i2c_bus == LCD_EXT_I2C_BUS_MAX)
 			EXTERR("%s: get i2c_bus failed\n", extconf->name);
 
 		extconf->cmd_size = *(p + LCD_UKEY_EXT_TYPE_VAL_3);
@@ -1404,10 +1341,11 @@ static int lcd_extern_table_init_save(struct lcd_extern_config_s *extconf)
 	return 0;
 }
 
-static int lcd_extern_common_get_config(void)
+static int lcd_extern_get_config(void)
 {
 	unsigned int extern_para[5];
 	const char *str;
+	unsigned int load_id = 0;
 	int ret;
 
 	if (lcd_extern_dev->of_node == NULL) {
@@ -1415,35 +1353,39 @@ static int lcd_extern_common_get_config(void)
 		return -1;
 	}
 
+	ret = lcd_extern_table_init_dft_malloc();
+	if (ret)
+		return -1;
+
 	ret = of_property_read_string(lcd_extern_dev->of_node, "i2c_bus", &str);
 	if (ret)
-		lcd_ext_common.i2c_bus = LCD_EXT_I2C_BUS_MAX;
+		lcd_extern_config.i2c_bus = LCD_EXT_I2C_BUS_MAX;
 	else
-		lcd_ext_common.i2c_bus = lcd_extern_get_i2c_bus_str(str);
+		lcd_extern_config.i2c_bus = lcd_extern_get_i2c_bus_str(str);
 
 	ret = of_property_read_u32_array(lcd_extern_dev->of_node,
 			"i2c_gpio", &extern_para[0], 2);
 	if (ret) {
-		lcd_ext_common.i2c_sck_gpio = LCD_EXT_GPIO_INVALID;
-		lcd_ext_common.i2c_sda_gpio = LCD_EXT_GPIO_INVALID;
+		lcd_extern_config.i2c_sck_gpio = LCD_EXT_GPIO_INVALID;
+		lcd_extern_config.i2c_sda_gpio = LCD_EXT_GPIO_INVALID;
 	} else {
-		lcd_ext_common.i2c_sck_gpio = (unsigned char)extern_para[0];
-		lcd_ext_common.i2c_sda_gpio = (unsigned char)extern_para[1];
+		lcd_extern_config.i2c_sck_gpio = (unsigned char)extern_para[0];
+		lcd_extern_config.i2c_sda_gpio = (unsigned char)extern_para[1];
 	}
 
 	ret = of_property_read_string(lcd_extern_dev->of_node,
 			"pinctrl-names", &str);
 	if (ret)
-		lcd_ext_common.pinmux_valid = 0;
+		lcd_extern_config.pinmux_valid = 0;
 	else
-		lcd_ext_common.pinmux_valid = 1;
+		lcd_extern_config.pinmux_valid = 1;
 
 	ret = of_property_read_u32(lcd_extern_dev->of_node,
 			"pinctrl_gpio_off", &extern_para[0]);
 	if (ret) {
-		lcd_ext_common.pinmux_gpio_off = 2;
+		lcd_extern_config.pinmux_gpio_off = 2;
 	} else {
-		lcd_ext_common.pinmux_gpio_off =
+		lcd_extern_config.pinmux_gpio_off =
 			(unsigned char)extern_para[0];
 	}
 
@@ -1452,39 +1394,13 @@ static int lcd_extern_common_get_config(void)
 	if (ret) {
 		if (lcd_debug_print_flag)
 			EXTPR("failed to get key_valid\n");
-		lcd_ext_common.key_valid = 0;
+		lcd_extern_config.key_valid = 0;
 	} else {
-		lcd_ext_common.key_valid = (unsigned char)extern_para[0];
+		lcd_extern_config.key_valid = (unsigned char)extern_para[0];
 	}
-	EXTPR("key_valid: %d\n", lcd_ext_common.key_valid);
+	EXTPR("key_valid: %d\n", lcd_extern_config.key_valid);
 
-	return 0;
-}
-
-static struct lcd_extern_config_s *lcd_extern_get_config_load(unsigned int
-							      index)
-{
-	struct lcd_extern_config_s *extern_config;
-	unsigned int load_id = 0;
-	int ret = 0;
-
-	extern_config =
-		kzalloc(sizeof(struct lcd_extern_config_s), GFP_KERNEL);
-	if (!extern_config) {
-		EXTERR("failed to alloc extern config[%d]\n", index);
-		return NULL;
-	}
-
-	memcpy(extern_config, &lcd_extern_config,
-	       sizeof(struct lcd_extern_config_s));
-
-	ret = lcd_extern_table_init_dft_malloc();
-	if (ret) {
-		kfree(extern_config);
-		return NULL;
-	}
-
-	if (lcd_ext_common.key_valid) {
+	if (lcd_extern_config.key_valid) {
 		ret = lcd_unifykey_check("lcd_extern");
 		if (ret < 0)
 			load_id = 0;
@@ -1495,33 +1411,32 @@ static struct lcd_extern_config_s *lcd_extern_get_config_load(unsigned int
 	if (load_id) {
 		EXTPR("%s from unifykey\n", __func__);
 		lcd_ext_config_load = 1;
-		ret = lcd_extern_get_config_unifykey(extern_config);
+		ret = lcd_extern_get_config_unifykey(&lcd_extern_config);
 	} else {
 #ifdef CONFIG_OF
 		EXTPR("%s from dts\n", __func__);
 		lcd_ext_config_load = 0;
 		ret = lcd_extern_get_config_dts(lcd_extern_dev->of_node,
-						extern_config, index);
+			&lcd_extern_config);
 #endif
 	}
 	if (ret)
 		goto lcd_extern_get_config_err;
 
-	if (extern_config->table_init_loaded > 0) {
-		ret = lcd_extern_table_init_save(extern_config);
+	if (lcd_extern_config.table_init_loaded > 0) {
+		ret = lcd_extern_table_init_save(&lcd_extern_config);
 		if (ret)
 			goto lcd_extern_get_config_err;
 	}
 
 	kfree(table_init_on_dft);
 	kfree(table_init_off_dft);
-	return extern_config;
+	return 0;
 
 lcd_extern_get_config_err:
 	kfree(table_init_on_dft);
 	kfree(table_init_off_dft);
-	kfree(extern_config);
-	return NULL;
+	return -1;
 }
 
 static int lcd_extern_add_i2c(struct aml_lcd_extern_driver_s *ext_drv)
@@ -1642,8 +1557,7 @@ static int lcd_extern_add_invalid(struct aml_lcd_extern_driver_s *ext_drv)
 	return -1;
 }
 
-static int lcd_extern_add_driver(struct lcd_extern_config_s *extconf,
-				 unsigned int index)
+static int lcd_extern_add_driver(struct lcd_extern_config_s *extconf)
 {
 	struct aml_lcd_extern_driver_s *ext_drv;
 	int ret = 0;
@@ -1654,15 +1568,17 @@ static int lcd_extern_add_driver(struct lcd_extern_config_s *extconf,
 		return -1;
 	}
 
-	lcd_ext_driver[index] =
+	lcd_ext_driver =
 		kzalloc(sizeof(struct aml_lcd_extern_driver_s), GFP_KERNEL);
-	if (!lcd_ext_driver[index]) {
+	if (lcd_ext_driver == NULL) {
 		EXTERR("failed to alloc driver %s[%d], not enough memory\n",
 			extconf->name, extconf->index);
 		return -1;
 	}
-	ext_drv = lcd_ext_driver[index];
+	ext_drv = lcd_ext_driver;
+
 	ext_drv->config = extconf;
+	ext_drv->pinmux_flag = 0xff;
 	ext_drv->reg_read  = NULL;
 	ext_drv->reg_write = NULL;
 	ext_drv->power_on  = NULL;
@@ -1685,17 +1601,17 @@ static int lcd_extern_add_driver(struct lcd_extern_config_s *extconf,
 	}
 	if (ret) {
 		EXTERR("add driver failed\n");
-		kfree(lcd_ext_driver[index]->config->table_init_on);
-		kfree(lcd_ext_driver[index]->config->table_init_off);
-		kfree(lcd_ext_driver[index]->config);
-		kfree(lcd_ext_driver[index]);
-		lcd_ext_driver[index] = NULL;
+		kfree(lcd_ext_driver->config->table_init_on);
+		kfree(lcd_ext_driver->config->table_init_off);
+		lcd_ext_driver->config->table_init_on = NULL;
+		lcd_ext_driver->config->table_init_off = NULL;
+		kfree(lcd_ext_driver);
+		lcd_ext_driver = NULL;
 		return -1;
 	}
 
 	EXTPR("add driver %s(%d)\n",
-	      ext_drv->config->name, ext_drv->config->index);
-
+		ext_drv->config->name, ext_drv->config->index);
 	return 0;
 }
 
@@ -1708,7 +1624,7 @@ static void lcd_extern_init_table_dynamic_size_print(
 		struct lcd_extern_config_s *econf, int flag)
 {
 	int i, j, k, max_len;
-	unsigned char type, size;
+	unsigned char cmd_size;
 	char *str;
 	unsigned char *table;
 
@@ -1737,54 +1653,44 @@ static void lcd_extern_init_table_dynamic_size_print(
 	case LCD_EXTERN_I2C:
 	case LCD_EXTERN_SPI:
 		while ((i + 1) < max_len) {
-			type = table[i];
-			size = table[i + 1];
-			if (type == LCD_EXT_CMD_TYPE_END) {
-				pr_info("  0x%02x,%d,\n", type, size);
+			if (table[i] == LCD_EXT_CMD_TYPE_END) {
+				pr_info("  0x%02x,%d,\n",
+					table[i], table[i+1]);
 				break;
 			}
+			cmd_size = table[i+1];
 
 			k = snprintf(str, EXT_LEN_MAX, "  0x%02x,%d,",
-				type, size);
-			if (size == 0)
+				table[i], cmd_size);
+			if (cmd_size == 0)
 				goto init_table_dynamic_print_i2c_spi_next;
-			if (i + 2 + size > max_len) {
-				pr_info("size out of support\n");
+			if (i + 2 + cmd_size > max_len) {
+				pr_info("cmd_size out of support\n");
 				break;
 			}
 
-			if ((type == LCD_EXT_CMD_TYPE_GPIO) ||
-			    (type == LCD_EXT_CMD_TYPE_DELAY)) {
-				for (j = 0; j < size; j++) {
+			if ((table[i] == LCD_EXT_CMD_TYPE_GPIO) ||
+				(table[i] == LCD_EXT_CMD_TYPE_DELAY)) {
+				for (j = 0; j < cmd_size; j++) {
 					k += snprintf(str+k, EXT_LEN_MAX,
 						"%d,", table[i+2+j]);
 				}
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4_BIN) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD_BIN_DATA) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD2_BIN_DATA) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD3_BIN_DATA) ||
-				   (type == LCD_EXT_CMD_TYPE_CMD4_BIN_DATA)) {
-				for (j = 0; j < size; j++) {
+			} else if ((table[i] == LCD_EXT_CMD_TYPE_CMD) ||
+				(table[i] == LCD_EXT_CMD_TYPE_CMD2)) {
+				for (j = 0; j < cmd_size; j++) {
 					k += snprintf(str+k, EXT_LEN_MAX,
 						"0x%02x,", table[i+2+j]);
 				}
-			} else if ((type == LCD_EXT_CMD_TYPE_CMD_DELAY) ||
-				(type == LCD_EXT_CMD_TYPE_CMD2_DELAY)) {
-				for (j = 0; j < (size - 1); j++) {
+			} else if ((table[i] == LCD_EXT_CMD_TYPE_CMD_DELAY) ||
+				(table[i] == LCD_EXT_CMD_TYPE_CMD2_DELAY)) {
+				for (j = 0; j < (cmd_size - 1); j++) {
 					k += snprintf(str+k, EXT_LEN_MAX,
 						"0x%02x,", table[i+2+j]);
 				}
 				snprintf(str+k, EXT_LEN_MAX,
-					 "%d,", table[i + size + 1]);
+					"%d,", table[i+cmd_size+1]);
 			} else {
-				for (j = 0; j < size; j++) {
+				for (j = 0; j < cmd_size; j++) {
 					k += snprintf(str+k, EXT_LEN_MAX,
 						"0x%02x,", table[i+2+j]);
 				}
@@ -1792,50 +1698,50 @@ static void lcd_extern_init_table_dynamic_size_print(
 
 init_table_dynamic_print_i2c_spi_next:
 			pr_info("%s\n", str);
-			i += (size + 2);
+			i += (cmd_size + 2);
 		}
 		break;
 	case LCD_EXTERN_MIPI:
 		while ((i + 1) < max_len) {
-			type = table[i];
-			size = table[i + 1];
-			if (type == LCD_EXT_CMD_TYPE_END) {
-				if (size == 0xff) {
+			cmd_size = table[i+1];
+			if (table[i] == LCD_EXT_CMD_TYPE_END) {
+				if (cmd_size == 0xff) {
 					pr_info("  0x%02x,0x%02x,\n",
-						type, size);
+						table[i], table[i+1]);
 					break;
 				}
-				if (size == 0) {
-					pr_info("  0x%02x,%d,\n", type, size);
+				if (cmd_size == 0) {
+					pr_info("  0x%02x,%d,\n",
+						table[i], table[i+1]);
 					break;
 				}
-				size = 0;
+				cmd_size = 0;
 			}
 
 			k = snprintf(str, EXT_LEN_MAX, "  0x%02x,%d,",
-				     type, size);
-			if (size == 0)
+				table[i], cmd_size);
+			if (cmd_size == 0)
 				goto init_table_dynamic_print_mipi_next;
-			if (i + 2 + size > max_len) {
-				pr_info("size out of support\n");
+			if (i + 2 + cmd_size > max_len) {
+				pr_info("cmd_size out of support\n");
 				break;
 			}
 
-			if ((type == LCD_EXT_CMD_TYPE_GPIO) ||
-			    (type == LCD_EXT_CMD_TYPE_DELAY)) {
-				for (j = 0; j < size; j++) {
+			if ((table[i] == LCD_EXT_CMD_TYPE_GPIO) ||
+				(table[i] == LCD_EXT_CMD_TYPE_DELAY)) {
+				for (j = 0; j < cmd_size; j++) {
 					k += snprintf(str+k, EXT_LEN_MAX,
 						"%d,", table[i+2+j]);
 				}
-			} else if ((type & 0xf) == 0x0) {
+			} else if ((table[i] & 0xf) == 0x0) {
 				pr_info("  init_%s wrong data_type: 0x%02x\n",
-					flag ? "on" : "off", type);
+					flag ? "on" : "off", table[i]);
 				break;
 			} else {
-				size = table[i + DSI_CMD_SIZE_INDEX];
+				cmd_size = table[i+DSI_CMD_SIZE_INDEX];
 				k = snprintf(str, EXT_LEN_MAX, "  0x%02x,%d,",
-					     type, size);
-				for (j = 0; j < size; j++) {
+					table[i], cmd_size);
+				for (j = 0; j < cmd_size; j++) {
 					k += snprintf(str+k, EXT_LEN_MAX,
 						"0x%02x,",
 						table[i+2+j]);
@@ -1844,7 +1750,7 @@ static void lcd_extern_init_table_dynamic_size_print(
 
 init_table_dynamic_print_mipi_next:
 			pr_info("%s\n", str);
-			i += (size + 2);
+			i += (cmd_size + 2);
 		}
 		break;
 	default:
@@ -1902,105 +1808,87 @@ static ssize_t lcd_extern_info_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
 	struct lcd_extern_config_s *econf;
-	int i = 0;
 
-	for (i = 0; i < lcd_extern_drv_cnt; i++) {
-		if (!lcd_ext_driver[i])
-			return -EINVAL;
-		econf = lcd_ext_driver[i]->config;
-		pr_info("lcd extern driver %s(%d) info:\n",
-			econf->name, econf->index);
-		pr_info("status:             %d\n", econf->status);
-		switch (econf->type) {
-		case LCD_EXTERN_I2C:
-			pr_info("type:               i2c(%d)\n", econf->type);
-			pr_info("i2c_addr:           0x%02x\n"
-				"i2c_addr2:          0x%02x\n"
-				"i2c_addr3:          0x%02x\n"
-				"i2c_addr4:          0x%02x\n"
-				"i2c_bus:            %d\n"
-				"table_loaded:       %d\n"
-				"cmd_size:           %d\n"
-				"table_init_on_cnt:  %d\n"
-				"table_init_off_cnt: %d\n",
-				econf->i2c_addr, econf->i2c_addr2,
-				econf->i2c_addr3, econf->i2c_addr4,
-				econf->common_config->i2c_bus,
-				econf->table_init_loaded, econf->cmd_size,
-				econf->table_init_on_cnt,
-				econf->table_init_off_cnt);
-			if (econf->cmd_size == 0)
-				break;
-			if (econf->cmd_size == LCD_EXT_CMD_SIZE_DYNAMIC) {
-				lcd_extern_init_table_dynamic_size_print
-					(econf, 1);
-				lcd_extern_init_table_dynamic_size_print
-					(econf, 0);
-			} else {
-				lcd_extern_init_table_fixed_size_print
-					(econf, 1);
-				lcd_extern_init_table_fixed_size_print
-					(econf, 0);
-			}
+	if (lcd_ext_driver == NULL)
+		return sprintf(buf, "lcd extern  driver is NULL\n");
+
+	econf = lcd_ext_driver->config;
+	pr_info("lcd extern driver %s(%d) info:\n", econf->name, econf->index);
+	pr_info("status:             %d\n", econf->status);
+	switch (econf->type) {
+	case LCD_EXTERN_I2C:
+		pr_info("type:               i2c(%d)\n", econf->type);
+		pr_info("i2c_addr:           0x%02x\n"
+			"i2c_addr2:          0x%02x\n"
+			"i2c_bus:            %d\n"
+			"table_loaded:       %d\n"
+			"cmd_size:           %d\n"
+			"table_init_on_cnt:  %d\n"
+			"table_init_off_cnt: %d\n",
+			econf->i2c_addr, econf->i2c_addr2, econf->i2c_bus,
+			econf->table_init_loaded, econf->cmd_size,
+			econf->table_init_on_cnt,
+			econf->table_init_off_cnt);
+		if (econf->cmd_size == 0)
 			break;
-		case LCD_EXTERN_SPI:
-			pr_info("type:               spi(%d)\n", econf->type);
-			pr_info("spi_gpio_cs:        %d\n"
-				"spi_gpio_clk:       %d\n"
-				"spi_gpio_data:      %d\n"
-				"spi_clk_freq:       %dKHz\n"
-				"spi_delay_us:       %d\n"
-				"spi_clk_pol:        %d\n"
-				"table_loaded:       %d\n"
-				"cmd_size:           %d\n"
-				"table_init_on_cnt:  %d\n"
-				"table_init_off_cnt: %d\n",
-				econf->spi_gpio_cs, econf->spi_gpio_clk,
-				econf->spi_gpio_data, econf->spi_clk_freq,
-				econf->spi_delay_us, econf->spi_clk_pol,
-				econf->table_init_loaded, econf->cmd_size,
-				econf->table_init_on_cnt,
-				econf->table_init_off_cnt);
-			if (econf->cmd_size == 0)
-				break;
-			if (econf->cmd_size == LCD_EXT_CMD_SIZE_DYNAMIC) {
-				lcd_extern_init_table_dynamic_size_print
-					(econf, 1);
-				lcd_extern_init_table_dynamic_size_print
-					(econf, 0);
-				} else {
-					lcd_extern_init_table_fixed_size_print
-						(econf, 1);
-					lcd_extern_init_table_fixed_size_print
-						(econf, 0);
-				}
-				break;
-		case LCD_EXTERN_MIPI:
-			pr_info("type:            mipi(%d)\n", econf->type);
-			pr_info("table_loaded:       %d\n"
-				"cmd_size:        %d\n"
-				"table_init_on_cnt:  %d\n"
-				"table_init_off_cnt: %d\n",
-				econf->table_init_loaded,
-				econf->cmd_size,
-				econf->table_init_on_cnt,
-				econf->table_init_off_cnt);
-			if (econf->cmd_size != LCD_EXT_CMD_SIZE_DYNAMIC)
-				break;
+		if (econf->cmd_size == LCD_EXT_CMD_SIZE_DYNAMIC) {
 			lcd_extern_init_table_dynamic_size_print(econf, 1);
 			lcd_extern_init_table_dynamic_size_print(econf, 0);
-			break;
-		default:
-			pr_info("not support extern_type\n");
-			break;
+		} else {
+			lcd_extern_init_table_fixed_size_print(econf, 1);
+			lcd_extern_init_table_fixed_size_print(econf, 0);
 		}
-
-		if (econf->common_config->pinmux_valid) {
-			pr_info("pinmux_flag:     %d\n",
-				econf->common_config->pinmux_flag);
-			pr_info("pinmux_pointer:  0x%p\n",
-				econf->common_config->pin);
+		break;
+	case LCD_EXTERN_SPI:
+		pr_info("type:               spi(%d)\n", econf->type);
+		pr_info("spi_gpio_cs:        %d\n"
+			"spi_gpio_clk:       %d\n"
+			"spi_gpio_data:      %d\n"
+			"spi_clk_freq:       %dKHz\n"
+			"spi_delay_us:       %d\n"
+			"spi_clk_pol:        %d\n"
+			"table_loaded:       %d\n"
+			"cmd_size:           %d\n"
+			"table_init_on_cnt:  %d\n"
+			"table_init_off_cnt: %d\n",
+			econf->spi_gpio_cs, econf->spi_gpio_clk,
+			econf->spi_gpio_data, econf->spi_clk_freq,
+			econf->spi_delay_us, econf->spi_clk_pol,
+			econf->table_init_loaded, econf->cmd_size,
+			econf->table_init_on_cnt,
+			econf->table_init_off_cnt);
+		if (econf->cmd_size == 0)
+			break;
+		if (econf->cmd_size == LCD_EXT_CMD_SIZE_DYNAMIC) {
+			lcd_extern_init_table_dynamic_size_print(econf, 1);
+			lcd_extern_init_table_dynamic_size_print(econf, 0);
+		} else {
+			lcd_extern_init_table_fixed_size_print(econf, 1);
+			lcd_extern_init_table_fixed_size_print(econf, 0);
 		}
+		break;
+	case LCD_EXTERN_MIPI:
+		pr_info("type:            mipi(%d)\n", econf->type);
+		pr_info("table_loaded:       %d\n"
+			"cmd_size:        %d\n"
+			"table_init_on_cnt:  %d\n"
+			"table_init_off_cnt: %d\n",
+			econf->table_init_loaded,
+			econf->cmd_size,
+			econf->table_init_on_cnt,
+			econf->table_init_off_cnt);
+		if (econf->cmd_size != LCD_EXT_CMD_SIZE_DYNAMIC)
+			break;
+		lcd_extern_init_table_dynamic_size_print(econf, 1);
+		lcd_extern_init_table_dynamic_size_print(econf, 0);
+		break;
+	default:
+		pr_info("not support extern_type\n");
+		break;
+	}
+	if (econf->pinmux_valid) {
+		pr_info("pinmux_flag:     %d\n", lcd_ext_driver->pinmux_flag);
+		pr_info("pinmux_pointer:  0x%p\n", lcd_ext_driver->pin);
 	}
 
 	return sprintf(buf, "\n");
@@ -2009,7 +1897,7 @@ static ssize_t lcd_extern_info_show(struct class *class,
 static ssize_t lcd_extern_key_valid_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", lcd_ext_common.key_valid);
+	return sprintf(buf, "%d\n", lcd_extern_config.key_valid);
 }
 
 static ssize_t lcd_extern_config_load_show(struct class *class,
@@ -2036,27 +1924,26 @@ static ssize_t lcd_extern_debug_show(struct class *class,
 static ssize_t lcd_extern_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret, j;
+	unsigned int ret, i;
 	unsigned int val[3];
 	unsigned char reg, value;
 	unsigned char reg_buf[2];
-	unsigned int index = LCD_EXTERN_INDEX_INVALID;
-	struct aml_lcd_extern_driver_s *ext_drv;
+
+	if (lcd_ext_driver == NULL) {
+		pr_info("lcd_extern_driver is null\n");
+		return count;
+	}
 
 	switch (buf[0]) {
 	case 't':
-		ret = sscanf(buf, "test %d %d", &index, &val[0]);
-		if (ret == 2) {
-			ext_drv = aml_lcd_extern_get_driver(index);
-			if (!ext_drv)
-				return -EINVAL;
-
+		ret = sscanf(buf, "test %d", &val[0]);
+		if (ret == 1) {
 			if (val[0]) {
-				if (ext_drv->power_on)
-					ext_drv->power_on();
+				if (lcd_ext_driver->power_on)
+					lcd_ext_driver->power_on();
 			} else {
-				if (ext_drv->power_off)
-					ext_drv->power_off();
+				if (lcd_ext_driver->power_off)
+					lcd_ext_driver->power_off();
 			}
 		} else {
 			pr_info("invalid data\n");
@@ -2064,18 +1951,13 @@ static ssize_t lcd_extern_debug_store(struct class *class,
 		}
 		break;
 	case 'r':
-		ret = sscanf(buf, "r %d %d %x", &index, &val[0],
-			     &val[1]);
-		if (ret == 3) {
-			ext_drv = lcd_ext_driver[index];
-			if (!ext_drv)
-				return -EINVAL;
-
-			ext_drv->config->addr_sel =
+		ret = sscanf(buf, "r %d %x", &val[0], &val[1]);
+		if (ret == 2) {
+			lcd_ext_driver->config->addr_sel =
 				(unsigned char)val[0];
 			reg = (unsigned char)val[1];
-			if (ext_drv->reg_read) {
-				ext_drv->reg_read(reg, &value);
+			if (lcd_ext_driver->reg_read) {
+				lcd_ext_driver->reg_read(reg, &value);
 				pr_info("reg read: 0x%02x = 0x%02x\n",
 					reg, value);
 			}
@@ -2085,21 +1967,15 @@ static ssize_t lcd_extern_debug_store(struct class *class,
 		}
 		break;
 	case 'd':
-		ret = sscanf(buf, "d %d %d %x %d", &index, &val[0],
-			     &val[1], &val[2]);
-		if (ret == 4) {
-			ext_drv = lcd_ext_driver[index];
-			if (!ext_drv)
-				return -EINVAL;
-
-			ext_drv->config->addr_sel =
+		ret = sscanf(buf, "d %d %x %d", &val[0], &val[1], &val[2]);
+		if (ret == 3) {
+			lcd_ext_driver->config->addr_sel =
 				(unsigned char)val[0];
 			reg = (unsigned char)val[1];
-			if (ext_drv->reg_read) {
+			if (lcd_ext_driver->reg_read) {
 				pr_info("reg dump:\n");
-				for (j = 0; j < val[2]; j++) {
-					ext_drv->reg_read
-						(reg + j, &value);
+				for (i = 0; i < val[2]; i++) {
+					lcd_ext_driver->reg_read(reg+i, &value);
 					pr_info("  0x%02x = 0x%02x\n",
 						reg, value);
 				}
@@ -2110,27 +1986,21 @@ static ssize_t lcd_extern_debug_store(struct class *class,
 		}
 		break;
 	case 'w':
-		ret = sscanf(buf, "w %d %d %x %x", &index, &val[0],
-			     &val[1], &val[2]);
-		if (ret == 4) {
-			ext_drv = lcd_ext_driver[index];
-			if (!ext_drv)
-				return -EINVAL;
-
-			ext_drv->config->addr_sel =
+		ret = sscanf(buf, "w %d %x %x", &val[0], &val[1], &val[2]);
+		if (ret == 2) {
+			lcd_ext_driver->config->addr_sel =
 				(unsigned char)val[0];
 			reg = (unsigned char)val[1];
 			value = (unsigned char)val[2];
-			if (ext_drv->reg_write) {
+			if (lcd_ext_driver->reg_write) {
 				reg_buf[0] = (unsigned char)val[1];
 				reg_buf[1] = (unsigned char)val[2];
-				ext_drv->reg_write(reg_buf, 2);
-				if (ext_drv->reg_read) {
-					ext_drv->reg_read
-						(reg, &value);
-					pr_info
-			("reg write 0x%02x = 0x%02x, readback: 0x%02x\n",
-			 reg, val[2], value);
+				lcd_ext_driver->reg_write(reg_buf, 2);
+				if (lcd_ext_driver->reg_read) {
+					lcd_ext_driver->reg_read(reg, &value);
+					pr_info(
+				"reg write 0x%02x = 0x%02x, readback: 0x%02x\n",
+					reg, val[2], value);
 				} else {
 					pr_info("reg write 0x%02x = 0x%02x\n",
 						reg, value);
@@ -2198,22 +2068,14 @@ static int remove_lcd_extern_class(void)
 
 static int aml_lcd_extern_probe(struct platform_device *pdev)
 {
-	struct lcd_extern_config_s *extern_config;
-	int ret, i = 0;
+	int ret;
 
 	lcd_extern_dev = &pdev->dev;
 
-	ret = lcd_extern_common_get_config();
-	if (ret == 0) {
-		for (i = 0; i < lcd_extern_drv_cnt; i++) {
-			extern_config = lcd_extern_get_config_load
-				(lcd_extern_index_lut[i]);
-			if (!extern_config)
-				continue;
-			lcd_extern_add_driver(extern_config,
-					      lcd_extern_index_lut[i]);
-		}
-	}
+	ret = lcd_extern_get_config();
+	if (ret == 0)
+		lcd_extern_add_driver(&lcd_extern_config);
+
 
 	creat_lcd_extern_class();
 
@@ -2223,18 +2085,13 @@ static int aml_lcd_extern_probe(struct platform_device *pdev)
 
 static int aml_lcd_extern_remove(struct platform_device *pdev)
 {
-	int i = 0;
-
 	remove_lcd_extern_class();
-	for (i = 0; i < lcd_extern_drv_cnt; i++) {
-		if (lcd_ext_driver[i]) {
-			kfree(lcd_ext_driver[i]->config->table_init_on);
-			kfree(lcd_ext_driver[i]->config->table_init_off);
-			kfree(lcd_ext_driver[i]->config);
-			kfree(lcd_ext_driver[i]);
-			lcd_ext_driver[i] = NULL;
-		}
-	}
+	kfree(lcd_ext_driver->config->table_init_on);
+	kfree(lcd_ext_driver->config->table_init_off);
+	lcd_ext_driver->config->table_init_on = NULL;
+	lcd_ext_driver->config->table_init_off = NULL;
+	kfree(lcd_ext_driver);
+	lcd_ext_driver = NULL;
 	return 0;
 }
 
diff --git a/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c b/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c
index 15e0d7989ba8..d6682b11c73b 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c
@@ -34,6 +34,61 @@
  * format:  data_type, num, data....
  * special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
  */
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+static unsigned char mipi_init_on_table[] = {
+	0x13, 1, 0x01,
+	0xfd, 1, 5,	/* delay (ms) */
+	0x13, 1, 0x11,
+	0xfd, 1, 250,	/* delay (ms) */
+
+	0x29, 6, 0xFF, 0x77, 0x01, 0x00, 0x00, 0x10,
+	0x29, 3, 0xC0, 0xE9, 0x03,
+	0x29, 3, 0xC1, 0x11, 0x02,
+	0x29, 3, 0xC2, 0x31, 0x08,
+	0x23, 2, 0xCC, 0x10,
+	0x29,17, 0xB0, 0x00, 0x0D, 0x14, 0x0D, 0x10, 0x05, 0x02, 0x08,
+	         0x08, 0x1E, 0x05, 0x13, 0x11, 0xA3, 0x29, 0x18,
+	0x29,17, 0xB1, 0x00, 0x0C, 0x14, 0x0C, 0x10, 0x05, 0x03, 0x08,
+	         0x07, 0x20, 0x05, 0x13, 0x11, 0xA4, 0x29, 0x18,
+	0x29, 6, 0xFF, 0x77, 0x01, 0x00, 0x00, 0x11,
+	0x23, 2, 0xB0, 0x6C,
+	0x23, 2, 0xB1, 0x43,
+	0x23, 2, 0xB2, 0x07,
+	0x23, 2, 0xB3, 0x80,
+	0x23, 2, 0xB5, 0x47,
+	0x23, 2, 0xB7, 0x85,
+	0x23, 2, 0xB8, 0x20,
+	0x23, 2, 0xB9, 0x10,
+	0x23, 2, 0xC1, 0x78,
+	0x23, 2, 0xC3, 0x78,
+	0x23, 2, 0xD0, 0x88,
+	0xfd, 1, 250,	/* delay (ms) */
+
+	0x29, 4, 0xE0, 0x00, 0x00, 0x02,
+	0x29,12, 0xE1, 0x08, 0x00, 0x0A, 0x00, 0x07, 0x00, 0x09, 0x00, 0x00, 0x33, 0x33,
+	0x29,15, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x29, 5, 0xE3, 0x00, 0x00, 0x33, 0x33,
+	0x29, 3, 0xE4, 0x44, 0x44,
+	0x29,17, 0xE5, 0x0E, 0x60, 0xA0, 0xA0, 0x10, 0x60, 0xA0, 0xA0,
+	         0x0A, 0x60, 0xA0, 0xA0, 0x0C, 0x60, 0xA0, 0xA0,
+	0x29, 5, 0xE6, 0x00, 0x00, 0x33, 0x33,
+	0x29, 3, 0xE7, 0x44, 0x44,
+	0x29,17, 0xE8, 0x0D, 0x60, 0xA0, 0xA0, 0x0F, 0x60, 0xA0, 0xA0,
+	         0x09, 0x60, 0xA0, 0xA0, 0x0B, 0x60, 0xA0, 0xA0,
+	0x29, 8, 0xEB, 0x02, 0x01, 0xE4, 0xE4, 0x44, 0x00, 0x40,
+	0x29, 3, 0xEC, 0x02, 0x01,
+	0x29,17, 0xED, 0xAB, 0x89, 0x76, 0x54, 0x01, 0xFF, 0xFF, 0xFF,
+	         0xFF, 0xFF, 0xFF, 0x10, 0x45, 0x67, 0x98, 0xBA,
+	0x29, 6, 0xFF, 0x77, 0x01, 0x00, 0x00, 0x00,
+	0x23, 2, 0x3A, 0x70,
+	0x23, 2, 0x53, 0xEC,
+	0x23, 2, 0x55, 0xB3,
+	0x23, 2, 0x5E, 0xFF,
+	0x13, 1, 0x29,
+	0xfd, 1, 50,	/* delay (ms) */
+	0xff, 0,   	/* ending flag */
+};
+#else
 static unsigned char mipi_init_on_table[] = {
 	0x13, 1, 0x11,
 	//0x13, 1, 0x21,
@@ -97,13 +152,14 @@ static unsigned char mipi_init_on_table[] = {
 	0xff, 200,     /* delay(ms) */
 	0xff, 0xff,   /* ending flag */
 };
+#endif
 
 static unsigned char mipi_init_off_table[] = {
-	0x05, 1, 0x28, /* display off */
-	0xff, 10,      /* delay 10ms */
-	0x05, 1, 0x10, /* sleep in */
-	0xff, 150,      /* delay 150ms */
-	0xff, 0xff,   /* ending flag */
+	0x05, 1, 0x28,	/* display off */
+	0xfd, 1, 10,	/* delay 10ms */
+	0x05, 1, 0x10,	/* sleep in */
+	0xfd, 1, 150,	/* delay 150ms */
+	0xff, 0,   	/* ending flag */
 };
 
 static int lcd_extern_driver_update(struct aml_lcd_extern_driver_s *ext_drv)
diff --git a/drivers/amlogic/media/vout/lcd/lcd_notify.c b/drivers/amlogic/media/vout/lcd/lcd_notify.c
index 1fec06a7c593..23d7f054324b 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_notify.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_notify.c
@@ -19,8 +19,7 @@
 #include <linux/notifier.h>
 #include <linux/amlogic/media/vout/lcd/lcd_notify.h>
 
-static BLOCKING_NOTIFIER_HEAD(lcd_block_notifier_list);
-static ATOMIC_NOTIFIER_HEAD(lcd_atomic_notifier_list);
+static BLOCKING_NOTIFIER_HEAD(lcd_notifier_list);
 
 /**
  * aml_lcd_notifier_register - register a client notifier
@@ -28,7 +27,7 @@ static ATOMIC_NOTIFIER_HEAD(lcd_atomic_notifier_list);
  */
 int aml_lcd_notifier_register(struct notifier_block *nb)
 {
-	return blocking_notifier_chain_register(&lcd_block_notifier_list, nb);
+	return blocking_notifier_chain_register(&lcd_notifier_list, nb);
 }
 EXPORT_SYMBOL(aml_lcd_notifier_register);
 
@@ -38,7 +37,7 @@ EXPORT_SYMBOL(aml_lcd_notifier_register);
  */
 int aml_lcd_notifier_unregister(struct notifier_block *nb)
 {
-	return blocking_notifier_chain_unregister(&lcd_block_notifier_list, nb);
+	return blocking_notifier_chain_unregister(&lcd_notifier_list, nb);
 }
 EXPORT_SYMBOL(aml_lcd_notifier_unregister);
 
@@ -48,36 +47,6 @@ EXPORT_SYMBOL(aml_lcd_notifier_unregister);
  */
 int aml_lcd_notifier_call_chain(unsigned long event, void *v)
 {
-	return blocking_notifier_call_chain(&lcd_block_notifier_list, event, v);
+	return blocking_notifier_call_chain(&lcd_notifier_list, event, v);
 }
 EXPORT_SYMBOL_GPL(aml_lcd_notifier_call_chain);
-
-/**
- * aml_lcd_notifier_register - register a client notifier
- * @nb: notifier block to callback on events
- */
-int aml_lcd_atomic_notifier_register(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&lcd_atomic_notifier_list, nb);
-}
-EXPORT_SYMBOL(aml_lcd_atomic_notifier_register);
-
-/**
- * aml_lcd_notifier_unregister - unregister a client notifier
- * @nb: notifier block to callback on events
- */
-int aml_lcd_atomic_notifier_unregister(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&lcd_atomic_notifier_list, nb);
-}
-EXPORT_SYMBOL(aml_lcd_atomic_notifier_unregister);
-
-/**
- * aml_lcd_notifier_call_chain - notify clients of lcd events
- *
- */
-int aml_lcd_atomic_notifier_call_chain(unsigned long event, void *v)
-{
-	return atomic_notifier_call_chain(&lcd_atomic_notifier_list, event, v);
-}
-EXPORT_SYMBOL_GPL(aml_lcd_atomic_notifier_call_chain);
diff --git a/drivers/amlogic/media/vout/lcd/lcd_phy_config.c b/drivers/amlogic/media/vout/lcd/lcd_phy_config.c
index ef484cde49e6..1509dd48a7d5 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_phy_config.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_phy_config.c
@@ -30,7 +30,6 @@
 #include "lcd_common.h"
 
 static int phy_ctrl_bit_on;
-static struct lcd_phy_ctrl_s *lcd_phy_ctrl;
 
 static unsigned int lcd_lvds_channel_on_value(struct lcd_config_s *pconf)
 {
@@ -98,27 +97,25 @@ static unsigned int lcd_lvds_channel_on_value(struct lcd_config_s *pconf)
 	return channel_on;
 }
 
-static void lcd_phy_cntl_set_tl1(int status, unsigned int chreg, int bypass,
-				 unsigned int ckdi)
+void lcd_phy_cntl_set_tl1(int status, unsigned int data32, int flag)
 {
-	unsigned int tmp = 0;
+	unsigned int cntl16 = 0x80000000;
 	unsigned int data = 0;
-	unsigned int cntl16 = 0;
+	unsigned int tmp = 0;
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s: %d\n", __func__, status);
 
 	if (status) {
-		chreg |= ((phy_ctrl_bit_on << 16) | (phy_ctrl_bit_on << 0));
-		if (bypass)
+		data32 |= ((phy_ctrl_bit_on << 16) | (phy_ctrl_bit_on << 0));
+		if (flag)
 			tmp |= ((1 << 18) | (1 << 2));
-		cntl16 = ckdi | 0x80000000;
 	} else {
 		if (phy_ctrl_bit_on)
 			data = 0;
 		else
 			data = 1;
-		chreg |= ((data << 16) | (data << 0));
+		data32 |= ((data << 16) | (data << 0));
 		cntl16 = 0;
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14, 0);
 	}
@@ -126,127 +123,24 @@ static void lcd_phy_cntl_set_tl1(int status, unsigned int chreg, int bypass,
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL15, tmp);
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL16, cntl16);
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL8, tmp);
-	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, chreg);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL9, tmp);
-	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, chreg);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, data32);
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL10, tmp);
-	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, chreg);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL11, tmp);
-	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL4, chreg);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL4, data32);
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL12, tmp);
-	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL6, chreg);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL6, data32);
 	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL13, tmp);
-	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL7, chreg);
-}
-
-/*
- *    chreg: channel ctrl
- *    bypass: 1=bypass
- *    mode: 1=normal mode, 0=low common mode
- *    ckdi: clk phase for minilvds
- */
-static void lcd_phy_cntl_set_t5(int status, unsigned int chreg, int bypass,
-				unsigned int mode, unsigned int ckdi)
-{
-	unsigned int cntl15 = 0, cntl16 = 0;
-	unsigned int data = 0;
-	unsigned int tmp = 0;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	if (status) {
-		chreg |= ((phy_ctrl_bit_on << 16) | (phy_ctrl_bit_on << 0));
-		if (bypass)
-			tmp |= ((1 << 18) | (1 << 2));
-		if (mode)
-			cntl15 = 0x00070000;
-		else
-			cntl15 = 0x000e0000;
-		cntl16 = ckdi | 0x80000000;
-	} else {
-		if (phy_ctrl_bit_on)
-			data = 0;
-		else
-			data = 1;
-		chreg |= ((data << 16) | (data << 0));
-		cntl15 = 0;
-		cntl16 = 0;
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14, 0);
-	}
-
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL15, cntl15);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL16, cntl16);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL8, tmp);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL1, chreg);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL9, tmp);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL2, chreg);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL10, tmp);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL3, chreg);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL11, tmp);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL4, chreg);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL12, tmp);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL6, chreg);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL13, tmp);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL7, chreg);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL7, data32);
 }
 
-void lcd_phy_tcon_chpi_bbc_init_tl1(struct lcd_config_s *pconf)
-{
-	unsigned int data32 = 0x06020602;
-	unsigned int preem;
-	unsigned int size;
-	unsigned int n = 10;
-	struct p2p_config_s *p2p_conf;
-
-	p2p_conf = pconf->lcd_control.p2p_config;
-	size = sizeof(p2p_low_common_phy_preem_tl1) / sizeof(unsigned int);
-
-	/*get tcon tx pre_emphasis*/
-	preem = p2p_conf->phy_preem & 0xf;
-
-	/*check tx pre_emphasis ok or no*/
-	if (preem >= size) {
-		LCDERR("%s: invalid preem=0x%x, use default\n",
-		       __func__, preem);
-		preem = 0x1;
-	}
-
-	udelay(n);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL1, 1, 3, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL1, 1, 19, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL2, 1, 3, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL2, 1, 19, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL3, 1, 3, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL3, 1, 19, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL4, 1, 3, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL4, 1, 19, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL6, 1, 3, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL6, 1, 19, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL7, 1, 3, 1);
-	lcd_ana_setb(HHI_DIF_CSI_PHY_CNTL7, 1, 19, 1);
-	LCDPR("%s: delay: %dus\n", __func__, n);
-
-	/*follow pre-emphasis*/
-	data32 = p2p_low_common_phy_preem_tl1[preem];
-
-	if (phy_ctrl_bit_on)
-		data32 &= ~((1 << 16) | (1 << 0));
-	else
-		data32 |= ((1 << 16) | (1 << 0));
-
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL1, data32);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL2, data32);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL3, data32);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL4, data32);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL6, data32);
-	lcd_ana_write(HHI_DIF_CSI_PHY_CNTL7, data32);
-}
-
-static void lcd_lvds_phy_set_txl(struct lcd_config_s *pconf, int status)
+void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 {
 	unsigned int vswing, preem, clk_vswing, clk_preem, channel_on;
-	unsigned int data32 = 0;
+	unsigned int data32 = 0, size;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lvds_config_s *lvds_conf;
 
 	if (lcd_debug_print_flag)
@@ -261,202 +155,79 @@ static void lcd_lvds_phy_set_txl(struct lcd_config_s *pconf, int status)
 		if (lcd_debug_print_flag)
 			LCDPR("vswing=0x%x, prrem=0x%x\n", vswing, preem);
 
-		if (vswing > 7) {
-			LCDERR("%s: invalid vswing=0x%x, use default\n",
-				__func__, vswing);
-			vswing = LVDS_PHY_VSWING_DFT;
-		}
-		if (preem > 7) {
-			LCDERR("%s: invalid preem=0x%x, use default\n",
-				__func__, preem);
-			preem = LVDS_PHY_PREEM_DFT;
-		}
-		if (clk_vswing > 3) {
-			LCDERR(
-			"%s: invalid clk_vswing=0x%x, use default\n",
-				__func__, clk_vswing);
-			clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
-		}
-		if (clk_preem > 7) {
-			LCDERR(
-			"%s: invalid clk_preem=0x%x, use default\n",
-				__func__, clk_preem);
-			clk_preem = LVDS_PHY_CLK_PREEM_DFT;
-		}
-		channel_on = lcd_lvds_channel_on_value(pconf);
-
-		data32 = LVDS_PHY_CNTL1_G9TV |
-			(vswing << 26) | (preem << 0);
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL1, data32);
-		data32 = LVDS_PHY_CNTL2_G9TV;
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL2, data32);
-		data32 = LVDS_PHY_CNTL3_G9TV |
-			(channel_on << 16) |
-			(clk_vswing << 8) |
-			(clk_preem << 5);
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL3, data32);
-	} else {
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL1, 0);
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL2, 0);
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL3, 0);
-	}
-}
-
-static void lcd_lvds_phy_set_tl1(struct lcd_config_s *pconf, int status)
-{
-	unsigned int vswing, preem;
-	unsigned int data32 = 0, size;
-	struct lvds_config_s *lvds_conf;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	lvds_conf = pconf->lcd_control.lvds_config;
-	if (status) {
-		vswing = lvds_conf->phy_vswing & 0xf;
-		preem = lvds_conf->phy_preem & 0xf;
-		if (lcd_debug_print_flag)
-			LCDPR("vswing=0x%x, prrem=0x%x\n", vswing, preem);
-
-		size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
-			sizeof(unsigned int);
-		if (preem >= size) {
-			LCDERR("%s: invalid preem=0x%x, use default\n",
-				__func__, preem);
-			preem = 0;
-		}
-		data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14, 0xff2027e0 | vswing);
-		lcd_phy_cntl_set_tl1(status, data32, 0, 0);
-	} else {
-		lcd_phy_cntl_set_tl1(status, data32, 0, 0);
-	}
-}
-
-static void lcd_lvds_phy_set_t5(struct lcd_config_s *pconf, int status)
-{
-	unsigned int vswing, preem;
-	unsigned int data32 = 0, size;
-	struct lvds_config_s *lvds_conf;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	lvds_conf = pconf->lcd_control.lvds_config;
-	if (status) {
-		vswing = lvds_conf->phy_vswing & 0xf;
-		preem = lvds_conf->phy_preem & 0xf;
-		if (lcd_debug_print_flag)
-			LCDPR("vswing=0x%x, prrem=0x%x\n", vswing, preem);
-
-		size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
-			sizeof(unsigned int);
-		if (preem >= size) {
-			LCDERR("%s: invalid preem=0x%x, use default\n",
-				__func__, preem);
-			preem = 0;
-		}
-		data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14, 0xff2027e0 | vswing);
-		lcd_phy_cntl_set_t5(status, data32, 0, 1, 0);
-	} else {
-		lcd_phy_cntl_set_t5(status, data32, 0, 0, 0);
-	}
-}
-
-static void lcd_vbyone_phy_set_txl(struct lcd_config_s *pconf, int status)
-{
-	unsigned int vswing, preem, ext_pullup;
-	unsigned int data32 = 0;
-	unsigned int rinner_table[] = {0xa, 0xa, 0x6, 0x4};
-	struct vbyone_config_s *vbyone_conf;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	vbyone_conf = pconf->lcd_control.vbyone_config;
-	if (status) {
-		ext_pullup = (vbyone_conf->phy_vswing >> 4) & 0x3;
-		vswing = vbyone_conf->phy_vswing & 0xf;
-		preem = vbyone_conf->phy_preem & 0xf;
-		if (lcd_debug_print_flag) {
-			LCDPR("vswing=0x%x, prrem=0x%x\n",
-				vbyone_conf->phy_vswing, preem);
-		}
-
-		if (vswing > 7) {
-			LCDERR("%s: invalid vswing=0x%x, use default\n",
-				__func__, vswing);
-			vswing = VX1_PHY_VSWING_DFT;
-		}
-		if (preem > 7) {
-			LCDERR("%s: invalid preem=0x%x, use default\n",
-				__func__, preem);
-			preem = VX1_PHY_PREEM_DFT;
-		}
-		if (ext_pullup) {
-			data32 = VX1_PHY_CNTL1_G9TV_PULLUP |
-				(vswing << 3);
-		} else {
-			data32 = VX1_PHY_CNTL1_G9TV | (vswing << 3);
-		}
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL1, data32);
-		data32 = VX1_PHY_CNTL2_G9TV | (preem << 20) |
-			(rinner_table[ext_pullup] << 8);
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL2, data32);
-		data32 = VX1_PHY_CNTL3_G9TV;
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL3, data32);
-	} else {
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL1, 0);
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL2, 0);
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL3, 0);
-	}
-}
-
-static void lcd_vbyone_phy_set_tl1(struct lcd_config_s *pconf, int status)
-{
-	unsigned int vswing, preem, ext_pullup;
-	unsigned int data32 = 0, size;
-	struct vbyone_config_s *vbyone_conf;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	vbyone_conf = pconf->lcd_control.vbyone_config;
-	if (status) {
-		ext_pullup = (vbyone_conf->phy_vswing >> 4) & 0x3;
-		vswing = vbyone_conf->phy_vswing & 0xf;
-		preem = vbyone_conf->phy_preem & 0xf;
-		if (lcd_debug_print_flag) {
-			LCDPR("vswing=0x%x, prrem=0x%x\n",
-				vbyone_conf->phy_vswing, preem);
-		}
-
-		size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
-			sizeof(unsigned int);
-		if (preem >= size) {
-			LCDERR("%s: invalid preem=0x%x, use default\n",
-				__func__, preem);
-			preem = 0x1;
-		}
-		data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-		if (ext_pullup) {
+		switch (lcd_drv->data->chip_type) {
+		case LCD_CHIP_TL1:
+		case LCD_CHIP_TM2:
+			size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
+				sizeof(unsigned int);
+			if (preem >= size) {
+				LCDERR("%s: invalid preem=0x%x, use default\n",
+					__func__, preem);
+				preem = 0;
+			}
+			data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
 			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14,
 				0xff2027e0 | vswing);
-		} else {
-			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14,
-				0xf02027a0 | vswing);
+			lcd_phy_cntl_set_tl1(status, data32, 0);
+			break;
+		default:
+			if (vswing > 7) {
+				LCDERR("%s: invalid vswing=0x%x, use default\n",
+					__func__, vswing);
+				vswing = LVDS_PHY_VSWING_DFT;
+			}
+			if (preem > 7) {
+				LCDERR("%s: invalid preem=0x%x, use default\n",
+					__func__, preem);
+				preem = LVDS_PHY_PREEM_DFT;
+			}
+			if (clk_vswing > 3) {
+				LCDERR(
+				"%s: invalid clk_vswing=0x%x, use default\n",
+					__func__, clk_vswing);
+				clk_vswing = LVDS_PHY_CLK_VSWING_DFT;
+			}
+			if (clk_preem > 7) {
+				LCDERR(
+				"%s: invalid clk_preem=0x%x, use default\n",
+					__func__, clk_preem);
+				clk_preem = LVDS_PHY_CLK_PREEM_DFT;
+			}
+			channel_on = lcd_lvds_channel_on_value(pconf);
+
+			data32 = LVDS_PHY_CNTL1_G9TV |
+				(vswing << 26) | (preem << 0);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
+			data32 = LVDS_PHY_CNTL2_G9TV;
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, data32);
+			data32 = LVDS_PHY_CNTL3_G9TV |
+				(channel_on << 16) |
+				(clk_vswing << 8) |
+				(clk_preem << 5);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
+			break;
 		}
-		lcd_phy_cntl_set_tl1(status, data32, 1, 0);
 	} else {
-		lcd_phy_cntl_set_tl1(status, data32, 1, 0);
+		switch (lcd_drv->data->chip_type) {
+		case LCD_CHIP_TL1:
+		case LCD_CHIP_TM2:
+			lcd_phy_cntl_set_tl1(status, data32, 0);
+			break;
+		default:
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0);
+			break;
+		}
 	}
 }
 
-static void lcd_vbyone_phy_set_t5(struct lcd_config_s *pconf, int status)
+void lcd_vbyone_phy_set(struct lcd_config_s *pconf, int status)
 {
 	unsigned int vswing, preem, ext_pullup;
 	unsigned int data32 = 0, size;
+	unsigned int rinner_table[] = {0xa, 0xa, 0x6, 0x4};
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vbyone_config_s *vbyone_conf;
 
 	if (lcd_debug_print_flag)
@@ -472,63 +243,70 @@ static void lcd_vbyone_phy_set_t5(struct lcd_config_s *pconf, int status)
 				vbyone_conf->phy_vswing, preem);
 		}
 
-		size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
-			sizeof(unsigned int);
-		if (preem >= size) {
-			LCDERR("%s: invalid preem=0x%x, use default\n",
-				__func__, preem);
-			preem = 0x1;
-		}
-		data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-		if (ext_pullup) {
-			lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14,
-				0xff2027e0 | vswing);
-		} else {
-			lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14,
-				0xf02027a0 | vswing);
+		switch (lcd_drv->data->chip_type) {
+		case LCD_CHIP_TL1:
+		case LCD_CHIP_TM2:
+			size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
+				sizeof(unsigned int);
+			if (preem >= size) {
+				LCDERR("%s: invalid preem=0x%x, use default\n",
+					__func__, preem);
+				preem = 0x1;
+			}
+			data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
+			if (ext_pullup) {
+				lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14,
+					0xff2027e0 | vswing);
+			} else {
+				lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14,
+					0xf02027a0 | vswing);
+			}
+			lcd_phy_cntl_set_tl1(status, data32, 0);
+			break;
+		default:
+			if (vswing > 7) {
+				LCDERR("%s: invalid vswing=0x%x, use default\n",
+					__func__, vswing);
+				vswing = VX1_PHY_VSWING_DFT;
+			}
+			if (preem > 7) {
+				LCDERR("%s: invalid preem=0x%x, use default\n",
+					__func__, preem);
+				preem = VX1_PHY_PREEM_DFT;
+			}
+			if (ext_pullup) {
+				data32 = VX1_PHY_CNTL1_G9TV_PULLUP |
+					(vswing << 3);
+			} else {
+				data32 = VX1_PHY_CNTL1_G9TV | (vswing << 3);
+			}
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
+			data32 = VX1_PHY_CNTL2_G9TV | (preem << 20) |
+				(rinner_table[ext_pullup] << 8);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, data32);
+			data32 = VX1_PHY_CNTL3_G9TV;
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
+			break;
 		}
-		lcd_phy_cntl_set_t5(status, data32, 1, 1, 0);
 	} else {
-		lcd_phy_cntl_set_t5(status, data32, 1, 0, 0);
-	}
-}
-
-static void lcd_mlvds_phy_set_tl1(struct lcd_config_s *pconf, int status)
-{
-	unsigned int vswing, preem;
-	unsigned int data32 = 0, size, ckdi;
-	struct mlvds_config_s *mlvds_conf;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
-
-	mlvds_conf = pconf->lcd_control.mlvds_config;
-	if (status) {
-		vswing = mlvds_conf->phy_vswing & 0xf;
-		preem = mlvds_conf->phy_preem & 0xf;
-		if (lcd_debug_print_flag)
-			LCDPR("vswing=0x%x, prrem=0x%x\n", vswing, preem);
-
-		size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
-			sizeof(unsigned int);
-		if (preem >= size) {
-			LCDERR("%s: invalid preem=0x%x, use default\n",
-				__func__, preem);
-			preem = 0;
+		switch (lcd_drv->data->chip_type) {
+		case LCD_CHIP_TL1:
+		case LCD_CHIP_TM2:
+			lcd_phy_cntl_set_tl1(status, data32, 0);
+			break;
+		default:
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0);
+			break;
 		}
-		data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14, 0xff2027e0 | vswing);
-		ckdi = (mlvds_conf->pi_clk_sel << 12);
-		lcd_phy_cntl_set_tl1(status, data32, 0, ckdi);
-	} else {
-		lcd_phy_cntl_set_tl1(status, data32, 0, 0);
 	}
 }
 
-static void lcd_mlvds_phy_set_t5(struct lcd_config_s *pconf, int status)
+void lcd_mlvds_phy_set(struct lcd_config_s *pconf, int status)
 {
 	unsigned int vswing, preem;
-	unsigned int data32 = 0, size, ckdi;
+	unsigned int data32 = 0, size, cntl16;
 	struct mlvds_config_s *mlvds_conf;
 
 	if (lcd_debug_print_flag)
@@ -549,17 +327,21 @@ static void lcd_mlvds_phy_set_t5(struct lcd_config_s *pconf, int status)
 			preem = 0;
 		}
 		data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-		lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14, 0xff2027e0 | vswing);
-		ckdi = (mlvds_conf->pi_clk_sel << 12);
-		lcd_phy_cntl_set_t5(status, data32, 0, 1, ckdi);
-	} else {
-		lcd_phy_cntl_set_t5(status, data32, 0, 0, 0);
-	}
+		if (is_meson_rev_c())
+			data32 |= ((1 << 16) | (1 << 0));
+		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14,
+			0xff2027e0 | vswing);
+		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL15, 0);
+		cntl16 = (mlvds_conf->pi_clk_sel << 12);
+		cntl16 |= 0x80000000;
+		lcd_phy_cntl_set_tl1(status, data32, cntl16);
+	} else
+		lcd_phy_cntl_set_tl1(status, data32, 0);
 }
 
-static void lcd_p2p_phy_set_tl1(struct lcd_config_s *pconf, int status)
+void lcd_p2p_phy_set(struct lcd_config_s *pconf, int status)
 {
-	unsigned int vswing, preem, p2p_type;
+	unsigned int vswing, preem;
 	unsigned int data32 = 0, size;
 	struct p2p_config_s *p2p_conf;
 
@@ -573,8 +355,7 @@ static void lcd_p2p_phy_set_tl1(struct lcd_config_s *pconf, int status)
 		if (lcd_debug_print_flag)
 			LCDPR("vswing=0x%x, prrem=0x%x\n", vswing, preem);
 
-		p2p_type = p2p_conf->p2p_type & 0x1f;
-		switch (p2p_type) {
+		switch (p2p_conf->p2p_type) {
 		case P2P_CEDS:
 		case P2P_CMPI:
 		case P2P_ISP:
@@ -587,9 +368,9 @@ static void lcd_p2p_phy_set_tl1(struct lcd_config_s *pconf, int status)
 				preem = 0x1;
 			}
 			data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-			lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14,
-				      0xff2027a0 | vswing);
-			lcd_phy_cntl_set_tl1(status, data32, 1, 0);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14,
+				0xff2027a0 | vswing);
+			lcd_phy_cntl_set_tl1(status, data32, 0);
 			break;
 		case P2P_CHPI: /* low common mode */
 		case P2P_CSPI:
@@ -602,113 +383,68 @@ static void lcd_p2p_phy_set_tl1(struct lcd_config_s *pconf, int status)
 				preem = 0x1;
 			}
 			data32 = p2p_low_common_phy_preem_tl1[preem];
-			if (p2p_type == P2P_CHPI) {
+			if (p2p_conf->p2p_type == P2P_CHPI) {
 				/* weakly pull down */
 				data32 &= ~((1 << 19) | (1 << 3));
 			}
 
-			lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14, 0xfe60027f);
-			lcd_phy_cntl_set_tl1(status, data32, 1, 0);
+			lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14, 0xfe60027f);
+			lcd_phy_cntl_set_tl1(status, data32, 0);
 			break;
 		default:
-			LCDERR("%s: invalid p2p_type %d\n", __func__, p2p_type);
+			LCDERR("%s: invalid p2p_type %d\n",
+				__func__, p2p_conf->p2p_type);
 			break;
 		}
-	} else {
-		lcd_phy_cntl_set_tl1(status, data32, 1, 0);
-	}
+	} else
+		lcd_phy_cntl_set_tl1(status, data32, 0);
 }
 
-static void lcd_p2p_phy_set_t5(struct lcd_config_s *pconf, int status)
+void lcd_mipi_phy_set(struct lcd_config_s *pconf, int status)
 {
-	unsigned int vswing, preem, p2p_type, vcm_flag;
-	unsigned int data32 = 0, size;
-	struct p2p_config_s *p2p_conf;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %d\n", __func__, status);
+	unsigned int phy_reg, phy_bit, phy_width;
+	unsigned int lane_cnt;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	p2p_conf = pconf->lcd_control.p2p_config;
 	if (status) {
-		vswing = p2p_conf->phy_vswing & 0xf;
-		preem = p2p_conf->phy_preem & 0xf;
-		if (lcd_debug_print_flag)
-			LCDPR("vswing=0x%x, prrem=0x%x\n", vswing, preem);
-
-		p2p_type = p2p_conf->p2p_type & 0x1f;
-		vcm_flag = (p2p_conf->p2p_type >> 5) & 0x1;
-		switch (p2p_type) {
-		case P2P_CEDS:
-		case P2P_CMPI:
-		case P2P_ISP:
-		case P2P_EPI:
-			size = sizeof(lvds_vx1_p2p_phy_preem_tl1) /
-				sizeof(unsigned int);
-			if (preem >= size) {
-				LCDERR("%s: invalid preem=0x%x, use default\n",
-					__func__, preem);
-				preem = 0x1;
-			}
-			data32 = lvds_vx1_p2p_phy_preem_tl1[preem];
-			lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14,
-				      0xff2027a0 | vswing);
-			lcd_phy_cntl_set_t5(status, data32, 1, 1, 0);
+		switch (lcd_drv->data->chip_type) {
+		case LCD_CHIP_G12A:
+		case LCD_CHIP_G12B:
+		case LCD_CHIP_SM1:
+			/* HHI_MIPI_CNTL0 */
+			/* DIF_REF_CTL1:31-16bit, DIF_REF_CTL0:15-0bit */
+			lcd_hiu_write(HHI_MIPI_CNTL0,
+				(0xa487 << 16) | (0x8 << 0));
+
+			/* HHI_MIPI_CNTL1 */
+			/* DIF_REF_CTL2:15-0bit; bandgap bit16 */
+			lcd_hiu_write(HHI_MIPI_CNTL1,
+				(0x1 << 16) | (0x002e << 0));
+
+			/* HHI_MIPI_CNTL2 */
+			/* DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit */
+			lcd_hiu_write(HHI_MIPI_CNTL2,
+				(0x2680 << 16) | (0x45a << 0));
 			break;
-		case P2P_CHPI: /* low common mode */
-		case P2P_CSPI:
-		case P2P_USIT:
-			size = sizeof(p2p_low_common_phy_preem_tl1) /
-				sizeof(unsigned int);
-			if (preem >= size) {
-				LCDERR("%s: invalid preem=0x%x, use default\n",
-					__func__, preem);
-				preem = 0x1;
-			}
-			data32 = p2p_low_common_phy_preem_tl1[preem];
-			if (p2p_type == P2P_CHPI) {
-				/* weakly pull down */
-				data32 &= ~((1 << 19) | (1 << 3));
-			}
-
-			if (vcm_flag) { /* 580mV */
-				lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14,
-					      0xe0600272);
-			} else {
-				lcd_ana_write(HHI_DIF_CSI_PHY_CNTL14,
-					      0xfe60027f);
-			} /* default 385mV */
-			lcd_phy_cntl_set_t5(status, data32, 1, 0, 0);
-			break;
-		default:
-			LCDERR("%s: invalid p2p_type %d\n", __func__, p2p_type);
+		default: /* LCD_CHIP_AXG */
+			/* HHI_MIPI_CNTL0 */
+			/* DIF_REF_CTL1:31-16bit, DIF_REF_CTL0:15-0bit */
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 0x1b8, 16, 10);
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 1, 26, 1); /* bandgap */
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 1, 29, 1); /* current */
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 1, 31, 1);
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 0x8, 0, 16);
+
+			/* HHI_MIPI_CNTL1 */
+			/* DIF_REF_CTL2:15-0bit */
+			lcd_hiu_write(HHI_MIPI_CNTL1, (0x001e << 0));
+
+			/* HHI_MIPI_CNTL2 */
+			/* DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit */
+			lcd_hiu_write(HHI_MIPI_CNTL2,
+				(0x26e0 << 16) | (0x459 << 0));
 			break;
 		}
-	} else {
-		lcd_phy_cntl_set_t5(status, data32, 1, 0, 0);
-	}
-}
-
-static void lcd_mipi_phy_set_axg(struct lcd_config_s *pconf, int status)
-{
-	unsigned int phy_reg, phy_bit, phy_width;
-	unsigned int lane_cnt;
-
-	if (status) {
-		/* HHI_MIPI_CNTL0 */
-		/* DIF_REF_CTL1:31-16bit, DIF_REF_CTL0:15-0bit */
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 0x1b8, 16, 10);
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 1, 26, 1); /* bandgap */
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 1, 29, 1); /* current */
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 1, 31, 1);
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 0x8, 0, 16);
-
-		/* HHI_MIPI_CNTL1 */
-		/* DIF_REF_CTL2:15-0bit */
-		lcd_hiu_write(HHI_MIPI_CNTL1, (0x001e << 0));
-
-		/* HHI_MIPI_CNTL2 */
-		/* DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit */
-		lcd_hiu_write(HHI_MIPI_CNTL2, (0x26e0 << 16) | (0x459 << 0));
 
 		phy_reg = HHI_MIPI_CNTL2;
 		phy_bit = MIPI_PHY_LANE_BIT;
@@ -732,192 +468,82 @@ static void lcd_mipi_phy_set_axg(struct lcd_config_s *pconf, int status)
 		}
 		lcd_hiu_setb(phy_reg, lane_cnt, phy_bit, phy_width);
 	} else {
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 0, 16, 10);
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 0, 31, 1);
-		lcd_hiu_setb(HHI_MIPI_CNTL0, 0, 0, 16);
-		lcd_hiu_write(HHI_MIPI_CNTL1, 0x6);
-		lcd_hiu_write(HHI_MIPI_CNTL2, 0x00200000);
-	}
-}
-
-static void lcd_mipi_phy_set_g12a(struct lcd_config_s *pconf, int status)
-{
-	unsigned int phy_reg, phy_bit, phy_width;
-	unsigned int lane_cnt;
-
-	if (status) {
-		/* HHI_MIPI_CNTL0 */
-		/* DIF_REF_CTL1:31-16bit, DIF_REF_CTL0:15-0bit */
-		lcd_hiu_write(HHI_MIPI_CNTL0,
-			(0xa487 << 16) | (0x8 << 0));
-
-		/* HHI_MIPI_CNTL1 */
-		/* DIF_REF_CTL2:15-0bit; bandgap bit16 */
-		lcd_hiu_write(HHI_MIPI_CNTL1,
-			(0x1 << 16) | (0x002e << 0));
-
-		/* HHI_MIPI_CNTL2 */
-		/* DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit */
-		lcd_hiu_write(HHI_MIPI_CNTL2,
-			(0x2680 << 16) | (0x45a << 0));
-
-		phy_reg = HHI_MIPI_CNTL2;
-		phy_bit = MIPI_PHY_LANE_BIT;
-		phy_width = MIPI_PHY_LANE_WIDTH;
-		switch (pconf->lcd_control.mipi_config->lane_num) {
-		case 1:
-			lane_cnt = DSI_LANE_COUNT_1;
+		switch (lcd_drv->data->chip_type) {
+		case LCD_CHIP_G12A:
+		case LCD_CHIP_G12B:
+		case LCD_CHIP_SM1:
+			lcd_hiu_write(HHI_MIPI_CNTL0, 0);
+			lcd_hiu_write(HHI_MIPI_CNTL1, 0);
+			lcd_hiu_write(HHI_MIPI_CNTL2, 0);
 			break;
-		case 2:
-			lane_cnt = DSI_LANE_COUNT_2;
-			break;
-		case 3:
-			lane_cnt = DSI_LANE_COUNT_3;
-			break;
-		case 4:
-			lane_cnt = DSI_LANE_COUNT_4;
-			break;
-		default:
-			lane_cnt = 0;
+		default:/* LCD_CHIP_AXG */
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 0, 16, 10);
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 0, 31, 1);
+			lcd_hiu_setb(HHI_MIPI_CNTL0, 0, 0, 16);
+			lcd_hiu_write(HHI_MIPI_CNTL1, 0x6);
+			lcd_hiu_write(HHI_MIPI_CNTL2, 0x00200000);
 			break;
 		}
-		lcd_hiu_setb(phy_reg, lane_cnt, phy_bit, phy_width);
-	} else {
-		lcd_hiu_write(HHI_MIPI_CNTL0, 0);
-		lcd_hiu_write(HHI_MIPI_CNTL1, 0);
-		lcd_hiu_write(HHI_MIPI_CNTL2, 0);
 	}
 }
 
-void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
-{
-	if (!lcd_phy_ctrl)
-		return;
-	if (!lcd_phy_ctrl->phy_set_lvds)
-		return;
-
-	lcd_phy_ctrl->phy_set_lvds(pconf, status);
-}
-
-void lcd_vbyone_phy_set(struct lcd_config_s *pconf, int status)
+void lcd_phy_tcon_chpi_bbc_init_tl1(int delay)
 {
-	if (!lcd_phy_ctrl)
-		return;
-	if (!lcd_phy_ctrl->phy_set_vx1)
-		return;
-
-	lcd_phy_ctrl->phy_set_vx1(pconf, status);
-}
-
-void lcd_mlvds_phy_set(struct lcd_config_s *pconf, int status)
-{
-	if (!lcd_phy_ctrl)
-		return;
-	if (!lcd_phy_ctrl->phy_set_mlvds)
-		return;
-
-	lcd_phy_ctrl->phy_set_mlvds(pconf, status);
-}
-
-void lcd_p2p_phy_set(struct lcd_config_s *pconf, int status)
-{
-	if (!lcd_phy_ctrl)
-		return;
-	if (!lcd_phy_ctrl->phy_set_p2p)
-		return;
-
-	lcd_phy_ctrl->phy_set_p2p(pconf, status);
-}
-
-void lcd_mipi_phy_set(struct lcd_config_s *pconf, int status)
-{
-	if (!lcd_phy_ctrl)
-		return;
-	if (!lcd_phy_ctrl->phy_set_mipi)
-		return;
+	unsigned int data32 = 0x06020602;
+	unsigned int tmp = 0;
 
-	lcd_phy_ctrl->phy_set_mipi(pconf, status);
+	udelay(delay);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL1, 1, 3, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL1, 1, 19, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL2, 1, 3, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL2, 1, 19, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL3, 1, 3, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL3, 1, 19, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL4, 1, 3, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL4, 1, 19, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL6, 1, 3, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL6, 1, 19, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL7, 1, 3, 1);
+	lcd_hiu_setb(HHI_DIF_CSI_PHY_CNTL7, 1, 19, 1);
+	LCDPR("%s: delay: %dus\n", __func__, delay);
+
+	data32 |= ((phy_ctrl_bit_on << 16) |
+		   (phy_ctrl_bit_on << 0));
+	tmp |= ((1 << 18) | (1 << 2));
+
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL14, 0xff2027ef);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL15, tmp);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL16, 0x80000000);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL8, tmp);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL9, tmp);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, data32);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL10, tmp);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL11, tmp);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL4, data32);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL12, tmp);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL6, data32);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL13, tmp);
+	lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL7, data32);
 }
 
-struct lcd_phy_ctrl_s lcd_phy_ctrl_txl = {
-	.phy_set_lvds = lcd_lvds_phy_set_txl,
-	.phy_set_vx1 = lcd_vbyone_phy_set_txl,
-	.phy_set_mlvds = NULL,
-	.phy_set_p2p = NULL,
-	.phy_set_mipi = NULL,
-};
-
-struct lcd_phy_ctrl_s lcd_phy_ctrl_axg = {
-	.phy_set_lvds = NULL,
-	.phy_set_vx1 = NULL,
-	.phy_set_mlvds = NULL,
-	.phy_set_p2p = NULL,
-	.phy_set_mipi = lcd_mipi_phy_set_axg,
-};
-
-struct lcd_phy_ctrl_s lcd_phy_ctrl_g12a = {
-	.phy_set_lvds = NULL,
-	.phy_set_vx1 = NULL,
-	.phy_set_mlvds = NULL,
-	.phy_set_p2p = NULL,
-	.phy_set_mipi = lcd_mipi_phy_set_g12a,
-};
-
-struct lcd_phy_ctrl_s lcd_phy_ctrl_tl1 = {
-	.phy_set_lvds = lcd_lvds_phy_set_tl1,
-	.phy_set_vx1 = lcd_vbyone_phy_set_tl1,
-	.phy_set_mlvds = lcd_mlvds_phy_set_tl1,
-	.phy_set_p2p = lcd_p2p_phy_set_tl1,
-	.phy_set_mipi = NULL,
-};
-
-struct lcd_phy_ctrl_s lcd_phy_ctrl_t5 = {
-	.phy_set_lvds = lcd_lvds_phy_set_t5,
-	.phy_set_vx1 = lcd_vbyone_phy_set_t5,
-	.phy_set_mlvds = lcd_mlvds_phy_set_t5,
-	.phy_set_p2p = lcd_p2p_phy_set_t5,
-	.phy_set_mipi = NULL,
-};
-
 int lcd_phy_probe(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	lcd_phy_ctrl = NULL;
-	if (lcd_drv->lcd_pxp)
-		return 0;
-
 	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TXL:
-	case LCD_CHIP_TXLX:
-		lcd_phy_ctrl = &lcd_phy_ctrl_txl;
-		break;
-	case LCD_CHIP_AXG:
-		lcd_phy_ctrl = &lcd_phy_ctrl_axg;
-		break;
-	case LCD_CHIP_G12A:
-	case LCD_CHIP_G12B:
-	case LCD_CHIP_SM1:
-		lcd_phy_ctrl = &lcd_phy_ctrl_g12a;
-		break;
 	case LCD_CHIP_TL1:
-		lcd_phy_ctrl = &lcd_phy_ctrl_tl1;
-		if (is_meson_rev_a() || is_meson_rev_b())
-			phy_ctrl_bit_on = 0;
-		else
+		if (is_meson_rev_c())
 			phy_ctrl_bit_on = 1;
-		break;
-	case LCD_CHIP_TM2:
-		lcd_phy_ctrl = &lcd_phy_ctrl_tl1;
-		if (is_meson_rev_a())
-			phy_ctrl_bit_on = 0;
 		else
-			phy_ctrl_bit_on = 1;
+			phy_ctrl_bit_on = 0;
 		break;
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		lcd_phy_ctrl = &lcd_phy_ctrl_t5;
-		phy_ctrl_bit_on = 1;
+	case LCD_CHIP_G12B:
+		if (is_meson_rev_b())
+			phy_ctrl_bit_on = 1;
+		else
+			phy_ctrl_bit_on = 0;
 		break;
 	default:
 		break;
diff --git a/drivers/amlogic/media/vout/lcd/lcd_phy_config.h b/drivers/amlogic/media/vout/lcd/lcd_phy_config.h
index 059b02c6c76a..3ed875e5c38b 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_phy_config.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_phy_config.h
@@ -18,14 +18,6 @@
 #ifndef __AML_LCD_PHY_CONFIG_H__
 #define __AML_LCD_PHY_CONFIG_H__
 
-struct lcd_phy_ctrl_s {
-	void (*phy_set_lvds)(struct lcd_config_s *pconf, int status);
-	void (*phy_set_vx1)(struct lcd_config_s *pconf, int status);
-	void (*phy_set_mlvds)(struct lcd_config_s *pconf, int status);
-	void (*phy_set_p2p)(struct lcd_config_s *pconf, int status);
-	void (*phy_set_mipi)(struct lcd_config_s *pconf, int status);
-};
-
 /* -------------------------- */
 /* lvsd phy parameters define */
 /* -------------------------- */
diff --git a/drivers/amlogic/media/vout/lcd/lcd_reg.c b/drivers/amlogic/media/vout/lcd/lcd_reg.c
index 46ef7c0a8e52..2824b04914b0 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_reg.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_reg.c
@@ -24,8 +24,6 @@
 #include <linux/amlogic/cpu_version.h>
 #include <linux/amlogic/media/vout/lcd/lcd_vout.h>
 #include <linux/amlogic/iomap.h>
-#include <linux/amlogic/media/vout/vclk_serve.h>
-#include <linux/amlogic/media/vpu/vpu.h>
 #include "lcd_common.h"
 #include "lcd_reg.h"
 
@@ -33,8 +31,7 @@
 #define LCD_MAP_DSI_HOST  1
 #define LCD_MAP_DSI_PHY   2
 #define LCD_MAP_TCON      3
-#define LCD_MAP_RESET     4
-#define LCD_MAP_MAX       5
+#define LCD_MAP_MAX       4
 
 int lcd_reg_gxb[] = {
 	LCD_MAP_PERIPHS,
@@ -53,13 +50,6 @@ int lcd_reg_tl1[] = {
 	LCD_MAP_MAX,
 };
 
-int lcd_reg_t5[] = {
-	LCD_MAP_TCON,
-	LCD_MAP_PERIPHS,
-	LCD_MAP_RESET,
-	LCD_MAP_MAX
-};
-
 struct lcd_reg_map_s {
 	unsigned int base_addr;
 	unsigned int size;
@@ -67,7 +57,6 @@ struct lcd_reg_map_s {
 	char flag;
 };
 
-static spinlock_t lcd_tcon_reg_lock;
 static struct lcd_reg_map_s *lcd_reg_map;
 
 int lcd_ioremap(struct platform_device *pdev)
@@ -120,8 +109,6 @@ int lcd_ioremap(struct platform_device *pdev)
 		i++;
 	}
 
-	spin_lock_init(&lcd_tcon_reg_lock);
-
 	return 0;
 }
 
@@ -158,26 +145,6 @@ static inline void __iomem *check_lcd_periphs_reg(unsigned int _reg)
 	return p;
 }
 
-static inline void __iomem *check_lcd_reset_reg(unsigned int _reg)
-{
-	void __iomem *p;
-	int reg_bus;
-	unsigned int reg_offset;
-
-	reg_bus = LCD_MAP_RESET;
-	if (check_lcd_ioremap(reg_bus))
-		return NULL;
-
-	reg_offset = LCD_REG_OFFSET(_reg);
-
-	if (reg_offset >= lcd_reg_map[reg_bus].size) {
-		LCDERR("invalid reset reg offset: 0x%04x\n", _reg);
-		return NULL;
-	}
-	p = lcd_reg_map[reg_bus].p + reg_offset;
-	return p;
-}
-
 static inline void __iomem *check_lcd_dsi_host_reg(unsigned int _reg)
 {
 	void __iomem *p;
@@ -256,20 +223,12 @@ static inline void __iomem *check_lcd_tcon_reg_byte(unsigned int _reg)
 
 unsigned int lcd_vcbus_read(unsigned int reg)
 {
-#ifdef CONFIG_AMLOGIC_VPU
-	return vpu_vcbus_read(reg);
-#else
 	return aml_read_vcbus(reg);
-#endif
 };
 
 void lcd_vcbus_write(unsigned int reg, unsigned int value)
 {
-#ifdef CONFIG_AMLOGIC_VPU
-	vpu_vcbus_write(reg, value);
-#else
 	aml_write_vcbus(reg, value);
-#endif
 };
 
 void lcd_vcbus_setb(unsigned int reg, unsigned int value,
@@ -298,20 +257,12 @@ void lcd_vcbus_clr_mask(unsigned int reg, unsigned int _mask)
 
 unsigned int lcd_hiu_read(unsigned int _reg)
 {
-#ifdef CONFIG_AMLOGIC_VOUT_CLK_SERVE
-	return vclk_clk_reg_read(_reg);
-#else
 	return aml_read_hiubus(_reg);
-#endif
 };
 
 void lcd_hiu_write(unsigned int _reg, unsigned int _value)
 {
-#ifdef CONFIG_AMLOGIC_VOUT_CLK_SERVE
-	vclk_clk_reg_write(_reg, _value);
-#else
 	aml_write_hiubus(_reg, _value);
-#endif
 };
 
 void lcd_hiu_setb(unsigned int _reg, unsigned int _value,
@@ -338,38 +289,6 @@ void lcd_hiu_clr_mask(unsigned int _reg, unsigned int _mask)
 	lcd_hiu_write(_reg, (lcd_hiu_read(_reg) & (~(_mask))));
 }
 
-unsigned int lcd_ana_read(unsigned int _reg)
-{
-#ifdef CONFIG_AMLOGIC_VOUT_CLK_SERVE
-	return vclk_ana_reg_read(_reg);
-#else
-	return aml_read_hiubus(_reg);
-#endif
-}
-
-void lcd_ana_write(unsigned int _reg, unsigned int _value)
-{
-#ifdef CONFIG_AMLOGIC_VOUT_CLK_SERVE
-	vclk_ana_reg_write(_reg, _value);
-#else
-	aml_write_hiubus(_reg, _value);
-#endif
-}
-
-void lcd_ana_setb(unsigned int _reg, unsigned int _value,
-		  unsigned int _start, unsigned int _len)
-{
-	lcd_ana_write(_reg, ((lcd_ana_read(_reg) &
-		      (~(((1L << _len) - 1) << _start))) |
-		      ((_value & ((1L << _len) - 1)) << _start)));
-}
-
-unsigned int lcd_ana_getb(unsigned int _reg,
-			  unsigned int _start, unsigned int _len)
-{
-	return (lcd_ana_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
-}
-
 unsigned int lcd_cbus_read(unsigned int _reg)
 {
 	return aml_read_cbus(_reg);
@@ -408,34 +327,6 @@ void lcd_periphs_write(unsigned int _reg, unsigned int _value)
 		writel(_value, p);
 };
 
-unsigned int lcd_reset_read(unsigned int _reg)
-{
-	void __iomem *p;
-
-	p = check_lcd_reset_reg(_reg);
-	if (p)
-		return readl(p);
-	else
-		return -1;
-};
-
-void lcd_reset_write(unsigned int _reg, unsigned int _value)
-{
-	void __iomem *p;
-
-	p = check_lcd_reset_reg(_reg);
-	if (p)
-		writel(_value, p);
-};
-
-void lcd_reset_setb(unsigned int _reg, unsigned int _value,
-		unsigned int _start, unsigned int _len)
-{
-	lcd_reset_write(_reg, ((lcd_reset_read(_reg) &
-			~(((1L << (_len)) - 1) << (_start))) |
-			(((_value) & ((1L << (_len)) - 1)) << (_start))));
-}
-
 unsigned int dsi_host_read(unsigned int _reg)
 {
 	void __iomem *p;
@@ -523,238 +414,72 @@ void dsi_phy_clr_mask(unsigned int reg, unsigned int _mask)
 unsigned int lcd_tcon_read(unsigned int _reg)
 {
 	void __iomem *p;
-	unsigned int val;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
 
 	p = check_lcd_tcon_reg(_reg);
 	if (p)
-		val = readl(p);
+		return readl(p);
 	else
-		val = 0;
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
-	return val;
+		return -1;
 };
-
 void lcd_tcon_write(unsigned int _reg, unsigned int _value)
 {
 	void __iomem *p;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
 
 	p = check_lcd_tcon_reg(_reg);
 	if (p)
 		writel(_value, p);
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
 };
 
 void lcd_tcon_setb(unsigned int reg, unsigned int value,
 		unsigned int _start, unsigned int _len)
 {
-	void __iomem *p;
-	unsigned int temp;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg(reg);
-	if (p) {
-		temp = readl(p);
-		temp = (temp & (~(((1L << _len) - 1) << _start))) |
-			((value & ((1L << _len) - 1)) << _start);
-		writel(temp, p);
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
+	lcd_tcon_write(reg, ((lcd_tcon_read(reg) &
+		(~(((1L << _len)-1) << _start))) |
+		((value & ((1L << _len)-1)) << _start)));
 }
 unsigned int lcd_tcon_getb(unsigned int reg,
 		unsigned int _start, unsigned int _len)
 {
-	void __iomem *p;
-	unsigned int val;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg(reg);
-	if (p) {
-		val = readl(p);
-		val = (val >> _start) & ((1L << _len) - 1);
-	} else {
-		val = 0;
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
-	return val;
+	return (lcd_tcon_read(reg) >> _start) & ((1L << _len)-1);
 }
 
-void lcd_tcon_update_bits(unsigned int reg,
-			  unsigned int mask, unsigned int value)
+void lcd_tcon_set_mask(unsigned int reg, unsigned int _mask)
 {
-	void __iomem *p;
-	unsigned int temp;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg(reg);
-	if (p) {
-		if (mask == 0xffffffff) {
-			writel(value, p);
-		} else {
-			temp =  readl(p);
-			temp = (temp & (~(mask))) | (value & mask);
-			writel(temp, p);
-		}
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
+	lcd_tcon_write(reg, (lcd_tcon_read(reg) | (_mask)));
 }
-
-int lcd_tcon_check_bits(unsigned int reg,
-			unsigned int mask, unsigned int value)
+void lcd_tcon_clr_mask(unsigned int reg, unsigned int _mask)
 {
-	void __iomem *p;
-	unsigned int temp;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg(reg);
-	if (p) {
-		temp = readl(p);
-		if ((temp & mask) != value)
-			temp = -1;
-		else
-			temp = 0;
-	} else {
-		temp = -1;
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
-	return temp;
+	lcd_tcon_write(reg, (lcd_tcon_read(reg) & (~(_mask))));
 }
 
 unsigned char lcd_tcon_read_byte(unsigned int _reg)
 {
 	void __iomem *p;
-	unsigned char val;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
 
 	p = check_lcd_tcon_reg_byte(_reg);
 	if (p)
-		val = readb(p);
+		return readb(p);
 	else
-		val = 0;
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
-	return val;
+		return -1;
 };
-
 void lcd_tcon_write_byte(unsigned int _reg, unsigned char _value)
 {
 	void __iomem *p;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
 
 	p = check_lcd_tcon_reg_byte(_reg);
 	if (p)
 		writeb(_value, p);
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
 };
 
 void lcd_tcon_setb_byte(unsigned int reg, unsigned char value,
-			unsigned int _start, unsigned int _len)
+		unsigned int _start, unsigned int _len)
 {
-	void __iomem *p;
-	unsigned char temp;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg_byte(reg);
-	if (p) {
-		temp = readl(p);
-		temp = (temp & (~(((1L << _len) - 1) << _start))) |
-			((value & ((1L << _len) - 1)) << _start);
-		writel(temp, p);
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
+	lcd_tcon_write_byte(reg, ((lcd_tcon_read_byte(reg) &
+		(~(((1L << _len)-1) << _start))) |
+		((value & ((1L << _len)-1)) << _start)));
 }
-
 unsigned char lcd_tcon_getb_byte(unsigned int reg,
-				 unsigned int _start, unsigned int _len)
-{
-	void __iomem *p;
-	unsigned char val;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg_byte(reg);
-	if (p) {
-		val = readl(p);
-		val = (val >> _start) & ((1L << _len) - 1);
-	} else {
-		val = 0;
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
-	return val;
-}
-
-void lcd_tcon_update_bits_byte(unsigned int reg,
-			       unsigned char mask, unsigned char value)
-{
-	void __iomem *p;
-	unsigned char temp;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg_byte(reg);
-	if (p) {
-		if (mask == 0xffffffff) {
-			writel(value, p);
-		} else {
-			temp =  readl(p);
-			temp = (temp & (~(mask))) | (value & mask);
-			writel(temp, p);
-		}
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
-}
-
-int lcd_tcon_check_bits_byte(unsigned int reg,
-			     unsigned char mask, unsigned char value)
+		unsigned int _start, unsigned int _len)
 {
-	void __iomem *p;
-	unsigned char temp;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lcd_tcon_reg_lock, flags);
-
-	p = check_lcd_tcon_reg_byte(reg);
-	if (p) {
-		temp = readl(p);
-		if ((temp & mask) != value)
-			temp = -1;
-		else
-			temp = 0;
-	} else {
-		temp = -1;
-	}
-
-	spin_unlock_irqrestore(&lcd_tcon_reg_lock, flags);
-	return temp;
+	return (lcd_tcon_read_byte(reg) >> _start) & ((1L << _len)-1);
 }
diff --git a/drivers/amlogic/media/vout/lcd/lcd_reg.h b/drivers/amlogic/media/vout/lcd/lcd_reg.h
index e6a52986e3d2..c3ca21e03af1 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_reg.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_reg.h
@@ -233,32 +233,6 @@
 #define CRT_MASK                                   0x1117
 #define RESET7_MASK                                0x1118
 
-#define VERSION_CTRL_T5                            0x0000
-#define RESET0_REGISTER_T5                         0x0001
-#define RESET1_REGISTER_T5                         0x0002
-#define RESET2_REGISTER_T5                         0x0003
-#define RESET3_REGISTER_T5                         0x0004
-#define RESET4_REGISTER_T5                         0x0005
-#define RESET5_REGISTER_T5                         0x0006
-#define RESET6_REGISTER_T5                         0x0007
-#define RESET7_REGISTER_T5                         0x0008
-#define RESET0_MASK_T5                             0x0010
-#define RESET1_MASK_T5                             0x0011
-#define RESET2_MASK_T5                             0x0012
-#define RESET3_MASK_T5                             0x0013
-#define RESET4_MASK_T5                             0x0014
-#define RESET5_MASK_T5                             0x0015
-#define RESET6_MASK_T5                             0x0016
-#define RESET7_MASK_T5                             0x0017
-#define RESET0_LEVEL_T5                            0x0020
-#define RESET1_LEVEL_T5                            0x0021
-#define RESET2_LEVEL_T5                            0x0022
-#define RESET3_LEVEL_T5                            0x0023
-#define RESET4_LEVEL_T5                            0x0024
-#define RESET5_LEVEL_T5                            0x0025
-#define RESET6_LEVEL_T5                            0x0026
-#define RESET7_LEVEL_T5                            0x0027
-
 /* ********************************
  * TCON:  VCBUS_BASE = 0x14
  */
@@ -981,6 +955,8 @@
  * TCON TOP:  TCON_TOP_BASE = 0x2000
  * ********************************
  */
+#define TCON_CORE_REG_START                        0x0000
+
 #define TCON_CTRL_TIMING_BASE                      0x01b0
 
 #define TCON_TOP_BASE                              0x2000
@@ -1529,7 +1505,6 @@
 extern int lcd_reg_gxb[];
 extern int lcd_reg_axg[];
 extern int lcd_reg_tl1[];
-extern int lcd_reg_t5[];
 
 extern int lcd_ioremap(struct platform_device *pdev);
 extern unsigned int lcd_vcbus_read(unsigned int _reg);
@@ -1550,13 +1525,6 @@ extern unsigned int lcd_hiu_getb(unsigned int _reg,
 extern void lcd_hiu_set_mask(unsigned int _reg, unsigned int _mask);
 extern void lcd_hiu_clr_mask(unsigned int _reg, unsigned int _mask);
 
-unsigned int lcd_ana_read(unsigned int _reg);
-void lcd_ana_write(unsigned int _reg, unsigned int _value);
-void lcd_ana_setb(unsigned int _reg, unsigned int _value,
-		  unsigned int _start, unsigned int _len);
-unsigned int lcd_ana_getb(unsigned int _reg,
-			  unsigned int _start, unsigned int _len);
-
 extern unsigned int lcd_cbus_read(unsigned int _reg);
 extern void lcd_cbus_write(unsigned int _reg, unsigned int _value);
 extern void lcd_cbus_setb(unsigned int _reg, unsigned int _value,
@@ -1564,10 +1532,8 @@ extern void lcd_cbus_setb(unsigned int _reg, unsigned int _value,
 
 extern unsigned int lcd_periphs_read(unsigned int _reg);
 extern void lcd_periphs_write(unsigned int _reg, unsigned int _value);
-unsigned int lcd_reset_read(unsigned int _reg);
-void lcd_reset_write(unsigned int _reg, unsigned int _value);
-void lcd_reset_setb(unsigned int _reg, unsigned int _value,
-		    unsigned int _start, unsigned int _len);
+extern void lcd_pinmux_set_mask(unsigned int _reg, unsigned int _mask);
+extern void lcd_pinmux_clr_mask(unsigned int _reg, unsigned int _mask);
 
 extern unsigned int dsi_host_read(unsigned int _reg);
 extern void dsi_host_write(unsigned int _reg, unsigned int _value);
@@ -1594,19 +1560,12 @@ extern unsigned int lcd_tcon_getb(unsigned int reg,
 		unsigned int _start, unsigned int _len);
 extern void lcd_tcon_set_mask(unsigned int reg, unsigned int _mask);
 extern void lcd_tcon_clr_mask(unsigned int reg, unsigned int _mask);
-void lcd_tcon_update_bits(unsigned int reg, unsigned int mask,
-			  unsigned int value);
-int lcd_tcon_check_bits(unsigned int reg, unsigned int mask,
-			unsigned int value);
 extern unsigned char lcd_tcon_read_byte(unsigned int _reg);
 extern void lcd_tcon_write_byte(unsigned int _reg, unsigned char _value);
 extern void lcd_tcon_setb_byte(unsigned int reg, unsigned char value,
 		unsigned int _start, unsigned int _len);
 extern unsigned char lcd_tcon_getb_byte(unsigned int reg,
 		unsigned int _start, unsigned int _len);
-void lcd_tcon_update_bits_byte(unsigned int reg, unsigned char mask,
-			       unsigned char value);
-int lcd_tcon_check_bits_byte(unsigned int reg, unsigned char mask,
-			     unsigned char value);
+
 #endif
 
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_drv.c b/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_drv.c
index 0e0ba4d404c3..cb4647640bed 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_drv.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_drv.c
@@ -201,8 +201,6 @@ static void lcd_venc_set(struct lcd_config_s *pconf)
 		lcd_vcbus_write(ENCL_INBUF_CNTL0, 0x200);
 		break;
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		/*[15:14]: 2'b10 or 2'b01 bit13:1*/
 		lcd_vcbus_write(ENCL_INBUF_CNTL1, (5 << 13) | (h_active - 1));
 		lcd_vcbus_write(ENCL_INBUF_CNTL0, 0x200);
@@ -246,8 +244,6 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
 		reg_cntl1 = HHI_LVDS_TX_PHY_CNTL1_TL1;
 		break;
@@ -263,25 +259,23 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 		phy_div = 1;
 
 	/* set fifo_clk_sel: div 7 */
-	lcd_ana_write(reg_cntl0, (1 << 6));
+	lcd_hiu_write(reg_cntl0, (1 << 6));
 	/* set cntl_ser_en:  8-channel to 1 */
-	lcd_ana_setb(reg_cntl0, 0xfff, 16, 12);
+	lcd_hiu_setb(reg_cntl0, 0xfff, 16, 12);
 	switch (lcd_drv->data->chip_type) { /* pn swap */
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		lcd_ana_setb(reg_cntl0, 1, 2, 1);
+		lcd_hiu_setb(reg_cntl0, 1, 2, 1);
 		break;
 	default:
 		break;
 	}
 
 	/* decoupling fifo enable, gated clock enable */
-	lcd_ana_write(reg_cntl1,
-		      (1 << 30) | ((phy_div - 1) << 25) | (1 << 24));
+	lcd_hiu_write(reg_cntl1,
+		(1 << 30) | ((phy_div - 1) << 25) | (1 << 24));
 	/* decoupling fifo write enable after fifo enable */
-	lcd_ana_setb(reg_cntl1, 1, 31, 1);
+	lcd_hiu_setb(reg_cntl1, 1, 31, 1);
 }
 
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
@@ -340,43 +334,8 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-		if (port_swap) {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x456789ab);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x0123);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x10ba9876);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x5432);
-			}
-		} else {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0xab012345);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x6789);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x76543210);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0xba98);
-			}
-		}
-		break;
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		if (port_swap) {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x345789ab);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x0612);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x210a9876);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x5b43);
-			}
-		} else {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0xab12345);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x60789);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x87643210);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0xb5a9);
-			}
-		}
+		lcd_vcbus_write(P2P_CH_SWAP0, 0x76543210);
+		lcd_vcbus_write(P2P_CH_SWAP1, 0xba98);
 		break;
 	default:
 		lcd_vcbus_setb(LCD_PORT_SWAP, port_swap, 12, 1);
@@ -386,7 +345,8 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 	}
 
 	lcd_vcbus_write(LVDS_GEN_CNTL,
-		(lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
+		(lcd_vcbus_read(LVDS_GEN_CNTL) |
+		(1 << 4) | (fifo_mode << 0)));
 
 	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 }
@@ -415,8 +375,6 @@ static void lcd_vbyone_clk_util_set(struct lcd_config_s *pconf)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
 		reg_cntl1 = HHI_LVDS_TX_PHY_CNTL1_TL1;
 		break;
@@ -444,25 +402,23 @@ static void lcd_vbyone_clk_util_set(struct lcd_config_s *pconf)
 		break;
 	}
 	/* set fifo_clk_sel */
-	lcd_ana_write(reg_cntl0, (div_sel << 6));
+	lcd_hiu_write(reg_cntl0, (div_sel << 6));
 	/* set cntl_ser_en:  8-channel to 1 */
-	lcd_ana_setb(reg_cntl0, 0xfff, 16, 12);
+	lcd_hiu_setb(reg_cntl0, 0xfff, 16, 12);
 	switch (lcd_drv->data->chip_type) { /* pn swap */
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		lcd_ana_setb(reg_cntl0, 1, 2, 1);
+		lcd_hiu_setb(reg_cntl0, 1, 2, 1);
 		break;
 	default:
 		break;
 	}
 
 	/* decoupling fifo enable, gated clock enable */
-	lcd_ana_write(reg_cntl1,
-		      (1 << 30) | ((phy_div - 1) << 25) | (1 << 24));
+	lcd_hiu_write(reg_cntl1,
+		(1 << 30) | ((phy_div - 1) << 25) | (1 << 24));
 	/* decoupling fifo write enable after fifo enable */
-	lcd_ana_setb(reg_cntl1, 1, 31, 1);
+	lcd_hiu_setb(reg_cntl1, 1, 31, 1);
 }
 
 static int lcd_vbyone_lanes_set(int lane_num, int byte_mode, int region_num,
@@ -534,132 +490,17 @@ static int lcd_vbyone_lanes_set(int lane_num, int byte_mode, int region_num,
 	return 0;
 }
 
-static void lcd_vbyone_hw_filter(int flag)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct vbyone_config_s *vx1_conf;
-	unsigned int temp, period;
-	unsigned int tick_period[] = {
-		0xfff,
-		0xff,    /* 1: 0.8us */
-		0x1ff,   /* 2: 1.7us */
-		0x3ff,   /* 3: 3.4us */
-		0x7ff,   /* 4: 6.9us */
-		0xfff,   /* 5: 13.8us */
-		0x1fff,  /* 6: 27us */
-		0x3fff,  /* 7: 55us */
-		0x7fff,  /* 8: 110us */
-		0xffff,  /* 9: 221us */
-		0x1ffff, /* 10: 441us */
-		0x3ffff, /* 11: 883us */
-		0x7ffff, /* 12: 1.76ms */
-		0xfffff, /* 13: 3.53ms */
-	};
-
-	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
-	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TL1:
-	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		if (flag) {
-			period = vx1_conf->hw_filter_time & 0xff;
-			if (period >=
-				(sizeof(tick_period) / sizeof(unsigned int)))
-				period = tick_period[0];
-			else
-				period = tick_period[period];
-			temp = period & 0xffff;
-			lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_L, temp);
-			temp = (period >> 16) & 0xf;
-			lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_H, temp);
-			/* hpd */
-			temp = vx1_conf->hw_filter_cnt & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 8, 4);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INSGN_CTRL, temp, 8, 4);
-			}
-			/* lockn */
-			temp = (vx1_conf->hw_filter_cnt >> 8) & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 12, 4);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INSGN_CTRL, temp, 12, 4);
-			}
-		} else {
-			temp = (vx1_conf->hw_filter_time >> 8) & 0x1;
-			if (temp) {
-				lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_L,
-						0xff);
-				lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_H,
-						0x0);
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 8, 4);
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 12, 4);
-				LCDPR("%s: %d disable for debug\n",
-				      __func__, flag);
-			}
-		}
-		break;
-	default:
-		if (flag) {
-			lcd_vcbus_setb(VBO_INFILTER_CTRL, 0xff, 8, 8);
-			/* hpd */
-			temp = vx1_conf->hw_filter_cnt & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, 0, 0, 3);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, temp, 0, 3);
-			}
-			/* lockn */
-			temp = (vx1_conf->hw_filter_cnt >> 8) & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, 0, 4, 3);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, temp, 4, 3);
-			}
-		} else {
-			temp = (vx1_conf->hw_filter_time >> 8) & 0x1;
-			if (temp) {
-				lcd_vcbus_write(VBO_INFILTER_CTRL, 0xff00);
-				LCDPR("%s: %d disable for debug\n",
-				      __func__, flag);
-			}
-		}
-		break;
-	}
-}
-
 static void lcd_vbyone_sw_reset(void)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned int reg_cntl0;
-
-	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TL1:
-	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
-		break;
-	default:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0;
-		break;
-	}
-
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
 
 	/* force PHY to 0 */
-	lcd_ana_setb(reg_cntl0, 3, 8, 2);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
 	lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
 	udelay(5);
 	/* realease PHY */
-	lcd_ana_setb(reg_cntl0, 0, 8, 2);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
 	lcd_vcbus_write(VBO_SOFT_RST, 0);
 }
 
@@ -686,6 +527,7 @@ static void lcd_vbyone_wait_timing_stable(void)
 
 static void lcd_vbyone_control_set(struct lcd_config_s *pconf)
 {
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	int lane_count, byte_mode, region_num, hsize, vsize, color_fmt;
 	int vin_color, vin_bpp;
 
@@ -753,8 +595,6 @@ static void lcd_vbyone_control_set(struct lcd_config_s *pconf)
 	//lcd_vcbus_setb(VBO_PXL_CTRL,0x2,0,4);
 	//lcd_vcbus_setb(VBO_PXL_CTRL,0x3,VBO_PXL_CTR1_BIT,VBO_PXL_CTR1_WID);
 	//set_vbyone_ctlbits(1,0,0); */
-	/* VBO_RGN_GEN clk always on */
-	lcd_vcbus_setb(VBO_GCLK_MAIN, 2, 2, 2);
 
 	/* PAD select: */
 	if ((lane_count == 1) || (lane_count == 2))
@@ -768,7 +608,18 @@ static void lcd_vbyone_control_set(struct lcd_config_s *pconf)
 	/* Mux pads in combo-phy: 0 for dsi; 1 for lvds or vbyone; 2 for edp */
 	/*lcd_hiu_write(HHI_DSI_LVDS_EDP_CNTL0, 0x1);*/
 
-	lcd_vbyone_hw_filter(1);
+	switch (lcd_drv->data->chip_type) {
+	case LCD_CHIP_TL1:
+	case LCD_CHIP_TM2:
+		lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_L, 0xff);
+		lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_H, 0x0);
+		lcd_vcbus_setb(VBO_INSGN_CTRL, 0x7, 8, 4);
+		lcd_vcbus_setb(VBO_INSGN_CTRL, 0x7, 12, 4);
+		break;
+	default:
+		lcd_vcbus_write(VBO_INFILTER_CTRL, 0xff77);
+		break;
+	}
 	lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 2, 2);
 
 	lcd_vcbus_setb(VBO_CTRL_L, 1, 0, 1);
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_tablet.c b/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_tablet.c
index f5a6dc9c293f..c62d124b9140 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_tablet.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_tablet/lcd_tablet.c
@@ -53,16 +53,9 @@ static struct vinfo_s *lcd_get_current_info(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return NULL;
 	return lcd_drv->lcd_info;
 }
 
-static int lcd_check_same_vmodeattr(char *mode)
-{
-	return 0;
-}
-
 static int lcd_vmode_is_supported(enum vmode_e mode)
 {
 	mode &= VMODE_MODE_BIT_MASK;
@@ -74,15 +67,12 @@ static int lcd_vmode_is_supported(enum vmode_e mode)
 	return false;
 }
 
-static enum vmode_e lcd_validate_vmode(char *mode, unsigned int frac)
+static enum vmode_e lcd_validate_vmode(char *mode)
 {
 	if (mode == NULL)
 		return VMODE_MAX;
 
-	if (frac)
-		return VMODE_MAX;
-
-	if ((strcmp(mode, PANEL_NAME)) == 0)
+	if ((strncmp(mode, PANEL_NAME, strlen(PANEL_NAME))) == 0)
 		return VMODE_LCD;
 
 	return VMODE_MAX;
@@ -93,9 +83,6 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	mutex_lock(&lcd_drv->power_mutex);
 
 	if (VMODE_LCD == (mode & VMODE_MODE_BIT_MASK)) {
@@ -119,9 +106,6 @@ static int lcd_vout_disable(enum vmode_e cur_vmod)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	mutex_lock(&lcd_drv->power_mutex);
 	lcd_drv->lcd_status &= ~LCD_STATUS_VMODE_ACTIVE;
 	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
@@ -136,9 +120,6 @@ static int lcd_vout_set_state(int index)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	lcd_vout_state |= (1 << index);
 	lcd_drv->viu_sel = index;
 
@@ -149,9 +130,6 @@ static int lcd_vout_clr_state(int index)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	lcd_vout_state &= ~(1 << index);
 	if (lcd_drv->viu_sel == index)
 		lcd_drv->viu_sel = LCD_VIU_SEL_NONE;
@@ -164,42 +142,40 @@ static int lcd_vout_get_state(void)
 	return lcd_vout_state;
 }
 
-static int lcd_vout_get_disp_cap(char *buf)
-{
-	int ret = 0;
-
-	ret += sprintf(buf + ret, "%s\n", "panel");
-	return ret;
-}
-
 #ifdef CONFIG_AMLOGIC_VOUT_SERVE
 struct lcd_vframe_match_s {
+	int fps;
 	int frame_rate; /* *100 */
 	unsigned int duration_num;
 	unsigned int duration_den;
-	unsigned int frac;
 };
 
 static struct lcd_vframe_match_s lcd_vframe_match_table_1[] = {
-	{5000, 50, 1, 0},
-	{6000, 60, 1, 0},
-	{5994, 5994, 100, 1}
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 6000, 60, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
 };
 
 static struct lcd_vframe_match_s lcd_vframe_match_table_2[] = {
-	{5000, 50, 1, 0},
-	{6000, 60, 1, 0},
-	{4800, 48, 1, 0},
-	{5994, 5994, 100, 1}
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 4800, 48, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
 };
 
 static int lcd_framerate_automation_set_mode(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	LCDPR("%s\n", __func__);
 
 	/* update lcd config sync_duration, for calculate */
@@ -232,29 +208,21 @@ static int lcd_set_vframe_rate_hint(int duration)
 #ifdef CONFIG_AMLOGIC_VOUT_SERVE
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vinfo_s *info;
+	int fr_policy;
 	unsigned int frame_rate = 6000;
-	unsigned int duration_num = 60, duration_den = 1, frac = 0;
+	unsigned int duration_num = 60, duration_den = 1;
 	struct lcd_vframe_match_s *vtable = lcd_vframe_match_table_1;
-	int i, n, find = 0;
-
-	if (!lcd_drv)
-		return -1;
+	int fps, i, n;
 
 	if ((lcd_drv->lcd_status & LCD_STATUS_ENCL_ON) == 0) {
 		LCDPR("%s: lcd is disabled, exit\n", __func__);
-		return -1;
-	}
-
-	if (lcd_drv->lcd_config->lcd_timing.fr_adjust_type == 0xff) {
-		LCDPR("%s: fixed timing, exit\n", __func__);
-		return -1;
+		return 0;
 	}
 
-	if (lcd_debug_print_flag)
-		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
-
 	info = lcd_drv->lcd_info;
-	switch (lcd_drv->fr_auto_policy) {
+
+	fr_policy = lcd_drv->fr_auto_policy;
+	switch (fr_policy) {
 	case 1:
 		vtable = lcd_vframe_match_table_1;
 		n = ARRAY_SIZE(lcd_vframe_match_table_1);
@@ -265,16 +233,55 @@ static int lcd_set_vframe_rate_hint(int duration)
 		break;
 	default:
 		LCDPR("%s: fr_auto_policy = %d, disabled\n",
-		      __func__, lcd_drv->fr_auto_policy);
+			__func__, fr_policy);
+		return 0;
+	}
+	fps = vout_get_vsource_fps(duration);
+	for (i = 0; i < n; i++) {
+		if (fps == vtable[i].fps) {
+			frame_rate = vtable[i].frame_rate;
+			duration_num = vtable[i].duration_num;
+			duration_den = vtable[i].duration_den;
+		}
+	}
+	LCDPR("%s: policy = %d, duration = %d, fps = %d, frame_rate = %d\n",
+		__func__, fr_policy, duration, fps, frame_rate);
+
+	/* if the sync_duration is same as current */
+	if ((duration_num == info->sync_duration_num) &&
+		(duration_den == info->sync_duration_den)) {
+		LCDPR("%s: sync_duration is the same, exit\n", __func__);
+		return 0;
+	}
+
+	/* update vinfo */
+	info->sync_duration_num = duration_num;
+	info->sync_duration_den = duration_den;
+	lcd_drv->fr_mode = 1;
+
+	lcd_framerate_automation_set_mode();
+#endif
+	return 0;
+}
+
+static int lcd_set_vframe_rate_end_hint(void)
+{
+#ifdef CONFIG_AMLOGIC_VOUT_SERVE
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *info;
+
+	if ((lcd_drv->lcd_status & LCD_STATUS_ENCL_ON) == 0) {
+		LCDPR("%s: lcd is disabled, exit\n", __func__);
 		return 0;
 	}
 
-	if (duration == 0) { /* end hint */
+	if (lcd_debug_print_flag)
+		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
+	if (lcd_drv->fr_auto_policy) {
 		info = lcd_drv->lcd_info;
 		LCDPR("%s: return mode = %s, policy = %d\n", __func__,
 			info->name, lcd_drv->fr_auto_policy);
 
-		lcd_drv->fr_duration = 0;
 		if (lcd_drv->fr_mode == 0) {
 			LCDPR("%s: fr_mode is invalid, exit\n", __func__);
 			return 0;
@@ -283,58 +290,31 @@ static int lcd_set_vframe_rate_hint(int duration)
 		/* update vinfo */
 		info->sync_duration_num = lcd_drv->std_duration.duration_num;
 		info->sync_duration_den = lcd_drv->std_duration.duration_den;
-		info->frac = 0;
 		lcd_drv->fr_mode = 0;
-	} else {
-		for (i = 0; i < n; i++) {
-			if (duration == vtable[i].frame_rate) {
-				frame_rate = vtable[i].frame_rate;
-				duration_num = vtable[i].duration_num;
-				duration_den = vtable[i].duration_den;
-				frac = vtable[i].frac;
-				find = 1;
-			}
-		}
-		if (find == 0) {
-			LCDERR("%s: can't support duration %d\n, exit\n",
-			       __func__, duration);
-			return -1;
-		}
-
-		LCDPR("%s: policy = %d, duration = %d, frame_rate = %d\n",
-		      __func__, lcd_drv->fr_auto_policy,
-		      duration, frame_rate);
-
-		lcd_drv->fr_duration = duration;
-		/* if the sync_duration is same as current */
-		if ((duration_num == info->sync_duration_num) &&
-			(duration_den == info->sync_duration_den)) {
-			LCDPR("%s: sync_duration is the same, exit\n",
-			      __func__);
-			return 0;
-		}
 
-		/* update vinfo */
-		info->sync_duration_num = duration_num;
-		info->sync_duration_den = duration_den;
-		info->frac = frac;
-		lcd_drv->fr_mode = duration;
+		lcd_framerate_automation_set_mode();
 	}
-
-	lcd_framerate_automation_set_mode();
 #endif
 	return 0;
 }
 
-static int lcd_get_vframe_rate_hint(void)
+static int lcd_set_vframe_rate_policy(int policy)
 {
 #ifdef CONFIG_AMLOGIC_VOUT_SERVE
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return 0;
+	lcd_drv->fr_auto_policy = policy;
+	LCDPR("%s: %d\n", __func__, lcd_drv->fr_auto_policy);
+#endif
+	return 0;
+}
+
+static int lcd_get_vframe_rate_policy(void)
+{
+#ifdef CONFIG_AMLOGIC_VOUT_SERVE
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	return lcd_drv->fr_duration;
+	return lcd_drv->fr_auto_policy;
 #else
 	return 0;
 #endif
@@ -345,9 +325,6 @@ static int lcd_suspend(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	mutex_lock(&lcd_drv->power_mutex);
 	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
 	lcd_resume_flag = 0;
@@ -360,9 +337,6 @@ static int lcd_resume(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	if ((lcd_drv->lcd_status & LCD_STATUS_VMODE_ACTIVE) == 0)
 		return 0;
 
@@ -380,11 +354,7 @@ static int lcd_resume(void)
 		mutex_lock(&lcd_drv->power_mutex);
 		LCDPR("directly lcd late resume\n");
 		lcd_resume_flag = 1;
-		if (lcd_drv->boot_ctrl->lcd_init_level ==
-		    LCD_INIT_LEVEL_KERNEL_OFF)
-			aml_lcd_notifier_call_chain(LCD_EVENT_PREPARE, NULL);
-		else
-			aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
 		lcd_if_enable_retry(lcd_drv->lcd_config);
 		LCDPR("%s finished\n", __func__);
 		mutex_unlock(&lcd_drv->power_mutex);
@@ -400,15 +370,15 @@ static struct vout_server_s lcd_vout_server = {
 		.get_vinfo = lcd_get_current_info,
 		.set_vmode = lcd_set_current_vmode,
 		.validate_vmode = lcd_validate_vmode,
-		.check_same_vmodeattr = lcd_check_same_vmodeattr,
 		.vmode_is_supported = lcd_vmode_is_supported,
 		.disable = lcd_vout_disable,
 		.set_state = lcd_vout_set_state,
 		.clr_state = lcd_vout_clr_state,
 		.get_state = lcd_vout_get_state,
-		.get_disp_cap = lcd_vout_get_disp_cap,
 		.set_vframe_rate_hint = lcd_set_vframe_rate_hint,
-		.get_vframe_rate_hint = lcd_get_vframe_rate_hint,
+		.set_vframe_rate_end_hint = lcd_set_vframe_rate_end_hint,
+		.set_vframe_rate_policy = lcd_set_vframe_rate_policy,
+		.get_vframe_rate_policy = lcd_get_vframe_rate_policy,
 		.set_bist = lcd_debug_test,
 #ifdef CONFIG_PM
 		.vout_suspend = lcd_suspend,
@@ -424,15 +394,15 @@ static struct vout_server_s lcd_vout2_server = {
 		.get_vinfo = lcd_get_current_info,
 		.set_vmode = lcd_set_current_vmode,
 		.validate_vmode = lcd_validate_vmode,
-		.check_same_vmodeattr = lcd_check_same_vmodeattr,
 		.vmode_is_supported = lcd_vmode_is_supported,
 		.disable = lcd_vout_disable,
 		.set_state = lcd_vout_set_state,
 		.clr_state = lcd_vout_clr_state,
 		.get_state = lcd_vout_get_state,
-		.get_disp_cap = lcd_vout_get_disp_cap,
 		.set_vframe_rate_hint = lcd_set_vframe_rate_hint,
-		.get_vframe_rate_hint = lcd_get_vframe_rate_hint,
+		.set_vframe_rate_end_hint = lcd_set_vframe_rate_end_hint,
+		.set_vframe_rate_policy = lcd_set_vframe_rate_policy,
+		.get_vframe_rate_policy = lcd_get_vframe_rate_policy,
 		.set_bist = lcd_debug_test,
 #ifdef CONFIG_PM
 		.vout_suspend = lcd_suspend,
@@ -448,9 +418,6 @@ static void lcd_tablet_vinfo_update(void)
 	struct vinfo_s *vinfo;
 	struct lcd_config_s *pconf;
 
-	if (!lcd_drv)
-		return;
-
 	vinfo = lcd_drv->lcd_info;
 	pconf = lcd_drv->lcd_config;
 
@@ -506,9 +473,6 @@ static void lcd_tablet_vinfo_update_default(void)
 	struct vinfo_s *vinfo;
 	unsigned int h_active, v_active, h_total, v_total;
 
-	if (!lcd_drv)
-		return;
-
 	if (lcd_drv->lcd_info == NULL) {
 		LCDERR("no lcd_info exist\n");
 		return;
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tcon.c b/drivers/amlogic/media/vout/lcd/lcd_tcon.c
index 98d137248835..bfd300b2de3c 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_tcon.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_tcon.c
@@ -14,11 +14,11 @@
  * more details.
  *
  */
+
 #include <linux/init.h>
 #include <linux/version.h>
 #include <linux/types.h>
 #include <linux/slab.h>
-#include <linux/vmalloc.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
@@ -33,36 +33,30 @@
 #include <linux/dma-mapping.h>
 #include <linux/amlogic/media/vout/lcd/lcd_vout.h>
 #include <linux/amlogic/media/vout/lcd/lcd_unifykey.h>
-#ifdef CONFIG_AMLOGIC_BACKLIGHT
-#include <linux/amlogic/media/vout/lcd/aml_bl.h>
-#endif
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#ifdef CONFIG_AMLOGIC_TEE
-#include <linux/amlogic/tee.h>
-#endif
 #include "lcd_common.h"
 #include "lcd_reg.h"
 #include "lcd_tcon.h"
 /*#include "tcon_ceds.h"*/
 
-static struct lcd_tcon_config_s *lcd_tcon_conf;
-static struct tcon_rmem_s tcon_rmem;
-static struct tcon_mem_map_table_s tcon_mm_table;
+#define TCON_INTR_MASKN_VAL    0x0  /* default mask all */
+
+static struct tcon_rmem_s tcon_rmem = {
+	.flag = 0,
+	.mem_vaddr = NULL,
+	.mem_paddr = 0,
+	.mem_size = 0,
+};
+
+static struct lcd_tcon_data_s *lcd_tcon_data;
 static struct delayed_work lcd_tcon_delayed_work;
-static struct lcd_tcon_local_cfg_s tcon_local_cfg;
 
-/* **********************************
- * tcon common function
- * **********************************
- */
-int lcd_tcon_valid_check(void)
+static int lcd_tcon_valid_check(void)
 {
-	if (!lcd_tcon_conf) {
+	if (lcd_tcon_data == NULL) {
 		LCDERR("invalid tcon data\n");
 		return -1;
 	}
-	if (lcd_tcon_conf->tcon_valid == 0) {
+	if (lcd_tcon_data->tcon_valid == 0) {
 		LCDERR("invalid tcon\n");
 		return -1;
 	}
@@ -70,165 +64,320 @@ int lcd_tcon_valid_check(void)
 	return 0;
 }
 
-struct lcd_tcon_config_s *get_lcd_tcon_config(void)
+unsigned int lcd_tcon_reg_read(unsigned int addr)
 {
+	unsigned int val;
 	int ret;
 
 	ret = lcd_tcon_valid_check();
 	if (ret)
-		return NULL;
+		return 0;
+
+	if (addr < TCON_TOP_BASE) {
+		if (lcd_tcon_data->core_reg_width == 8)
+			val = lcd_tcon_read_byte(addr);
+		else
+			val = lcd_tcon_read(addr);
+	} else {
+		val = lcd_tcon_read(addr);
+	}
 
-	return lcd_tcon_conf;
+	return val;
 }
 
-struct tcon_rmem_s *get_lcd_tcon_rmem(void)
+void lcd_tcon_reg_write(unsigned int addr, unsigned int val)
 {
+	unsigned char temp;
 	int ret;
 
 	ret = lcd_tcon_valid_check();
 	if (ret)
-		return NULL;
+		return;
 
-	return &tcon_rmem;
+	if (addr < TCON_TOP_BASE) {
+		if (lcd_tcon_data->core_reg_width == 8) {
+			temp = (unsigned char)val;
+			lcd_tcon_write_byte(addr, temp);
+		} else {
+			lcd_tcon_write(addr, val);
+		}
+	} else {
+		lcd_tcon_write(addr, val);
+	}
 }
 
-struct tcon_mem_map_table_s *get_lcd_tcon_mm_table(void)
+static void lcd_tcon_od_init(unsigned char *table)
 {
-	int ret;
+	unsigned int reg, bit, flag;
 
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return NULL;
+	if (lcd_tcon_data->reg_core_od == REG_LCD_TCON_MAX)
+		return;
 
-	return &tcon_mm_table;
+	reg = lcd_tcon_data->reg_core_od;
+	bit = lcd_tcon_data->bit_od_en;
+	flag = (table[reg] >> bit) & 1;
+	lcd_tcon_od_set(flag);
 }
 
-unsigned int lcd_tcon_data_size_align(unsigned int size)
+static void lcd_tcon_od_check(unsigned char *table)
 {
-	unsigned int new_size;
+	unsigned int reg, bit;
+
+	if (lcd_tcon_data->reg_core_od == REG_LCD_TCON_MAX)
+		return;
 
-	/* ready for burst 128bit */
-	new_size = ((size + 15) / 16) * 16;
+	reg = lcd_tcon_data->reg_core_od;
+	bit = lcd_tcon_data->bit_od_en;
+	if (((table[reg] >> bit) & 1) == 0)
+		return;
 
-	return new_size;
+	if (tcon_rmem.flag == 0) {
+		table[reg] &= ~(1 << bit);
+		LCDPR("%s: invalid fb, disable od function\n", __func__);
+	}
 }
 
-unsigned char lcd_tcon_checksum(unsigned char *buf, unsigned int len)
+void lcd_tcon_core_reg_update(void)
 {
-	unsigned int temp = 0;
-	unsigned int i;
+	unsigned char *table;
+	unsigned int len, temp;
+	int i, ret;
 
-	if (!buf)
-		return 0;
-	if (len == 0)
-		return 0;
-	for (i = 0; i < len; i++)
-		temp += buf[i];
+	ret = lcd_tcon_valid_check();
+	if (ret)
+		return;
 
-	return (unsigned char)(temp & 0xff);
-}
+	len = lcd_tcon_data->reg_table_len;
+	table = lcd_tcon_data->reg_table;
+	if (table == NULL) {
+		LCDERR("%s: table is NULL\n", __func__);
+		return;
+	}
+	lcd_tcon_od_check(table);
+	if (lcd_tcon_data->core_reg_width == 8) {
+		for (i = 0; i < len; i++) {
+			lcd_tcon_write_byte((i + TCON_CORE_REG_START),
+				table[i]);
+		}
+	} else {
+		for (i = 0; i < len; i++)
+			lcd_tcon_write((i + TCON_CORE_REG_START), table[i]);
+	}
+	LCDPR("tcon core regs update\n");
 
-unsigned char lcd_tcon_lrc(unsigned char *buf, unsigned int len)
-{
-	unsigned char temp = 0;
-	unsigned int i;
-
-	if (!buf)
-		return 0xff;
-	if (len == 0)
-		return 0xff;
-	temp = buf[0];
-	for (i = 1; i < len; i++)
-		temp = temp ^ buf[i];
-
-	return temp;
+	if (lcd_tcon_data->reg_core_od != REG_LCD_TCON_MAX) {
+		i = lcd_tcon_data->reg_core_od;
+		if (lcd_tcon_data->core_reg_width == 8)
+			temp = lcd_tcon_read_byte(i + TCON_CORE_REG_START);
+		else
+			temp = lcd_tcon_read(i + TCON_CORE_REG_START);
+		LCDPR("%s: tcon od reg readback: 0x%04x = 0x%04x\n",
+			__func__, i, temp);
+	}
 }
 
-static unsigned char *lcd_tcon_paddrtovaddr(unsigned long paddr,
-					    unsigned int mem_size)
+static int lcd_tcon_top_set_tl1(struct lcd_config_s *pconf)
 {
-	unsigned int highmem_flag = 0;
-	int max_mem_size = 0;
-	void *vaddr = NULL;
+	unsigned int axi_reg[3] = {
+		TCON_AXI_OFST0, TCON_AXI_OFST1, TCON_AXI_OFST2
+	};
+	unsigned int addr[3] = {0, 0, 0};
+	unsigned int size[3] = {4162560, 4162560, 1960440};
+	int i;
 
-	if (tcon_rmem.flag == 0) {
-		LCDPR("%s: invalid paddr\n", __func__);
-		return NULL;
-	}
+	LCDPR("lcd tcon top set\n");
 
-	highmem_flag = PageHighMem(phys_to_page(paddr));
-	if (lcd_debug_print_flag) {
-		LCDPR("%s: paddr 0x%lx highmem_flag:%d\n",
-		      __func__, paddr, highmem_flag);
-	}
-	if (highmem_flag) {
-		max_mem_size = PAGE_ALIGN(mem_size);
-		max_mem_size = roundup(max_mem_size, PAGE_SIZE);
-		vaddr = lcd_vmap(paddr, max_mem_size);
-		if (!vaddr) {
-			LCDPR("tcon paddr mapping error: addr: 0x%lx\n",
-				(unsigned long)paddr);
-			return NULL;
+	if (tcon_rmem.flag) {
+		addr[0] = tcon_rmem.mem_paddr;
+		addr[1] = addr[0] + size[0];
+		addr[2] = addr[1] + size[1];
+		for (i = 0; i < 3; i++) {
+			lcd_tcon_write(axi_reg[i], addr[i]);
+			LCDPR("set tcon axi_mem_paddr[%d]: 0x%08x\n",
+				i, addr[i]);
 		}
-		/*LCDPR("tcon vaddr: 0x%p\n", vaddr);*/
 	} else {
-		vaddr = phys_to_virt(paddr);
-		if (!vaddr) {
-			LCDERR("tcon vaddr mapping failed: 0x%lx\n",
-			       (unsigned long)paddr);
-			return NULL;
+		LCDERR("%s: invalid axi_mem\n", __func__);
+	}
+
+	lcd_tcon_write(TCON_CLK_CTRL, 0x001f);
+	if (pconf->lcd_basic.lcd_type == LCD_P2P) {
+		switch (pconf->lcd_control.p2p_config->p2p_type) {
+		case P2P_CHPI:
+			lcd_tcon_write(TCON_TOP_CTRL, 0x8199);
+			break;
+		default:
+			lcd_tcon_write(TCON_TOP_CTRL, 0x8999);
+			break;
 		}
-		/*LCDPR("tcon vaddr: 0x%p\n", vaddr);*/
+	} else {
+		lcd_tcon_write(TCON_TOP_CTRL, 0x8999);
 	}
-	return (unsigned char *)vaddr;
+	lcd_tcon_write(TCON_PLLLOCK_CNTL, 0x0037);
+	lcd_tcon_write(TCON_RST_CTRL, 0x003f);
+	lcd_tcon_write(TCON_RST_CTRL, 0x0000);
+	lcd_tcon_write(TCON_DDRIF_CTRL0, 0x33fff000);
+	lcd_tcon_write(TCON_DDRIF_CTRL1, 0x300300);
+
+	return 0;
 }
 
-/* **********************************
- * tcon function api
- * **********************************
- */
-unsigned int lcd_tcon_reg_read(unsigned int addr)
+static int lcd_tcon_enable_tl1(struct lcd_config_s *pconf)
 {
-	unsigned int val;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	unsigned int n = 10;
 	int ret;
 
 	ret = lcd_tcon_valid_check();
 	if (ret)
-		return 0;
+		return -1;
 
-	if (addr < lcd_tcon_conf->top_reg_base) {
-		if (lcd_tcon_conf->core_reg_width == 8)
-			val = lcd_tcon_read_byte(addr);
-		else
-			val = lcd_tcon_read(addr);
-	} else {
-		val = lcd_tcon_read(addr);
+	/* step 1: tcon top */
+	lcd_tcon_top_set_tl1(pconf);
+
+	/* step 2: tcon_core_reg_update */
+	lcd_tcon_core_reg_update();
+	if (pconf->lcd_basic.lcd_type == LCD_P2P) {
+		switch (pconf->lcd_control.p2p_config->p2p_type) {
+		case P2P_CHPI:
+			lcd_phy_tcon_chpi_bbc_init_tl1(n);
+			break;
+		default:
+			break;
+		}
 	}
 
-	return val;
+	if (lcd_tcon_getb_byte(0x23d, 0, 1))
+		lcd_drv->tcon_status = 3;
+	else
+		lcd_drv->tcon_status = 0;
+
+	/* step 3: tcon_top_output_set */
+	lcd_tcon_write(TCON_OUT_CH_SEL0, 0x76543210);
+	lcd_tcon_write(TCON_OUT_CH_SEL1, 0xba98);
+
+	/* step 4: tcon_intr_mask */
+	lcd_tcon_write(TCON_INTR_MASKN, TCON_INTR_MASKN_VAL);
+
+	return 0;
 }
 
-void lcd_tcon_reg_write(unsigned int addr, unsigned int val)
+static irqreturn_t lcd_tcon_isr(int irq, void *dev_id)
 {
-	unsigned char temp;
-	int ret;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	unsigned int temp;
 
-	ret = lcd_tcon_valid_check();
-	if (ret)
+	if ((lcd_drv->lcd_status & LCD_STATUS_IF_ON) == 0)
+		return IRQ_HANDLED;
+
+	temp = lcd_tcon_read(TCON_INTR_RO);
+	if (temp & 0x2) {
+		LCDPR("%s: tcon sw_reset triggered\n", __func__);
+		lcd_tcon_core_reg_update();
+	}
+	if (temp & 0x40)
+		LCDPR("%s: tcon ddr interface error triggered\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static void lcd_tcon_intr_init(struct aml_lcd_drv_s *lcd_drv)
+{
+	unsigned int tcon_irq = 0;
+
+	if (!lcd_drv->res_tcon_irq) {
+		LCDERR("res_tcon_irq is null\n");
 		return;
+	}
+	tcon_irq = lcd_drv->res_tcon_irq->start;
+	if (lcd_debug_print_flag)
+		LCDPR("tcon_irq: %d\n", tcon_irq);
 
-	if (addr < lcd_tcon_conf->top_reg_base) {
-		if (lcd_tcon_conf->core_reg_width == 8) {
-			temp = (unsigned char)val;
-			lcd_tcon_write_byte(addr, temp);
-		} else {
-			lcd_tcon_write(addr, val);
+	if (request_irq(tcon_irq, lcd_tcon_isr, IRQF_SHARED,
+		"lcd_tcon", (void *)"lcd_tcon"))
+		LCDERR("can't request lcd_tcon irq\n");
+	else {
+		if (lcd_debug_print_flag)
+			LCDPR("request lcd_tcon irq successful\n");
+	}
+
+	lcd_tcon_write(TCON_INTR_MASKN, TCON_INTR_MASKN_VAL);
+}
+
+static int lcd_tcon_config(struct aml_lcd_drv_s *lcd_drv)
+{
+	int key_len, reg_len, ret;
+
+#if 1
+	/* get reg table from unifykey */
+	reg_len = lcd_tcon_data->reg_table_len;
+	if (lcd_tcon_data->reg_table == NULL) {
+		lcd_tcon_data->reg_table =
+			kcalloc(reg_len, sizeof(unsigned char), GFP_KERNEL);
+		if (!lcd_tcon_data->reg_table) {
+			LCDERR("%s: Not enough memory\n", __func__);
+			return -1;
 		}
-	} else {
-		lcd_tcon_write(addr, val);
 	}
+	key_len = reg_len;
+	ret = lcd_unifykey_get_no_header("lcd_tcon",
+		lcd_tcon_data->reg_table, &key_len);
+	if (ret) {
+		kfree(lcd_tcon_data->reg_table);
+		lcd_tcon_data->reg_table = NULL;
+		LCDERR("%s: !!!!!!!!tcon unifykey load error!!!!!!!!\n",
+			__func__);
+		return -1;
+	}
+	if (key_len != reg_len) {
+		kfree(lcd_tcon_data->reg_table);
+		lcd_tcon_data->reg_table = NULL;
+		LCDERR("%s: !!!!!!!!tcon unifykey load length error!!!!!!!!\n",
+			__func__);
+		return -1;
+	}
+	LCDPR("tcon: load unifykey len: %d\n", key_len);
+#else
+	reg_len = lcd_tcon_data->reg_table_len;
+	lcd_tcon_data->reg_table = uhd_tcon_setting_ceds_h10;
+	key_len = sizeof(uhd_tcon_setting_ceds_h10)/sizeof(unsigned char);
+	if (key_len != reg_len) {
+		lcd_tcon_data->reg_table = NULL;
+		LCDERR("%s: !!!!!!!!tcon unifykey load length error!!!!!!!!\n",
+			__func__);
+		return -1;
+	}
+	LCDPR("tcon: load default table len: %d\n", key_len);
+#endif
+
+	lcd_tcon_intr_init(lcd_drv);
+	lcd_tcon_od_init(lcd_tcon_data->reg_table);
+
+	return 0;
+}
+
+static void lcd_tcon_config_delayed(struct work_struct *work)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	int key_init_flag = 0;
+	int i = 0;
+
+	key_init_flag = key_unify_get_init_flag();
+	while (key_init_flag == 0) {
+		if (i++ >= LCD_UNIFYKEY_WAIT_TIMEOUT)
+			break;
+		msleep(LCD_UNIFYKEY_RETRY_INTERVAL);
+		key_init_flag = key_unify_get_init_flag();
+	}
+	LCDPR("tcon: key_init_flag=%d, i=%d\n", key_init_flag, i);
+	if (key_init_flag)
+		lcd_tcon_config(lcd_drv);
 }
 
+/* **********************************
+ * tcon function api
+ * **********************************
+ */
 #define PR_BUF_MAX    200
 void lcd_tcon_reg_table_print(void)
 {
@@ -240,24 +389,26 @@ void lcd_tcon_reg_table_print(void)
 	if (ret)
 		return;
 
-	if (!tcon_mm_table.core_reg_table) {
+	if (lcd_tcon_data->reg_table == NULL) {
 		LCDERR("%s: reg_table is null\n", __func__);
 		return;
 	}
 
 	buf = kcalloc(PR_BUF_MAX, sizeof(char), GFP_KERNEL);
-	if (!buf)
+	if (buf == NULL) {
+		LCDERR("%s: buf malloc error\n", __func__);
 		return;
+	}
 
 	LCDPR("%s:\n", __func__);
-	cnt = tcon_mm_table.core_reg_table_size;
+	cnt = lcd_tcon_data->reg_table_len;
 	for (i = 0; i < cnt; i += 16) {
-		n = snprintf(buf, PR_BUF_MAX, "%04x: ", i);
+		n = snprintf(buf, PR_BUF_MAX, "0x%04x: ", i);
 		for (j = 0; j < 16; j++) {
 			if ((i + j) >= cnt)
 				break;
-			n += snprintf(buf + n, PR_BUF_MAX, " %02x",
-				      tcon_mm_table.core_reg_table[i + j]);
+			n += snprintf(buf+n, PR_BUF_MAX, " 0x%02x",
+				lcd_tcon_data->reg_table[i+j]);
 		}
 		buf[n] = '\0';
 		pr_info("%s\n", buf);
@@ -267,7 +418,7 @@ void lcd_tcon_reg_table_print(void)
 
 void lcd_tcon_reg_readback_print(void)
 {
-	int i, j, n, cnt, offset;
+	int i, j, n, cnt;
 	char *buf;
 	int ret;
 
@@ -276,334 +427,96 @@ void lcd_tcon_reg_readback_print(void)
 		return;
 
 	buf = kcalloc(PR_BUF_MAX, sizeof(char), GFP_KERNEL);
-	if (!buf)
+	if (buf == NULL) {
+		LCDERR("%s: buf malloc error\n", __func__);
 		return;
+	}
 
 	LCDPR("%s:\n", __func__);
-	cnt = tcon_mm_table.core_reg_table_size;
-	offset = lcd_tcon_conf->core_reg_start;
-	if (lcd_tcon_conf->core_reg_width == 8) {
-		for (i = offset; i < cnt; i += 16) {
-			n = snprintf(buf, PR_BUF_MAX, "%04x: ", i);
-			for (j = 0; j < 16; j++) {
-				if ((i + j) >= cnt)
-					break;
-				n += snprintf(buf + n, PR_BUF_MAX, " %02x",
-					lcd_tcon_read_byte(i + j));
-			}
-			buf[n] = '\0';
-			pr_info("%s\n", buf);
-		}
-	} else {
-		if (lcd_tcon_conf->reg_table_width == 32) {
-			cnt /= 4;
-			for (i = offset; i < cnt; i += 4) {
-				n = snprintf(buf, PR_BUF_MAX, "%04x: ", i);
-				for (j = 0; j < 4; j++) {
-					if ((i + j) >= cnt)
-						break;
-					n += snprintf
-					(buf + n, PR_BUF_MAX,
-					 " %08x", lcd_tcon_read(i + j));
-				}
-				buf[n] = '\0';
-				pr_info("%s\n", buf);
-			}
-		} else {
-			for (i = offset; i < cnt; i += 16) {
-				n = snprintf(buf, PR_BUF_MAX, "%04x: ", i);
-				for (j = 0; j < 16; j++) {
-					if ((i + j) >= cnt)
-						break;
-					n += snprintf
-					(buf + n, PR_BUF_MAX, " %02x",
-					 lcd_tcon_read(i + j));
-				}
-				buf[n] = '\0';
-				pr_info("%s\n", buf);
+	cnt = lcd_tcon_data->reg_table_len;
+	for (i = 0; i < cnt; i += 16) {
+		n = snprintf(buf, PR_BUF_MAX, "0x%04x: ", i);
+		for (j = 0; j < 16; j++) {
+			if ((i + j) >= cnt)
+				break;
+			if (lcd_tcon_data->core_reg_width == 8) {
+				n += snprintf(buf+n, PR_BUF_MAX, " 0x%02x",
+					lcd_tcon_read_byte(i+j));
+			} else {
+				n += snprintf(buf+n, PR_BUF_MAX, " 0x%02x",
+					lcd_tcon_read(i+j));
 			}
 		}
+		buf[n] = '\0';
+		pr_info("%s\n", buf);
 	}
-
 	kfree(buf);
 }
 
-unsigned int lcd_tcon_table_read(unsigned int addr)
+int lcd_tcon_info_print(char *buf, int offset)
 {
-	unsigned char *table8;
-	unsigned int *table32, size = 0, val = 0;
-	int ret;
+	int len = 0, n, ret;
 
 	ret = lcd_tcon_valid_check();
 	if (ret)
-		return 0;
-
-	if (!tcon_mm_table.core_reg_table) {
-		LCDERR("tcon reg_table is null\n");
-		return 0;
-	}
-
-	if (lcd_tcon_conf->core_reg_width == 8)
-		size = tcon_mm_table.core_reg_table_size;
-	else
-		size = tcon_mm_table.core_reg_table_size / 4;
-	if (addr >= size) {
-		LCDERR("invalid tcon reg_table addr: 0x%04x\n", addr);
-		return 0;
-	}
+		return len;
 
-	if (lcd_tcon_conf->core_reg_width == 8) {
-		table8 = tcon_mm_table.core_reg_table;
-		val = table8[addr];
-	} else {
-		table32 = (unsigned int *)tcon_mm_table.core_reg_table;
-		val = table32[addr];
-	}
+	n = lcd_debug_info_len(len + offset);
+	len += snprintf((buf+len), n,
+		"tcon info:\n"
+		"core_reg_width:    %d\n"
+		"reg_table_len:     %d\n"
+		"axi_mem paddr:     0x%lx\n"
+		"axi_mem size:      0x%x\n\n",
+		lcd_tcon_data->core_reg_width,
+		lcd_tcon_data->reg_table_len,
+		(unsigned long)tcon_rmem.mem_paddr,
+		tcon_rmem.mem_size);
 
-	return val;
+	return len;
 }
 
-unsigned int lcd_tcon_table_write(unsigned int addr, unsigned int val)
+int lcd_tcon_reg_table_size_get(void)
 {
-	unsigned char *table8;
-	unsigned int *table32, size = 0, read_val = 0;
 	int ret;
 
 	ret = lcd_tcon_valid_check();
 	if (ret)
-		return 0;
-
-	if (!tcon_mm_table.core_reg_table) {
-		LCDERR("tcon reg_table is null\n");
-		return 0;
-	}
-
-	if (lcd_tcon_conf->core_reg_width == 8)
-		size = tcon_mm_table.core_reg_table_size;
-	else
-		size = tcon_mm_table.core_reg_table_size / 4;
-	if (addr >= size) {
-		LCDERR("invalid tcon reg_table addr: 0x%04x\n", addr);
-		return 0;
-	}
-
-	if (lcd_tcon_conf->core_reg_width == 8) {
-		table8 = tcon_mm_table.core_reg_table;
-		table8[addr] = (unsigned char)(val & 0xff);
-		read_val = table8[addr];
-	} else {
-		table32 = (unsigned int *)tcon_mm_table.core_reg_table;
-		table32[addr] = val;
-		read_val = table32[addr];
-	}
+		return -1;
 
-	return read_val;
+	return lcd_tcon_data->reg_table_len;
 }
 
-int lcd_tcon_info_print(char *buf, int offset)
+unsigned char *lcd_tcon_reg_table_get(void)
 {
-	unsigned int size, cnt, m;
-	unsigned char *mem_vaddr;
-	char *str;
-	int len = 0, n, ret;
-	int i;
+	int ret;
 
 	ret = lcd_tcon_valid_check();
 	if (ret)
-		return len;
-
-	n = lcd_debug_info_len(len + offset);
-	if (tcon_mm_table.version == 0) {
-		len += snprintf((buf + len), n,
-			"\ntcon info:\n"
-			"core_reg_width:         %d\n"
-			"reg_table_len:          %d\n"
-			"tcon_bin_ver:           %s\n"
-			"tcon_rmem_flag:         %d\n"
-			"tcon_data_flag:         %d\n"
-			"reserved_mem paddr:     0x%lx\n"
-			"reserved_mem size:      0x%x\n"
-			"bin_path_mem_paddr:     0x%lx\n"
-			"bin_path_mem_vaddr:     0x%p\n"
-			"bin_path_mem_size:      0x%x\n"
-			"vac_mem paddr:          0x%lx\n"
-			"vac_mem vaddr:          0x%p\n"
-			"vac_mem size:           0x%x\n"
-			"demura_set_mem paddr:   0x%lx\n"
-			"demura_set_mem vaddr:   0x%p\n"
-			"demura_set_mem size:    0x%x\n"
-			"demura_lut_mem paddr:   0x%lx\n"
-			"demura_lut_mem vaddr:   0x%p\n"
-			"demura_lut_mem size:    0x%x\n"
-			"acc_lut_mem paddr:      0x%lx\n"
-			"acc_lut_mem vaddr:      0x%p\n"
-			"acc_lut_mem size:       0x%x\n\n",
-			lcd_tcon_conf->core_reg_width,
-			lcd_tcon_conf->reg_table_len,
-			tcon_local_cfg.bin_ver,
-			tcon_rmem.flag,
-			tcon_mm_table.tcon_data_flag,
-			(unsigned long)tcon_rmem.rsv_mem_paddr,
-			tcon_rmem.rsv_mem_size,
-			(unsigned long)tcon_rmem.bin_path_rmem.mem_paddr,
-			tcon_rmem.bin_path_rmem.mem_vaddr,
-			tcon_rmem.bin_path_rmem.mem_size,
-			(unsigned long)tcon_rmem.vac_rmem.mem_paddr,
-			tcon_rmem.vac_rmem.mem_vaddr,
-			tcon_rmem.vac_rmem.mem_size,
-			(unsigned long)tcon_rmem.demura_set_rmem.mem_paddr,
-			tcon_rmem.demura_set_rmem.mem_vaddr,
-			tcon_rmem.demura_set_rmem.mem_size,
-			(unsigned long)tcon_rmem.demura_lut_rmem.mem_paddr,
-			tcon_rmem.demura_lut_rmem.mem_vaddr,
-			tcon_rmem.demura_lut_rmem.mem_size,
-			(unsigned long)tcon_rmem.acc_lut_rmem.mem_paddr,
-			tcon_rmem.acc_lut_rmem.mem_vaddr,
-			tcon_rmem.acc_lut_rmem.mem_size);
-		if (tcon_rmem.axi_rmem) {
-			for (i = 0; i < lcd_tcon_conf->axi_bank; i++) {
-				n = lcd_debug_info_len(len + offset);
-				len += snprintf
-				((buf + len), n,
-				 "axi_mem[%d]_paddr:      0x%lx\n"
-				 "axi_mem[%d]_vaddr:      0x%p\n"
-				 "axi_mem[%d]_size:       0x%x\n",
-				 i,
-				(unsigned long)tcon_rmem.axi_rmem[i].mem_paddr,
-				i, tcon_rmem.axi_rmem[i].mem_vaddr,
-				i, tcon_rmem.axi_rmem[i].mem_size);
-			}
-		}
-	} else {
-		len += snprintf((buf + len), n,
-			"\ntcon info:\n"
-			"core_reg_width:         %d\n"
-			"reg_table_len:          %d\n"
-			"tcon_bin_ver:           %s\n"
-			"tcon_rmem_flag:         %d\n"
-			"tcon_data_flag:         %d\n"
-			"reserved_mem paddr:     0x%lx\n"
-			"reserved_mem size:      0x%x\n"
-			"bin_path_mem_paddr:     0x%lx\n"
-			"bin_path_mem_vaddr:     0x%p\n"
-			"bin_path_mem_size:      0x%x\n\n",
-			lcd_tcon_conf->core_reg_width,
-			lcd_tcon_conf->reg_table_len,
-			tcon_local_cfg.bin_ver,
-			tcon_rmem.flag,
-			tcon_mm_table.tcon_data_flag,
-			(unsigned long)tcon_rmem.rsv_mem_paddr,
-			tcon_rmem.rsv_mem_size,
-			(unsigned long)tcon_rmem.bin_path_rmem.mem_paddr,
-			tcon_rmem.bin_path_rmem.mem_vaddr,
-			tcon_rmem.bin_path_rmem.mem_size);
-		if (tcon_rmem.axi_rmem) {
-			for (i = 0; i < lcd_tcon_conf->axi_bank; i++) {
-				n = lcd_debug_info_len(len + offset);
-				len += snprintf
-				((buf + len), n,
-				 "axi_mem[%d]_paddr:      0x%lx\n"
-				 "axi_mem[%d]_size:       0x%x\n",
-				 i,
-				 (unsigned long)tcon_rmem.axi_rmem[i].mem_paddr,
-				 i, tcon_rmem.axi_rmem[i].mem_size);
-			}
-		}
-		if (tcon_mm_table.data_mem_vaddr) {
-			for (i = 0; i < tcon_mm_table.block_cnt; i++) {
-				n = lcd_debug_info_len(len + offset);
-				len += snprintf((buf + len), n,
-					"data_mem_vaddr[%d]:     0x%p\n",
-					i, tcon_mm_table.data_mem_vaddr[i]);
-			}
-		}
-		if ((tcon_mm_table.data_multi_cnt > 0) &&
-		    tcon_mm_table.data_multi) {
-			for (i = 0; i < tcon_mm_table.data_multi_cnt; i++) {
-				n = lcd_debug_info_len(len + offset);
-				len += snprintf
-				((buf + len), n,
-				 "data_multi[%d] type:    0x%x\n"
-				 "data_multi[%d] list_cnt: %d\n"
-				 "data_multi[%d] sel_id:   %d\n",
-				 i, tcon_mm_table.data_multi[i].block_type,
-				 i, tcon_mm_table.data_multi[i].list_cnt,
-				 i, tcon_mm_table.data_multi[i].sel_id);
-			}
-		}
-	}
-
-	if (tcon_rmem.bin_path_rmem.mem_vaddr) {
-		mem_vaddr = tcon_rmem.bin_path_rmem.mem_vaddr;
-		size = mem_vaddr[4] |
-			(mem_vaddr[5] << 8) |
-			(mem_vaddr[6] << 16) |
-			(mem_vaddr[7] << 24);
-		cnt = mem_vaddr[16] |
-			(mem_vaddr[17] << 8) |
-			(mem_vaddr[18] << 16) |
-			(mem_vaddr[19] << 24);
-		if (size < (32 + 256 * cnt))
-			return len;
-		if (cnt > 32)
-			return len;
-		n = lcd_debug_info_len(len + offset);
-		len += snprintf((buf + len), n, "\n");
-		for (i = 0; i < cnt; i++) {
-			m = 32 + 256 * i;
-			size = mem_vaddr[m] |
-				(mem_vaddr[m + 1] << 8) |
-				(mem_vaddr[m + 2] << 16) |
-				(mem_vaddr[m + 3] << 24);
-			str = (char *)&mem_vaddr[m + 4];
-			n = lcd_debug_info_len(len + offset);
-			len += snprintf((buf + len), n,
-					"tcon_path[%d]: size: 0x%x, %s\n",
-					i, size, str);
-		}
-	}
+		return NULL;
 
-	n = lcd_debug_info_len(len + offset);
-	len += snprintf
-	((buf + len), n,
-	 "\ntcon_status:\n"
-	 "vac_valid:              %d\n"
-	 "demura_valid:           %d\n"
-	 "acc_valid:              %d\n",
-	 ((tcon_mm_table.valid_flag >> LCD_TCON_DATA_VALID_VAC) & 0x1),
-	 ((tcon_mm_table.valid_flag >> LCD_TCON_DATA_VALID_DEMURA) & 0x1),
-	 ((tcon_mm_table.valid_flag >> LCD_TCON_DATA_VALID_ACC) & 0x1));
-	return len;
+	return lcd_tcon_data->reg_table;
 }
 
 int lcd_tcon_core_reg_get(unsigned char *buf, unsigned int size)
 {
-	unsigned int reg_max = 0, offset = 0, val;
 	int i, ret;
 
 	ret = lcd_tcon_valid_check();
 	if (ret)
 		return -1;
 
-	if (size > lcd_tcon_conf->reg_table_len) {
-		LCDERR("%s: size 0x%x is not enough(0x%x)\n",
-		       __func__, size, lcd_tcon_conf->reg_table_len);
+	if (size > lcd_tcon_data->reg_table_len) {
+		LCDERR("%s: size is not enough\n", __func__);
 		return -1;
 	}
 
-	offset = lcd_tcon_conf->core_reg_start;
-	if (lcd_tcon_conf->core_reg_width == 8) {
-		for (i = offset; i < size; i++)
-			buf[i] = lcd_tcon_read_byte(i);
+	if (lcd_tcon_data->core_reg_width == 8) {
+		for (i = 0; i < size; i++)
+			buf[i] = lcd_tcon_read_byte(i + TCON_CORE_REG_START);
 	} else {
-		reg_max = size / 4;
-		for (i = offset; i < reg_max; i++) {
-			val = lcd_tcon_read(i);
-			buf[i * 4] = val & 0xff;
-			buf[i * 4 + 1] = (val >> 8) & 0xff;
-			buf[i * 4 + 2] = (val >> 16) & 0xff;
-			buf[i * 4 + 3] = (val >> 24) & 0xff;
-		}
+		for (i = 0; i < size; i++)
+			buf[i] = lcd_tcon_read(i + TCON_CORE_REG_START);
 	}
 
 	return 0;
@@ -619,7 +532,7 @@ int lcd_tcon_od_set(int flag)
 	if (ret)
 		return -1;
 
-	if (lcd_tcon_conf->reg_core_od == REG_LCD_TCON_MAX) {
+	if (lcd_tcon_data->reg_core_od == REG_LCD_TCON_MAX) {
 		LCDERR("%s: invalid od reg\n", __func__);
 		return -1;
 	}
@@ -635,13 +548,21 @@ int lcd_tcon_od_set(int flag)
 	if (!(lcd_drv->lcd_status & LCD_STATUS_IF_ON))
 		return -1;
 
-	reg = lcd_tcon_conf->reg_core_od;
-	bit = lcd_tcon_conf->bit_od_en;
-	temp = flag ? 1 : 0;
-	if (lcd_tcon_conf->core_reg_width == 8)
-		lcd_tcon_setb_byte(reg, temp, bit, 1);
+	reg = lcd_tcon_data->reg_core_od;
+	bit = lcd_tcon_data->bit_od_en;
+	if (lcd_tcon_data->core_reg_width == 8)
+		temp = lcd_tcon_read_byte(reg + TCON_CORE_REG_START);
+	else
+		temp = lcd_tcon_read(reg + TCON_CORE_REG_START);
+	if (flag)
+		temp |= (1 << bit);
+	else
+		temp &= ~(1 << bit);
+	temp &= 0xff;
+	if (lcd_tcon_data->core_reg_width == 8)
+		lcd_tcon_write_byte((reg + TCON_CORE_REG_START), temp);
 	else
-		lcd_tcon_setb(reg, temp, bit, 1);
+		lcd_tcon_write((reg + TCON_CORE_REG_START), temp);
 
 	msleep(100);
 	LCDPR("%s: %d\n", __func__, flag);
@@ -658,1484 +579,93 @@ int lcd_tcon_od_get(void)
 	if (ret)
 		return 0;
 
-	if (lcd_tcon_conf->reg_core_od == REG_LCD_TCON_MAX) {
+	if (lcd_tcon_data->reg_core_od == REG_LCD_TCON_MAX) {
 		LCDERR("%s: invalid od reg\n", __func__);
 		return 0;
 	}
 
-	reg = lcd_tcon_conf->reg_core_od;
-	bit = lcd_tcon_conf->bit_od_en;
-	if (lcd_tcon_conf->core_reg_width == 8)
-		temp = lcd_tcon_read_byte(reg);
+	reg = lcd_tcon_data->reg_core_od;
+	bit = lcd_tcon_data->bit_od_en;
+	if (lcd_tcon_data->core_reg_width == 8)
+		temp = lcd_tcon_read_byte(reg + TCON_CORE_REG_START);
 	else
-		temp = lcd_tcon_read(reg);
+		temp = lcd_tcon_read(reg + TCON_CORE_REG_START);
 	ret = ((temp >> bit) & 1);
 
 	return ret;
 }
 
-int lcd_tcon_gamma_set_pattern(unsigned int bit_width, unsigned int gamma_r,
-			       unsigned int gamma_g, unsigned int gamma_b)
-{
-	int ret;
-
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return -1;
-
-	if (lcd_tcon_conf->tcon_gamma_pattern) {
-		ret = lcd_tcon_conf->tcon_gamma_pattern(bit_width, gamma_r,
-							gamma_g, gamma_b);
-		LCDPR("%s: %dbits gamma r:0x%x g:0x%x b:0x%x\n",
-		      __func__, bit_width, gamma_r, gamma_g, gamma_b);
-	}
-
-	return ret;
-}
-
-int lcd_tcon_core_update(void)
-{
-	int ret;
-
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return -1;
-
-	lcd_tcon_core_reg_set(lcd_tcon_conf, &tcon_mm_table);
-
-	return 0;
-}
-
-int lcd_tcon_enable(struct lcd_config_s *pconf)
-{
-	int ret;
-
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return -1;
-
-	if (lcd_tcon_conf->tcon_enable)
-		lcd_tcon_conf->tcon_enable(pconf);
-
-	return 0;
-}
-
-void lcd_tcon_disable(struct lcd_config_s *pconf)
-{
-	int i, ret;
-
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return;
-
-	LCDPR("%s\n", __func__);
-
-	/* release data*/
-	if (tcon_mm_table.version) {
-		for (i = 0; i < tcon_mm_table.block_cnt; i++) {
-			if (!tcon_mm_table.data_mem_vaddr[i])
-				continue;
-			if (!tcon_mm_table.data_size)
-				continue;
-			memset(tcon_mm_table.data_mem_vaddr[i], 0,
-			       tcon_mm_table.data_size[i]);
-		}
-		tcon_mm_table.valid_flag = 0;
-		tcon_mm_table.tcon_data_flag = 0;
-		lcd_tcon_data_multi_remvoe(&tcon_mm_table);
-	}
-
-	if (lcd_tcon_conf->tcon_disable)
-		lcd_tcon_conf->tcon_disable(pconf);
-}
-
-/* return:
- *    0: matched
- *   -1: not match
- *    1: default
- */
-static int lcd_tcon_data_multi_match_check(struct aml_lcd_drv_s *lcd_drv,
-					   unsigned char *data_buf)
-{
-	struct lcd_config_s *pconf;
-#ifdef CONFIG_AMLOGIC_BACKLIGHT
-	struct aml_bl_drv_s *bldrv;
-	struct bl_pwm_config_s *bl_pwm = NULL;
-#endif
-	struct lcd_tcon_data_block_header_s *block_header;
-	struct lcd_tcon_data_block_ext_header_s *ext_header;
-	union lcd_tcon_data_part_u data_part;
-	unsigned char *p, part_type;
-	unsigned int size, data_offset, offset, i, j, k;
-	unsigned short part_cnt, block_ctrl_flag, ctrl_data_flag, ctrl_sub_type;
-	unsigned int data_byte, data_cnt, data, min, max;
-	unsigned int sync_num, sync_den, temp;
-
-	pconf = lcd_drv->lcd_config;
-	block_header = (struct lcd_tcon_data_block_header_s *)data_buf;
-	p = data_buf + LCD_TCON_DATA_BLOCK_HEADER_SIZE;
-	ext_header = (struct lcd_tcon_data_block_ext_header_s *)p;
-	part_cnt = ext_header->part_cnt;
-
-	block_ctrl_flag = block_header->block_ctrl;
-	data_offset = LCD_TCON_DATA_BLOCK_HEADER_SIZE +
-			block_header->ext_header_size;
-	size = 0;
-	for (i = 0; i < part_cnt; i++) {
-		p = data_buf + data_offset;
-		part_type = p[LCD_TCON_DATA_PART_NAME_SIZE + 3];
-		if (lcd_debug_print_flag)
-			LCDPR("%s: %s, type = 0x%02x,\n", __func__, p,
-			      part_type);
-
-		switch (part_type) {
-		case LCD_TCON_DATA_PART_TYPE_CONTROL:
-			block_ctrl_flag = 0;
-			data_part.ctrl = (struct lcd_tcon_data_part_ctrl_s *)p;
-			offset = LCD_TCON_DATA_PART_CTRL_SIZE_PRE;
-			size = offset + (data_part.ctrl->data_cnt *
-					 data_part.ctrl->data_byte_width);
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_multi_match_check_err_size;
-			ctrl_data_flag = data_part.ctrl->ctrl_data_flag;
-			ctrl_sub_type = data_part.ctrl->ctrl_sub_type;
-			if (ctrl_data_flag != LCD_TCON_DATA_CTRL_FLAG_MULTI)
-				break;
-
-			data_byte = data_part.ctrl->data_byte_width;
-			data_cnt = data_part.ctrl->data_cnt;
-
-			k = offset;
-			data = 0;
-			min = 0;
-			max = 0;
-
-			if (ctrl_sub_type == LCD_TCON_DATA_CTRL_MULTI_VFREQ) {
-				sync_num = pconf->lcd_timing.sync_duration_num;
-				sync_den = pconf->lcd_timing.sync_duration_den;
-				temp = sync_num * 100 / sync_den;
-
-				if (data_cnt != 2)
-					goto
-				lcd_tcon_data_multi_match_check_err_data_cnt;
-				for (j = 0; j < data_byte; j++)
-					min |= (p[k + j] << (j * 8));
-				k += data_byte;
-				for (j = 0; j < data_byte; j++)
-					max |= (p[k + j] << (j * 8));
-
-				if ((temp < min) || (temp > max))
-				goto lcd_tcon_data_multi_match_check_exit;
-			} else if (ctrl_sub_type ==
-				   LCD_TCON_DATA_CTRL_MULTI_BL_LEVEL) {
-#ifdef CONFIG_AMLOGIC_BACKLIGHT
-				bldrv = aml_bl_get_driver();
-				if (!bldrv)
-				goto lcd_tcon_data_multi_match_check_err_type;
-				temp = bldrv->level;
-
-				if (data_cnt != 2)
-					goto
-				lcd_tcon_data_multi_match_check_err_data_cnt;
-				for (j = 0; j < data_byte; j++)
-					min |= (p[k + j] << (j * 8));
-				k += data_byte;
-				for (j = 0; j < data_byte; j++)
-					max |= (p[k + j] << (j * 8));
-				if ((temp < min) || (temp > max))
-					goto
-				lcd_tcon_data_multi_match_check_exit;
-#endif
-			} else if (ctrl_sub_type ==
-				   LCD_TCON_DATA_CTRL_MULTI_BL_PWM_DUTY) {
-#ifdef CONFIG_AMLOGIC_BACKLIGHT
-				bldrv = aml_bl_get_driver();
-				if (!bldrv || !bldrv->bconf)
-					goto
-				lcd_tcon_data_multi_match_check_err_type;
-
-				if (data_cnt != 3)
-					goto
-				lcd_tcon_data_multi_match_check_err_data_cnt;
-				for (j = 0; j < data_byte; j++)
-					data |= (p[k + j] << (j * 8));
-				k += data_byte;
-				for (j = 0; j < data_byte; j++)
-					min |= (p[k + j] << (j * 8));
-				k += data_byte;
-				for (j = 0; j < data_byte; j++)
-					max |= (p[k + j] << (j * 8));
-
-				switch (bldrv->bconf->method) {
-				case BL_CTRL_PWM:
-					bl_pwm = bldrv->bconf->bl_pwm;
-					break;
-				case BL_CTRL_PWM_COMBO:
-					if (data == 0)
-						bl_pwm =
-						bldrv->bconf->bl_pwm_combo0;
-					else
-						bl_pwm =
-						bldrv->bconf->bl_pwm_combo1;
-					break;
-				default:
-					break;
-				}
-				if (!bl_pwm)
-				goto lcd_tcon_data_multi_match_check_err_type;
-
-				temp = bl_pwm->pwm_duty;
-				if ((temp < min) || (temp > max))
-				goto lcd_tcon_data_multi_match_check_exit;
-#endif
-			} else if (ctrl_sub_type ==
-				   LCD_TCON_DATA_CTRL_DEFAULT) {
-				return 1;
-			}
-			break;
-		default:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_multi_match_check_err_ctrl;
-			return 0;
-		}
-		data_offset += size;
-	}
-
-	return 0;
-
-lcd_tcon_data_multi_match_check_exit:
-	if (lcd_debug_print_flag)
-		LCDPR("%s: block %s control exit\n", __func__,
-		      block_header->name);
-	return -1;
-
-lcd_tcon_data_multi_match_check_err_data_cnt:
-	LCDERR("%s: block %s data_cnt error\n", __func__, block_header->name);
-	return -1;
-
-lcd_tcon_data_multi_match_check_err_ctrl:
-	LCDERR("%s: block %s need control part\n", __func__,
-	       block_header->name);
-	return -1;
-
-#ifdef CONFIG_AMLOGIC_BACKLIGHT
-lcd_tcon_data_multi_match_check_err_type:
-	LCDERR("%s: block %s control type invalid\n", __func__,
-	       block_header->name);
-	return -1;
-#endif
-
-lcd_tcon_data_multi_match_check_err_size:
-	LCDERR("%s: block %s size error\n", __func__, block_header->name);
-	return -1;
-}
-
-static int lcd_tcon_data_multi_update(struct aml_lcd_drv_s *lcd_drv,
-				      struct tcon_mem_map_table_s *mm_table)
-{
-	struct tcon_data_multi_s *data_multi = NULL;
-	struct tcon_data_list_s *temp_list, *dft_list, *match_list;
-	int i, ret = 0;
-
-	if (!mm_table || !mm_table->data_multi)
-		return 0;
-	if (mm_table->data_multi_cnt == 0)
-		return 0;
-
-	for (i = 0; i < mm_table->data_multi_cnt; i++) {
-		data_multi = &mm_table->data_multi[i];
-		temp_list = data_multi->list_header;
-		dft_list = NULL;
-		match_list = NULL;
-		while (temp_list) {
-			/* bypass current data */
-			if (data_multi->sel_id == temp_list->id) {
-				temp_list = temp_list->next;
-				continue;
-			}
-			ret = lcd_tcon_data_multi_match_check
-				(lcd_drv, temp_list->block_vaddr);
-			if (ret == 0) {
-				match_list = temp_list;
-				break;
-			}
-			if (ret == 1)
-				dft_list = temp_list;
-
-			temp_list = temp_list->next;
-		}
-
-		if (!match_list) {
-			if (dft_list) {
-				ret = lcd_tcon_data_common_parse_set
-					(dft_list->block_vaddr, 0);
-				if (ret == 0) {
-					data_multi->sel_id = dft_list->id;
-					data_multi->list_cur = dft_list;
-				}
-				if (lcd_debug_print_flag) {
-					LCDPR
-				("%s: sel default, type=0x%x, sel_id=%d\n",
-				 __func__, data_multi->block_type,
-				 data_multi->sel_id);
-				}
-			}
-		} else {
-			ret = lcd_tcon_data_common_parse_set
-				(match_list->block_vaddr, 0);
-			if (ret == 0) {
-				data_multi->sel_id = match_list->id;
-				data_multi->list_cur = match_list;
-			}
-			if (lcd_debug_print_flag) {
-				LCDPR("%s: type=0x%x, sel_id=%d\n",
-				      __func__, data_multi->block_type,
-				      data_multi->sel_id);
-			}
-		}
-	}
-
-	return ret;
-}
-
-void lcd_tcon_vsync_isr(struct aml_lcd_drv_s *lcd_drv)
-{
-	if (tcon_mm_table.version)
-		lcd_tcon_data_multi_update(lcd_drv, &tcon_mm_table);
-}
-
-/* **********************************
- * tcon config
- * **********************************
- */
-static int lcd_tcon_vac_load(void)
-{
-	unsigned int n;
-	unsigned char *buff = tcon_rmem.vac_rmem.mem_vaddr;
-	unsigned int data_cnt;
-	unsigned char data_checksum, data_lrc, temp_checksum, temp_lrc;
-
-	if ((tcon_rmem.vac_rmem.mem_size == 0) || (!buff))
-		return -1;
-
-	data_cnt = (buff[0] |
-		    (buff[1] << 8) |
-		    (buff[2] << 16) |
-		    (buff[3] << 24));
-	if (data_cnt == 0) {
-		LCDPR("%s: vac data_cnt is zero\n", __func__);
-		return -1;
-	}
-	data_checksum = buff[4];
-	data_lrc = buff[5];
-	temp_checksum = lcd_tcon_checksum(&buff[8], data_cnt);
-	temp_lrc = lcd_tcon_lrc(&buff[8], data_cnt);
-	if (data_checksum != temp_checksum) {
-		LCDERR("%s: vac_data checksum error\n", __func__);
-		return -1;
-	}
-	if (data_lrc != temp_lrc) {
-		LCDERR("%s: vac_data lrc error\n", __func__);
-		return -1;
-	}
-	if ((buff[6] != 0x55) || (buff[7] != 0xaa)) {
-		LCDERR("%s: vac_data pattern error\n", __func__);
-		return -1;
-	}
-
-	if (lcd_debug_print_flag == 3) {
-		for (n = 0; n < 30; n++)
-			LCDPR("%s: vac_data[%d]: 0x%x", __func__,
-			      n, buff[n * 1]);
-	}
-
-	return 0;
-}
-
-static int lcd_tcon_demura_set_load(void)
-{
-	unsigned int n;
-	char *buff = tcon_rmem.demura_set_rmem.mem_vaddr;
-	unsigned int data_cnt;
-	unsigned char data_checksum, data_lrc, temp_checksum, temp_lrc;
-
-	if ((tcon_rmem.demura_set_rmem.mem_size == 0) || (!buff))
-		return -1;
-
-	data_cnt = (buff[0] |
-		    (buff[1] << 8) |
-		    (buff[2] << 16) |
-		    (buff[3] << 24));
-	if (data_cnt == 0) {
-		LCDPR("%s: demura_set data_cnt is zero\n", __func__);
-		return -1;
-	}
-	data_checksum = buff[4];
-	data_lrc = buff[5];
-	temp_checksum = lcd_tcon_checksum(&buff[8], data_cnt);
-	temp_lrc = lcd_tcon_lrc(&buff[8], data_cnt);
-	if (data_checksum != temp_checksum) {
-		LCDERR("%s: demura_set checksum error\n", __func__);
-		return -1;
-	}
-	if (data_lrc != temp_lrc) {
-		LCDERR("%s: demura_set lrc error\n", __func__);
-		return -1;
-	}
-	if ((buff[6] != 0x55) || (buff[7] != 0xaa)) {
-		LCDERR("%s: demura_set pattern error\n", __func__);
-		return -1;
-	}
-
-	if (lcd_debug_print_flag == 3) {
-		for (n = 0; n < 30; n++)
-			LCDPR("%s: demura_set[%d]: 0x%x",
-			      __func__, n, buff[n]);
-	}
-
-	return 0;
-}
-
-static int lcd_tcon_demura_lut_load(void)
-{
-	unsigned int n;
-	char *buff = tcon_rmem.demura_lut_rmem.mem_vaddr;
-	unsigned int data_cnt;
-	unsigned char data_checksum, data_lrc, temp_checksum, temp_lrc;
-
-	if ((tcon_rmem.demura_lut_rmem.mem_size == 0) || (!buff))
-		return -1;
-
-	data_cnt = (buff[0] |
-		    (buff[1] << 8) |
-		    (buff[2] << 16) |
-		    (buff[3] << 24));
-	if (data_cnt == 0) {
-		LCDPR("%s: demura_lut data_cnt is zero\n", __func__);
-		return -1;
-	}
-	data_checksum = buff[4];
-	data_lrc = buff[5];
-	temp_checksum = lcd_tcon_checksum(&buff[8], data_cnt);
-	temp_lrc = lcd_tcon_lrc(&buff[8], data_cnt);
-	if (data_checksum != temp_checksum) {
-		LCDERR("%s: demura_lut checksum error\n", __func__);
-		return -1;
-	}
-	if (data_lrc != temp_lrc) {
-		LCDERR("%s: demura_lut lrc error\n", __func__);
-		return -1;
-	}
-	if ((buff[6] != 0x55) || (buff[7] != 0xaa)) {
-		LCDERR("%s: demura_lut pattern error\n", __func__);
-		return -1;
-	}
-
-	if (lcd_debug_print_flag == 3) {
-		for (n = 0; n < 30; n++)
-			LCDPR("%s: demura_lut[%d]: 0x%x\n",
-			      __func__, n, buff[n]);
-	}
-
-	return 0;
-}
-
-static int lcd_tcon_acc_lut_load(void)
-{
-	unsigned int n;
-	char *buff = tcon_rmem.acc_lut_rmem.mem_vaddr;
-	unsigned int data_cnt;
-	unsigned char data_checksum, data_lrc, temp_checksum, temp_lrc;
-
-	if ((tcon_rmem.acc_lut_rmem.mem_size == 0) || (!buff))
-		return -1;
-
-	data_cnt = (buff[0] |
-		    (buff[1] << 8) |
-		    (buff[2] << 16) |
-		    (buff[3] << 24));
-	if (data_cnt == 0) {
-		LCDPR("%s: acc_lut data_cnt is zero\n", __func__);
-		return -1;
-	}
-	data_checksum = buff[4];
-	data_lrc = buff[5];
-	temp_checksum = lcd_tcon_checksum(&buff[8], data_cnt);
-	temp_lrc = lcd_tcon_lrc(&buff[8], data_cnt);
-	if (data_checksum != temp_checksum) {
-		LCDERR("%s: acc_lut checksum error\n", __func__);
-		return -1;
-	}
-	if (data_lrc != temp_lrc) {
-		LCDERR("%s: acc_lut lrc error\n", __func__);
-		return -1;
-	}
-	if ((buff[6] != 0x55) || (buff[7] != 0xaa)) {
-		LCDERR("%s: acc_lut pattern error\n", __func__);
-		return -1;
-	}
-
-	if (lcd_debug_print_flag == 3) {
-		for (n = 0; n < 30; n++)
-			LCDPR("%s: acc_lut[%d]: 0x%x\n",
-			      __func__, n, buff[n]);
-	}
-
-	return 0;
-}
-
-static inline void lcd_tcon_data_list_add(struct tcon_data_list_s *list_header,
-					  struct tcon_data_list_s *data_list)
-{
-	struct tcon_data_list_s *temp_list;
-
-	if (!data_list)
-		return;
-
-	if (!list_header) { /* new list */
-		list_header = data_list;
-		return;
-	}
-
-	temp_list = list_header;
-	while (temp_list->next)
-		temp_list = temp_list->next;
-	temp_list->next = data_list;
-}
-
-static inline void lcd_tcon_data_list_remove(struct tcon_data_list_s
-					     *list_header)
-{
-	struct tcon_data_list_s *cur_list, *next_list;
-
-	if (!list_header)
-		return;
-
-	/* add to exist list */
-	cur_list = list_header;
-	while (cur_list) {
-		next_list = cur_list->next;
-		kfree(cur_list);
-		cur_list = next_list;
-	}
-}
-
-/* return:
- *    0: find
- *   -1: failed
- */
-static int lcd_tcon_data_multi_default_find(unsigned char *data_buf)
-{
-	struct lcd_tcon_data_block_header_s *block_header;
-	struct lcd_tcon_data_block_ext_header_s *ext_header;
-	union lcd_tcon_data_part_u data_part;
-	unsigned char *p, part_type;
-	unsigned int size, data_offset, offset, i;
-	unsigned short part_cnt, block_ctrl_flag, ctrl_data_flag, ctrl_sub_type;
-
-	block_header = (struct lcd_tcon_data_block_header_s *)data_buf;
-	p = data_buf + LCD_TCON_DATA_BLOCK_HEADER_SIZE;
-	ext_header = (struct lcd_tcon_data_block_ext_header_s *)p;
-	part_cnt = ext_header->part_cnt;
-
-	block_ctrl_flag = block_header->block_ctrl;
-	data_offset = LCD_TCON_DATA_BLOCK_HEADER_SIZE +
-		block_header->ext_header_size;
-	size = 0;
-	for (i = 0; i < part_cnt; i++) {
-		p = data_buf + data_offset;
-		part_type = p[LCD_TCON_DATA_PART_NAME_SIZE + 3];
-
-		switch (part_type) {
-		case LCD_TCON_DATA_PART_TYPE_CONTROL:
-			block_ctrl_flag = 0;
-			data_part.ctrl = (struct lcd_tcon_data_part_ctrl_s *)p;
-			offset = LCD_TCON_DATA_PART_CTRL_SIZE_PRE;
-			size = offset + (data_part.ctrl->data_cnt *
-					 data_part.ctrl->data_byte_width);
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_multi_match_check_err_size;
-			ctrl_data_flag = data_part.ctrl->ctrl_data_flag;
-			ctrl_sub_type = data_part.ctrl->ctrl_sub_type;
-			if (ctrl_data_flag != LCD_TCON_DATA_CTRL_FLAG_MULTI)
-				break;
-
-			if (ctrl_sub_type == LCD_TCON_DATA_CTRL_DEFAULT)
-				return 0;
-			break;
-		default:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_multi_match_check_err_ctrl;
-			return -1;
-		}
-		data_offset += size;
-	}
-
-	return -1;
-
-lcd_tcon_data_multi_match_check_err_ctrl:
-	LCDERR("%s: block %s need control part\n", __func__,
-	       block_header->name);
-	return -1;
-
-lcd_tcon_data_multi_match_check_err_size:
-	LCDERR("%s: block %s size error\n", __func__,
-	       block_header->name);
-	return -1;
-}
-
-int lcd_tcon_data_multi_add(struct tcon_mem_map_table_s *mm_table,
-			    struct lcd_tcon_data_block_header_s *block_header,
-			    unsigned int index)
-{
-	struct tcon_data_multi_s *data_multi = NULL;
-	struct tcon_data_list_s *data_list;
-	int i, ret;
-
-	if (!mm_table->data_multi)
-		return -1;
-	if (mm_table->data_multi_cnt > 0) {
-		if ((mm_table->data_multi_cnt + 1) >= mm_table->block_cnt) {
-			LCDERR("%s: multi block %s invalid\n",
-			       __func__, block_header->name);
-			return -1;
-		}
-	}
-
-	/* create list */
-	data_list = kmalloc(sizeof(*data_list), GFP_KERNEL);
-	if (!data_list)
-		return -1;
-	data_list->block_vaddr = mm_table->data_mem_vaddr[index];
-	data_list->next = NULL;
-	data_list->id = index;
-
-	for (i = 0; i < mm_table->data_multi_cnt; i++) {
-		if (mm_table->data_multi[i].block_type ==
-		    block_header->block_type) {
-			data_multi = &mm_table->data_multi[i];
-			break;
-		}
-	}
-	if (!data_multi) { /* create new list */
-		data_multi = &mm_table->data_multi[mm_table->data_multi_cnt];
-		mm_table->data_multi_cnt++;
-		data_multi->block_type = block_header->block_type;
-		data_multi->list_header = NULL;
-		data_multi->list_cnt = 0;
-		data_multi->sel_id = 0xff; /* default invalid */
-	}
-
-	lcd_tcon_data_list_add(data_multi->list_header, data_list);
-	ret = lcd_tcon_data_multi_default_find(data_list->block_vaddr);
-	if (ret == 0) {
-		data_multi->sel_id = data_list->id;
-		data_multi->list_cur = data_list;
-	}
-
-	data_multi->list_cnt++;
-
-	return 0;
-}
-
-int lcd_tcon_data_multi_remvoe(struct tcon_mem_map_table_s *mm_table)
-{
-	struct tcon_data_multi_s *data_multi = NULL;
-	int i;
-
-	if (!mm_table->data_multi)
-		return 0;
-	if (mm_table->data_multi_cnt == 0)
-		return 0;
-
-	for (i = 0; i < mm_table->data_multi_cnt; i++) {
-		data_multi = &mm_table->data_multi[i];
-		data_multi->block_type = LCD_TCON_DATA_BLOCK_TYPE_NONE;
-		data_multi->list_cnt = 0;
-		data_multi->flag = 0xff;
-		lcd_tcon_data_list_remove(data_multi->list_header);
-		data_multi->list_header = NULL;
-	}
-
-	return 0;
-}
-
-int lcd_tcon_data_load(void)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned char *table = tcon_mm_table.core_reg_table;
-	struct file *filp = NULL;
-	mm_segment_t old_fs = get_fs();
-	loff_t pos = 0;
-	char *str;
-	struct lcd_tcon_data_block_header_s block_header;
-	struct tcon_data_priority_s *data_prio;
-	int i, j, data_cnt = 0, demura_cnt = 0;
-	unsigned int n = 0, size, priority;
-	unsigned int header_size = LCD_TCON_DATA_BLOCK_HEADER_SIZE;
-	int ret;
-
-	if (!table) {
-		LCDERR("%s: no tcon bin table\n", __func__);
-		return -1;
-	}
-	LCDPR("%s\n", __func__);
-
-	if (tcon_mm_table.version == 0) {
-		if ((lcd_drv->data->chip_type == LCD_CHIP_TL1) ||
-		    (lcd_drv->data->chip_type == LCD_CHIP_TM2)) {
-			ret = lcd_tcon_vac_load();
-			if (ret == 0) {
-				tcon_mm_table.valid_flag |=
-					LCD_TCON_DATA_VALID_VAC;
-			}
-			ret = lcd_tcon_demura_set_load();
-			if (ret) {
-				table[0x178] = 0x38;
-				table[0x17c] = 0x20;
-				table[0x181] = 0x00;
-				table[0x23d] &= ~(1 << 0);
-			} else {
-				ret = lcd_tcon_demura_lut_load();
-				if (ret)  {
-					table[0x178] = 0x38;
-					table[0x17c] = 0x20;
-					table[0x181] = 0x00;
-					table[0x23d] &= ~(1 << 0);
-				} else {
-					tcon_mm_table.valid_flag |=
-						LCD_TCON_DATA_VALID_DEMURA;
-				}
-			}
-		}
-
-		ret = lcd_tcon_acc_lut_load();
-		if (ret == 0)
-			tcon_mm_table.valid_flag |= LCD_TCON_DATA_VALID_ACC;
-	} else {
-		if (!tcon_mm_table.data_mem_vaddr) {
-			LCDERR("%s: data_mem error\n", __func__);
-			return -1;
-		}
-		if (!tcon_mm_table.data_priority) {
-			LCDERR("%s: data_priority error\n", __func__);
-			return -1;
-		}
-		if (!tcon_mm_table.data_size) {
-			LCDERR("%s: data_size error\n", __func__);
-			return -1;
-		}
-		data_prio = tcon_mm_table.data_priority;
-
-		for (i = 0; i < tcon_mm_table.block_cnt; i++) {
-			n = 32 + i * 256;
-			size = tcon_mm_table.data_size[i];
-			str = (char *)&tcon_rmem.bin_path_rmem.mem_vaddr[n + 4];
-			set_fs(KERNEL_DS);
-			filp = filp_open(str, O_RDONLY, 0);
-			if (IS_ERR(filp)) {
-				LCDERR("%s: read %s error\n", __func__, str);
-				set_fs(old_fs);
-				return -1;
-			}
-
-			if (!tcon_mm_table.data_mem_vaddr[i]) {
-				data_cnt = vfs_read(filp, (void *)&block_header,
-						    header_size, &pos);
-				if (data_cnt != header_size) {
-					LCDERR
-				("read block head failed, data_cnt: %d\n",
-				 data_cnt);
-					goto lcd_tcon_data_load_next;
-				}
-
-				size = block_header.block_size;
-				tcon_mm_table.data_size[i] = size;
-				tcon_mm_table.data_mem_vaddr[i] =
-					kcalloc(size, sizeof(unsigned char),
-						GFP_KERNEL);
-				if (!tcon_mm_table.data_mem_vaddr[i]) {
-					LCDERR("%s: Not enough memory\n",
-					       __func__);
-					goto lcd_tcon_data_load_next;
-				}
-			}
-			pos = 0; /* must reset pos for file read */
-			data_cnt =
-			vfs_read(filp, (char *)tcon_mm_table.data_mem_vaddr[i],
-				 size, &pos);
-			if (data_cnt != size) {
-				LCDERR("%s: data_cnt: %d, data_size: %d\n",
-				       __func__, data_cnt, size);
-				goto lcd_tcon_data_load_next;
-			}
-			memcpy((void *)&block_header,
-			       (void *)tcon_mm_table.data_mem_vaddr[i],
-			       header_size);
-
-			tcon_mm_table.valid_flag |= block_header.block_flag;
-			if (block_header.block_flag ==
-			    LCD_TCON_DATA_VALID_DEMURA)
-				demura_cnt++;
-
-			/* insertion sort for block data init_priority */
-			data_prio[i].index = i;
-			/*data_prio[i].priority = block_header.init_priority;*/
-			/* update init_priority by index */
-			priority = i;
-			data_prio[i].priority = priority;
-			if (i > 0) {
-				j = i - 1;
-				while (j >= 0) {
-					if (priority > data_prio[j].priority)
-						break;
-					if (priority == data_prio[j].priority) {
-						LCDERR
-				("%s: block %d init_prio same as block %d\n",
-				 __func__, data_prio[i].index,
-				 data_prio[j].index);
-						return -1;
-					}
-					data_prio[j + 1].index =
-						data_prio[j].index;
-					data_prio[j + 1].priority =
-						data_prio[j].priority;
-					j--;
-				}
-				data_prio[j + 1].index = i;
-				data_prio[j + 1].priority = priority;
-			}
-
-			if (lcd_debug_print_flag) {
-				LCDPR
-		("%s %d: size=0x%x, type=0x%02x, name=%s, init_priority=%d\n",
-				      __func__, i,
-				      block_header.block_size,
-				      block_header.block_type,
-				      block_header.name,
-				      priority);
-			}
-
-lcd_tcon_data_load_next:
-			vfs_fsync(filp, 0);
-			filp_close(filp, NULL);
-			set_fs(old_fs);
-		}
-
-		/* specially check demura setting */
-		if ((lcd_drv->data->chip_type == LCD_CHIP_TL1) ||
-		    (lcd_drv->data->chip_type == LCD_CHIP_TM2)) {
-			if (demura_cnt < 2) {
-				tcon_mm_table.valid_flag &=
-					~LCD_TCON_DATA_VALID_DEMURA;
-				/* disable demura */
-				table[0x178] = 0x38;
-				table[0x17c] = 0x20;
-				table[0x181] = 0x00;
-				table[0x23d] &= ~(1 << 0);
-			}
-		}
-	}
-
-	tcon_mm_table.tcon_data_flag = 1;
-
-	return 0;
-}
-
-static int lcd_tcon_bin_path_update(unsigned int size)
-{
-	unsigned char *mem_vaddr;
-	unsigned int data_size, block_cnt;
-	unsigned int data_crc32, temp_crc32;
-
-	if (!tcon_rmem.bin_path_rmem.mem_vaddr) {
-		LCDERR("%s: get mem error\n", __func__);
-		return -1;
-	}
-	mem_vaddr = tcon_rmem.bin_path_rmem.mem_vaddr;
-	data_size = mem_vaddr[4] |
-		(mem_vaddr[5] << 8) |
-		(mem_vaddr[6] << 16) |
-		(mem_vaddr[7] << 24);
-	if (data_size < 32) { /* header size */
-		LCDERR("%s: tcon_bin_path data_size error\n", __func__);
-		return -1;
-	}
-	block_cnt = mem_vaddr[16] |
-		(mem_vaddr[17] << 8) |
-		(mem_vaddr[18] << 16) |
-		(mem_vaddr[19] << 24);
-	if (block_cnt > 32) {
-		LCDERR("%s: tcon_bin_path block_cnt error\n", __func__);
-		return -1;
-	}
-	data_crc32 = mem_vaddr[0] |
-		(mem_vaddr[1] << 8) |
-		(mem_vaddr[2] << 16) |
-		(mem_vaddr[3] << 24);
-	temp_crc32 = cal_crc32(0, &mem_vaddr[4], (data_size - 4));
-	if (data_crc32 != temp_crc32) {
-		LCDERR("%s: tcon_bin_path data crc error\n", __func__);
-		return -1;
-	}
-
-	tcon_mm_table.version = mem_vaddr[8] |
-		(mem_vaddr[9] << 8) |
-		(mem_vaddr[10] << 16) |
-		(mem_vaddr[11] << 24);
-	tcon_mm_table.data_load_level = mem_vaddr[12] |
-		(mem_vaddr[13] << 8) |
-		(mem_vaddr[14] << 16) |
-		(mem_vaddr[15] << 24);
-	tcon_mm_table.block_cnt = block_cnt;
-
-	return 0;
-}
-
-static int lcd_tcon_mm_table_config_v0(void)
-{
-	unsigned int max_size;
-
-	max_size = lcd_tcon_conf->axi_mem_size +
-		lcd_tcon_conf->bin_path_size +
-		lcd_tcon_conf->vac_size +
-		lcd_tcon_conf->demura_set_size +
-		lcd_tcon_conf->demura_lut_size +
-		lcd_tcon_conf->acc_lut_size;
-	if (tcon_rmem.rsv_mem_size < max_size) {
-		LCDERR("%s: tcon mem size 0x%x is not enough, need 0x%x\n",
-			__func__, tcon_rmem.rsv_mem_size, max_size);
-		return -1;
-	}
-
-	if (tcon_mm_table.block_cnt != 4) {
-		LCDERR("%s: tcon data block_cnt %d invalid\n",
-		       __func__, tcon_mm_table.block_cnt);
-		return -1;
-	}
-
-	tcon_rmem.vac_rmem.mem_size = lcd_tcon_conf->vac_size;
-	tcon_rmem.vac_rmem.mem_paddr = tcon_rmem.bin_path_rmem.mem_paddr +
-			tcon_rmem.bin_path_rmem.mem_size;
-	tcon_rmem.vac_rmem.mem_vaddr =
-		lcd_tcon_paddrtovaddr(tcon_rmem.vac_rmem.mem_paddr,
-				      tcon_rmem.vac_rmem.mem_size);
-	if (lcd_debug_print_flag && (tcon_rmem.vac_rmem.mem_size > 0))
-		LCDPR("vac_mem paddr: 0x%08x, vaddr: 0x%p, size: 0x%x\n",
-		      (unsigned int)tcon_rmem.vac_rmem.mem_paddr,
-		      tcon_rmem.vac_rmem.mem_vaddr,
-		      tcon_rmem.vac_rmem.mem_size);
-
-	tcon_rmem.demura_set_rmem.mem_size = lcd_tcon_conf->demura_set_size;
-	tcon_rmem.demura_set_rmem.mem_paddr = tcon_rmem.vac_rmem.mem_paddr +
-			tcon_rmem.vac_rmem.mem_size;
-	tcon_rmem.demura_set_rmem.mem_vaddr =
-		lcd_tcon_paddrtovaddr(tcon_rmem.demura_set_rmem.mem_paddr,
-				      tcon_rmem.demura_set_rmem.mem_size);
-	if (lcd_debug_print_flag && (tcon_rmem.demura_set_rmem.mem_size > 0))
-		LCDPR("demura_set_mem paddr: 0x%08x, vaddr: 0x%p, size: 0x%x\n",
-		      (unsigned int)tcon_rmem.demura_set_rmem.mem_paddr,
-		      tcon_rmem.demura_set_rmem.mem_vaddr,
-		      tcon_rmem.demura_set_rmem.mem_size);
-
-	tcon_rmem.demura_lut_rmem.mem_size = lcd_tcon_conf->demura_lut_size;
-	tcon_rmem.demura_lut_rmem.mem_paddr =
-			tcon_rmem.demura_set_rmem.mem_paddr +
-			tcon_rmem.demura_set_rmem.mem_size;
-	tcon_rmem.demura_lut_rmem.mem_vaddr =
-		lcd_tcon_paddrtovaddr(tcon_rmem.demura_lut_rmem.mem_paddr,
-				      tcon_rmem.demura_lut_rmem.mem_size);
-	if (lcd_debug_print_flag && (tcon_rmem.demura_lut_rmem.mem_size > 0))
-		LCDPR("demura_lut_mem paddr: 0x%08x, vaddr: 0x%p, size: 0x%x\n",
-		      (unsigned int)tcon_rmem.demura_lut_rmem.mem_paddr,
-		      tcon_rmem.demura_lut_rmem.mem_vaddr,
-		      tcon_rmem.demura_lut_rmem.mem_size);
-
-	tcon_rmem.acc_lut_rmem.mem_size = lcd_tcon_conf->acc_lut_size;
-	tcon_rmem.acc_lut_rmem.mem_paddr = tcon_rmem.demura_lut_rmem.mem_paddr +
-			tcon_rmem.demura_lut_rmem.mem_size;
-	tcon_rmem.acc_lut_rmem.mem_vaddr =
-		lcd_tcon_paddrtovaddr(tcon_rmem.acc_lut_rmem.mem_paddr,
-				      tcon_rmem.acc_lut_rmem.mem_size);
-	if (lcd_debug_print_flag && (tcon_rmem.acc_lut_rmem.mem_size > 0))
-		LCDPR("acc_lut_mem paddr: 0x%08x, vaddr: 0x%p, size: 0x%x\n",
-		      (unsigned int)tcon_rmem.acc_lut_rmem.mem_paddr,
-		      tcon_rmem.acc_lut_rmem.mem_vaddr,
-		      tcon_rmem.acc_lut_rmem.mem_size);
-
-	return 0;
-}
-
-static int lcd_tcon_mm_table_config_v1(void)
-{
-	unsigned char *mem_vaddr;
-	unsigned int cnt, data_size, n, i;
-
-	if (tcon_mm_table.block_cnt > 32) {
-		LCDERR("%s: tcon data block_cnt %d invalid\n",
-		       __func__, tcon_mm_table.block_cnt);
-		return -1;
-	}
-
-	if (tcon_mm_table.data_mem_vaddr)
-		return 0;
-	if (tcon_mm_table.block_cnt == 0) {
-		if (lcd_debug_print_flag)
-			LCDPR("%s: block_cnt is zero\n", __func__);
-		return 0;
-	}
-
-	cnt = tcon_mm_table.block_cnt;
-	tcon_mm_table.data_mem_vaddr =
-		kcalloc(cnt, sizeof(unsigned char *), GFP_KERNEL);
-	if (!tcon_mm_table.data_mem_vaddr)
-		return -1;
-
-	tcon_mm_table.data_priority =
-		kcalloc(cnt, sizeof(struct tcon_data_priority_s), GFP_KERNEL);
-	if (!tcon_mm_table.data_priority)
-		return -1;
-
-	memset(tcon_mm_table.data_priority, 0xff,
-	       cnt * sizeof(struct tcon_data_priority_s));
-
-	tcon_mm_table.data_size =
-		kcalloc(cnt, sizeof(unsigned int), GFP_KERNEL);
-	if (!tcon_mm_table.data_size)
-		return -1;
-
-	tcon_mm_table.data_multi =
-		kcalloc(cnt, sizeof(struct tcon_data_multi_s), GFP_KERNEL);
-	if (!tcon_mm_table.data_multi)
-		return -1;
-
-	mem_vaddr = tcon_rmem.bin_path_rmem.mem_vaddr;
-	for (i = 0; i < tcon_mm_table.block_cnt; i++) {
-		n = 32 + (i * 256);
-		data_size = mem_vaddr[n] |
-			(mem_vaddr[n + 1] << 8) |
-			(mem_vaddr[n + 2] << 16) |
-			(mem_vaddr[n + 3] << 24);
-		if (data_size == 0) {
-			LCDERR("%s: block[%d] size is zero\n", __func__, i);
-			continue;
-		}
-		tcon_mm_table.data_mem_vaddr[i] =
-			kcalloc(data_size, sizeof(unsigned char), GFP_KERNEL);
-		if (!tcon_mm_table.data_mem_vaddr[i])
-			continue;
-		tcon_mm_table.data_size[i] = data_size;
-	}
-
-	return 0;
-}
-
-static void lcd_tcon_axi_mem_config_tl1(void)
-{
-	unsigned int size[3] = {4162560, 4162560, 1960440};
-	unsigned int total_size = 0, temp_size = 0;
-	int i;
-
-	for (i = 0; i < lcd_tcon_conf->axi_bank; i++)
-		total_size += size[i];
-	if (total_size > tcon_rmem.axi_mem_size) {
-		LCDERR("%s: tcon axi_mem size 0x%x is not enough, need 0x%x\n",
-			__func__, tcon_rmem.axi_mem_size, total_size);
-		return;
-	}
-
-	tcon_rmem.axi_rmem =
-		kcalloc(lcd_tcon_conf->axi_bank,
-			sizeof(struct tcon_rmem_config_s), GFP_KERNEL);
-	if (!tcon_rmem.axi_rmem)
-		return;
-
-	for (i = 0; i < lcd_tcon_conf->axi_bank; i++) {
-		tcon_rmem.axi_rmem[i].mem_paddr =
-			tcon_rmem.axi_mem_paddr + temp_size;
-		tcon_rmem.axi_rmem[i].mem_vaddr = NULL;
-		tcon_rmem.axi_rmem[i].mem_size = size[i];
-		temp_size += size[i];
-	}
-}
-
-static void lcd_tcon_axi_mem_config_t5(void)
-{
-	unsigned int size[2] = {0x00800000, 0x200000};
-	unsigned int reg[2] = {0x261, 0x1a9};
-	unsigned int total_size = 0, temp_size = 0;
-	int i;
-
-	for (i = 0; i < lcd_tcon_conf->axi_bank; i++)
-		total_size += size[i];
-	if (total_size > tcon_rmem.axi_mem_size) {
-		LCDERR("%s: tcon axi_mem size 0x%x is not enough, need 0x%x\n",
-			__func__, tcon_rmem.axi_mem_size, total_size);
-		return;
-	}
-
-	tcon_rmem.axi_rmem =
-		kcalloc(lcd_tcon_conf->axi_bank,
-			sizeof(struct tcon_rmem_config_s), GFP_KERNEL);
-	if (!tcon_rmem.axi_rmem)
-		return;
-
-	lcd_tcon_conf->axi_reg = kcalloc(lcd_tcon_conf->axi_bank,
-					 sizeof(unsigned int), GFP_KERNEL);
-	if (!lcd_tcon_conf->axi_reg) {
-		kfree(tcon_rmem.axi_rmem);
-		return;
-	}
-
-	temp_size = 0;
-	for (i = 0; i < lcd_tcon_conf->axi_bank; i++) {
-		tcon_rmem.axi_rmem[i].mem_paddr =
-			tcon_rmem.axi_mem_paddr + temp_size;
-		tcon_rmem.axi_rmem[i].mem_vaddr = NULL;
-		tcon_rmem.axi_rmem[i].mem_size = size[i];
-		temp_size += size[i];
-
-		lcd_tcon_conf->axi_reg[i] = reg[i];
-	}
-}
-
-static void lcd_tcon_axi_mem_config_t5d(void)
-{
-	unsigned int size = 0x00500000;
-	unsigned int reg = 0x261;
-
-	if (size > tcon_rmem.axi_mem_size) {
-		LCDERR("%s: tcon axi_mem size 0x%x is not enough, need 0x%x\n",
-			__func__, tcon_rmem.axi_mem_size, size);
-		return;
-	}
-
-	tcon_rmem.axi_rmem =
-		kzalloc(sizeof(struct tcon_rmem_config_s), GFP_KERNEL);
-	if (!tcon_rmem.axi_rmem)
-		return;
-
-	lcd_tcon_conf->axi_reg = kzalloc(sizeof(unsigned int), GFP_KERNEL);
-	if (!lcd_tcon_conf->axi_reg) {
-		kfree(tcon_rmem.axi_rmem);
-		return;
-	}
-
-	tcon_rmem.axi_rmem->mem_paddr = tcon_rmem.axi_mem_paddr;
-	tcon_rmem.axi_rmem->mem_vaddr = NULL;
-	tcon_rmem.axi_rmem->mem_size = size;
-
-	*lcd_tcon_conf->axi_reg = reg;
-}
-
-static void lcd_tcon_axi_mem_secure_tl1(void)
-{
-#ifdef CONFIG_AMLOGIC_TEE
-	int ret;
-
-	tcon_local_cfg.secure_cfg.handle = 0;
-	ret = tee_protect_mem_by_type(TEE_MEM_TYPE_TCON,
-				      tcon_rmem.axi_mem_paddr,
-				      tcon_rmem.axi_mem_size,
-				      &tcon_local_cfg.secure_cfg.handle);
-	if (ret) {
-		tcon_local_cfg.secure_cfg.protect = 0;
-		LCDERR("%s: the tcon secure mem failed! protect status is:%d\n",
-		       __func__, tcon_local_cfg.secure_cfg.protect);
-	} else {
-		tcon_local_cfg.secure_cfg.protect = 1;
-	}
-#endif
-}
-
-static void lcd_tcon_axi_mem_secure_t5(void)
-{
-	/* only protect od mem */
-#ifdef CONFIG_AMLOGIC_TEE
-	int ret;
-
-	if (!tcon_rmem.axi_rmem)
-		return;
-
-	tcon_local_cfg.secure_cfg.handle = 0;
-	ret = tee_protect_mem_by_type(TEE_MEM_TYPE_TCON,
-				      tcon_rmem.axi_rmem[0].mem_paddr,
-				      tcon_rmem.axi_rmem[0].mem_size,
-				      &tcon_local_cfg.secure_cfg.handle);
-	if (ret) {
-		tcon_local_cfg.secure_cfg.protect = 0;
-		LCDERR("%s: the tcon secure mem failed! protect status is:%d\n",
-		       __func__, tcon_local_cfg.secure_cfg.protect);
-	} else {
-		tcon_local_cfg.secure_cfg.protect = 1;
-	}
-#endif
-}
-
-static int lcd_tcon_mem_config(void)
+int lcd_tcon_enable(struct lcd_config_s *pconf)
 {
-	unsigned int max_size;
 	int ret;
 
-	max_size = lcd_tcon_conf->axi_mem_size +
-		lcd_tcon_conf->bin_path_size;
-
-	if (tcon_rmem.rsv_mem_size < max_size) {
-		LCDERR("%s: tcon mem size 0x%x is not enough, need 0x%x\n",
-		       __func__, tcon_rmem.rsv_mem_size, max_size);
-		return -1;
-	}
-
-	tcon_rmem.axi_mem_size = lcd_tcon_conf->axi_mem_size;
-	tcon_rmem.axi_mem_paddr = tcon_rmem.rsv_mem_paddr;
-	if (lcd_debug_print_flag)
-		LCDPR("%s: axi_mem paddr: 0x%08x, size: 0x%x\n",
-		      __func__, (unsigned int)tcon_rmem.axi_mem_paddr,
-		      tcon_rmem.axi_mem_size);
-	if (lcd_tcon_conf->tcon_axi_mem_config)
-		lcd_tcon_conf->tcon_axi_mem_config();
-	if (lcd_tcon_conf->tcon_axi_mem_secure)
-		lcd_tcon_conf->tcon_axi_mem_secure();
-
-	tcon_rmem.bin_path_rmem.mem_size = lcd_tcon_conf->bin_path_size;
-	tcon_rmem.bin_path_rmem.mem_paddr =
-		tcon_rmem.axi_mem_paddr + tcon_rmem.axi_mem_size;
-	tcon_rmem.bin_path_rmem.mem_vaddr =
-		lcd_tcon_paddrtovaddr(tcon_rmem.bin_path_rmem.mem_paddr,
-				      tcon_rmem.bin_path_rmem.mem_size);
-	if (lcd_debug_print_flag && (tcon_rmem.bin_path_rmem.mem_size > 0))
-		LCDPR("tcon bin_path paddr: 0x%08x, vaddr: 0x%p, size: 0x%x\n",
-		      (unsigned int)tcon_rmem.bin_path_rmem.mem_paddr,
-		      tcon_rmem.bin_path_rmem.mem_vaddr,
-		      tcon_rmem.bin_path_rmem.mem_size);
-
-	ret = lcd_tcon_bin_path_update(tcon_rmem.bin_path_rmem.mem_size);
+	ret = lcd_tcon_valid_check();
 	if (ret)
 		return -1;
 
-	if (tcon_mm_table.version == 0)
-		ret = lcd_tcon_mm_table_config_v0();
-	else
-		ret = lcd_tcon_mm_table_config_v1();
-	return ret;
-}
-
-#ifdef CONFIG_AMLOGIC_TEE
-int lcd_tcon_mem_tee_get_status(void)
-{
-	return tcon_local_cfg.secure_cfg.protect;
-}
-
-int lcd_tcon_mem_tee_unprotect(void)
-{
-	if (tcon_local_cfg.secure_cfg.protect) {
-		tee_unprotect_mem(tcon_local_cfg.secure_cfg.handle);
-		tcon_local_cfg.secure_cfg.protect = 0;
-	}
-	return tcon_local_cfg.secure_cfg.protect;
-}
-#endif
-
-#ifdef CONFIG_CMA
-static int lcd_tcon_cma_mem_config(struct cma *cma)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned int mem_size;
-
-	tcon_rmem.rsv_mem_paddr = cma_get_base(cma);
-	LCDPR("tcon resv_mem base:0x%lx, size:0x%lx\n",
-	      (unsigned long)tcon_rmem.rsv_mem_paddr,
-	      cma_get_size(cma));
-	mem_size = lcd_tcon_conf->rsv_mem_size;
-	if (cma_get_size(cma) < mem_size) {
-		tcon_rmem.flag = 0;
-	} else {
-		tcon_rmem.rsv_mem_vaddr =
-			dma_alloc_from_contiguous(lcd_drv->dev,
-				(mem_size >> PAGE_SHIFT), 0);
-		if (!tcon_rmem.rsv_mem_vaddr) {
-			LCDERR("tcon resv_mem alloc failed\n");
-		} else {
-			LCDPR("tcon resv_mem dma_alloc=0x%x\n", mem_size);
-			tcon_rmem.rsv_mem_size = mem_size;
-			tcon_rmem.flag = 2; /* cma memory */
-		}
-	}
-
-	return 0;
-}
-#endif
-
-static irqreturn_t lcd_tcon_isr(int irq, void *dev_id)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned int temp;
-
-	if ((lcd_drv->lcd_status & LCD_STATUS_IF_ON) == 0)
-		return IRQ_HANDLED;
-
-	temp = lcd_tcon_read(TCON_INTR_RO);
-	if (temp & 0x2) {
-		LCDPR("%s: tcon sw_reset triggered\n", __func__);
-		lcd_tcon_core_update();
-	}
-	if (temp & 0x40)
-		LCDPR("%s: tcon ddr interface error triggered\n", __func__);
-
-	return IRQ_HANDLED;
-}
-
-static void lcd_tcon_intr_init(struct aml_lcd_drv_s *lcd_drv)
-{
-	unsigned int tcon_irq = 0;
-
-	if (!lcd_drv->res_tcon_irq) {
-		LCDERR("res_tcon_irq is null\n");
-		return;
-	}
-	tcon_irq = lcd_drv->res_tcon_irq->start;
-	if (lcd_debug_print_flag)
-		LCDPR("tcon_irq: %d\n", tcon_irq);
-
-	if (request_irq(tcon_irq, lcd_tcon_isr, IRQF_SHARED,
-		"lcd_tcon", (void *)"lcd_tcon"))
-		LCDERR("can't request lcd_tcon irq\n");
-	else {
-		if (lcd_debug_print_flag)
-			LCDPR("request lcd_tcon irq successful\n");
-	}
-
-	lcd_tcon_write(TCON_INTR_MASKN, TCON_INTR_MASKN_VAL);
-}
-
-static int lcd_tcon_load_init_data_from_unifykey(void)
-{
-	int key_len, data_len, ret;
-
-	data_len = tcon_mm_table.core_reg_table_size;
-	tcon_mm_table.core_reg_table =
-		kcalloc(data_len, sizeof(unsigned char), GFP_KERNEL);
-	if (!tcon_mm_table.core_reg_table)
-		return -1;
-	key_len = data_len;
-	ret = lcd_unifykey_get_no_header("lcd_tcon",
-					 tcon_mm_table.core_reg_table,
-					 &key_len);
-	if (ret)
-		goto lcd_tcon_load_init_data_err;
-	if (key_len != data_len)
-		goto lcd_tcon_load_init_data_err;
+	if (lcd_tcon_data->tcon_enable)
+		lcd_tcon_data->tcon_enable(pconf);
 
-	memset(tcon_local_cfg.bin_ver, 0, TCON_BIN_VER_LEN);
-	LCDPR("tcon: load init data len: %d\n", data_len);
 	return 0;
-
-lcd_tcon_load_init_data_err:
-	kfree(tcon_mm_table.core_reg_table);
-	tcon_mm_table.core_reg_table = NULL;
-	LCDERR("%s: !!!!!!tcon unifykey load error!!!!!!\n", __func__);
-	return -1;
 }
 
-static int lcd_tcon_load_init_data_from_unifykey_new(void)
+#define TCON_CTRL_TIMING_OFFSET    12
+void lcd_tcon_disable(void)
 {
-	int key_len, data_len;
-	unsigned char *buf, *p;
-	struct lcd_tcon_init_block_header_s *data_header;
+	unsigned int reg, i, cnt, offset, bit;
 	int ret;
 
-	data_len = tcon_mm_table.core_reg_table_size +
-		LCD_TCON_DATA_BLOCK_HEADER_SIZE;
-	buf = kcalloc(data_len, sizeof(unsigned char), GFP_KERNEL);
-	if (!buf)
-		return -1;
-
-	key_len = data_len;
-	ret = lcd_unifykey_get_tcon("lcd_tcon", buf, &key_len);
+	ret = lcd_tcon_valid_check();
 	if (ret)
-		goto lcd_tcon_load_init_data_new_err;
-	if (key_len != data_len)
-		goto lcd_tcon_load_init_data_new_err;
-
-	data_header = (struct lcd_tcon_init_block_header_s *)buf;
-	if (lcd_debug_print_flag) {
-		LCDPR("unifykey header:\n");
-		LCDPR("crc32             = 0x%08x\n", data_header->crc32);
-		LCDPR("block_size        = %d\n", data_header->block_size);
-		LCDPR("chipid            = %d\n", data_header->chipid);
-		LCDPR("name              = %s\n", data_header->name);
-	}
-	memcpy(tcon_local_cfg.bin_ver, data_header->version,
-	       LCD_TCON_INIT_BIN_VERSION_SIZE);
-	tcon_local_cfg.bin_ver[TCON_BIN_VER_LEN - 1] = '\0';
-
-	data_len = tcon_mm_table.core_reg_table_size;
-	tcon_mm_table.core_reg_table =
-		kcalloc(data_len, sizeof(unsigned char), GFP_KERNEL);
-	if (!tcon_mm_table.core_reg_table)
-		goto lcd_tcon_load_init_data_new_err;
-	p = buf + LCD_TCON_DATA_BLOCK_HEADER_SIZE;
-	memcpy(tcon_mm_table.core_reg_table, p, data_len);
-	kfree(buf);
-
-	LCDPR("tcon: load init data len: %d, ver: %s\n",
-	      data_len, tcon_local_cfg.bin_ver);
-	return 0;
-
-lcd_tcon_load_init_data_new_err:
-	kfree(buf);
-	LCDERR("%s: !!!!!!tcon unifykey load error!!!!!!\n", __func__);
-	return -1;
-}
-
-static int lcd_tcon_get_config(struct aml_lcd_drv_s *lcd_drv)
-{
-	tcon_mm_table.core_reg_table_size = lcd_tcon_conf->reg_table_len;
-	if (lcd_tcon_conf->core_reg_ver)
-		lcd_tcon_load_init_data_from_unifykey_new();
-	else
-		lcd_tcon_load_init_data_from_unifykey();
-
-	if (tcon_mm_table.tcon_data_flag == 0)
-		lcd_tcon_data_load();
-	lcd_drv->tcon_status = tcon_mm_table.valid_flag;
+		return;
 
-	lcd_tcon_intr_init(lcd_drv);
+	LCDPR("%s\n", __func__);
 
-	return 0;
-}
+	/* disable tcon intr */
+	lcd_tcon_write(TCON_INTR_MASKN, 0);
 
-static void lcd_tcon_get_config_delayed(struct work_struct *work)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	int key_init_flag = 0;
-	int i = 0;
+	/* disable over_drive */
+	if (lcd_tcon_data->reg_core_od != REG_LCD_TCON_MAX) {
+		reg = lcd_tcon_data->reg_core_od + TCON_CORE_REG_START;
+		bit = lcd_tcon_data->bit_od_en;
+		if (lcd_tcon_data->core_reg_width == 8)
+			lcd_tcon_setb_byte(reg, 0, bit, 1);
+		else
+			lcd_tcon_setb(reg, 0, bit, 1);
+		msleep(100);
+	}
+
+	/* disable all ctrl signal */
+	if (lcd_tcon_data->reg_core_ctrl_timing_base == REG_LCD_TCON_MAX)
+		goto lcd_tcon_disable_next;
+	reg = lcd_tcon_data->reg_core_ctrl_timing_base + TCON_CORE_REG_START;
+	offset = lcd_tcon_data->ctrl_timing_offset;
+	cnt = lcd_tcon_data->ctrl_timing_cnt;
+	for (i = 0; i < cnt; i++) {
+		if (lcd_tcon_data->core_reg_width == 8)
+			lcd_tcon_setb_byte((reg + (i * offset)), 1, 3, 1);
+		else
+			lcd_tcon_setb((reg + (i * offset)), 1, 3, 1);
+	}
 
-	key_init_flag = key_unify_get_init_flag();
-	while (key_init_flag == 0) {
-		if (i++ >= LCD_UNIFYKEY_WAIT_TIMEOUT)
-			break;
-		msleep(LCD_UNIFYKEY_RETRY_INTERVAL);
-		key_init_flag = key_unify_get_init_flag();
+	/* disable top */
+lcd_tcon_disable_next:
+	if (lcd_tcon_data->reg_top_ctrl != REG_LCD_TCON_MAX) {
+		reg = lcd_tcon_data->reg_top_ctrl;
+		bit = lcd_tcon_data->bit_en;
+		lcd_tcon_setb(reg, 0, bit, 1);
 	}
-	LCDPR("tcon: key_init_flag=%d, i=%d\n", key_init_flag, i);
-	if (key_init_flag)
-		lcd_tcon_get_config(lcd_drv);
 }
 
 /* **********************************
  * tcon match data
  * **********************************
  */
-static struct lcd_tcon_config_s tcon_data_tl1 = {
+static struct lcd_tcon_data_s tcon_data_tl1 = {
 	.tcon_valid = 0,
 
-	.core_reg_ver = 0,
 	.core_reg_width = LCD_TCON_CORE_REG_WIDTH_TL1,
-	.reg_table_width = LCD_TCON_TABLE_WIDTH_TL1,
 	.reg_table_len = LCD_TCON_TABLE_LEN_TL1,
-	.core_reg_start = TCON_CORE_REG_START_TL1,
-	.top_reg_base = TCON_TOP_BASE,
 
 	.reg_top_ctrl = TCON_TOP_CTRL,
 	.bit_en = BIT_TOP_EN_TL1,
@@ -2143,107 +673,14 @@ static struct lcd_tcon_config_s tcon_data_tl1 = {
 	.reg_core_od = REG_CORE_OD_TL1,
 	.bit_od_en = BIT_OD_EN_TL1,
 
-	.reg_ctrl_timing_base = REG_LCD_TCON_MAX,
+	.reg_core_ctrl_timing_base = REG_LCD_TCON_MAX,
 	.ctrl_timing_offset = CTRL_TIMING_OFFSET_TL1,
 	.ctrl_timing_cnt = CTRL_TIMING_CNT_TL1,
 
-	.axi_bank = LCD_TCON_AXI_BANK_TL1,
-
-	/*rsv_mem(12M)    axi_mem(10M)   bin_path(10K)
-	 *             |----------------|-------------|
-	 */
-	.rsv_mem_size    = 0x00c00000,
-	.axi_mem_size    = 0x00a00000,
-	.bin_path_size   = 0x00002800,
-	.vac_size        = 0x00002000, /* 8k */
-	.demura_set_size = 0x00001000, /* 4k */
-	.demura_lut_size = 0x00120000, /* 1152k */
-	.acc_lut_size    = 0x00001000, /* 4k */
-
-	.axi_reg = NULL,
-	.tcon_axi_mem_config = lcd_tcon_axi_mem_config_tl1,
-	.tcon_axi_mem_secure = lcd_tcon_axi_mem_secure_tl1,
-	.tcon_gamma_pattern = lcd_tcon_gamma_pattern_tl1,
-	.tcon_enable = lcd_tcon_enable_tl1,
-	.tcon_disable = lcd_tcon_disable_tl1,
-};
-
-static struct lcd_tcon_config_s tcon_data_t5 = {
-	.tcon_valid = 0,
-
-	.core_reg_ver = 1, /* new version with header */
-	.core_reg_width = LCD_TCON_CORE_REG_WIDTH_T5,
-	.reg_table_width = LCD_TCON_TABLE_WIDTH_T5,
-	.reg_table_len = LCD_TCON_TABLE_LEN_T5,
-	.core_reg_start = TCON_CORE_REG_START_T5,
-	.top_reg_base = TCON_TOP_BASE,
-
-	.reg_top_ctrl = REG_LCD_TCON_MAX,
-	.bit_en = BIT_TOP_EN_T5,
-
-	.reg_core_od = REG_CORE_OD_T5,
-	.bit_od_en = BIT_OD_EN_T5,
-
-	.reg_ctrl_timing_base = REG_LCD_TCON_MAX,
-	.ctrl_timing_offset = CTRL_TIMING_OFFSET_T5,
-	.ctrl_timing_cnt = CTRL_TIMING_CNT_T5,
-
-	.axi_bank = LCD_TCON_AXI_BANK_T5,
-
-	/*rsv_mem(12M)    axi_mem(10M)   bin_path(10K)
-	 *             |----------------|-------------|
-	 */
-	.rsv_mem_size    = 0x00c00000,
-	.axi_mem_size    = 0x00a00000,
-	.bin_path_size   = 0x00002800,
-	.vac_size        = 0,
-	.demura_set_size = 0,
-	.demura_lut_size = 0,
-	.acc_lut_size    = 0,
-
-	.axi_reg = NULL,
-	.tcon_axi_mem_config = lcd_tcon_axi_mem_config_t5,
-	.tcon_axi_mem_secure = lcd_tcon_axi_mem_secure_t5,
-	.tcon_gamma_pattern = lcd_tcon_gamma_pattern_t5,
-	.tcon_enable = lcd_tcon_enable_t5,
-	.tcon_disable = lcd_tcon_disable_t5,
-};
-
-static struct lcd_tcon_config_s tcon_data_t5d = {
-	.tcon_valid = 0,
+	.axi_mem_size = 0xc00000,
+	.reg_table = NULL,
 
-	.core_reg_ver = 1, /* new version with header */
-	.core_reg_width = LCD_TCON_CORE_REG_WIDTH_T5D,
-	.reg_table_width = LCD_TCON_TABLE_WIDTH_T5D,
-	.reg_table_len = LCD_TCON_TABLE_LEN_T5D,
-	.core_reg_start = TCON_CORE_REG_START_T5D,
-
-	.reg_top_ctrl = REG_LCD_TCON_MAX,
-	.bit_en = BIT_TOP_EN_T5D,
-
-	.reg_core_od = REG_CORE_OD_T5D,
-	.bit_od_en = BIT_OD_EN_T5D,
-
-	.reg_ctrl_timing_base = REG_LCD_TCON_MAX,
-	.ctrl_timing_offset = CTRL_TIMING_OFFSET_T5D,
-	.ctrl_timing_cnt = CTRL_TIMING_CNT_T5D,
-
-	.axi_bank = LCD_TCON_AXI_BANK_T5D,
-
-	.rsv_mem_size    = 0x00800000, /* 8M */
-	.axi_mem_size    = 0x00500000, /* 5M */
-	.bin_path_size   = 0x00002800, /* 10K */
-	.vac_size        = 0,
-	.demura_set_size = 0,
-	.demura_lut_size = 0,
-	.acc_lut_size    = 0,
-
-	.axi_reg = NULL,
-	.tcon_axi_mem_config = lcd_tcon_axi_mem_config_t5d,
-	.tcon_axi_mem_secure = lcd_tcon_axi_mem_secure_t5,
-	.tcon_gamma_pattern = lcd_tcon_gamma_pattern_t5,
-	.tcon_enable = lcd_tcon_enable_t5,
-	.tcon_disable = lcd_tcon_disable_t5,
+	.tcon_enable = lcd_tcon_enable_tl1,
 };
 
 int lcd_tcon_probe(struct aml_lcd_drv_s *lcd_drv)
@@ -2253,51 +690,62 @@ int lcd_tcon_probe(struct aml_lcd_drv_s *lcd_drv)
 	int key_init_flag = 0;
 	int ret = 0;
 
-	lcd_tcon_conf = NULL;
+	lcd_tcon_data = NULL;
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-		lcd_tcon_conf = &tcon_data_tl1;
-		break;
-	case LCD_CHIP_T5:
-		lcd_tcon_conf = &tcon_data_t5;
-		break;
-	case LCD_CHIP_T5D:
-		lcd_tcon_conf = &tcon_data_t5d;
+		switch (lcd_drv->lcd_config->lcd_basic.lcd_type) {
+		case LCD_MLVDS:
+		case LCD_P2P:
+			lcd_tcon_data = &tcon_data_tl1;
+			lcd_tcon_data->tcon_valid = 1;
+			break;
+		default:
+			break;
+		}
 		break;
 	default:
 		break;
 	}
-	if (!lcd_tcon_conf)
+	if (lcd_tcon_data == NULL)
 		return 0;
-
-	switch (lcd_drv->lcd_config->lcd_basic.lcd_type) {
-	case LCD_MLVDS:
-		lcd_tcon_conf->tcon_valid = 1;
-		break;
-	case LCD_P2P:
-		if (lcd_drv->data->chip_type == LCD_CHIP_T5D)
-			lcd_tcon_conf->tcon_valid = 0;
-		else
-			lcd_tcon_conf->tcon_valid = 1;
-		break;
-	default:
-		break;
-	}
-	if (lcd_tcon_conf->tcon_valid == 0)
+	if (lcd_tcon_data->tcon_valid == 0)
 		return 0;
 
+	if (lcd_tcon_getb_byte(0x23d, 0, 1))
+		lcd_drv->tcon_status = 3;
+	else
+		lcd_drv->tcon_status = 0;
 	/* init reserved memory */
 	ret = of_reserved_mem_device_init(lcd_drv->dev);
 	if (ret) {
 		LCDERR("tcon: init reserved memory failed\n");
 	} else {
-		if (!(void *)tcon_rmem.rsv_mem_paddr) {
+		if ((void *)tcon_rmem.mem_paddr == NULL) {
 #ifdef CONFIG_CMA
 			cma = dev_get_cma_area(lcd_drv->dev);
 			if (cma) {
-				lcd_tcon_cma_mem_config(cma);
-				lcd_tcon_mem_config();
+				tcon_rmem.mem_paddr = cma_get_base(cma);
+				LCDPR("tcon axi_mem base:0x%lx, size:0x%lx\n",
+					(unsigned long)tcon_rmem.mem_paddr,
+					cma_get_size(cma));
+				mem_size = lcd_tcon_data->axi_mem_size;
+				if (cma_get_size(cma) < mem_size)
+					tcon_rmem.flag = 0;
+				else {
+				tcon_rmem.mem_vaddr = dma_alloc_from_contiguous(
+					lcd_drv->dev,
+					(mem_size >> PAGE_SHIFT),
+					0);
+					if (tcon_rmem.mem_vaddr == NULL) {
+					LCDERR("tcon axi_mem alloc failed\n");
+					} else {
+					LCDPR("tcon axi_mem dma_alloc=0x%x\n",
+						mem_size);
+						tcon_rmem.mem_size = mem_size;
+					tcon_rmem.flag = 2; /* cma memory */
+					}
+				}
 			} else {
 				LCDERR("tcon: NO CMA\n");
 			}
@@ -2305,24 +753,22 @@ int lcd_tcon_probe(struct aml_lcd_drv_s *lcd_drv)
 			LCDERR("tcon axi_mem alloc failed\n");
 #endif
 		} else {
-			mem_size = tcon_rmem.rsv_mem_size;
-			if (mem_size < lcd_tcon_conf->rsv_mem_size) {
+			mem_size = tcon_rmem.mem_size;
+			if (mem_size < lcd_tcon_data->axi_mem_size)
 				tcon_rmem.flag = 0;
-			} else {
+			else {
 				tcon_rmem.flag = 1; /* reserved memory */
-				LCDPR("tcon resv_mem base:0x%lx, size:0x%x\n",
-				      (unsigned long)tcon_rmem.rsv_mem_paddr,
-				      mem_size);
-				lcd_tcon_mem_config();
+				LCDPR("tcon axi_mem base:0x%lx, size:0x%x\n",
+				(unsigned long)tcon_rmem.mem_paddr, mem_size);
 			}
 		}
 	}
 
-	INIT_DELAYED_WORK(&lcd_tcon_delayed_work, lcd_tcon_get_config_delayed);
+	INIT_DELAYED_WORK(&lcd_tcon_delayed_work, lcd_tcon_config_delayed);
 
 	key_init_flag = key_unify_get_init_flag();
 	if (key_init_flag) {
-		ret = lcd_tcon_get_config(lcd_drv);
+		ret = lcd_tcon_config(lcd_drv);
 	} else {
 		if (lcd_drv->workqueue) {
 			queue_delayed_work(lcd_drv->workqueue,
@@ -2339,70 +785,43 @@ int lcd_tcon_probe(struct aml_lcd_drv_s *lcd_drv)
 
 int lcd_tcon_remove(struct aml_lcd_drv_s *lcd_drv)
 {
-	int i;
-
-	kfree(tcon_mm_table.core_reg_table);
-	tcon_mm_table.core_reg_table = NULL;
-	if (tcon_mm_table.version) {
-		if (tcon_mm_table.data_mem_vaddr) {
-			for (i = 0; i < tcon_mm_table.block_cnt; i++) {
-				if (!tcon_mm_table.data_mem_vaddr[i])
-					continue;
-				kfree(tcon_mm_table.data_mem_vaddr[i]);
-				tcon_mm_table.data_mem_vaddr[i] = NULL;
-			}
-			kfree(tcon_mm_table.data_mem_vaddr);
-			tcon_mm_table.data_mem_vaddr = NULL;
-		}
-	} else {
-		lcd_unmap_phyaddr(tcon_rmem.vac_rmem.mem_vaddr);
-		lcd_unmap_phyaddr(tcon_rmem.demura_set_rmem.mem_vaddr);
-		lcd_unmap_phyaddr(tcon_rmem.demura_lut_rmem.mem_vaddr);
-		lcd_unmap_phyaddr(tcon_rmem.acc_lut_rmem.mem_vaddr);
-		tcon_rmem.vac_rmem.mem_vaddr = NULL;
-		tcon_rmem.demura_set_rmem.mem_vaddr = NULL;
-		tcon_rmem.demura_lut_rmem.mem_vaddr = NULL;
-		tcon_rmem.acc_lut_rmem.mem_vaddr = NULL;
-	}
-
 	if (tcon_rmem.flag == 2) {
 		LCDPR("tcon free memory: base:0x%lx, size:0x%x\n",
-			(unsigned long)tcon_rmem.rsv_mem_paddr,
-			tcon_rmem.rsv_mem_size);
+			(unsigned long)tcon_rmem.mem_paddr,
+			tcon_rmem.mem_size);
 #ifdef CONFIG_CMA
 		dma_release_from_contiguous(lcd_drv->dev,
-			tcon_rmem.rsv_mem_vaddr,
-			tcon_rmem.rsv_mem_size >> PAGE_SHIFT);
+			tcon_rmem.mem_vaddr,
+			tcon_rmem.mem_size >> PAGE_SHIFT);
 #endif
 	}
 
-	if (lcd_tcon_conf) {
-		/* lcd_tcon_conf == NULL; */
-		lcd_tcon_conf->tcon_valid = 0;
+	if (lcd_tcon_data) {
+		/* lcd_tcon_data == NULL; */
+		lcd_tcon_data->tcon_valid = 0;
 	}
 
 	return 0;
 }
 
-static int __init tcon_buf_device_init(struct reserved_mem *rmem,
-				       struct device *dev)
+static int __init tcon_fb_device_init(struct reserved_mem *rmem,
+		struct device *dev)
 {
 	return 0;
 }
 
-static const struct reserved_mem_ops tcon_buf_ops = {
-	.device_init = tcon_buf_device_init,
+static const struct reserved_mem_ops tcon_fb_ops = {
+	.device_init = tcon_fb_device_init,
 };
 
-static int __init tcon_buf_setup(struct reserved_mem *rmem)
+static int __init tcon_fb_setup(struct reserved_mem *rmem)
 {
-	tcon_rmem.rsv_mem_paddr = rmem->base;
-	tcon_rmem.rsv_mem_size = rmem->size;
-	rmem->ops = &tcon_buf_ops;
-	LCDPR("tcon: Reserved memory: created buf at 0x%lx, size %ld MiB\n",
-	      (unsigned long)rmem->base, (unsigned long)rmem->size / SZ_1M);
+	tcon_rmem.mem_paddr = rmem->base;
+	tcon_rmem.mem_size = rmem->size;
+	rmem->ops = &tcon_fb_ops;
+	LCDPR("tcon: Reserved memory: created fb at 0x%lx, size %ld MiB\n",
+		(unsigned long)rmem->base, (unsigned long)rmem->size / SZ_1M);
 	return 0;
 }
-
-RESERVEDMEM_OF_DECLARE(buf, "amlogic, lcd_tcon-memory", tcon_buf_setup);
+RESERVEDMEM_OF_DECLARE(fb, "amlogic, lcd_tcon-memory", tcon_fb_setup);
 
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tcon.h b/drivers/amlogic/media/vout/lcd/lcd_tcon.h
index 3803fc2ba379..e557923d8cea 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_tcon.h
+++ b/drivers/amlogic/media/vout/lcd/lcd_tcon.h
@@ -21,20 +21,14 @@
 #include <linux/dma-mapping.h>
 #include <linux/mm.h>
 #include <linux/amlogic/media/vout/lcd/lcd_vout.h>
-#include <linux/amlogic/media/vout/lcd/lcd_tcon_data.h>
 
 #define REG_LCD_TCON_MAX    0xffff
-#define TCON_INTR_MASKN_VAL    0x0  /* default mask all */
 
-struct lcd_tcon_config_s {
+struct lcd_tcon_data_s {
 	unsigned char tcon_valid;
 
-	unsigned int core_reg_ver;
 	unsigned int core_reg_width;
-	unsigned int reg_table_width;
 	unsigned int reg_table_len;
-	unsigned int core_reg_start;
-	unsigned int top_reg_base;
 
 	unsigned int reg_top_ctrl;
 	unsigned int bit_en;
@@ -42,196 +36,38 @@ struct lcd_tcon_config_s {
 	unsigned int reg_core_od;
 	unsigned int bit_od_en;
 
-	unsigned int reg_ctrl_timing_base;
+	unsigned int reg_core_ctrl_timing_base;
 	unsigned int ctrl_timing_offset;
 	unsigned int ctrl_timing_cnt;
 
-	unsigned int axi_bank;
-
-	unsigned int rsv_mem_size;
 	unsigned int axi_mem_size;
-	unsigned int bin_path_size;
-	unsigned int vac_size;
-	unsigned int demura_set_size;
-	unsigned int demura_lut_size;
-	unsigned int acc_lut_size;
+	unsigned char *reg_table;
 
-	unsigned int *axi_reg;
-	void (*tcon_axi_mem_config)(void);
-	void (*tcon_axi_mem_secure)(void);
-	int (*tcon_gamma_pattern)(unsigned int bit_width, unsigned int gamma_r,
-				  unsigned int gamma_g, unsigned int gamma_b);
 	int (*tcon_enable)(struct lcd_config_s *pconf);
-	int (*tcon_disable)(struct lcd_config_s *pconf);
-};
-
-struct tcon_rmem_config_s {
-	phys_addr_t mem_paddr;
-	unsigned char *mem_vaddr;
-	unsigned int mem_size;
 };
 
 struct tcon_rmem_s {
 	unsigned char flag;
-	unsigned int rsv_mem_size;
-	unsigned int axi_mem_size;
-
-	void *rsv_mem_vaddr;
-	phys_addr_t rsv_mem_paddr;
-	phys_addr_t axi_mem_paddr;
-
-	struct tcon_rmem_config_s *axi_rmem;
-	struct tcon_rmem_config_s bin_path_rmem;
-
-	struct tcon_rmem_config_s vac_rmem;
-	struct tcon_rmem_config_s demura_set_rmem;
-	struct tcon_rmem_config_s demura_lut_rmem;
-	struct tcon_rmem_config_s acc_lut_rmem;
-};
-
-struct tcon_data_list_s {
-	unsigned int flag;
-	unsigned int id;
-	unsigned char *block_vaddr;
-	struct tcon_data_list_s *next;
-};
-
-struct tcon_data_multi_s {
-	unsigned int block_type;
-	unsigned int list_cnt;
-	unsigned int flag;
-	unsigned int sel_id;
-	struct tcon_data_list_s *list_header;
-	struct tcon_data_list_s *list_cur;
-};
-
-struct tcon_data_priority_s {
-	unsigned int index;
-	unsigned int priority;
-};
-
-struct tcon_mem_map_table_s {
-	unsigned int version;
-	unsigned char tcon_data_flag;
-	unsigned int data_load_level;
-	unsigned int block_cnt;
-	unsigned int valid_flag;
-
-	unsigned int core_reg_table_size;
-	unsigned char *core_reg_table;
-
-	struct tcon_data_priority_s *data_priority;
-	unsigned int *data_size;
-	unsigned char **data_mem_vaddr;
-
-	unsigned int data_multi_cnt;
-	struct tcon_data_multi_s *data_multi;
-};
-
-struct tcon_mem_secure_config_s {
-	unsigned int handle;
-	bool protect;
-};
-
-#define TCON_BIN_VER_LEN    9
-struct lcd_tcon_local_cfg_s {
-	struct tcon_mem_secure_config_s secure_cfg;
-	char bin_ver[TCON_BIN_VER_LEN];
+	void *mem_vaddr;
+	phys_addr_t mem_paddr;
+	unsigned int mem_size;
 };
 
-#ifdef CONFIG_AMLOGIC_TEE
-int lcd_tcon_mem_tee_get_status(void);
-int lcd_tcon_mem_tee_unprotect(void);
-#endif
-
-struct lcd_tcon_config_s *get_lcd_tcon_config(void);
-struct tcon_rmem_s *get_lcd_tcon_rmem(void);
-struct tcon_mem_map_table_s *get_lcd_tcon_mm_table(void);
-
 /* **********************************
  * tcon config
  * **********************************
  */
-/* common */
-#define TCON_VAC_SET_PARAM_NUM		 3
-#define TCON_VAC_LUT_PARAM_NUM		 256
-
 /* TL1 */
 #define LCD_TCON_CORE_REG_WIDTH_TL1      8
-#define LCD_TCON_TABLE_WIDTH_TL1         8
 #define LCD_TCON_TABLE_LEN_TL1           24000
 #define LCD_TCON_AXI_BANK_TL1            3
 
 #define BIT_TOP_EN_TL1                   4
 
-#define TCON_CORE_REG_START_TL1          0x0000
 #define REG_CORE_OD_TL1                  0x247
 #define BIT_OD_EN_TL1                    0
 #define REG_CORE_CTRL_TIMING_BASE_TL1    0x1b
 #define CTRL_TIMING_OFFSET_TL1           12
 #define CTRL_TIMING_CNT_TL1              0
 
-/* T5 */
-#define LCD_TCON_CORE_REG_WIDTH_T5       32
-#define LCD_TCON_TABLE_WIDTH_T5          32
-#define LCD_TCON_TABLE_LEN_T5            0x18d4 /* 0x635*4 */
-#define LCD_TCON_AXI_BANK_T5             2
-
-#define BIT_TOP_EN_T5                    4
-
-#define TCON_CORE_REG_START_T5           0x0100
-#define REG_CORE_OD_T5                   0x263
-#define BIT_OD_EN_T5                     31
-#define REG_CORE_CTRL_TIMING_BASE_T5     0x1b
-#define CTRL_TIMING_OFFSET_T5            12
-#define CTRL_TIMING_CNT_T5               0
-
-/* T5D */
-#define LCD_TCON_CORE_REG_WIDTH_T5D       32
-#define LCD_TCON_TABLE_WIDTH_T5D          32
-#define LCD_TCON_TABLE_LEN_T5D            0x102c /* 0x40b*4 */
-#define LCD_TCON_AXI_BANK_T5D             1
-
-#define BIT_TOP_EN_T5D                    4
-
-#define TCON_CORE_REG_START_T5D           0x0100
-#define REG_CORE_OD_T5D                   0x263
-#define BIT_OD_EN_T5D                     31
-#define REG_CTRL_TIMING_BASE_T5D          0x1b
-#define CTRL_TIMING_OFFSET_T5D            12
-#define CTRL_TIMING_CNT_T5D               0
-
-/* **********************************
- * tcon api
- * **********************************
- */
-/* internal */
-int lcd_tcon_valid_check(void);
-struct tcon_rmem_s *get_lcd_tcon_rmem(void);
-struct tcon_mem_map_table_s *get_lcd_tcon_mm_table(void);
-int lcd_tcon_gamma_pattern_tl1(unsigned int bit_width, unsigned int gamma_r,
-			       unsigned int gamma_g, unsigned int gamma_b);
-int lcd_tcon_gamma_pattern_t5(unsigned int bit_width, unsigned int gamma_r,
-			      unsigned int gamma_g, unsigned int gamma_b);
-void lcd_tcon_core_reg_set(struct lcd_tcon_config_s *tcon_conf,
-			   struct tcon_mem_map_table_s *mm_table);
-int lcd_tcon_enable_tl1(struct lcd_config_s *pconf);
-int lcd_tcon_disable_tl1(struct lcd_config_s *pconf);
-int lcd_tcon_enable_t5(struct lcd_config_s *pconf);
-int lcd_tcon_disable_t5(struct lcd_config_s *pconf);
-
-/* common */
-int lcd_tcon_data_common_parse_set(unsigned char *data_buf, int init_flag);
-int lcd_tcon_data_multi_remvoe(struct tcon_mem_map_table_s *mm_table);
-int lcd_tcon_data_multi_add(struct tcon_mem_map_table_s *mm_table,
-			    struct lcd_tcon_data_block_header_s *block_header,
-			    unsigned int index);
-
-int lcd_tcon_data_load(void);
-void lcd_tcon_reg_table_print(void);
-void lcd_tcon_reg_readback_print(void);
-int lcd_tcon_info_print(char *buf, int offset);
-void lcd_tcon_axi_rmem_lut_load(unsigned int index, unsigned char *buf,
-				unsigned int size);
-
 #endif
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tcon_hw.c b/drivers/amlogic/media/vout/lcd/lcd_tcon_hw.c
deleted file mode 100644
index 5edf5ecf9989..000000000000
--- a/drivers/amlogic/media/vout/lcd/lcd_tcon_hw.c
+++ /dev/null
@@ -1,1316 +0,0 @@
-/*
- * drivers/amlogic/media/vout/lcd/lcd_tcon_hw.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/init.h>
-#include <linux/version.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/reset.h>
-#include "lcd_common.h"
-#include "lcd_reg.h"
-#include "lcd_tcon.h"
-
-static void lcd_tcon_core_reg_pre_od(struct lcd_tcon_config_s *tcon_conf,
-				     struct tcon_mem_map_table_s *mm_table)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	unsigned char *table8;
-	unsigned int *table32;
-	unsigned int reg, bit, en = 0;
-
-	if ((!mm_table) || (!mm_table->core_reg_table)) {
-		LCDERR("%s: table is NULL\n", __func__);
-		return;
-	}
-	if (tcon_conf->reg_core_od == REG_LCD_TCON_MAX)
-		return;
-
-	reg = tcon_conf->reg_core_od;
-	bit = tcon_conf->bit_od_en;
-
-	if (tcon_conf->core_reg_width == 8) {
-		table8 = mm_table->core_reg_table;
-		if (((table8[reg] >> bit) & 1) == 0)
-			return;
-		if (!tcon_rmem) {
-			en = 0;
-		} else {
-			if (tcon_rmem->flag == 0)
-				en = 0;
-			else
-				en = 1;
-		}
-		if (en == 0) {
-			table8[reg] &= ~(1 << bit);
-			LCDPR("%s: invalid buf, disable od function\n",
-			      __func__);
-		}
-	} else {
-		table32 = (unsigned int *)mm_table->core_reg_table;
-		if (((table32[reg] >> bit) & 1) == 0)
-			return;
-		if (!tcon_rmem) {
-			en = 0;
-		} else {
-			if (tcon_rmem->flag == 0)
-				en = 0;
-			else
-				en = 1;
-		}
-		if (en == 0) {
-			table32[reg] &= ~(1 << bit);
-			LCDPR("%s: invalid buf, disable od function\n",
-			      __func__);
-		}
-	}
-}
-
-static void lcd_tcon_core_reg_pre_dis_od(struct lcd_tcon_config_s *tcon_conf,
-					 struct tcon_mem_map_table_s *mm_table)
-{
-	unsigned char *table8;
-	unsigned int *table32;
-	unsigned int reg, bit;
-
-	if ((!mm_table) || (!mm_table->core_reg_table)) {
-		LCDERR("%s: table is NULL\n", __func__);
-		return;
-	}
-	if (tcon_conf->reg_core_od == REG_LCD_TCON_MAX)
-		return;
-
-	reg = tcon_conf->reg_core_od;
-	bit = tcon_conf->bit_od_en;
-
-	if (tcon_conf->core_reg_width == 8) {
-		table8 = mm_table->core_reg_table;
-		table8[reg] &= ~(1 << bit);
-	} else {
-		table32 = (unsigned int *)mm_table->core_reg_table;
-		table32[reg] &= ~(1 << bit);
-	}
-}
-
-void lcd_tcon_core_reg_set(struct lcd_tcon_config_s *tcon_conf,
-			   struct tcon_mem_map_table_s *mm_table)
-{
-	unsigned char *table8;
-	unsigned int *table32;
-	unsigned int len, offset;
-	int i, ret;
-
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return;
-
-	if ((!mm_table) || (!mm_table->core_reg_table)) {
-		LCDERR("%s: table is NULL\n", __func__);
-		return;
-	}
-
-	len = mm_table->core_reg_table_size;
-	offset = tcon_conf->core_reg_start;
-	if (tcon_conf->core_reg_width == 8) {
-		table8 = mm_table->core_reg_table;
-		for (i = offset; i < len; i++)
-			lcd_tcon_write_byte(i, table8[i]);
-	} else {
-		if (tcon_conf->reg_table_width == 32) {
-			table32 = (unsigned int *)mm_table->core_reg_table;
-			len /= 4;
-			for (i = offset; i < len; i++)
-				lcd_tcon_write(i, table32[i]);
-		} else {
-			table8 = mm_table->core_reg_table;
-			for (i = offset; i < len; i++)
-				lcd_tcon_write(i, table8[i]);
-		}
-	}
-	LCDPR("%s\n", __func__);
-}
-
-static void lcd_tcon_axi_rmem_set(struct lcd_tcon_config_s *tcon_conf)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	unsigned int paddr, i;
-
-	if (!tcon_conf)
-		return;
-	if (!tcon_rmem)
-		return;
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s\n", __func__);
-
-	if ((tcon_rmem->flag == 0) || (!tcon_rmem->axi_rmem)) {
-		LCDERR("%s: invalid axi_mem\n", __func__);
-		return;
-	}
-
-	for (i = 0; i < tcon_conf->axi_bank; i++) {
-		paddr = tcon_rmem->axi_rmem[i].mem_paddr;
-		lcd_tcon_write(tcon_conf->axi_reg[i], paddr);
-		if (lcd_debug_print_flag) {
-			LCDPR
-			("set tcon axi_mem[%d] reg: 0x%08x, paddr: 0x%08x\n",
-			 i, tcon_conf->axi_reg[i], paddr);
-		}
-	}
-}
-
-static void lcd_tcon_vac_set_tl1(unsigned int demura_valid)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	int len, i, j, n;
-	unsigned int d0, d1, temp, set0, set1, set2;
-	unsigned char *buf = NULL;
-
-	if (!tcon_rmem)
-		return;
-
-	buf = tcon_rmem->vac_rmem.mem_vaddr;
-	if (!buf) {
-		LCDERR("%s: vac_mem_vaddr is null\n", __func__);
-		return;
-	}
-
-	n = 8;
-	len = TCON_VAC_SET_PARAM_NUM;
-	set0 = buf[n];
-	set1 = buf[n + 2];
-	set2 = buf[n + 4];
-	n += (len * 2);
-	if (lcd_debug_print_flag)
-		LCDPR("vac_set: 0x%x, 0x%x, 0x%x\n", set0, set1, set2);
-
-	lcd_tcon_write_byte(0x0267, lcd_tcon_read_byte(0x0267) | 0xa0);
-	/*vac_cntl, 12pipe delay temp for pre_dt*/
-	lcd_tcon_write(0x2800, 0x807);
-	if (demura_valid)
-		lcd_tcon_write(0x2817, (0x1e | ((set1 & 0xff) << 8)));
-	else
-		lcd_tcon_write(0x2817, (0x1e | ((set0 & 0xff) << 8)));
-
-	len = TCON_VAC_LUT_PARAM_NUM;
-	if (lcd_debug_print_flag)
-		LCDPR("%s: start write vac_ramt1~2\n", __func__);
-	/*write vac_ramt1: 8bit, 256 regs*/
-	for (i = 0; i < len; i++)
-		lcd_tcon_write_byte(0xa100 + i, buf[n + i * 2]);
-
-	for (i = 0; i < len; i++)
-		lcd_tcon_write_byte(0xa200 + i, buf[n + i * 2]);
-
-	/*write vac_ramt2: 8bit, 256 regs*/
-	n += (len * 2);
-	for (i = 0; i < len; i++)
-		lcd_tcon_write_byte(0xa300 + i, buf[n + i * 2]);
-
-	for (i = 0; i < len; i++)
-		lcd_tcon_write_byte(0xbc00 + i, buf[n + i * 2]);
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: write vac_ramt1~2 ok\n", __func__);
-	for (i = 0; i < len; i++)
-		lcd_tcon_read_byte(0xbc00 + i);
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s: start write vac_ramt3\n", __func__);
-	/*write vac_ramt3_1~6: 16bit({data0[11:0],data1[11:0]},128 regs)*/
-	for (j = 0; j < 6; j++) {
-		n += (len * 2);
-		for (i = 0; i < (len >> 1); i++) {
-			d0 = (buf[n + (i * 4)] |
-				(buf[n + (i * 4 + 1)] << 8)) & 0xfff;
-			d1 = (buf[n + (i * 4 + 2)] |
-				(buf[n + (i * 4 + 3)] << 8)) & 0xfff;
-			temp = ((d0 << 12) | d1);
-			lcd_tcon_write((0x2900 + i + (j * 128)), temp);
-		}
-	}
-	if (lcd_debug_print_flag)
-		LCDPR("%s: write vac_ramt3 ok\n", __func__);
-	for (i = 0; i < ((len >> 1) * 6); i++)
-		lcd_tcon_read(0x2900 + i);
-
-	lcd_tcon_write(0x2801, 0x0f000870); /* vac_size */
-	lcd_tcon_write(0x2802, (0x58e00d00 | (set2 & 0xff)));
-	lcd_tcon_write(0x2803, 0x80400058);
-	lcd_tcon_write(0x2804, 0x58804000);
-	lcd_tcon_write(0x2805, 0x80400000);
-	lcd_tcon_write(0x2806, 0xf080a032);
-	lcd_tcon_write(0x2807, 0x4c08a864);
-	lcd_tcon_write(0x2808, 0x10200000);
-	lcd_tcon_write(0x2809, 0x18200000);
-	lcd_tcon_write(0x280a, 0x18000004);
-	lcd_tcon_write(0x280b, 0x735244c2);
-	lcd_tcon_write(0x280c, 0x9682383d);
-	lcd_tcon_write(0x280d, 0x96469449);
-	lcd_tcon_write(0x280e, 0xaf363ce7);
-	lcd_tcon_write(0x280f, 0xc71fbb56);
-	lcd_tcon_write(0x2810, 0x953885a1);
-	lcd_tcon_write(0x2811, 0x7a7a7900);
-	lcd_tcon_write(0x2812, 0xc4640708);
-	lcd_tcon_write(0x2813, 0x4b14b08a);
-	lcd_tcon_write(0x2814, 0x4004b12c);
-	lcd_tcon_write(0x2815, 0x0);
-	/*vac_cntl,always read*/
-	lcd_tcon_write(0x2800, 0x381f);
-
-	LCDPR("tcon vac finish\n");
-}
-
-static int lcd_tcon_demura_set_tl1(void)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	unsigned char *data_buf;
-	unsigned int data_cnt, i;
-
-	if ((!tcon_rmem) || (!tcon_rmem->demura_set_rmem.mem_vaddr)) {
-		LCDERR("%s: demura_set_mem_vaddr is null\n", __func__);
-		return -1;
-	}
-
-	if (lcd_tcon_getb_byte(0x23d, 0, 1) == 0) {
-		if (lcd_debug_print_flag)
-			LCDPR("%s: demura function disabled\n", __func__);
-		return 0;
-	}
-
-	if (lcd_debug_print_flag == 3) {
-		for (i = 0; i < 30; i++)
-			LCDPR("demura_set data[%d]: 0x%x\n",
-			      i, tcon_rmem->demura_set_rmem.mem_vaddr[i]);
-	}
-
-	/*demura_setting:
-	 *  8byte chk_data + demura_set_data: 161byte
-	 */
-	data_cnt = (tcon_rmem->demura_set_rmem.mem_vaddr[0] |
-		    (tcon_rmem->demura_set_rmem.mem_vaddr[1] << 8) |
-		    (tcon_rmem->demura_set_rmem.mem_vaddr[2] << 16) |
-		    (tcon_rmem->demura_set_rmem.mem_vaddr[3] << 24));
-	data_buf = &tcon_rmem->demura_set_rmem.mem_vaddr[8];
-	for (i = 0; i < data_cnt; i++)
-		lcd_tcon_write_byte(0x186, data_buf[i]);
-
-	LCDPR("tcon demura_set cnt %d\n", data_cnt);
-
-	return 0;
-}
-
-static int lcd_tcon_demura_lut_tl1(void)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	unsigned char *data_buf;
-	unsigned int data_cnt, i;
-
-	if ((!tcon_rmem) || (!tcon_rmem->demura_lut_rmem.mem_vaddr)) {
-		LCDERR("%s: demura_lut_mem_vaddr is null\n", __func__);
-		return -1;
-	}
-
-	if (lcd_tcon_getb_byte(0x23d, 0, 1) == 0) {
-		if (lcd_debug_print_flag)
-			LCDPR("%s: demura function disabled\n", __func__);
-		return 0;
-	}
-
-	/*disable demura when load lut data*/
-	lcd_tcon_setb_byte(0x23d, 0, 0, 1);
-
-	lcd_tcon_setb_byte(0x181, 1, 0, 1);
-	lcd_tcon_write_byte(0x182, 0x01);
-	lcd_tcon_write_byte(0x183, 0x86);
-	lcd_tcon_write_byte(0x184, 0x01);
-	lcd_tcon_write_byte(0x185, 0x87);
-
-	if (lcd_debug_print_flag == 3) {
-		for (i = 0; i < 30; i++)
-			LCDPR("demura_lut data[%d]: 0x%x\n",
-			      i, tcon_rmem->demura_lut_rmem.mem_vaddr[i]);
-	}
-
-	/*demura_lut is
-	 *chk_data: 8byte + demura_lut_data: 391053byte
-	 */
-	data_cnt = (tcon_rmem->demura_lut_rmem.mem_vaddr[0] |
-		    (tcon_rmem->demura_lut_rmem.mem_vaddr[1] << 8) |
-		    (tcon_rmem->demura_lut_rmem.mem_vaddr[2] << 16) |
-		    (tcon_rmem->demura_lut_rmem.mem_vaddr[3] << 24));
-	data_buf = &tcon_rmem->demura_lut_rmem.mem_vaddr[8];
-	/* fixed 2 byte 0 for border */
-	lcd_tcon_write_byte(0x187, 0);
-	lcd_tcon_write_byte(0x187, 0);
-	for (i = 0; i < data_cnt; i++)
-		lcd_tcon_write_byte(0x187, data_buf[i]);
-
-	/*enable demura when load lut data finished*/
-	lcd_tcon_setb_byte(0x23d, 1, 0, 1);
-
-	LCDPR("tcon demura_lut cnt %d\n", data_cnt);
-	LCDPR("lcd_tcon 0x23d = 0x%02x\n", lcd_tcon_read_byte(0x23d));
-
-	return 0;
-}
-
-static int lcd_tcon_acc_lut_tl1(void)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	unsigned char *data_buf;
-	unsigned int data_cnt, i;
-
-	if ((!tcon_rmem) || (!tcon_rmem->acc_lut_rmem.mem_vaddr)) {
-		LCDERR("%s: acc_lut_mem_vaddr is null\n", __func__);
-		return -1;
-	}
-
-	/* enable lut access, disable gamma en*/
-	lcd_tcon_setb_byte(0x262, 0x2, 0, 2);
-
-	/* write gamma lut */
-	/*acc_lut is
-	 *chk_data: 8byte + acc_lut_data: 1158byte
-	 */
-	data_cnt = (tcon_rmem->acc_lut_rmem.mem_vaddr[0] |
-		    (tcon_rmem->acc_lut_rmem.mem_vaddr[1] << 8) |
-		    (tcon_rmem->acc_lut_rmem.mem_vaddr[2] << 16) |
-		    (tcon_rmem->acc_lut_rmem.mem_vaddr[3] << 24));
-	if (data_cnt > 1161) { /* 0xb50~0xfd8, 1161 */
-		LCDPR("%s: data_cnt %d is invalid, force to 1161\n",
-		      __func__, data_cnt);
-		data_cnt = 1161;
-	}
-
-	data_buf = &tcon_rmem->acc_lut_rmem.mem_vaddr[8];
-	for (i = 0; i < data_cnt; i++)
-		lcd_tcon_write_byte((0xb50 + i), data_buf[i]);
-
-	/* enable gamma */
-	lcd_tcon_setb_byte(0x262, 0x3, 0, 2);
-
-	LCDPR("tcon acc_lut cnt %d\n", data_cnt);
-
-	return 0;
-}
-
-void lcd_tcon_axi_rmem_lut_load(unsigned int index, unsigned char *buf,
-				unsigned int size)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-	unsigned char *p;
-	unsigned int span = 0, remain = 0, count = 0;
-	unsigned long paddr, phys;
-	void *vaddr = NULL;
-	unsigned int highmem_flag = 0;
-	int i;
-
-	if ((!tcon_rmem) || (!tcon_rmem->axi_rmem)) {
-		LCDERR("axi_rmem is NULL\n");
-		return;
-	}
-	if (!tcon_conf)
-		return;
-	if (index > tcon_conf->axi_bank) {
-		LCDERR("axi_rmem index %d invalid\n", index);
-		return;
-	}
-	if (tcon_rmem->axi_rmem[index].mem_size < size) {
-		LCDERR("axi_mem[%d] size 0x%x is not enough, need 0x%x\n",
-		       index, tcon_rmem->axi_rmem[index].mem_size, size);
-		return;
-	}
-
-	paddr = tcon_rmem->axi_rmem[index].mem_paddr;
-	highmem_flag = PageHighMem(phys_to_page(paddr));
-	if (highmem_flag == 0) {
-		vaddr = phys_to_virt(paddr);
-		if (!vaddr)
-			goto lcd_tcon_axi_rmem_lut_load_err;
-		memcpy(vaddr, buf, size);
-	} else {
-		span = SZ_1M;
-		count = size / PAGE_ALIGN(span);
-		remain = size % PAGE_ALIGN(span);
-
-		for (i = 0; i < count; i++) {
-			phys = paddr + i * span;
-			vaddr = lcd_vmap(phys, span);
-			if (!vaddr)
-				goto lcd_tcon_axi_rmem_lut_load_err;
-			p = buf + i * span;
-			memcpy(vaddr, p, span);
-			lcd_unmap_phyaddr(vaddr);
-		}
-		if (remain) {
-			phys = paddr + count * span;
-			vaddr = lcd_vmap(phys, remain);
-			if (!vaddr)
-				goto lcd_tcon_axi_rmem_lut_load_err;
-			p = buf + count * span;
-			memcpy(vaddr, p, remain);
-			lcd_unmap_phyaddr(vaddr);
-		}
-	}
-
-	return;
-
-lcd_tcon_axi_rmem_lut_load_err:
-	LCDERR("tcon axi_rmem[%d] mapping failed: 0x%lx\n", index, paddr);
-}
-
-static int lcd_tcon_wr_n_data_write(struct lcd_tcon_data_part_wr_n_s *wr_n,
-				    unsigned char *p,
-				    unsigned int n,
-				    unsigned int reg)
-{
-	unsigned int k, data, d;
-
-	if (wr_n->reg_inc) {
-		for (k = 0; k < wr_n->data_cnt; k++) {
-			data = 0;
-			for (d = 0; d < wr_n->reg_data_byte; d++)
-				data |= (p[n + d] << (d * 8));
-			if (wr_n->reg_data_byte == 1)
-				lcd_tcon_write_byte((reg + k), data);
-			else
-				lcd_tcon_write((reg + k), data);
-			n += wr_n->reg_data_byte;
-		}
-	} else {
-		for (k = 0; k < wr_n->data_cnt; k++) {
-			data = 0;
-			for (d = 0; d < wr_n->reg_data_byte; d++)
-				data |= (p[n + d] << (d * 8));
-			if (wr_n->reg_data_byte == 1)
-				lcd_tcon_write_byte(reg, data);
-			else
-				lcd_tcon_write(reg, data);
-			n += wr_n->reg_data_byte;
-		}
-	}
-
-	return 0;
-}
-
-int lcd_tcon_data_common_parse_set(unsigned char *data_buf, int init_flag)
-{
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-	struct lcd_tcon_data_block_header_s *block_header;
-	struct lcd_tcon_data_block_ext_header_s *ext_header;
-	unsigned char *p;
-	unsigned short part_cnt;
-	unsigned char part_type;
-	unsigned int size, reg, data, mask, temp, reg_base = 0;
-	union lcd_tcon_data_part_u data_part;
-	unsigned int data_offset, offset, i, j, k, d, m, n, step = 0;
-	unsigned int reg_cnt, reg_byte, data_cnt, data_byte;
-	unsigned short block_ctrl_flag, ctrl_data_flag, ctrl_sub_type;
-	int ret;
-
-	if (tcon_conf)
-		reg_base = tcon_conf->core_reg_start;
-
-	block_header = (struct lcd_tcon_data_block_header_s *)data_buf;
-	p = data_buf + LCD_TCON_DATA_BLOCK_HEADER_SIZE;
-	ext_header = (struct lcd_tcon_data_block_ext_header_s *)p;
-	part_cnt = ext_header->part_cnt;
-	if (lcd_debug_print_flag)
-		LCDPR("%s: part_cnt: %d\n", __func__, part_cnt);
-
-	block_ctrl_flag = block_header->block_ctrl;
-	data_offset = LCD_TCON_DATA_BLOCK_HEADER_SIZE +
-		block_header->ext_header_size;
-	size = 0;
-	for (i = 0; i < part_cnt; i++) {
-		p = data_buf + data_offset;
-		part_type = p[LCD_TCON_DATA_PART_NAME_SIZE + 3];
-		if (lcd_debug_print_flag) {
-			LCDPR("%s: start step %d, %s, type = 0x%02x,\n",
-			      __func__, step, p, part_type);
-		}
-		switch (part_type) {
-		case LCD_TCON_DATA_PART_TYPE_CONTROL:
-			block_ctrl_flag = 0;
-			data_part.ctrl =
-				(struct lcd_tcon_data_part_ctrl_s *)p;
-			offset = LCD_TCON_DATA_PART_CTRL_SIZE_PRE;
-			size = offset + (data_part.ctrl->data_cnt *
-					 data_part.ctrl->data_byte_width);
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			if (block_header->block_ctrl == 0)
-				break;
-			ctrl_data_flag = data_part.ctrl->ctrl_data_flag;
-			ctrl_sub_type = data_part.ctrl->ctrl_sub_type;
-			if (init_flag) {
-				if (ctrl_sub_type != LCD_TCON_DATA_CTRL_DEFAULT)
-					goto
-					lcd_tcon_data_common_parse_set_exit;
-			}
-			if (ctrl_data_flag == LCD_TCON_DATA_CTRL_FLAG_MULTI) {
-				ret = 0;
-			} else {
-				ret = -1;
-				LCDERR("%s: ctrl_data_flag 0x%x not support\n",
-				       __func__, ctrl_data_flag);
-			}
-			if (ret)
-				goto lcd_tcon_data_common_parse_set_exit;
-			break;
-		case LCD_TCON_DATA_PART_TYPE_WR_N:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.wr_n = (struct lcd_tcon_data_part_wr_n_s *)p;
-			offset = LCD_TCON_DATA_PART_WR_N_SIZE_PRE;
-			size = offset + (data_part.wr_n->reg_cnt *
-					 data_part.wr_n->reg_addr_byte) +
-					(data_part.wr_n->data_cnt *
-					 data_part.wr_n->reg_data_byte);
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			reg_cnt = data_part.wr_n->reg_cnt;
-			reg_byte = data_part.wr_n->reg_addr_byte;
-			m = offset; /*for reg*/
-			/*for data*/
-			n = m + (reg_cnt * reg_byte);
-			for (j = 0; j < reg_cnt; j++) {
-				reg = 0;
-				for (d = 0; d < reg_byte; d++)
-					reg |= (p[m + d] << (d * 8));
-				if (reg < reg_base)
-				goto lcd_tcon_data_common_parse_set_err_reg;
-				lcd_tcon_wr_n_data_write(data_part.wr_n, p, n,
-							 reg);
-				m += reg_byte;
-			}
-			break;
-		case LCD_TCON_DATA_PART_TYPE_WR_DDR:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.wr_ddr =
-				(struct lcd_tcon_data_part_wr_ddr_s *)p;
-			offset = LCD_TCON_DATA_PART_WR_DDR_SIZE_PRE;
-			m = data_part.wr_ddr->data_cnt *
-				data_part.wr_ddr->data_byte;
-			size = offset + m;
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			n = data_part.wr_ddr->axi_buf_id;
-			lcd_tcon_axi_rmem_lut_load(n, &p[offset], m);
-			break;
-		case LCD_TCON_DATA_PART_TYPE_WR_MASK:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.wr_mask =
-				(struct lcd_tcon_data_part_wr_mask_s *)p;
-			offset = LCD_TCON_DATA_PART_WR_MASK_SIZE_PRE;
-			size = offset + data_part.wr_mask->reg_addr_byte +
-				(2 * data_part.wr_mask->reg_data_byte);
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			reg_byte = data_part.wr_mask->reg_addr_byte;
-			data_byte = data_part.wr_mask->reg_data_byte;
-			m = offset; /* for reg */
-			/* for data */
-			n = m + reg_byte;
-			reg = 0;
-			for (d = 0; d < reg_byte; d++)
-				reg |= (p[m + d] << (d * 8));
-			if (reg < reg_base)
-				goto lcd_tcon_data_common_parse_set_err_reg;
-			mask = 0;
-			for (d = 0; d < data_byte; d++)
-				mask |= (p[n + d] << (d * 8));
-			n += data_byte;
-			data = 0;
-			for (d = 0; d < data_byte; d++)
-				data |= (p[n + d] << (d * 8));
-			if (data_byte == 1)
-				lcd_tcon_update_bits_byte(reg, mask, data);
-			else
-				lcd_tcon_update_bits(reg, mask, data);
-			break;
-		case LCD_TCON_DATA_PART_TYPE_RD_MASK:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.rd_mask =
-				(struct lcd_tcon_data_part_rd_mask_s *)p;
-			offset = LCD_TCON_DATA_PART_RD_MASK_SIZE_PRE;
-			size = offset + data_part.rd_mask->reg_addr_byte +
-				data_part.rd_mask->reg_data_byte;
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			reg_byte = data_part.rd_mask->reg_addr_byte;
-			data_byte = data_part.rd_mask->reg_data_byte;
-			m = offset; /* for reg */
-			/* for data */
-			n = m + reg_byte;
-			reg = 0;
-			for (d = 0; d < reg_byte; d++)
-				reg |= (p[m + d] << (d * 8));
-			if (reg < reg_base)
-				goto lcd_tcon_data_common_parse_set_err_reg;
-			mask = 0;
-			for (d = 0; d < data_byte; d++)
-				mask |= (p[n + d] << (d * 8));
-			if (data_byte == 1) {
-				data = lcd_tcon_read_byte(reg) & mask;
-				if (lcd_debug_print_flag)
-					LCDPR
-				("%s read reg 0x%04x = 0x%02x, mask = 0x%02x\n",
-				 __func__, reg, data, mask);
-			} else {
-				data = lcd_tcon_read(reg) & mask;
-				if (lcd_debug_print_flag)
-					LCDPR
-				("%s read reg 0x%04x = 0x%02x, mask = 0x%02x\n",
-				 __func__, reg, data, mask);
-			}
-			break;
-		case LCD_TCON_DATA_PART_TYPE_CHK_WR_MASK:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.chk_wr_mask =
-				(struct lcd_tcon_data_part_chk_wr_mask_s *)p;
-			offset = LCD_TCON_DATA_PART_CHK_WR_MASK_SIZE_PRE;
-			size = offset +
-			data_part.chk_wr_mask->reg_chk_addr_byte +
-				//include mask
-			data_part.chk_wr_mask->reg_chk_data_byte *
-			(data_part.chk_wr_mask->data_chk_cnt + 1) +
-			data_part.chk_wr_mask->reg_wr_addr_byte +
-			//include mask, default
-			data_part.chk_wr_mask->reg_wr_data_byte *
-			(data_part.chk_wr_mask->data_chk_cnt + 2);
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			reg_byte = data_part.chk_wr_mask->reg_chk_addr_byte;
-			data_cnt = data_part.chk_wr_mask->data_chk_cnt;
-			data_byte = data_part.chk_wr_mask->reg_chk_data_byte;
-			m = offset; /* for reg */
-			n = m + reg_byte; /* for data */
-			reg = 0;
-			for (d = 0; d < reg_byte; d++)
-				reg |= (p[m + d] << (d * 8));
-			if (reg < reg_base)
-				goto lcd_tcon_data_common_parse_set_err_reg;
-			mask = 0;
-			for (d = 0; d < data_byte; d++)
-				mask |= (p[n + d] << (d * 8));
-			if (data_byte == 1)
-				temp = lcd_tcon_read_byte(reg) & mask;
-			else
-				temp = lcd_tcon_read(reg) & mask;
-			n += data_byte;
-			for (j = 0; j < data_cnt; j++) {
-				data = 0;
-				for (d = 0; d < data_byte; d++)
-					data |= (p[n + d] << (d * 8));
-				if ((data & mask) == temp)
-					break;
-				n += data_byte;
-			}
-			k = j;
-
-			/* for reg */
-			m = offset + reg_byte + data_byte * (data_cnt + 1);
-			/* for data */
-			n = m + data_part.chk_wr_mask->reg_wr_addr_byte;
-			reg_byte = data_part.chk_wr_mask->reg_wr_addr_byte;
-			data_byte = data_part.chk_wr_mask->reg_wr_data_byte;
-			reg = 0;
-			for (d = 0; d < reg_byte; d++)
-				reg |= (p[m + d] << (d * 8));
-			if (reg < reg_base)
-				goto lcd_tcon_data_common_parse_set_err_reg;
-			mask = 0;
-			for (d = 0; d < data_byte; d++)
-				mask |= (p[n + d] << (d * 8));
-			n += data_byte;
-			n += data_byte * k;
-			data = 0;
-			for (d = 0; d < data_byte; d++)
-				data |= (p[n + d] << (d * 8));
-			if (data_byte == 1)
-				lcd_tcon_update_bits_byte(reg, mask, data);
-			else
-				lcd_tcon_update_bits(reg, mask, data);
-			break;
-		case LCD_TCON_DATA_PART_TYPE_CHK_EXIT:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.chk_exit =
-				(struct lcd_tcon_data_part_chk_exit_s *)p;
-			offset = LCD_TCON_DATA_PART_CHK_EXIT_SIZE_PRE;
-			size = offset + data_part.chk_exit->reg_addr_byte +
-				(2 * data_part.chk_exit->reg_data_byte);
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			reg_byte = data_part.chk_exit->reg_addr_byte;
-			data_byte = data_part.chk_exit->reg_data_byte;
-			m = offset; /* for reg */
-			/* for data */
-			n = m + reg_byte;
-			reg = 0;
-			for (d = 0; d < reg_byte; d++)
-				reg |= (p[m + d] << (d * 8));
-			if (reg < reg_base)
-				goto lcd_tcon_data_common_parse_set_err_reg;
-			mask = 0;
-			for (d = 0; d < data_byte; d++)
-				mask |= (p[n + d] << (d * 8));
-			n += data_byte;
-			data = 0;
-			for (d = 0; d < data_byte; d++)
-				data |= (p[n + d] << (d * 8));
-			if (data_byte == 1)
-				ret = lcd_tcon_check_bits_byte(reg, mask, data);
-			else
-				ret = lcd_tcon_check_bits(reg, mask, data);
-			if (ret) {
-				LCDPR("%s: block %s data_part %d check exit\n",
-				      __func__, block_header->name, i);
-				return 0;
-			}
-			break;
-		case LCD_TCON_DATA_PART_TYPE_DELAY:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.delay =
-				(struct lcd_tcon_data_part_delay_s *)p;
-			size = LCD_TCON_DATA_PART_DELAY_SIZE;
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			if (init_flag == 0) /* calling by vsync isr */
-				break;
-			if (data_part.delay->delay_us > 20000) {
-				m = data_part.delay->delay_us / 1000;
-				n = data_part.delay->delay_us % 1000;
-				msleep(m);
-				if (n > 20)
-					usleep_range(n, n + 1);
-				else if (n > 0)
-					udelay(n);
-			} else {
-				n = data_part.delay->delay_us;
-				if (n > 20)
-					usleep_range(n, n + 1);
-				else if (n > 0)
-					udelay(n);
-			}
-			break;
-		case LCD_TCON_DATA_PART_TYPE_PARAM:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			data_part.param =
-				(struct lcd_tcon_data_part_param_s *)p;
-			offset = LCD_TCON_DATA_PART_PARAM_SIZE_PRE;
-			size = offset + data_part.param->param_size;
-			if ((size + data_offset) > block_header->block_size)
-				goto lcd_tcon_data_common_parse_set_err_size;
-			break;
-		default:
-			if (block_ctrl_flag)
-				goto lcd_tcon_data_common_parse_set_ctrl_err;
-			LCDERR("%s: unsupport dat part type 0x%02x\n",
-			       __func__, part_type);
-			break;
-		}
-		if (lcd_debug_print_flag) {
-			LCDPR("%s: end step %d, %s, type=0x%02x, size=%d\n",
-			      __func__, step, p, part_type, size);
-		}
-		data_offset += size;
-		step++;
-	}
-
-	return 0;
-
-lcd_tcon_data_common_parse_set_exit:
-	if (lcd_debug_print_flag)
-		LCDPR("%s: block %s control exit\n", __func__,
-		      block_header->name);
-	return -1;
-
-lcd_tcon_data_common_parse_set_ctrl_err:
-	LCDERR("%s: block %s need control part\n", __func__,
-	       block_header->name);
-	return -1;
-
-lcd_tcon_data_common_parse_set_err_reg:
-	LCDERR("%s: block %s step %d reg 0x%04x error\n",
-	       __func__, block_header->name, step, reg);
-	return -1;
-
-lcd_tcon_data_common_parse_set_err_size:
-	LCDERR("%s: block %s step %d size error\n",
-	       __func__, block_header->name, step);
-	return -1;
-}
-
-static int lcd_tcon_data_set(struct tcon_mem_map_table_s *mm_table)
-{
-	struct lcd_tcon_data_block_header_s *block_header;
-	unsigned char *data_buf;
-	unsigned int temp_crc32;
-	unsigned int i, index, chk_size;
-
-	if (!mm_table->data_mem_vaddr) {
-		LCDERR("%s: data_mem error\n", __func__);
-		return -1;
-	}
-
-	if (!mm_table->data_priority) {
-		LCDERR("%s: data_priority is null\n", __func__);
-		return -1;
-	}
-
-	for (i = 0; i < mm_table->block_cnt; i++) {
-		index = mm_table->data_priority[i].index;
-		if ((index >= mm_table->block_cnt) ||
-		     (mm_table->data_priority[i].priority == 0xff)) {
-			LCDERR("%s: data index or priority is invalid\n",
-			       __func__);
-			return -1;
-		}
-		data_buf = mm_table->data_mem_vaddr[index];
-		block_header = (struct lcd_tcon_data_block_header_s *)data_buf;
-		chk_size = block_header->block_size - 4;
-		temp_crc32 = cal_crc32(0, &data_buf[4], chk_size);
-		if (temp_crc32 != block_header->crc32) {
-			LCDERR("%s: block %d, %s data crc error\n",
-				__func__, mm_table->data_priority[i].index,
-				block_header->name);
-			continue;
-		}
-
-		if (lcd_debug_print_flag) {
-			LCDPR
-	("%s: block %d, %s, priority %d: size=0x%x, type=0x%02x, ctrl=0x%x\n",
-			      __func__, mm_table->data_priority[i].index,
-			      block_header->name,
-			      mm_table->data_priority[i].priority,
-			      block_header->block_size,
-			      block_header->block_type,
-			      block_header->block_ctrl);
-		}
-
-		/* add data multi list */
-		if (block_header->block_ctrl & LCD_TCON_DATA_CTRL_FLAG_MULTI)
-			lcd_tcon_data_multi_add(mm_table, block_header, index);
-
-		/* apply data */
-		lcd_tcon_data_common_parse_set(data_buf, 1);
-	}
-
-	LCDPR("%s finish\n", __func__);
-	return 0;
-}
-
-static int lcd_tcon_top_set_tl1(struct lcd_config_s *pconf)
-{
-	struct tcon_rmem_s *tcon_rmem = get_lcd_tcon_rmem();
-	unsigned int axi_reg[3] = {
-		TCON_AXI_OFST0, TCON_AXI_OFST1, TCON_AXI_OFST2
-	};
-	unsigned int paddr, p2p_type;
-	int i;
-
-	if (lcd_debug_print_flag)
-		LCDPR("lcd tcon top set\n");
-
-	if (tcon_rmem && tcon_rmem->flag) {
-		if (!tcon_rmem->axi_rmem) {
-			LCDERR("%s: invalid axi_mem\n", __func__);
-		} else {
-			for (i = 0; i < 3; i++) {
-				paddr = tcon_rmem->axi_rmem[i].mem_paddr;
-				lcd_tcon_write(axi_reg[i], paddr);
-				LCDPR("set tcon axi_mem paddr[%d]: 0x%08x\n",
-				      i, paddr);
-			}
-		}
-	} else {
-		LCDERR("%s: invalid axi_mem\n", __func__);
-	}
-
-	lcd_tcon_write(TCON_CLK_CTRL, 0x001f);
-	if (pconf->lcd_basic.lcd_type == LCD_P2P) {
-		p2p_type = pconf->lcd_control.p2p_config->p2p_type & 0x1f;
-		switch (p2p_type) {
-		case P2P_CHPI:
-		case P2P_USIT:
-			lcd_tcon_write(TCON_TOP_CTRL, 0x8199);
-			break;
-		default:
-			lcd_tcon_write(TCON_TOP_CTRL, 0x8999);
-			break;
-		}
-	} else {
-		lcd_tcon_write(TCON_TOP_CTRL, 0x8999);
-	}
-	lcd_tcon_write(TCON_PLLLOCK_CNTL, 0x0037);
-	lcd_tcon_write(TCON_RST_CTRL, 0x003f);
-	lcd_tcon_write(TCON_RST_CTRL, 0x0000);
-	lcd_tcon_write(TCON_DDRIF_CTRL0, 0x33fff000);
-	lcd_tcon_write(TCON_DDRIF_CTRL1, 0x300300);
-
-	return 0;
-}
-
-static int lcd_tcon_top_set_t5(struct lcd_config_s *pconf)
-{
-	unsigned int p2p_type;
-
-	if (lcd_debug_print_flag)
-		LCDPR("lcd tcon top set\n");
-
-	lcd_tcon_write(TCON_CLK_CTRL, 0x001f);
-	if (pconf->lcd_basic.lcd_type == LCD_P2P) {
-		p2p_type = pconf->lcd_control.p2p_config->p2p_type & 0x1f;
-		switch (p2p_type) {
-		case P2P_CHPI:
-		case P2P_USIT:
-			lcd_tcon_write(TCON_TOP_CTRL, 0x8399);
-			break;
-		default:
-			lcd_tcon_write(TCON_TOP_CTRL, 0x8b99);
-			break;
-		}
-	} else {
-		lcd_tcon_write(TCON_TOP_CTRL, 0x8b99);
-	}
-	lcd_tcon_write(TCON_PLLLOCK_CNTL, 0x0037);
-	lcd_tcon_write(TCON_RST_CTRL, 0x003f);
-	lcd_tcon_write(TCON_RST_CTRL, 0x0000);
-	lcd_tcon_write(TCON_DDRIF_CTRL0, 0x33fff000);
-	lcd_tcon_write(TCON_DDRIF_CTRL1, 0x300300);
-
-	return 0;
-}
-
-int lcd_tcon_gamma_pattern_tl1(unsigned int bit_width, unsigned int gamma_r,
-			       unsigned int gamma_g, unsigned int gamma_b)
-{
-	unsigned int val_r = 0, val_g = 0, val_b = 0, reg;
-	unsigned char temp[3];
-	int i;
-
-	switch (bit_width) {
-	case 12:
-		val_r = gamma_r;
-		val_g = gamma_g;
-		val_b = gamma_b;
-		break;
-	case 10:
-		val_r = (gamma_r << 2);
-		val_g = (gamma_g << 2);
-		val_b = (gamma_b << 2);
-		break;
-	case 8:
-		val_r = (gamma_r << 4);
-		val_g = (gamma_g << 4);
-		val_b = (gamma_b << 4);
-		break;
-	default:
-		LCDERR("gamam_set: invalid bit_width %d\n", bit_width);
-		return -1;
-	}
-
-	/* enable lut access, disable gamma en*/
-	lcd_tcon_setb_byte(0x262, 0x2, 0, 2);
-
-	/* gamma_r */
-	/*2 data splice 3 bytes*/
-	temp[0] = val_r & 0xff;
-	temp[1] = ((val_r >> 8) & 0xf) | ((val_r & 0xf) << 4);
-	temp[2] = (val_r >> 4) & 0xff;
-	reg = 0xb50;
-	for (i = 0; i < 384; i += 3) { /* 256 * 1.5 */
-		lcd_tcon_write_byte((reg + i), temp[0]);
-		lcd_tcon_write_byte((reg + i + 1), temp[1]);
-		lcd_tcon_write_byte((reg + i + 2), temp[2]);
-	}
-	temp[0] = val_r & 0xff;
-	temp[1] = ((val_r >> 8) & 0xf);
-	temp[2] = 0;
-	reg += 384;
-	lcd_tcon_write_byte((reg), temp[0]);
-	lcd_tcon_write_byte((reg + 1), temp[1]);
-	lcd_tcon_write_byte((reg + 2), temp[2]);
-
-	/* gamma_g */
-	/*2 data splice 3 bytes*/
-	temp[0] = val_g & 0xff;
-	temp[1] = ((val_g >> 8) & 0xf) | ((val_g & 0xf) << 4);
-	temp[2] = (val_g >> 4) & 0xff;
-	reg += 3;
-	for (i = 0; i < 384; i += 3) { /* 256 * 1.5 */
-		lcd_tcon_write_byte((reg + i), temp[0]);
-		lcd_tcon_write_byte((reg + i + 1), temp[1]);
-		lcd_tcon_write_byte((reg + i + 2), temp[2]);
-	}
-	temp[0] = val_g & 0xff;
-	temp[1] = ((val_g >> 8) & 0xf);
-	temp[2] = 0;
-	reg += 384;
-	lcd_tcon_write_byte((reg), temp[0]);
-	lcd_tcon_write_byte((reg + 1), temp[1]);
-	lcd_tcon_write_byte((reg + 2), temp[2]);
-
-	/* gamma_b */
-	/*2 data splice 3 bytes*/
-	temp[0] = val_b & 0xff;
-	temp[1] = ((val_b >> 8) & 0xf) | ((val_b & 0xf) << 4);
-	temp[2] = (val_b >> 4) & 0xff;
-	reg += 3;
-	for (i = 0; i < 384; i += 3) { /* 256 * 1.5 */
-		lcd_tcon_write_byte((reg + i), temp[0]);
-		lcd_tcon_write_byte((reg + i + 1), temp[1]);
-		lcd_tcon_write_byte((reg + i + 2), temp[2]);
-	}
-	temp[0] = val_b & 0xff;
-	temp[1] = ((val_b >> 8) & 0xf);
-	temp[2] = 0;
-	reg += 384;
-	lcd_tcon_write_byte((reg), temp[0]);
-	lcd_tcon_write_byte((reg + 1), temp[1]);
-	lcd_tcon_write_byte((reg + 2), temp[2]);
-
-	/* enable gamma */
-	lcd_tcon_setb_byte(0x262, 0x3, 0, 2);
-
-	return 0;
-}
-
-int lcd_tcon_gamma_pattern_t5(unsigned int bit_width, unsigned int gamma_r,
-			      unsigned int gamma_g, unsigned int gamma_b)
-{
-	unsigned int val_r = 0, val_g = 0, val_b = 0;
-	unsigned int temp;
-
-	switch (bit_width) {
-	case 10:
-		val_r = gamma_r & 0x3ff;
-		val_g = gamma_g & 0x3ff;
-		val_b = gamma_b & 0x3ff;
-		break;
-	case 8:
-		val_r = (gamma_r << 2) & 0x3ff;
-		val_g = (gamma_g << 2) & 0x3ff;
-		val_b = (gamma_b << 2) & 0x3ff;
-		break;
-	default:
-		LCDERR("gamam_set: invalid bit_width %d\n", bit_width);
-		return -1;
-	}
-
-	/* gamma calibrate mode */
-	lcd_tcon_setb(0x222, 1, 13, 1);
-	lcd_tcon_setb(0x222, 0, 12, 1);
-	lcd_tcon_setb(0x222, 0, 8, 2);
-	lcd_tcon_setb(0x201, 1, 31, 1); //test pattern enable
-
-	/* gamma pattern */
-	lcd_tcon_setb(0x201, 0, 26, 4);
-	temp = (val_r << 0) | (val_g << 10) | (val_b << 20);
-	lcd_tcon_setb(0x204, temp, 0, 30);
-
-	return 0;
-}
-
-int lcd_tcon_enable_tl1(struct lcd_config_s *pconf)
-{
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-	struct tcon_mem_map_table_s *mm_table = get_lcd_tcon_mm_table();
-	unsigned int p2p_type;
-	int ret, flag;
-
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return -1;
-	if (!tcon_conf)
-		return -1;
-	if (!mm_table)
-		return -1;
-	if (mm_table->tcon_data_flag == 0)
-		lcd_tcon_data_load();
-
-	/* step 1: tcon top */
-	lcd_tcon_top_set_tl1(pconf);
-
-	/* step 2: tcon_core_reg_update */
-	lcd_tcon_core_reg_pre_od(tcon_conf, mm_table);
-	lcd_tcon_core_reg_set(tcon_conf, mm_table);
-	if (pconf->lcd_basic.lcd_type == LCD_P2P) {
-		p2p_type = pconf->lcd_control.p2p_config->p2p_type & 0x1f;
-		switch (p2p_type) {
-		case P2P_CHPI:
-			lcd_phy_tcon_chpi_bbc_init_tl1(pconf);
-			break;
-		default:
-			break;
-		}
-	}
-	if (mm_table->version == 0) {
-		if (mm_table->valid_flag & LCD_TCON_DATA_VALID_VAC) {
-			if (mm_table->valid_flag &
-			    LCD_TCON_DATA_VALID_DEMURA)
-				flag = 1;
-			else
-				flag = 0;
-			lcd_tcon_vac_set_tl1(flag);
-		}
-		if (mm_table->valid_flag & LCD_TCON_DATA_VALID_DEMURA) {
-			lcd_tcon_demura_set_tl1();
-			lcd_tcon_demura_lut_tl1();
-		}
-		if (mm_table->valid_flag & LCD_TCON_DATA_VALID_ACC)
-			lcd_tcon_acc_lut_tl1();
-	} else {
-		lcd_tcon_data_set(mm_table);
-	}
-
-	/* step 3: tcon_top_output_set */
-	lcd_tcon_write(TCON_OUT_CH_SEL0, 0x76543210);
-	lcd_tcon_write(TCON_OUT_CH_SEL1, 0xba98);
-
-	/* step 4: tcon_intr_mask */
-	lcd_tcon_write(TCON_INTR_MASKN, TCON_INTR_MASKN_VAL);
-
-	return 0;
-}
-
-int lcd_tcon_disable_tl1(struct lcd_config_s *pconf)
-{
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-	unsigned int reg, i, cnt, offset, bit;
-
-	if (!tcon_conf)
-		return -1;
-
-	/* disable tcon intr */
-	lcd_tcon_write(TCON_INTR_MASKN, 0);
-
-	/* disable over_drive */
-	if (tcon_conf->reg_core_od != REG_LCD_TCON_MAX) {
-		reg = tcon_conf->reg_core_od;
-		bit = tcon_conf->bit_od_en;
-		if (tcon_conf->core_reg_width == 8)
-			lcd_tcon_setb_byte(reg, 0, bit, 1);
-		else
-			lcd_tcon_setb(reg, 0, bit, 1);
-		msleep(100);
-	}
-
-	/* disable all ctrl signal */
-	if (tcon_conf->reg_ctrl_timing_base == REG_LCD_TCON_MAX)
-		goto lcd_tcon_disable_tl1_next;
-	reg = tcon_conf->reg_ctrl_timing_base;
-	offset = tcon_conf->ctrl_timing_offset;
-	cnt = tcon_conf->ctrl_timing_cnt;
-	for (i = 0; i < cnt; i++) {
-		if (tcon_conf->core_reg_width == 8)
-			lcd_tcon_setb_byte((reg + (i * offset)), 1, 3, 1);
-		else
-			lcd_tcon_setb((reg + (i * offset)), 1, 3, 1);
-	}
-
-	/* disable top */
-lcd_tcon_disable_tl1_next:
-	if (tcon_conf->reg_top_ctrl != REG_LCD_TCON_MAX) {
-		reg = tcon_conf->reg_top_ctrl;
-		bit = tcon_conf->bit_en;
-		lcd_tcon_setb(reg, 0, bit, 1);
-	}
-
-	return 0;
-}
-
-int lcd_tcon_enable_t5(struct lcd_config_s *pconf)
-{
-	struct lcd_tcon_config_s *tcon_conf = get_lcd_tcon_config();
-	struct tcon_mem_map_table_s *mm_table = get_lcd_tcon_mm_table();
-	int ret;
-
-	ret = lcd_tcon_valid_check();
-	if (ret)
-		return -1;
-	if (!tcon_conf)
-		return -1;
-	if (!mm_table)
-		return -1;
-	if (mm_table->tcon_data_flag == 0)
-		lcd_tcon_data_load();
-
-	lcd_vcbus_write(ENCL_VIDEO_EN, 0);
-
-	/* step 1: tcon top */
-	lcd_tcon_top_set_t5(pconf);
-
-	/* step 2: tcon_core_reg_update */
-	lcd_tcon_core_reg_pre_dis_od(tcon_conf, mm_table);
-	lcd_tcon_core_reg_set(tcon_conf, mm_table);
-
-	/* step 3: set axi rmem, must before tcon data */
-	lcd_tcon_axi_rmem_set(tcon_conf);
-
-	/* step 4: tcon data set */
-	if (mm_table->version)
-		lcd_tcon_data_set(mm_table);
-
-	/* step 5: tcon_top_output_set */
-	lcd_tcon_write(TCON_OUT_CH_SEL0, 0x76543210);
-	lcd_tcon_write(TCON_OUT_CH_SEL1, 0xba98);
-
-	/* step 6: tcon_intr_mask */
-	lcd_tcon_write(TCON_INTR_MASKN, TCON_INTR_MASKN_VAL);
-
-	lcd_vcbus_write(ENCL_VIDEO_EN, 1);
-
-	return 0;
-}
-
-int lcd_tcon_disable_t5(struct lcd_config_s *pconf)
-{
-	/* disable tcon intr */
-	lcd_tcon_write(TCON_INTR_MASKN, 0);
-
-	/* disable od ddr_if */
-	lcd_tcon_setb(0x263, 0, 31, 1);
-	msleep(100);
-
-	/* top reset */
-	lcd_tcon_write(TCON_RST_CTRL, 0x003f);
-
-	/* global reset tcon */
-	lcd_reset_setb(RESET1_MASK_T5, 0, 4, 1);
-	lcd_reset_setb(RESET1_LEVEL_T5, 0, 4, 1);
-	udelay(1);
-	lcd_reset_setb(RESET1_LEVEL_T5, 1, 4, 1);
-	udelay(2);
-	LCDPR("reset tcon\n");
-
-	return 0;
-}
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tcon_ref.h b/drivers/amlogic/media/vout/lcd/lcd_tcon_ref.h
new file mode 100644
index 000000000000..fdf5398957a0
--- /dev/null
+++ b/drivers/amlogic/media/vout/lcd/lcd_tcon_ref.h
@@ -0,0 +1,40993 @@
+/*
+ * drivers/amlogic/media/vout/lcd/lcd_tcon_ref.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __LCD_TCON_REF_H__
+#define __LCD_TCON_REF_H__
+
+static unsigned char tcon_boe_hd_hsd_n56[] = {
+	0x40,
+	0x44,
+	0x44,
+	0x44,
+	0x44,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x44,
+	0x44,
+	0x44,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xE4,
+	0x1B,
+	0x00,
+	0x00,
+	0x0F,
+	0xC8,
+	0x00,
+	0x11,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xC0,
+	0x6F,
+	0x00,
+	0x88,
+	0x2B,
+	0x00,
+	0x10,
+	0x32,
+	0x54,
+	0x76,
+	0x90,
+	0x06,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x07,
+	0x80,
+	0x03,
+	0x28,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40, /* 0x05c //0x00 --> 0x40  //[6]:od_en */
+	0x00,
+	0x04,
+	0x00,
+	0x80,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x80,
+	0x08,
+	0x10,
+	0x09,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xB4,
+	0x33,
+	0x00,
+	0x3B,
+	0x00,
+	0x06,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE8,
+	0x01,
+	0x5A,
+	0x00,
+	0x2A,
+	0xE8,
+	0x00,
+	0x02,
+	0x00,
+	0x02,
+	0x3D,
+	0xA3,
+	0xC2,
+	0x33,
+	0x82,
+	0xCA,
+	0x28,
+	0xC2,
+	0x2D,
+	0x22,
+	0xB1,
+	0xFB,
+	0x1F,
+	0xA1,
+	0x56,
+	0x11,
+	0x90,
+	0xBD,
+	0x02,
+	0xD0,
+	0x14,
+	0x00,
+	0x20,
+	0x56,
+	0x55,
+	0x6E,
+	0xFF,
+	0x3F,
+	0x00,
+	0x12,
+	0xF3,
+	0xC0,
+	0x44,
+	0x04,
+	0x96,
+	0xCC,
+	0x01,
+	0xFF,
+	0x0A,
+	0x0A,
+	0x0A,
+	0x0C,
+	0x69,
+	0x40,
+	0x03,
+	0x26,
+	0x64,
+	0x88,
+	0x4C,
+	0x00,
+	0x11,
+	0xC7,
+	0x80,
+	0x32,
+	0x8E,
+	0x88,
+	0x00,
+	0x0A,
+	0x00,
+	0x08,
+	0x05,
+	0xDC,
+	0x03,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0A,
+	0x00,
+	0x00,
+	0x20, /* 0x113: 0x00 --> 0x20, bit[5] */
+	0xAB,
+	0x42,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x0C,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x03,
+	0x1E,
+	0x0C,
+	0x20,
+	0x00,
+	0x88,
+	0x08,
+	0x00,
+	0x64,
+	0xC8,
+	0x00,
+	0x00,
+	0x0A,
+	0x20,
+	0x00,
+	0xCC,
+	0x99,
+	0x33,
+	0x66,
+	0x33,
+	0x55,
+	0xAA,
+	0xBB,
+	0x77,
+	0x66,
+	0x33,
+	0x55,
+	0xAA,
+	0xBB,
+	0x77,
+	0x66,
+	0x33,
+	0x55,
+	0xAA,
+	0xBB,
+	0x77,
+	0x66,
+	0x33,
+	0x55,
+	0xAA,
+	0xBB,
+	0x77,
+	0x10,
+	0x88,
+	0x8F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x10,
+	0x18,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x30,
+	0xE8,
+	0xFC,
+	0x03,
+	0x21,
+	0x49,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x04,
+	0x20,
+	0xA0,
+	0x86,
+	0x01,
+	0x03,
+	0xA0,
+	0x86,
+	0x01,
+	0xD4,
+	0x38,
+	0x34,
+	0xC0,
+	0x38,
+	0x74,
+	0x01,
+	0xF9,
+	0xC7,
+	0x11,
+	0xC7,
+	0x73,
+	0x3C,
+	0x80,
+	0xE0,
+	0xC7,
+	0x1E,
+	0x38,
+	0x6D,
+	0x60,
+	0x64,
+	0xF9,
+	0xC3,
+	0x06,
+	0x18,
+	0x9C,
+	0x40,
+	0x80,
+	0xE0,
+	0xC7,
+	0x1E,
+	0x38,
+	0x4A,
+	0x38,
+	0x64,
+	0x2C,
+	0x07,
+	0x00,
+	0x07,
+	0x0B,
+	0xB8,
+	0x80,
+	0x70,
+	0x07,
+	0x00,
+	0x07,
+	0x05,
+	0x14,
+	0x80,
+	0x3E,
+	0xCC,
+	0xCC,
+	0xCC,
+	0xFD,
+	0xE8,
+	0x80,
+	0x20,
+	0x89,
+	0x85,
+	0x22,
+	0x03,
+	0xE8,
+	0x80,
+	0x04,
+	0x50,
+	0xFF,
+	0x30,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0x02,
+	0x23,
+	0x03,
+	0x44,
+	0x29,
+	0x11,
+	0x10,
+	0x01,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0xFA,
+	0xA0,
+	0x0F,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x02,
+	0xF0,
+	0xFF,
+	0xBC,
+	0xC2,
+	0x30,
+	0x40,
+	0x01,
+	0x14,
+	0x40,
+	0x01,
+	0x00,
+	0x02,
+	0x30,
+	0x00,
+	0xBC,
+	0xC2,
+	0x2B,
+	0x40,
+	0x01,
+	0x35,
+	0x40,
+	0x01,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x79,
+	0xE2,
+	0x19,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x05,
+	0xF0,
+	0xFF,
+	0x79,
+	0x02,
+	0x23,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x02,
+	0xF0,
+	0xFF,
+	0x79,
+	0x02,
+	0x23,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x70,
+	0x50,
+	0x31,
+	0xF0,
+	0xF0,
+	0xF4,
+	0x20,
+	0x00,
+	0x10,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x02,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x04,
+	0xAA,
+	0x55,
+	0x00,
+	0x00,
+	0x00,
+	0x60,
+	0x08,
+	0x80,
+	0x00, /* 0x2b1: 0x00 */
+	0x08, /* 0x2b2: 0x08 */
+	0x05, /* 0x2b3: 0x00 --> 0x05 */
+	0x58, /* 0x2b4: 0x08 --> 0x58 */
+	0x05, /* 0x2b5: 0x05 */
+	0x58,
+	0x02,
+	0x00,
+	0x20,
+	0x01,
+	0x08,
+	0x00,
+	0x13,
+	0x00,
+	0x0C,
+	0x0D,
+	0xB7,
+	0x03,
+	0x94,
+	0x18,
+	0x00,
+	0x10,
+	0xF0,
+	0x07,
+	0x80,
+	0x20,
+	0x00,
+	0x06,
+	0x0B,
+	0x0B,
+	0x33,
+	0x0E,
+	0x1C,
+	0x2A,
+	0x38,
+	0x46,
+	0x54,
+	0x62,
+	0x69,
+	0x70,
+	0x77,
+	0x79,
+	0x7B,
+	0x7D,
+	0x7E,
+	0x02,
+	0x04,
+	0x00,
+	0x04,
+	0x00,
+	0x0D,
+	0x3E,
+	0x0E,
+	0x3C,
+	0x1F,
+	0x3A,
+	0x1F,
+	0x38,
+	0x1F,
+	0x78,
+	0x18,
+	0x78,
+	0x19,
+	0x76,
+	0x1A,
+	0x76,
+	0x1B,
+	0x74,
+	0x2C,
+	0x74,
+	0x2D,
+	0x74,
+	0x3D,
+	0x74,
+	0x6F,
+	0x00,
+	0x08,
+	0x11,
+	0x1A,
+	0x23,
+	0x2C,
+	0x2D,
+	0x3E,
+	0x10,
+	0x22,
+	0x33,
+	0x44,
+	0x55,
+	0x66,
+	0x87,
+	0x88,
+	0x4F,
+	0xA5, /* 0x30d: 0xa5 */
+	0xD7, /* 0x30e: 0x09 --> 0xd7 */
+	0x80, /* 0x30f: 0x60 --> 0x80 */
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x2B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x4B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0A,
+	0x14,
+	0x28,
+	0x35,
+	0x49,
+	0x58,
+	0x65,
+	0x74,
+	0x81,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x10,
+	0x1C,
+	0x27,
+	0x35,
+	0x4C,
+	0x5C,
+	0x6D,
+	0x7D,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x08,
+	0x16,
+	0x20,
+	0x2B,
+	0x46,
+	0x57,
+	0x69,
+	0x7B,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x02,
+	0x08,
+	0x10,
+	0x18,
+	0x20,
+	0x40,
+	0x52,
+	0x65,
+	0x79,
+	0x9D,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x05,
+	0x10,
+	0x18,
+	0x20,
+	0x38,
+	0x4F,
+	0x63,
+	0x76,
+	0x9C,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x04,
+	0x10,
+	0x18,
+	0x20,
+	0x30,
+	0x4B,
+	0x60,
+	0x73,
+	0x9B,
+	0xBA,
+	0xD6,
+	0xF1,
+	0xFD,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x18,
+	0x20,
+	0x30,
+	0x40,
+	0x5B,
+	0x70,
+	0x98,
+	0xB9,
+	0xD6,
+	0xF1,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x07,
+	0x12,
+	0x15,
+	0x30,
+	0x40,
+	0x50,
+	0x6B,
+	0x94,
+	0xB7,
+	0xD5,
+	0xF0,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x06,
+	0x0E,
+	0x11,
+	0x22,
+	0x40,
+	0x50,
+	0x60,
+	0x8F,
+	0xB3,
+	0xD3,
+	0xF0,
+	0xFB,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x0B,
+	0x0D,
+	0x11,
+	0x34,
+	0x50,
+	0x60,
+	0x8B,
+	0xB0,
+	0xD1,
+	0xEE,
+	0xFA,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x0A,
+	0x0D,
+	0x2C,
+	0x3C,
+	0x55,
+	0x80,
+	0xA8,
+	0xCB,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x06,
+	0x07,
+	0x0B,
+	0x24,
+	0x35,
+	0x4E,
+	0x77,
+	0xA0,
+	0xC6,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x05,
+	0x06,
+	0x09,
+	0x1C,
+	0x2E,
+	0x47,
+	0x6D,
+	0x98,
+	0xC0,
+	0xE3,
+	0xF3,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x08,
+	0x17,
+	0x27,
+	0x41,
+	0x67,
+	0x91,
+	0xC0,
+	0xE0,
+	0xF0,
+	0xFF,
+	0x00,
+	0x01,
+	0x01,
+	0x02,
+	0x04,
+	0x05,
+	0x07,
+	0x13,
+	0x24,
+	0x3B,
+	0x69,
+	0x95,
+	0xB9,
+	0xE0,
+	0xF0,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x01,
+	0x04,
+	0x04,
+	0x07,
+	0x0C,
+	0x1D,
+	0x32,
+	0x67,
+	0x91,
+	0xB7,
+	0xDA,
+	0xF0,
+	0x00,
+	0x00,
+	0x0A,
+	0x14,
+	0x28,
+	0x35,
+	0x49,
+	0x58,
+	0x65,
+	0x74,
+	0x81,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x10,
+	0x1C,
+	0x27,
+	0x35,
+	0x4C,
+	0x5C,
+	0x6D,
+	0x7D,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x08,
+	0x16,
+	0x20,
+	0x2B,
+	0x46,
+	0x57,
+	0x69,
+	0x7B,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x02,
+	0x08,
+	0x10,
+	0x18,
+	0x20,
+	0x40,
+	0x52,
+	0x65,
+	0x79,
+	0x9D,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x05,
+	0x10,
+	0x18,
+	0x20,
+	0x38,
+	0x4F,
+	0x63,
+	0x76,
+	0x9C,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x04,
+	0x10,
+	0x18,
+	0x20,
+	0x30,
+	0x4B,
+	0x60,
+	0x73,
+	0x9B,
+	0xBA,
+	0xD6,
+	0xF1,
+	0xFD,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x18,
+	0x20,
+	0x30,
+	0x40,
+	0x5B,
+	0x70,
+	0x98,
+	0xB9,
+	0xD6,
+	0xF1,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x07,
+	0x12,
+	0x15,
+	0x30,
+	0x40,
+	0x50,
+	0x6B,
+	0x94,
+	0xB7,
+	0xD5,
+	0xF0,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x06,
+	0x0E,
+	0x11,
+	0x22,
+	0x40,
+	0x50,
+	0x60,
+	0x8F,
+	0xB3,
+	0xD3,
+	0xF0,
+	0xFB,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x0B,
+	0x0D,
+	0x11,
+	0x34,
+	0x50,
+	0x60,
+	0x8B,
+	0xB0,
+	0xD1,
+	0xEE,
+	0xFA,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x0A,
+	0x0D,
+	0x2C,
+	0x3C,
+	0x55,
+	0x80,
+	0xA8,
+	0xCB,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x06,
+	0x07,
+	0x0B,
+	0x24,
+	0x35,
+	0x4E,
+	0x77,
+	0xA0,
+	0xC6,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x05,
+	0x06,
+	0x09,
+	0x1C,
+	0x2E,
+	0x47,
+	0x6D,
+	0x98,
+	0xC0,
+	0xE3,
+	0xF3,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x08,
+	0x17,
+	0x27,
+	0x41,
+	0x67,
+	0x91,
+	0xC0,
+	0xE0,
+	0xF0,
+	0xFF,
+	0x00,
+	0x01,
+	0x01,
+	0x02,
+	0x04,
+	0x05,
+	0x07,
+	0x13,
+	0x24,
+	0x3B,
+	0x69,
+	0x95,
+	0xB9,
+	0xE0,
+	0xF0,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x01,
+	0x04,
+	0x04,
+	0x07,
+	0x0C,
+	0x1D,
+	0x32,
+	0x67,
+	0x91,
+	0xB7,
+	0xDA,
+	0xF0,
+	0x00,
+	0x00,
+	0x0A,
+	0x14,
+	0x28,
+	0x35,
+	0x49,
+	0x58,
+	0x65,
+	0x74,
+	0x81,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x10,
+	0x1C,
+	0x27,
+	0x35,
+	0x4C,
+	0x5C,
+	0x6D,
+	0x7D,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x08,
+	0x16,
+	0x20,
+	0x2B,
+	0x46,
+	0x57,
+	0x69,
+	0x7B,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x02,
+	0x08,
+	0x10,
+	0x18,
+	0x20,
+	0x40,
+	0x52,
+	0x65,
+	0x79,
+	0x9D,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x05,
+	0x10,
+	0x18,
+	0x20,
+	0x38,
+	0x4F,
+	0x63,
+	0x76,
+	0x9C,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x04,
+	0x10,
+	0x18,
+	0x20,
+	0x30,
+	0x4B,
+	0x60,
+	0x73,
+	0x9B,
+	0xBA,
+	0xD6,
+	0xF1,
+	0xFD,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x18,
+	0x20,
+	0x30,
+	0x40,
+	0x5B,
+	0x70,
+	0x98,
+	0xB9,
+	0xD6,
+	0xF1,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x07,
+	0x12,
+	0x15,
+	0x30,
+	0x40,
+	0x50,
+	0x6B,
+	0x94,
+	0xB7,
+	0xD5,
+	0xF0,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x06,
+	0x0E,
+	0x11,
+	0x22,
+	0x40,
+	0x50,
+	0x60,
+	0x8F,
+	0xB3,
+	0xD3,
+	0xF0,
+	0xFB,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x0B,
+	0x0D,
+	0x11,
+	0x34,
+	0x50,
+	0x60,
+	0x8B,
+	0xB0,
+	0xD1,
+	0xEE,
+	0xFA,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x0A,
+	0x0D,
+	0x2C,
+	0x3C,
+	0x55,
+	0x80,
+	0xA8,
+	0xCB,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x06,
+	0x07,
+	0x0B,
+	0x24,
+	0x35,
+	0x4E,
+	0x77,
+	0xA0,
+	0xC6,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x05,
+	0x06,
+	0x09,
+	0x1C,
+	0x2E,
+	0x47,
+	0x6D,
+	0x98,
+	0xC0,
+	0xE3,
+	0xF3,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x08,
+	0x17,
+	0x27,
+	0x41,
+	0x67,
+	0x91,
+	0xC0,
+	0xE0,
+	0xF0,
+	0xFF,
+	0x00,
+	0x01,
+	0x01,
+	0x02,
+	0x04,
+	0x05,
+	0x07,
+	0x13,
+	0x24,
+	0x3B,
+	0x69,
+	0x95,
+	0xB9,
+	0xE0,
+	0xF0,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x01,
+	0x04,
+	0x04,
+	0x07,
+	0x0C,
+	0x1D,
+	0x32,
+	0x67,
+	0x91,
+	0xB7,
+	0xDA,
+	0xF0,
+	0x00,
+	0xDE,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x24,
+	0xD5,
+};/*end of boe hd hsd n56*/
+
+static unsigned char tcon_boe_fhd_goa_n10[] = {
+	0x40,
+	0x44,
+	0x44,
+	0x44,
+	0x44,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x44,
+	0x44,
+	0x44,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xE4,
+	0x1B,
+	0x00,
+	0x20,  /* 0x013  //0x00 --> 0x20 */
+	0x0F,
+	0xC8,
+	0x00,
+	0x11,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xC0,
+	0x6F,
+	0x00,
+	0x88,
+	0x2B,
+	0x00,
+	0x10,
+	0x32,
+	0x54,
+	0x76,
+	0x90,
+	0x06,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x07,
+	0x80,
+	0x03,
+	0x28,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40, /* 0x05c //0x00 --> 0x40  //[6]:od_en */
+	0x00,
+	0x04,
+	0x00,
+	0x80,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x80,
+	0x08,
+	0x10,
+	0x09,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xB4,
+	0x33,
+	0x00,
+	0x3B,
+	0x00,
+	0x06,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE8,
+	0x01,
+	0x5A,
+	0x00,
+	0x2A,
+	0xE8,
+	0x00,
+	0x02,
+	0x00,
+	0x02,
+	0x3D,
+	0xA3,
+	0xC2,
+	0x33,
+	0x82,
+	0xCA,
+	0x28,
+	0xC2,
+	0x2D,
+	0x22,
+	0xB1,
+	0xFB,
+	0x1F,
+	0xA1,
+	0x56,
+	0x11,
+	0x90,
+	0xBD,
+	0x02,
+	0xD0,
+	0x14,
+	0x00,
+	0x20,
+	0x80,
+	0x77,
+	0x98,
+	0xFF,
+	0x4F,
+	0x38,
+	0x3E,
+	0xF4,
+	0xC0,
+	0x44,
+	0x04,
+	0x96,
+	0xCC,
+	0x01,
+	0xFF,
+	0x0A,
+	0x0A,
+	0x0A,
+	0x0C,
+	0x89,
+	0x70,
+	0x04,
+	0x4C,
+	0x64,
+	0xC0,
+	0x6C,
+	0x68,
+	0x21,
+	0xD0,
+	0x80,
+	0x52,
+	0x00,
+	0x88,
+	0x00,
+	0x0A,
+	0x00,
+	0x08,
+	0x05,
+	0xDC,
+	0x03,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x38,
+	0x11,
+	0x11,
+	0x20, /* 0x113: 0x00 --> 0x20, bit[5] */
+	0x80,
+	0x37,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0C,
+	0x01,
+	0x10,
+	0x3C,
+	0x82, /* 0x11e  //0xc0 --> 0x82 */
+	0x27, /* 0x11f  //0x03 --> 0x27 */
+	0x3C, /* 0x120  //0x1e --> 0x3c */
+	0x0C,
+	0x20,
+	0x00,
+	0x18,
+	0x0F, /* 0x125 //0x0b --> 0x0f */
+	0x00,
+	0x64,
+	0xC8,
+	0x00,
+	0x00,
+	0x0A,
+	0x20,
+	0x00,
+	0xCC,
+	0x99,
+	0x33,
+	0xCC,
+	0xDD,
+	0xEE,
+	0xCC,
+	0xDD,
+	0xEE,
+	0xCC,
+	0xDD,
+	0xEE,
+	0xCC,
+	0xDD,
+	0xEE,
+	0xCC,
+	0xDD,
+	0xEE,
+	0xCC,
+	0xDD,
+	0xEE,
+	0xCC,
+	0xDD,
+	0xEE,
+	0xCC,
+	0xDD,
+	0xEE,
+	0x10,
+	0x88,
+	0x8F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x10,
+	0x18,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x30,
+	0xE8,
+	0xFC,
+	0x03,
+	0x21,
+	0x49,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x04,
+	0x20,
+	0xA0,
+	0x86,
+	0x01,
+	0x03,
+	0xA0,
+	0x86,
+	0x01,
+	0xD4,
+	0x38,
+	0x34,
+	0xC0,
+	0x38,
+	0x74,
+	0x01,
+	0xF9,
+	0xC7,
+	0x11,
+	0xC7,
+	0x73,
+	0x3C,
+	0x80,
+	0xE0,
+	0xC7,
+	0x1E,
+	0x38,
+	0x6D,
+	0x60,
+	0x64,
+	0xF9,
+	0xC3,
+	0x06,
+	0x18,
+	0x9C,
+	0x40,
+	0x80,
+	0xE0,
+	0xC7,
+	0x1E,
+	0x38,
+	0x4A,
+	0x38,
+	0x64,
+	0x2C,
+	0x07,
+	0x00,
+	0x07,
+	0x0B,
+	0xB8,
+	0x80,
+	0x70,
+	0x07,
+	0x00,
+	0x07,
+	0x05,
+	0x14,
+	0x80,
+	0x3E,
+	0xCC,
+	0xCC,
+	0xCC,
+	0xFD,
+	0xE8,
+	0x80,
+	0x20,
+	0x89,
+	0x85,
+	0x22,
+	0x03,
+	0xE8,
+	0x80,
+	0x04,
+	0x50,
+	0xFF,
+	0x30,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0xE9,
+	0x87,
+	0x07,
+	0x20,
+	0x0C,
+	0x01,
+	0x10,
+	0x01,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0x64,
+	0x80,
+	0x70,
+	0x24,
+	0x41,
+	0x03,
+	0x20,
+	0x01,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0x32,
+	0x20,
+	0x4E,
+	0x24,
+	0x41,
+	0x03,
+	0x20,
+	0x01,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0x32,
+	0x00,
+	0x78,
+	0x40,
+	0x01,
+	0x05,
+	0x3B,
+	0x01,
+	0x00,
+	0x01,
+	0x10,
+	0x44,
+	0xB0,
+	0x04,
+	0x4B,
+	0x44,
+	0x01,
+	0x05,
+	0x3A,
+	0x01,
+	0x00,
+	0x02,
+	0x20,
+	0x44,
+	0xB0,
+	0x04,
+	0x4B,
+	0x44,
+	0x01,
+	0x05,
+	0x39,
+	0x01,
+	0x00,
+	0x03,
+	0x30,
+	0x44,
+	0xB0,
+	0x04,
+	0x4B,
+	0x44,
+	0x01,
+	0x05,
+	0x38,
+	0x01,
+	0x00,
+	0x04,
+	0x40,
+	0x44,
+	0xB0,
+	0x04,
+	0x4B,
+	0x44,
+	0x01,
+	0x05,
+	0x37,
+	0x01,
+	0x00,
+	0x05,
+	0x50,
+	0x44,
+	0xB0,
+	0x04,
+	0x4B,
+	0x44,
+	0x01,
+	0x05,
+	0x36,
+	0x01,
+	0x00,
+	0x06,
+	0x60,
+	0x44,
+	0xB0,
+	0x04,
+	0x4B,
+	0x46,
+	0x01,
+	0x66,
+	0x25,
+	0x01,
+	0x00,
+	0x03,
+	0xA0,
+	0x43,
+	0xC8,
+	0x40,
+	0x06,
+	0x46,
+	0x01,
+	0x77,
+	0x14,
+	0x01,
+	0x00,
+	0x03,
+	0xA0,
+	0x43,
+	0xC8,
+	0x40,
+	0x06,
+	0x40,
+	0x29,
+	0x10,
+	0x10,
+	0xB4,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x41,
+	0x29,
+	0x10,
+	0x10,
+	0xB4,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x24,
+	0x41,
+	0x03,
+	0x30,
+	0x01,
+	0x00,
+	0x01,
+	0xF0,
+	0xFF,
+	0x32,
+	0x40,
+	0x06,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x90,
+	0x80,
+	0x70,
+	0x60,
+	0x50,
+	0x40,
+	0x20,
+	0x00,
+	0x10,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xC0,
+	0xD0,
+	0xF0,
+	0xF0,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x02,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x04,
+	0xAA,
+	0x55,
+	0x00,
+	0x00,
+	0x00,
+	0x87,
+	0x00,
+	0x80,
+	0x00,
+	0x08,
+	0x07,  /* 0x2b3  //0x00 --> 0x07 */
+	0x80,  /* 0x2b4  //0x08 --> 0x80 */
+	0x07,
+	0x80,
+	0x02,
+	0x00,
+	0x20,
+	0x01,
+	0x1E,
+	0x00,
+	0x1A,
+	0x00,
+	0x0C,
+	0x0D,
+	0xB7,
+	0x03,
+	0x94,
+	0x18,
+	0x00,
+	0x10,
+	0xF0,
+	0x07,
+	0x80,
+	0x20,
+	0x00,
+	0x06,
+	0x0B,
+	0x0B,
+	0x33,
+	0x0E,
+	0x1C,
+	0x2A,
+	0x38,
+	0x46,
+	0x54,
+	0x62,
+	0x69,
+	0x70,
+	0x77,
+	0x79,
+	0x7B,
+	0x7D,
+	0x7E,
+	0x02,
+	0x04,
+	0x00,
+	0x04,
+	0x00,
+	0x0D,
+	0x3E,
+	0x0E,
+	0x3C,
+	0x1F,
+	0x3A,
+	0x1F,
+	0x38,
+	0x1F,
+	0x78,
+	0x18,
+	0x78,
+	0x19,
+	0x76,
+	0x1A,
+	0x76,
+	0x1B,
+	0x74,
+	0x2C,
+	0x74,
+	0x2D,
+	0x74,
+	0x3D,
+	0x74,
+	0x6F,
+	0x00,
+	0x08,
+	0x11,
+	0x1A,
+	0x23,
+	0x2C,
+	0x2D,
+	0x3E,
+	0x10,
+	0x22,
+	0x33,
+	0x44,
+	0x55,
+	0x66,
+	0x87,
+	0x88,
+	0x4F,
+	0xF5,
+	0xFC,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFD,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x4B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0A,
+	0x14,
+	0x28,
+	0x35,
+	0x49,
+	0x58,
+	0x65,
+	0x74,
+	0x81,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x10,
+	0x1C,
+	0x27,
+	0x35,
+	0x4C,
+	0x5C,
+	0x6D,
+	0x7D,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x08,
+	0x16,
+	0x20,
+	0x2B,
+	0x46,
+	0x57,
+	0x69,
+	0x7B,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x02,
+	0x08,
+	0x10,
+	0x18,
+	0x20,
+	0x40,
+	0x52,
+	0x65,
+	0x79,
+	0x9D,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x05,
+	0x10,
+	0x18,
+	0x20,
+	0x38,
+	0x4F,
+	0x63,
+	0x76,
+	0x9C,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x04,
+	0x10,
+	0x18,
+	0x20,
+	0x30,
+	0x4B,
+	0x60,
+	0x73,
+	0x9B,
+	0xBA,
+	0xD6,
+	0xF1,
+	0xFD,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x18,
+	0x20,
+	0x30,
+	0x40,
+	0x5B,
+	0x70,
+	0x98,
+	0xB9,
+	0xD6,
+	0xF1,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x07,
+	0x12,
+	0x15,
+	0x30,
+	0x40,
+	0x50,
+	0x6B,
+	0x94,
+	0xB7,
+	0xD5,
+	0xF0,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x06,
+	0x0E,
+	0x11,
+	0x22,
+	0x40,
+	0x50,
+	0x60,
+	0x8F,
+	0xB3,
+	0xD3,
+	0xF0,
+	0xFB,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x0B,
+	0x0D,
+	0x11,
+	0x34,
+	0x50,
+	0x60,
+	0x8B,
+	0xB0,
+	0xD1,
+	0xEE,
+	0xFA,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x0A,
+	0x0D,
+	0x2C,
+	0x3C,
+	0x55,
+	0x80,
+	0xA8,
+	0xCB,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x06,
+	0x07,
+	0x0B,
+	0x24,
+	0x35,
+	0x4E,
+	0x77,
+	0xA0,
+	0xC6,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x05,
+	0x06,
+	0x09,
+	0x1C,
+	0x2E,
+	0x47,
+	0x6D,
+	0x98,
+	0xC0,
+	0xE3,
+	0xF3,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x08,
+	0x17,
+	0x27,
+	0x41,
+	0x67,
+	0x91,
+	0xC0,
+	0xE0,
+	0xF0,
+	0xFF,
+	0x00,
+	0x01,
+	0x01,
+	0x02,
+	0x04,
+	0x05,
+	0x07,
+	0x13,
+	0x24,
+	0x3B,
+	0x69,
+	0x95,
+	0xB9,
+	0xE0,
+	0xF0,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x01,
+	0x04,
+	0x04,
+	0x07,
+	0x0C,
+	0x1D,
+	0x32,
+	0x67,
+	0x91,
+	0xB7,
+	0xDA,
+	0xF0,
+	0x00,
+	0x00,
+	0x0A,
+	0x14,
+	0x28,
+	0x35,
+	0x49,
+	0x58,
+	0x65,
+	0x74,
+	0x81,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x10,
+	0x1C,
+	0x27,
+	0x35,
+	0x4C,
+	0x5C,
+	0x6D,
+	0x7D,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x08,
+	0x16,
+	0x20,
+	0x2B,
+	0x46,
+	0x57,
+	0x69,
+	0x7B,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x02,
+	0x08,
+	0x10,
+	0x18,
+	0x20,
+	0x40,
+	0x52,
+	0x65,
+	0x79,
+	0x9D,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x05,
+	0x10,
+	0x18,
+	0x20,
+	0x38,
+	0x4F,
+	0x63,
+	0x76,
+	0x9C,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x04,
+	0x10,
+	0x18,
+	0x20,
+	0x30,
+	0x4B,
+	0x60,
+	0x73,
+	0x9B,
+	0xBA,
+	0xD6,
+	0xF1,
+	0xFD,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x18,
+	0x20,
+	0x30,
+	0x40,
+	0x5B,
+	0x70,
+	0x98,
+	0xB9,
+	0xD6,
+	0xF1,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x07,
+	0x12,
+	0x15,
+	0x30,
+	0x40,
+	0x50,
+	0x6B,
+	0x94,
+	0xB7,
+	0xD5,
+	0xF0,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x06,
+	0x0E,
+	0x11,
+	0x22,
+	0x40,
+	0x50,
+	0x60,
+	0x8F,
+	0xB3,
+	0xD3,
+	0xF0,
+	0xFB,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x0B,
+	0x0D,
+	0x11,
+	0x34,
+	0x50,
+	0x60,
+	0x8B,
+	0xB0,
+	0xD1,
+	0xEE,
+	0xFA,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x0A,
+	0x0D,
+	0x2C,
+	0x3C,
+	0x55,
+	0x80,
+	0xA8,
+	0xCB,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x06,
+	0x07,
+	0x0B,
+	0x24,
+	0x35,
+	0x4E,
+	0x77,
+	0xA0,
+	0xC6,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x05,
+	0x06,
+	0x09,
+	0x1C,
+	0x2E,
+	0x47,
+	0x6D,
+	0x98,
+	0xC0,
+	0xE3,
+	0xF3,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x08,
+	0x17,
+	0x27,
+	0x41,
+	0x67,
+	0x91,
+	0xC0,
+	0xE0,
+	0xF0,
+	0xFF,
+	0x00,
+	0x01,
+	0x01,
+	0x02,
+	0x04,
+	0x05,
+	0x07,
+	0x13,
+	0x24,
+	0x3B,
+	0x69,
+	0x95,
+	0xB9,
+	0xE0,
+	0xF0,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x01,
+	0x04,
+	0x04,
+	0x07,
+	0x0C,
+	0x1D,
+	0x32,
+	0x67,
+	0x91,
+	0xB7,
+	0xDA,
+	0xF0,
+	0x00,
+	0x00,
+	0x0A,
+	0x14,
+	0x28,
+	0x35,
+	0x49,
+	0x58,
+	0x65,
+	0x74,
+	0x81,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x10,
+	0x1C,
+	0x27,
+	0x35,
+	0x4C,
+	0x5C,
+	0x6D,
+	0x7D,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x04,
+	0x08,
+	0x16,
+	0x20,
+	0x2B,
+	0x46,
+	0x57,
+	0x69,
+	0x7B,
+	0x9E,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFF,
+	0xFF,
+	0x00,
+	0x02,
+	0x08,
+	0x10,
+	0x18,
+	0x20,
+	0x40,
+	0x52,
+	0x65,
+	0x79,
+	0x9D,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x05,
+	0x10,
+	0x18,
+	0x20,
+	0x38,
+	0x4F,
+	0x63,
+	0x76,
+	0x9C,
+	0xBB,
+	0xD7,
+	0xF1,
+	0xFE,
+	0xFF,
+	0x00,
+	0x02,
+	0x04,
+	0x10,
+	0x18,
+	0x20,
+	0x30,
+	0x4B,
+	0x60,
+	0x73,
+	0x9B,
+	0xBA,
+	0xD6,
+	0xF1,
+	0xFD,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x18,
+	0x20,
+	0x30,
+	0x40,
+	0x5B,
+	0x70,
+	0x98,
+	0xB9,
+	0xD6,
+	0xF1,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x07,
+	0x12,
+	0x15,
+	0x30,
+	0x40,
+	0x50,
+	0x6B,
+	0x94,
+	0xB7,
+	0xD5,
+	0xF0,
+	0xFC,
+	0xFF,
+	0x00,
+	0x01,
+	0x03,
+	0x06,
+	0x0E,
+	0x11,
+	0x22,
+	0x40,
+	0x50,
+	0x60,
+	0x8F,
+	0xB3,
+	0xD3,
+	0xF0,
+	0xFB,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x0B,
+	0x0D,
+	0x11,
+	0x34,
+	0x50,
+	0x60,
+	0x8B,
+	0xB0,
+	0xD1,
+	0xEE,
+	0xFA,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x0A,
+	0x0D,
+	0x2C,
+	0x3C,
+	0x55,
+	0x80,
+	0xA8,
+	0xCB,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x06,
+	0x07,
+	0x0B,
+	0x24,
+	0x35,
+	0x4E,
+	0x77,
+	0xA0,
+	0xC6,
+	0xE7,
+	0xF7,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x05,
+	0x06,
+	0x09,
+	0x1C,
+	0x2E,
+	0x47,
+	0x6D,
+	0x98,
+	0xC0,
+	0xE3,
+	0xF3,
+	0xFF,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x08,
+	0x17,
+	0x27,
+	0x41,
+	0x67,
+	0x91,
+	0xC0,
+	0xE0,
+	0xF0,
+	0xFF,
+	0x00,
+	0x01,
+	0x01,
+	0x02,
+	0x04,
+	0x05,
+	0x07,
+	0x13,
+	0x24,
+	0x3B,
+	0x69,
+	0x95,
+	0xB9,
+	0xE0,
+	0xF0,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x01,
+	0x04,
+	0x04,
+	0x07,
+	0x0C,
+	0x1D,
+	0x32,
+	0x67,
+	0x91,
+	0xB7,
+	0xDA,
+	0xF0,
+	0x00,
+	0xDE,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x43,
+	0xE3,
+};/*end of boe fhd goa n10*/
+
+
+static unsigned char uhd_tcon_setting_ceds_3840x2160[] = {
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0x00,
+	0x00,
+	0x07,
+	0x00,
+	0xFF,
+	0x00,
+	0x07,
+	0x00,
+	0x00,
+	0xFF,
+	0x07,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x07,
+	0x7F,
+	0x7F,
+	0x7F,
+	0x07,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x63,
+	0x22,
+	0x51,
+	0xB0,
+	0x2D,
+	0x05,
+	0xA0,
+	0x50,
+	0x0A,
+	0x00,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x19,
+	0x00,
+	0x32,
+	0x01,
+	0x00,
+	0x05,
+	0x00,
+	0x12,
+	0x80,
+	0x0E,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x66,
+	0x66,
+	0x66,
+	0x66,
+	0x65,
+	0x66,
+	0x66,
+	0x66,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0D,
+	0x00,
+	0x07,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x55,
+	0x03,
+	0x80,
+	0x03,
+	0x28,
+	0x05,
+	0x00,
+	0x00,
+	0x28,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0B,
+	0x50,
+	0x1A,
+	0x70,
+	0x34,
+	0x00,
+	0x44,
+	0x00,
+	0x47,
+	0xF0,
+	0x48,
+	0x50,
+	0x4C,
+	0xE0,
+	0xB4,
+	0x33,
+	0x00,
+	0x3B,
+	0x00,
+	0x06,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x52,
+	0xF0,
+	0x54,
+	0x00,
+	0x55,
+	0x10,
+	0x5C,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE8,
+	0x01,
+	0x5A,
+	0x00,
+	0x2A,
+	0xE8,
+	0x00,
+	0x02,
+	0x00,
+	0x02,
+	0x3D,
+	0xA3,
+	0xC2,
+	0x33,
+	0x82,
+	0xCA,
+	0x28,
+	0xC2,
+	0x2D,
+	0x22,
+	0xB1,
+	0xFB,
+	0x1F,
+	0xA1,
+	0x56,
+	0x11,
+	0x90,
+	0xBD,
+	0x02,
+	0xD0,
+	0x14,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x06,
+	0x3B,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x9F,
+	0x3B,
+	0x02,
+	0x00,
+	0x00,
+	0x53,
+	0x42,
+	0x31,
+	0x37,
+	0x30,
+	0x32,
+	0x38,
+	0xC2,
+	0x28,
+	0x15,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x05,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x13,
+	0x00,
+	0x1E,
+	0x00,
+	0x00,
+	0x71,
+	0x00,
+	0x3F,
+	0x00,
+	0x00,
+	0x00,
+	0x3F,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x3F,
+	0x00,
+	0x00,
+	0x00,
+	0x2A,
+	0x58,
+	0x58,
+	0x58,
+	0x2A,
+	0xC8,
+	0xC8,
+	0xC8,
+	0x2A,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xCC,
+	0xCC,
+	0xCC,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x7F,
+	0x7F,
+	0x7F,
+	0x00,
+	0x3F,
+	0x3F,
+	0x3F,
+	0x15,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x3F,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x1F,
+	0x1F,
+	0x1F,
+	0xFF,
+	0x7F,
+	0x3F,
+	0x00,
+	0x00,
+	0x00,
+	0x46,
+	0x20,
+	0x00,
+	0xFF,
+	0x0C,
+	0xFF,
+	0x8F,
+	0x70,
+	0x76,
+	0x08,
+	0xFC,
+	0x40,
+	0x4C,
+	0x96,
+	0xCC,
+	0x01,
+	0xFF,
+	0x0A,
+	0x0A,
+	0x0A,
+	0x0C,
+	0x15,
+	0x47,
+	0x80,
+	0x08,
+	0x70,
+	0x29,
+	0xC4,
+	0x08,
+	0x98,
+	0x08,
+	0x98,
+	0x08,
+	0x98,
+	0x89,
+	0x00,
+	0x0A,
+	0x00,
+	0x08,
+	0x05,
+	0xDC,
+	0x05,
+	0x00,
+	0x0A,
+	0x3F,
+	0x1B,
+	0x0F,
+	0x1B,
+	0x00,
+	0x05,
+	0x03,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x02,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x15,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x7F,
+	0xFF,
+	0xFF,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x02,
+	0x00,
+	0x00,
+	0x00,
+	0x02,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x32,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x14,
+	0x10,
+	0x32,
+	0x54,
+	0x10,
+	0x32,
+	0x54,
+	0x00,
+	0x00,
+	0x00,
+	0x28,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x30,
+	0xE8,
+	0xFC,
+	0x03,
+	0x21,
+	0x49,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x04,
+	0x20,
+	0xA0,
+	0x86,
+	0x01,
+	0x00,
+	0xA0,
+	0x86,
+	0x01,
+	0xD0,
+	0x38,
+	0x34,
+	0xC0,
+	0x38,
+	0x74,
+	0x01,
+	0xA0,
+	0xC7,
+	0x11,
+	0xC7,
+	0x27,
+	0x10,
+	0x20,
+	0xA0,
+	0xFF,
+	0x11,
+	0xFF,
+	0x0E,
+	0x10,
+	0x20,
+	0xA0,
+	0x38,
+	0x01,
+	0xC0,
+	0xA7,
+	0xF8,
+	0x20,
+	0xA0,
+	0x3F,
+	0x00,
+	0x3F,
+	0x3E,
+	0x80,
+	0x20,
+	0xA0,
+	0x07,
+	0x00,
+	0x07,
+	0x0B,
+	0xB8,
+	0x20,
+	0xE0,
+	0x07,
+	0x00,
+	0x07,
+	0x05,
+	0x14,
+	0x20,
+	0x20,
+	0xCC,
+	0xCC,
+	0xCC,
+	0xFD,
+	0xE8,
+	0x20,
+	0x21,
+	0xC7,
+	0x10,
+	0x00,
+	0x03,
+	0xE8,
+	0x20,
+	0x80,
+	0xC7,
+	0x11,
+	0xC7,
+	0x27,
+	0x10,
+	0x20,
+	0x20,
+	0xC7,
+	0x11,
+	0xC7,
+	0x27,
+	0x10,
+	0x20,
+	0xA0,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x34,
+	0x50,
+	0xFF,
+	0x30,
+	0xC7,
+	0x01,
+	0x10,
+	0x27,
+	0x02,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0xC7,
+	0x01,
+	0xC7,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x01,
+	0xC7,
+	0x27,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x20,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x02,
+	0x03,
+	0x00,
+	0x04,
+	0x05,
+	0x00,
+	0x06,
+	0x07,
+	0x00,
+	0x08,
+	0x09,
+	0x00,
+	0x0A,
+	0x0B,
+	0x00,
+	0x0C,
+	0x0D,
+	0x00,
+	0x0E,
+	0x0F,
+	0x00,
+	0x10,
+	0x11,
+	0x00,
+	0x12,
+	0x13,
+	0x00,
+	0x14,
+	0x15,
+	0x00,
+	0x16,
+	0x17,
+	0x00,
+	0x18,
+	0x19,
+	0x00,
+	0x1A,
+	0x1B,
+	0x00,
+	0x1C,
+	0x1D,
+	0x00,
+	0x1E,
+	0x1F,
+	0x00,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x8B,
+	0x33,
+	0xE1,
+	0x11,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x44,
+	0x01,
+	0x90,
+	0x04,
+	0xC0,
+	0x0B,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0F,
+	0xFF,
+	0x03,
+	0x14,
+	0x01,
+	0x41,
+	0x00,
+	0xA0,
+	0x00,
+	0xD6,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x80,
+	0x80,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x30,
+	0xC2,
+	0x08,
+	0x08,
+	0x00,
+	0x08,
+	0x08,
+	0x00,
+	0x54,
+	0xAA,
+	0x55,
+	0x82,
+	0xFC,
+	0x00,
+	0x0E,
+	0x00,
+	0x80,
+	0x00,
+	0x08,
+	0x07,
+	0x80,
+	0x07,
+	0x80,
+	0x0E,
+	0x00,
+	0x20,
+	0x01,
+	0x1E,
+	0xF0,
+	0x1A,
+	0x00,
+	0x0C,
+	0x0D,
+	0xB7,
+	0x03,
+	0x94,
+	0x18,
+	0x00,
+	0x10,
+	0xF0,
+	0x07,
+	0x80,
+	0x20,
+	0x00,
+	0x66,
+	0x0B,
+	0x0B,
+	0x33,
+	0x0E,
+	0x1C,
+	0x2A,
+	0x38,
+	0x46,
+	0x54,
+	0x62,
+	0x69,
+	0x70,
+	0x77,
+	0x79,
+	0x7B,
+	0x7D,
+	0x7E,
+	0x02,
+	0x04,
+	0x00,
+	0x04,
+	0x00,
+	0x0D,
+	0x3E,
+	0x0E,
+	0x3C,
+	0x1F,
+	0x3A,
+	0x1F,
+	0x38,
+	0x1F,
+	0x78,
+	0x18,
+	0x78,
+	0x19,
+	0x76,
+	0x1A,
+	0x76,
+	0x1B,
+	0x74,
+	0x2C,
+	0x74,
+	0x2D,
+	0x74,
+	0x3D,
+	0x74,
+	0x6F,
+	0x00,
+	0x08,
+	0x11,
+	0x1A,
+	0x23,
+	0x2C,
+	0x2D,
+	0x3E,
+	0x10,
+	0x22,
+	0x33,
+	0x44,
+	0x55,
+	0x66,
+	0x87,
+	0x88,
+	0xCA,
+	0xF5,
+	0xF0,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x80,
+	0x80,
+	0x00,
+	0x08,
+	0x07,
+	0x80,
+	0x07,
+	0x80,
+	0x82,
+	0x00,
+	0x01,
+	0x1E,
+	0x60,
+	0x1A,
+	0x0C,
+	0x0D,
+	0xB7,
+	0x03,
+	0x94,
+	0x18,
+	0x00,
+	0x10,
+	0xF0,
+	0x20,
+	0x00,
+	0x0B,
+	0x0B,
+	0x33,
+	0x0E,
+	0x1C,
+	0x2A,
+	0x38,
+	0x46,
+	0x54,
+	0x62,
+	0x69,
+	0x70,
+	0x77,
+	0x79,
+	0x7B,
+	0x7D,
+	0x7E,
+	0x02,
+	0x20,
+	0x00,
+	0x20,
+	0x00,
+	0x29,
+	0x3E,
+	0x31,
+	0x3C,
+	0x3B,
+	0x3A,
+	0x3B,
+	0x38,
+	0x3B,
+	0x38,
+	0x43,
+	0x38,
+	0x4B,
+	0x36,
+	0x53,
+	0x36,
+	0x5B,
+	0x34,
+	0x65,
+	0x34,
+	0x6D,
+	0x34,
+	0x6F,
+	0x74,
+	0x7D,
+	0x10,
+	0x22,
+	0x33,
+	0x44,
+	0x55,
+	0x66,
+	0x87,
+	0x88,
+	0x00,
+	0x10,
+	0x21,
+	0x32,
+	0x43,
+	0x54,
+	0x55,
+	0x76,
+	0x5A,
+	0x04,
+	0x28,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x07,
+	0x80,
+	0x70,
+	0x00,
+	0x00,
+	0x00,
+	0x80,
+	0xAA,
+	0x54,
+	0x46,
+	0xAA,
+	0x65,
+	0x54,
+	0xAA,
+	0x46,
+	0x65,
+	0xAA,
+	0x54,
+	0x46,
+	0xAA,
+	0x65,
+	0x54,
+	0xAA,
+	0x46,
+	0x65,
+	0xAA,
+	0x54,
+	0x46,
+	0xAA,
+	0x65,
+	0x54,
+	0xAA,
+	0x46,
+	0x65,
+	0xAA,
+	0x54,
+	0x46,
+	0xAA,
+	0x65,
+	0x54,
+	0xAA,
+	0x46,
+	0x65,
+	0xAA,
+	0x87,
+	0x79,
+	0xAA,
+	0x98,
+	0x87,
+	0xAA,
+	0x79,
+	0x98,
+	0xAA,
+	0x87,
+	0x79,
+	0xAA,
+	0x98,
+	0x87,
+	0xAA,
+	0x79,
+	0x98,
+	0xAA,
+	0x87,
+	0x79,
+	0xAA,
+	0x98,
+	0x87,
+	0xAA,
+	0x79,
+	0x98,
+	0xAA,
+	0x87,
+	0x79,
+	0xAA,
+	0x98,
+	0x87,
+	0xAA,
+	0x79,
+	0x98,
+	0x4E,
+	0xA0,
+	0x00,
+	0x07,
+	0x04,
+	0x0B,
+	0x33,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x19,
+	0x0A,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x1A,
+	0x10,
+	0x28,
+	0x10,
+	0xE0,
+	0x21,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x50,
+	0xA5,
+	0x2D,
+	0x36,
+	0x2D,
+	0x36,
+	0x18,
+	0x00,
+	0x00,
+	0xD5,
+	0x5E,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0A,
+	0x00,
+	0x00,
+	0xCC,
+	0x99,
+	0x33,
+	0x44,
+	0x66,
+	0x88,
+	0x11,
+	0x33,
+	0x55,
+	0x00,
+	0x00,
+	0x00,
+	0xAA,
+	0xCC,
+	0xEE,
+	0x77,
+	0x99,
+	0xBB,
+	0x00,
+	0x00,
+	0x00,
+	0x88,
+	0xAA,
+	0xCC,
+	0x55,
+	0x77,
+	0x99,
+	0x00,
+	0x00,
+	0x00,
+	0xEE,
+	0x00,
+	0x22,
+	0xBB,
+	0xDD,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x66,
+	0x66,
+	0x66,
+	0xBB,
+	0xBB,
+	0xBB,
+	0x00,
+	0x00,
+	0x00,
+	0x66,
+	0xAA,
+	0xAA,
+	0xBB,
+	0xBB,
+	0xBB,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xC2,
+	0x22,
+	0x82,
+	0xE2,
+	0x42,
+	0xA2,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x6F,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x04,
+	0x00,
+	0x00,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x05,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xD0,
+	0x00,
+	0x00,
+	0x00,
+	0xEF,
+	0xDF,
+	0xBF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x10,
+	0x32,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x64,
+	0x64,
+	0x64,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x65,
+	0xC2,
+	0x20,
+	0x10,
+	0xE0,
+	0x00,
+	0x04,
+	0x13,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3F,
+	0xFF,
+	0x00,
+	0x00,
+	0x3F,
+	0xFF,
+	0x00,
+	0x00,
+	0x3F,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x04,
+	0x29,
+	0x00,
+	0x00,
+	0x08,
+	0x88,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x00,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xB9,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x05,
+	0x00,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xB0,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x80,
+	0x8C,
+	0x00,
+	0x9B,
+	0x9B,
+	0x00,
+	0x9B,
+	0x9B,
+	0x00,
+	0x9B,
+	0x9B,
+	0x00,
+	0x9B,
+	0x9B,
+	0x00,
+	0x9B,
+	0x9B,
+	0x00,
+	0x9B,
+	0x9B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3E,
+	0x3E,
+	0x00,
+	0x3E,
+	0x3E,
+	0x00,
+	0x3E,
+	0x3E,
+	0x00,
+	0x3E,
+	0x3E,
+	0x00,
+	0x3E,
+	0x3E,
+	0x00,
+	0x3E,
+	0x3E,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x64,
+	0x08,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x00,
+	0x01,
+	0x01,
+	0x00,
+	0x01,
+	0x01,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x4E,
+	0x1E,
+	0xE6,
+	0xEE,
+	0x81,
+	0x7E,
+	0x00,
+	0x00,
+	0x33,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x1E,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0A,
+	0x0A,
+	0x14,
+	0x69,
+	0xFA,
+	0x04,
+	0x06,
+	0xF8,
+	0xAA,
+	0xA8,
+	0xE0,
+	0x70,
+	0x38,
+	0xEA,
+	0xEB,
+	0xEC,
+	0xED,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x02,
+	0x03,
+	0x00,
+	0x04,
+	0x05,
+	0x00,
+	0x06,
+	0x07,
+	0x00,
+	0x00,
+	0x08,
+	0x09,
+	0x00,
+	0x0A,
+	0x0B,
+	0x03,
+	0x04,
+	0x05,
+	0x06,
+	0x07,
+	0x08,
+	0x09,
+	0x0A,
+	0x0B,
+	0x0C,
+	0x0D,
+	0x8E,
+	0x1E,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0C,
+	0x00,
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x06,
+	0x07,
+	0x08,
+	0x09,
+	0x0A,
+	0x0B,
+	0x0C,
+	0x0D,
+	0x0E,
+	0x0F,
+	0x10,
+	0x11,
+	0x12,
+	0x13,
+	0x14,
+	0x15,
+	0x16,
+	0x17,
+	0x18,
+	0x19,
+	0x1A,
+	0x1B,
+	0x1C,
+	0x1D,
+	0x1E,
+	0x1F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x32,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0xA8,
+	0x00,
+	0xC4,
+	0x09,
+	0x03,
+	0x03,
+	0x7C,
+	0x13,
+	0x23,
+	0x33,
+	0x43,
+	0x53,
+	0x63,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x98,
+	0x3A,
+	0x31,
+	0x2F,
+	0x07,
+	0x27,
+	0x01,
+	0x00,
+	0x48,
+	0x00,
+	0x00,
+	0x49,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x70,
+	0x57,
+	0x30,
+	0x0A,
+	0x00,
+	0x11,
+	0x22,
+	0x33,
+	0x44,
+	0x55,
+	0x00,
+	0x00,
+	0xFF,
+	0x00,
+	0xFA,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x44,
+	0x01,
+	0x89,
+	0x20,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x99,
+	0x30,
+	0x01,
+	0x00,
+	0x06,
+	0x20,
+	0x11,
+	0x40,
+	0xE1,
+	0x15,
+	0x24,
+	0x01,
+	0x08,
+	0x80,
+	0x01,
+	0x00,
+	0x01,
+	0x80,
+	0x01,
+	0x0A,
+	0x00,
+	0x14,
+	0x24,
+	0x01,
+	0x01,
+	0x10,
+	0x01,
+	0x0A,
+	0x08,
+	0x01,
+	0x11,
+	0x40,
+	0x01,
+	0x14,
+	0x44,
+	0x01,
+	0x09,
+	0x40,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x19,
+	0x50,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x29,
+	0x60,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x39,
+	0x70,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x49,
+	0x80,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x59,
+	0x90,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x69,
+	0x00,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x44,
+	0x01,
+	0x79,
+	0x10,
+	0x01,
+	0x00,
+	0x06,
+	0xA0,
+	0x10,
+	0x40,
+	0xE1,
+	0x15,
+	0x20,
+	0x0C,
+	0x00,
+	0x00,
+	0xB4,
+	0x00,
+	0x1C,
+	0xF1,
+	0xFF,
+	0x64,
+	0x00,
+	0x00,
+	0x31,
+	0x0C,
+	0x00,
+	0x00,
+	0xB4,
+	0x00,
+	0x1C,
+	0xF1,
+	0xFF,
+	0x64,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x01,
+	0x00,
+	0x87,
+	0x32,
+	0x20,
+	0x03,
+	0x20,
+	0x30,
+	0xC0,
+	0xD0,
+	0x40,
+	0x50,
+	0x60,
+	0x70,
+	0x80,
+	0x90,
+	0xA0,
+	0xB0,
+	0x00,
+	0x10,
+	0xE0,
+	0xF0,
+	0x4F,
+	0x50,
+	0x61,
+	0xFF,
+	0x7F,
+	0x8F,
+	0x92,
+	0x13,
+	0x00,
+	0x0D,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x88,
+	0xA0,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x22,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0xF4,
+	0x00,
+	0x00,
+	0x00,
+	0x37,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x9D,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x20,
+	0x00,
+	0x03,
+	0x40,
+	0x00,
+	0x05,
+	0x60,
+	0x00,
+	0x07,
+	0x80,
+	0x00,
+	0x09,
+	0xA0,
+	0x00,
+	0x0B,
+	0xC0,
+	0x00,
+	0x0D,
+	0xE0,
+	0x00,
+	0x0F,
+	0x00,
+	0x01,
+	0x11,
+	0x20,
+	0x01,
+	0x13,
+	0x40,
+	0x01,
+	0x15,
+	0x60,
+	0x01,
+	0x17,
+	0x80,
+	0x01,
+	0x19,
+	0xA0,
+	0x01,
+	0x1B,
+	0xC0,
+	0x01,
+	0x1D,
+	0xE0,
+	0x01,
+	0x1F,
+	0x00,
+	0x02,
+	0x21,
+	0x20,
+	0x02,
+	0x23,
+	0x40,
+	0x02,
+	0x25,
+	0x60,
+	0x02,
+	0x27,
+	0x80,
+	0x02,
+	0x29,
+	0xA0,
+	0x02,
+	0x2B,
+	0xC0,
+	0x02,
+	0x2D,
+	0xE0,
+	0x02,
+	0x2F,
+	0x00,
+	0x03,
+	0x31,
+	0x20,
+	0x03,
+	0x33,
+	0x40,
+	0x03,
+	0x35,
+	0x60,
+	0x03,
+	0x37,
+	0x80,
+	0x03,
+	0x39,
+	0xA0,
+	0x03,
+	0x3B,
+	0xC0,
+	0x03,
+	0x3D,
+	0xE0,
+	0x03,
+	0x3F,
+	0x00,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0x04,
+	0x47,
+	0x80,
+	0x04,
+	0x49,
+	0xA0,
+	0x04,
+	0x4B,
+	0xC0,
+	0x04,
+	0x4D,
+	0xE0,
+	0x04,
+	0x4F,
+	0x00,
+	0x05,
+	0x51,
+	0x20,
+	0x05,
+	0x53,
+	0x40,
+	0x05,
+	0x55,
+	0x60,
+	0x05,
+	0x57,
+	0x80,
+	0x05,
+	0x59,
+	0xA0,
+	0x05,
+	0x5B,
+	0xC0,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x06,
+	0x63,
+	0x40,
+	0x06,
+	0x65,
+	0x60,
+	0x06,
+	0x67,
+	0x80,
+	0x06,
+	0x69,
+	0xA0,
+	0x06,
+	0x6B,
+	0xC0,
+	0x06,
+	0x6D,
+	0xE0,
+	0x06,
+	0x6F,
+	0x00,
+	0x07,
+	0x71,
+	0x20,
+	0x07,
+	0x73,
+	0x40,
+	0x07,
+	0x75,
+	0x60,
+	0x07,
+	0x77,
+	0x80,
+	0x07,
+	0x79,
+	0xA0,
+	0x07,
+	0x7B,
+	0xC0,
+	0x07,
+	0x7D,
+	0xE0,
+	0x07,
+	0x7F,
+	0x00,
+	0x08,
+	0x81,
+	0x20,
+	0x08,
+	0x83,
+	0x40,
+	0x08,
+	0x85,
+	0x60,
+	0x08,
+	0x87,
+	0x80,
+	0x08,
+	0x89,
+	0xA0,
+	0x08,
+	0x8B,
+	0xC0,
+	0x08,
+	0x8D,
+	0xE0,
+	0x08,
+	0x8F,
+	0x00,
+	0x09,
+	0x91,
+	0x20,
+	0x09,
+	0x93,
+	0x40,
+	0x09,
+	0x95,
+	0x60,
+	0x09,
+	0x97,
+	0x80,
+	0x09,
+	0x99,
+	0xA0,
+	0x09,
+	0x9B,
+	0xC0,
+	0x09,
+	0x9D,
+	0xE0,
+	0x09,
+	0x9F,
+	0x00,
+	0x0A,
+	0xA1,
+	0x20,
+	0x0A,
+	0xA3,
+	0x40,
+	0x0A,
+	0xA5,
+	0x60,
+	0x0A,
+	0xA7,
+	0x80,
+	0x0A,
+	0xA9,
+	0xA0,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x0A,
+	0xAD,
+	0xE0,
+	0x0A,
+	0xAF,
+	0x00,
+	0x0B,
+	0xB1,
+	0x20,
+	0x0B,
+	0xB3,
+	0x40,
+	0x0B,
+	0xB5,
+	0x60,
+	0x0B,
+	0xB7,
+	0x80,
+	0x0B,
+	0xB9,
+	0xA0,
+	0x0B,
+	0xBB,
+	0xC0,
+	0x0B,
+	0xBD,
+	0xE0,
+	0x0B,
+	0xBF,
+	0x00,
+	0x0C,
+	0xC1,
+	0x20,
+	0x0C,
+	0xC3,
+	0x40,
+	0x0C,
+	0xC5,
+	0x60,
+	0x0C,
+	0xC7,
+	0x80,
+	0x0C,
+	0xC9,
+	0xA0,
+	0x0C,
+	0xCB,
+	0xC0,
+	0x0C,
+	0xCD,
+	0xE0,
+	0x0C,
+	0xCF,
+	0x00,
+	0x0D,
+	0xD1,
+	0x20,
+	0x0D,
+	0xD3,
+	0x40,
+	0x0D,
+	0xD5,
+	0x60,
+	0x0D,
+	0xD7,
+	0x80,
+	0x0D,
+	0xD9,
+	0xA0,
+	0x0D,
+	0xDB,
+	0xC0,
+	0x0D,
+	0xDD,
+	0xE0,
+	0x0D,
+	0xDF,
+	0x00,
+	0x0E,
+	0xE1,
+	0x20,
+	0x0E,
+	0xE3,
+	0x40,
+	0x0E,
+	0xE5,
+	0x60,
+	0x0E,
+	0xE7,
+	0x80,
+	0x0E,
+	0xE9,
+	0xA0,
+	0x0E,
+	0xEB,
+	0xC0,
+	0x0E,
+	0xED,
+	0xE0,
+	0x0E,
+	0xEF,
+	0x00,
+	0x0F,
+	0xF1,
+	0x20,
+	0x0F,
+	0xF3,
+	0x40,
+	0x0F,
+	0xF5,
+	0x60,
+	0x0F,
+	0xF7,
+	0x80,
+	0x0F,
+	0xF9,
+	0xA0,
+	0x0F,
+	0xFB,
+	0xC0,
+	0x0F,
+	0xFD,
+	0xE0,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0xF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x08,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x10,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x18,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x20,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x28,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x30,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x38,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x40,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x48,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x50,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x58,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x60,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x68,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x70,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x78,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x80,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x88,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x90,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0x98,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA0,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xA8,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB0,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xB8,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC0,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xC8,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xD8,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE0,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xE8,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF0,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF6,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xD3,
+	0x4F,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFD,
+	0xF0,
+	0xB3,
+	0x8F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0xB3,
+	0x0F,
+	0x3F,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x0F,
+	0x3F,
+	0xFB,
+	0xE8,
+	0x93,
+	0x0F,
+	0x3E,
+	0xF7,
+	0xD8,
+	0x63,
+	0x8F,
+	0x3D,
+	0xF6,
+	0xD8,
+	0x63,
+	0x8F,
+	0x3D,
+	0xF6,
+	0xD8,
+	0x63,
+	0x8F,
+	0x3D,
+	0xF6,
+	0xD8,
+	0x63,
+	0x8F,
+	0x3D,
+	0xF6,
+	0xD8,
+	0x63,
+	0x8F,
+	0x3E,
+	0xFB,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFD,
+	0xF0,
+	0xB3,
+	0x8F,
+	0x3E,
+	0xF9,
+	0xE0,
+	0x73,
+	0x8F,
+	0x3D,
+	0xF5,
+	0xD0,
+	0x43,
+	0x0F,
+	0x3D,
+	0xF4,
+	0xD0,
+	0x43,
+	0x0F,
+	0x3D,
+	0xF4,
+	0xD0,
+	0x43,
+	0x0F,
+	0x3D,
+	0xF4,
+	0xD0,
+	0x43,
+	0x0F,
+	0x3D,
+	0xF9,
+	0xE8,
+	0x43,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x0F,
+	0x3F,
+	0xFB,
+	0xE8,
+	0x93,
+	0x0F,
+	0x3E,
+	0xF7,
+	0xD8,
+	0x53,
+	0x0F,
+	0x3D,
+	0xF3,
+	0xC8,
+	0x23,
+	0x8F,
+	0x3C,
+	0xF2,
+	0xC8,
+	0x23,
+	0x8F,
+	0x3C,
+	0xF2,
+	0xC8,
+	0x23,
+	0x8F,
+	0x3C,
+	0xF2,
+	0xE0,
+	0x93,
+	0x4F,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFD,
+	0xF0,
+	0xB3,
+	0x8F,
+	0x3E,
+	0xF9,
+	0xE0,
+	0x73,
+	0x8F,
+	0x3D,
+	0xF5,
+	0xD0,
+	0x33,
+	0x8F,
+	0x3C,
+	0xF1,
+	0xC4,
+	0x13,
+	0x4F,
+	0x3C,
+	0xF1,
+	0xC4,
+	0x13,
+	0x4F,
+	0x3C,
+	0xF1,
+	0xC4,
+	0x73,
+	0x0F,
+	0x3E,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x0F,
+	0x3F,
+	0xFB,
+	0xE8,
+	0x93,
+	0x0F,
+	0x3E,
+	0xF7,
+	0xD8,
+	0x53,
+	0x0F,
+	0x3D,
+	0xF3,
+	0xC8,
+	0x13,
+	0x0F,
+	0x3C,
+	0xF0,
+	0xC0,
+	0x03,
+	0x0F,
+	0x3C,
+	0xF0,
+	0xC0,
+	0x03,
+	0x8F,
+	0x3D,
+	0xF7,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFD,
+	0xF0,
+	0xB3,
+	0x8F,
+	0x3E,
+	0xF9,
+	0xE0,
+	0x73,
+	0x8F,
+	0x3D,
+	0xF5,
+	0xD0,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xCC,
+	0xF3,
+	0x4E,
+	0x3C,
+	0xF5,
+	0xD8,
+	0x83,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x0F,
+	0x3F,
+	0xFB,
+	0xE8,
+	0x93,
+	0x0F,
+	0x3E,
+	0xF7,
+	0xDC,
+	0x73,
+	0xCF,
+	0x3D,
+	0xF7,
+	0xDC,
+	0x73,
+	0xCF,
+	0x3D,
+	0xF7,
+	0xDC,
+	0x73,
+	0x0F,
+	0x3C,
+	0xF2,
+	0xD0,
+	0x53,
+	0x4F,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFD,
+	0xF0,
+	0xB3,
+	0x8F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF1,
+	0xCC,
+	0x33,
+	0x0F,
+	0x3D,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x0F,
+	0x3F,
+	0xFB,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xC8,
+	0x43,
+	0x8F,
+	0x3C,
+	0xF3,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFD,
+	0xF0,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0x33,
+	0x4F,
+	0x3D,
+	0xF1,
+	0xC8,
+	0xC3,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x0F,
+	0x3F,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0x0F,
+	0x3D,
+	0xF6,
+	0xC0,
+	0x13,
+	0x4F,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFD,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xF5,
+	0xDC,
+	0xF3,
+	0x0E,
+	0x3C,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xD8,
+	0x83,
+	0x0F,
+	0x3C,
+	0xEF,
+	0x3C,
+	0xE0,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0xFE,
+	0xF8,
+	0xE3,
+	0x8F,
+	0x3F,
+	0xFE,
+	0xF8,
+	0xE3,
+	0x8F,
+	0x3F,
+	0xFE,
+	0xF8,
+	0x73,
+	0x4F,
+	0x3E,
+	0xF1,
+	0xC0,
+	0xE3,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0xFC,
+	0x03,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFF,
+	0xFC,
+	0x03,
+	0x00,
+	0x00,
+	0xFF,
+	0xFC,
+	0x03,
+	0x00,
+	0x3E,
+	0xFA,
+	0xC8,
+	0x13,
+	0x4F,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF9,
+	0xEC,
+	0x33,
+	0x8F,
+	0x3C,
+	0x12,
+	0x44,
+	0x00,
+	0xC1,
+	0x03,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE8,
+	0xC3,
+	0x0F,
+	0x3D,
+	0xF3,
+	0x4C,
+	0x20,
+	0x41,
+	0x04,
+	0x10,
+	0x3C,
+	0xE0,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xB0,
+	0x4F,
+	0x3F,
+	0xF5,
+	0xD0,
+	0x43,
+	0xC1,
+	0x04,
+	0x12,
+	0x44,
+	0x00,
+	0xC1,
+	0x03,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3F,
+	0xFE,
+	0xD8,
+	0x53,
+	0x4F,
+	0x05,
+	0x14,
+	0x4C,
+	0x20,
+	0x41,
+	0x04,
+	0x10,
+	0x3C,
+	0xE0,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFD,
+	0xFC,
+	0x73,
+	0x8F,
+	0x3D,
+	0x16,
+	0x54,
+	0x40,
+	0xC1,
+	0x04,
+	0x12,
+	0x44,
+	0x00,
+	0xC1,
+	0x03,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF8,
+	0x03,
+	0x00,
+	0x3E,
+	0xF7,
+	0x5C,
+	0x60,
+	0x41,
+	0x05,
+	0x14,
+	0x4C,
+	0x20,
+	0x41,
+	0x04,
+	0x10,
+	0x3C,
+	0xE0,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x0F,
+	0x00,
+	0xF9,
+	0xE0,
+	0x83,
+	0xC1,
+	0x05,
+	0x16,
+	0x54,
+	0x40,
+	0xC1,
+	0x04,
+	0x12,
+	0x44,
+	0x00,
+	0xC1,
+	0x03,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE8,
+	0x93,
+	0x4F,
+	0x06,
+	0x18,
+	0x5C,
+	0x60,
+	0x41,
+	0x05,
+	0x14,
+	0x4C,
+	0x20,
+	0x41,
+	0x04,
+	0x10,
+	0x3C,
+	0xE0,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xB0,
+	0x8F,
+	0x3E,
+	0x1A,
+	0x64,
+	0x80,
+	0xC1,
+	0x05,
+	0x16,
+	0x54,
+	0x40,
+	0xC1,
+	0x04,
+	0x12,
+	0x44,
+	0x00,
+	0xC1,
+	0x03,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3F,
+	0xFB,
+	0x6C,
+	0xA0,
+	0x41,
+	0x06,
+	0x18,
+	0x5C,
+	0x60,
+	0x41,
+	0x05,
+	0x14,
+	0x4C,
+	0x20,
+	0x41,
+	0x04,
+	0x10,
+	0x3C,
+	0xE0,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFD,
+	0xF0,
+	0xC3,
+	0xC1,
+	0x06,
+	0x1A,
+	0x64,
+	0x80,
+	0xC1,
+	0x05,
+	0x16,
+	0x54,
+	0x40,
+	0xC1,
+	0x04,
+	0x12,
+	0x44,
+	0x00,
+	0xC1,
+	0x03,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF8,
+	0xD3,
+	0x4F,
+	0x07,
+	0x1C,
+	0x6C,
+	0xA0,
+	0x41,
+	0x06,
+	0x18,
+	0x5C,
+	0x60,
+	0x41,
+	0x05,
+	0x14,
+	0x4C,
+	0x20,
+	0x41,
+	0x04,
+	0x10,
+	0x3C,
+	0xE0,
+	0x40,
+	0x03,
+	0x0C,
+	0x2C,
+	0xA0,
+	0x40,
+	0x02,
+	0x08,
+	0x1C,
+	0x60,
+	0x40,
+	0x01,
+	0x04,
+	0x0C,
+	0x20,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0x1E,
+	0x74,
+	0xC0,
+	0xC1,
+	0x06,
+	0x1A,
+	0x64,
+	0x80,
+	0xC1,
+	0x05,
+	0x16,
+	0x54,
+	0x40,
+	0xC1,
+	0x04,
+	0x12,
+	0x44,
+	0x00,
+	0xC1,
+	0x03,
+	0x0E,
+	0x34,
+	0xC0,
+	0xC0,
+	0x02,
+	0x0A,
+	0x24,
+	0x80,
+	0xC0,
+	0x01,
+	0x06,
+	0x14,
+	0x40,
+	0xC0,
+	0x00,
+	0x02,
+	0x04,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xE3,
+	0x8F,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xC3,
+	0x4F,
+	0x3F,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xDC,
+	0x73,
+	0xCF,
+	0x3D,
+	0xF7,
+	0xDC,
+	0x73,
+	0xCF,
+	0x3D,
+	0xF7,
+	0xDC,
+	0x73,
+	0xCF,
+	0x3D,
+	0xF7,
+	0xDC,
+	0x73,
+	0xCF,
+	0x3D,
+	0xF7,
+	0xDC,
+	0x73,
+	0xCF,
+	0x3E,
+	0xFC,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x83,
+	0xCF,
+	0x3D,
+	0xF6,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xF5,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xF5,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xF5,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xFA,
+	0xEC,
+	0x53,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xDC,
+	0x63,
+	0x4F,
+	0x3D,
+	0xF4,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xE4,
+	0xA3,
+	0x8F,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x83,
+	0xCF,
+	0x3D,
+	0xF6,
+	0xD4,
+	0x43,
+	0xCF,
+	0x3C,
+	0xF2,
+	0xC8,
+	0x23,
+	0x8F,
+	0x3C,
+	0xF2,
+	0xC8,
+	0x23,
+	0x8F,
+	0x3C,
+	0xF2,
+	0xC8,
+	0x83,
+	0x4F,
+	0x3E,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xDC,
+	0x63,
+	0x4F,
+	0x3D,
+	0xF4,
+	0xCC,
+	0x23,
+	0x4F,
+	0x3C,
+	0xF1,
+	0xC4,
+	0x13,
+	0x4F,
+	0x3C,
+	0xF1,
+	0xC4,
+	0x13,
+	0xCF,
+	0x3D,
+	0xF8,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x83,
+	0xCF,
+	0x3D,
+	0xF6,
+	0xD4,
+	0x43,
+	0x0F,
+	0x3D,
+	0xF4,
+	0xD0,
+	0x43,
+	0x0F,
+	0x3D,
+	0xF4,
+	0xD0,
+	0x03,
+	0x8F,
+	0x3C,
+	0xF6,
+	0xDC,
+	0x93,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x04,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x4F,
+	0x3C,
+	0xF3,
+	0xD4,
+	0x63,
+	0x8F,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xF2,
+	0xD0,
+	0x43,
+	0x4F,
+	0x3D,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xCC,
+	0x53,
+	0xCF,
+	0x3C,
+	0xF4,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFE,
+	0xF4,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0x43,
+	0x8F,
+	0x3D,
+	0xF2,
+	0xCC,
+	0xD3,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x4F,
+	0x3D,
+	0xF7,
+	0xC4,
+	0x23,
+	0x8F,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFE,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xF6,
+	0xE0,
+	0x03,
+	0x4F,
+	0x3C,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0xFC,
+	0xE3,
+	0x8F,
+	0x3F,
+	0xFE,
+	0xF8,
+	0xE3,
+	0x8F,
+	0x3F,
+	0xFE,
+	0xF8,
+	0xE3,
+	0x8F,
+	0x3F,
+	0xFE,
+	0xDC,
+	0x93,
+	0x4F,
+	0x3C,
+	0xF0,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0x83,
+	0x8F,
+	0x3E,
+	0xF2,
+	0xC4,
+	0xF3,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x10,
+	0x00,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x40,
+	0x3E,
+	0xFB,
+	0xCC,
+	0x23,
+	0x8F,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0xF0,
+	0x8F,
+	0x3F,
+	0x01,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0xFA,
+	0xF0,
+	0x43,
+	0xCF,
+	0x3C,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0xEC,
+	0xD3,
+	0x4F,
+	0x3D,
+	0xF4,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0xC0,
+	0x8F,
+	0x3F,
+	0xF6,
+	0xD4,
+	0x53,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x3F,
+	0xFF,
+	0xDC,
+	0x63,
+	0x8F,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0xFE,
+	0x00,
+	0x80,
+	0xCF,
+	0x3D,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0xFC,
+	0x13,
+	0x40,
+	0x3E,
+	0xF8,
+	0x60,
+	0x70,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x00,
+	0x40,
+	0x00,
+	0xFA,
+	0xE4,
+	0x93,
+	0x01,
+	0x06,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0xEC,
+	0xA3,
+	0x8F,
+	0x06,
+	0x19,
+	0x60,
+	0x70,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x40,
+	0x00,
+	0x01,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0xC0,
+	0xCF,
+	0x3E,
+	0x1B,
+	0x68,
+	0x90,
+	0x01,
+	0x06,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x3F,
+	0xFC,
+	0x70,
+	0xB0,
+	0x81,
+	0x06,
+	0x19,
+	0x60,
+	0x70,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x10,
+	0x40,
+	0x00,
+	0xFE,
+	0xF4,
+	0xD3,
+	0x01,
+	0x07,
+	0x1B,
+	0x68,
+	0x90,
+	0x01,
+	0x06,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x01,
+	0xFC,
+	0xE3,
+	0x8F,
+	0x07,
+	0x1D,
+	0x70,
+	0xB0,
+	0x81,
+	0x06,
+	0x19,
+	0x60,
+	0x70,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0xC0,
+	0x3F,
+	0x1F,
+	0x78,
+	0xD0,
+	0x01,
+	0x07,
+	0x1B,
+	0x68,
+	0x90,
+	0x01,
+	0x06,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x04,
+	0x10,
+	0x40,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0x03,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xC3,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0xA3,
+	0xCF,
+	0x3E,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x83,
+	0xCF,
+	0x3D,
+	0xF6,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xF5,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xF5,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xF5,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3D,
+	0xF5,
+	0xD4,
+	0x53,
+	0x4F,
+	0x3E,
+	0xFA,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xDC,
+	0x63,
+	0x4F,
+	0x3D,
+	0xF4,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF3,
+	0xCC,
+	0x33,
+	0xCF,
+	0x3C,
+	0xF8,
+	0xE4,
+	0x33,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x83,
+	0xCF,
+	0x3D,
+	0xF6,
+	0xD4,
+	0x43,
+	0xCF,
+	0x3C,
+	0xF2,
+	0xC4,
+	0x13,
+	0x4F,
+	0x3C,
+	0xF1,
+	0xC4,
+	0x13,
+	0x4F,
+	0x3C,
+	0xF1,
+	0xC4,
+	0x13,
+	0x4F,
+	0x3C,
+	0xF1,
+	0xDC,
+	0x83,
+	0x0F,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xDC,
+	0x63,
+	0x4F,
+	0x3D,
+	0xF4,
+	0xCC,
+	0x23,
+	0x4F,
+	0x3C,
+	0xF0,
+	0xC0,
+	0x03,
+	0x0F,
+	0x3C,
+	0xF0,
+	0xC0,
+	0x03,
+	0x0F,
+	0x3C,
+	0xF0,
+	0xC0,
+	0x63,
+	0xCF,
+	0x3D,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x83,
+	0xCF,
+	0x3D,
+	0xF6,
+	0xD4,
+	0x43,
+	0xCF,
+	0x3C,
+	0xF2,
+	0xC4,
+	0x03,
+	0xCF,
+	0x3B,
+	0xEF,
+	0xBC,
+	0xF3,
+	0xCE,
+	0x3B,
+	0xEF,
+	0xBC,
+	0xF3,
+	0x4E,
+	0x3D,
+	0xF6,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xDC,
+	0x63,
+	0x4F,
+	0x3D,
+	0xF4,
+	0xCC,
+	0x23,
+	0x8F,
+	0x3C,
+	0xF2,
+	0xC8,
+	0x23,
+	0x8F,
+	0x3C,
+	0xF2,
+	0xC8,
+	0xE3,
+	0x0E,
+	0x3C,
+	0xF4,
+	0xD4,
+	0x73,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x83,
+	0xCF,
+	0x3D,
+	0xF6,
+	0xD8,
+	0x63,
+	0x8F,
+	0x3D,
+	0xF6,
+	0xD8,
+	0x63,
+	0x8F,
+	0x3D,
+	0xF6,
+	0xD8,
+	0x63,
+	0xCF,
+	0x3B,
+	0xF1,
+	0xCC,
+	0x43,
+	0x0F,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF8,
+	0xE0,
+	0x83,
+	0x0F,
+	0x3E,
+	0xF0,
+	0xC8,
+	0x23,
+	0xCF,
+	0x3C,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xE4,
+	0x93,
+	0x4F,
+	0x3E,
+	0xF9,
+	0xC4,
+	0x33,
+	0x4F,
+	0x3C,
+	0xF2,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0x23,
+	0x0F,
+	0x3D,
+	0xF0,
+	0xC4,
+	0xB3,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0x8F,
+	0x3E,
+	0xFA,
+	0xE8,
+	0xA3,
+	0xCF,
+	0x3C,
+	0xF5,
+	0xBC,
+	0x03,
+	0x0F,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xFB,
+	0xEC,
+	0xB3,
+	0xCF,
+	0x3E,
+	0xF4,
+	0xD8,
+	0xE3,
+	0xCE,
+	0x3B,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0xF4,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xF0,
+	0xC3,
+	0x0F,
+	0x3F,
+	0xFC,
+	0xD4,
+	0x73,
+	0xCF,
+	0x3B,
+	0xEE,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0xD3,
+	0x4F,
+	0x3F,
+	0xFD,
+	0xF4,
+	0x63,
+	0x0F,
+	0x3E,
+	0xF0,
+	0xBC,
+	0xD3,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFC,
+	0xF3,
+	0x8F,
+	0x3F,
+	0xFE,
+	0xF8,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFE,
+	0xF8,
+	0xF3,
+	0xCF,
+	0x3D,
+	0xF9,
+	0xC4,
+	0x03,
+	0x0F,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xF8,
+	0xE8,
+	0x23,
+	0x4F,
+	0x3C,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xE4,
+	0xB3,
+	0xCF,
+	0x3C,
+	0xF2,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xA3,
+	0x0F,
+	0x3F,
+	0xF4,
+	0xCC,
+	0x33,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3E,
+	0xFD,
+	0xD4,
+	0x43,
+	0x0F,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFC,
+	0xF8,
+	0x63,
+	0x4F,
+	0x3D,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xF4,
+	0xF3,
+	0xCF,
+	0x3D,
+	0xF6,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xE3,
+	0xCF,
+	0x3F,
+	0xF8,
+	0xDC,
+	0x73,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xE4,
+	0x83,
+	0x0F,
+	0x06,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0xCF,
+	0x3F,
+	0xFF,
+	0xFC,
+	0xA3,
+	0x4F,
+	0x3E,
+	0x19,
+	0x60,
+	0x70,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFC,
+	0xF3,
+	0xCF,
+	0x3E,
+	0xFA,
+	0x68,
+	0x90,
+	0x01,
+	0x06,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xF0,
+	0xCF,
+	0x3F,
+	0xFC,
+	0xEC,
+	0xB3,
+	0x81,
+	0x06,
+	0x19,
+	0x60,
+	0x70,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xF4,
+	0xC3,
+	0x0F,
+	0x07,
+	0x1B,
+	0x68,
+	0x90,
+	0x01,
+	0x06,
+	0x17,
+	0x58,
+	0x50,
+	0x01,
+	0x05,
+	0x13,
+	0x48,
+	0x10,
+	0x01,
+	0x04,
+	0x0F,
+	0x38,
+	0xD0,
+	0x00,
+	0x03,
+	0x0B,
+	0x28,
+	0x90,
+	0x00,
+	0x02,
+	0x07,
+	0x18,
+	0x50,
+	0x00,
+	0x01,
+	0x03,
+	0x08,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xE0,
+	0x4F,
+	0x3F,
+	0x1D,
+	0x70,
+	0xB0,
+	0x81,
+	0x06,
+	0x19,
+	0x60,
+	0x70,
+	0x81,
+	0x05,
+	0x15,
+	0x50,
+	0x30,
+	0x81,
+	0x04,
+	0x11,
+	0x40,
+	0xF0,
+	0x80,
+	0x03,
+	0x0D,
+	0x30,
+	0xB0,
+	0x80,
+	0x02,
+	0x09,
+	0x20,
+	0x70,
+	0x80,
+	0x01,
+	0x05,
+	0x10,
+	0x30,
+	0x80,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFE,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x83,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x3A,
+	0x3D,
+	0x14,
+	0x18,
+	0x3D,
+	0x40,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x5A,
+	0x5D,
+	0x00,
+	0xF0,
+	0x53,
+	0x56,
+	0x20,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x46,
+	0x4A,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x28,
+	0xD8,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x53,
+	0x56,
+	0x00,
+	0xF4,
+	0x50,
+	0x53,
+	0x18,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x4A,
+	0x4D,
+	0x00,
+	0x00,
+	0x46,
+	0x4A,
+	0x00,
+	0x00,
+	0x43,
+	0x46,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x3D,
+	0x40,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0xF8,
+	0x4D,
+	0x50,
+	0x10,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x46,
+	0x4A,
+	0x00,
+	0xFC,
+	0x4A,
+	0x4D,
+	0x08,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x50,
+	0x53,
+	0x00,
+	0x00,
+	0x53,
+	0x56,
+	0x00,
+	0x00,
+	0x56,
+	0x5A,
+	0x00,
+	0x00,
+	0x5A,
+	0x5D,
+	0x00,
+	0x00,
+	0x5D,
+	0x60,
+	0x00,
+	0x00,
+	0x60,
+	0x63,
+	0x00,
+	0x00,
+	0x5D,
+	0x60,
+	0x00,
+	0x00,
+	0x5A,
+	0x5D,
+	0x00,
+	0x00,
+	0x56,
+	0x5A,
+	0x00,
+	0x00,
+	0x53,
+	0x56,
+	0x00,
+	0x00,
+	0x50,
+	0x53,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x04,
+	0x00,
+	0x40,
+	0x43,
+	0x08,
+	0xD8,
+	0x46,
+	0x4A,
+	0x0C,
+	0xDC,
+	0x4D,
+	0x50,
+	0x10,
+	0xE0,
+	0x53,
+	0x56,
+	0x14,
+	0xE4,
+	0x5A,
+	0x5D,
+	0x18,
+	0xE8,
+	0x60,
+	0x63,
+	0x1C,
+	0xEC,
+	0x5A,
+	0x5D,
+	0x18,
+	0xF0,
+	0x53,
+	0x56,
+	0x14,
+	0xF4,
+	0x4D,
+	0x50,
+	0x10,
+	0xF8,
+	0x46,
+	0x4A,
+	0x0C,
+	0xFC,
+	0x40,
+	0x43,
+	0x08,
+	0x00,
+	0x46,
+	0x40,
+	0x04,
+	0xF8,
+	0x4D,
+	0x50,
+	0x08,
+	0xF4,
+	0x53,
+	0x56,
+	0x0C,
+	0xF0,
+	0x5A,
+	0x5D,
+	0x10,
+	0xEC,
+	0x60,
+	0x63,
+	0x14,
+	0xE8,
+	0x66,
+	0x6A,
+	0x10,
+	0xE4,
+	0x6D,
+	0x70,
+	0x0C,
+	0xE0,
+	0x66,
+	0x6A,
+	0x08,
+	0xDC,
+	0x60,
+	0x63,
+	0x04,
+	0xD8,
+	0x5A,
+	0x5D,
+	0x00,
+	0x00,
+	0x53,
+	0x56,
+	0x00,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x46,
+	0x4A,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x3A,
+	0x3D,
+	0x00,
+	0xF8,
+	0x43,
+	0x46,
+	0x08,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x56,
+	0x5A,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x33,
+	0x36,
+	0x00,
+	0xF0,
+	0x40,
+	0x43,
+	0x0C,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x5A,
+	0x5D,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x2D,
+	0x30,
+	0x00,
+	0xE8,
+	0x3D,
+	0x40,
+	0x10,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x5D,
+	0x60,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x26,
+	0x2A,
+	0x00,
+	0xE0,
+	0x3A,
+	0x3D,
+	0x14,
+	0x00,
+	0x4D,
+	0x50,
+	0x00,
+	0x00,
+	0x60,
+	0x63,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x20,
+	0x23,
+	0x00,
+	0x00,
+	0x33,
+	0x36,
+	0x10,
+	0x1C,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x18,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x40,
+	0x43,
+	0x00,
+	0x00,
+	0x1A,
+	0x1D,
+	0x0C,
+	0x20,
+	0x94,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xBF,
+	0x82,
+	0x01,
+	0x07,
+	0x82,
+	0x01,
+	0x0F,
+	0x82,
+	0x01,
+	0x17,
+	0x82,
+	0x01,
+	0x1F,
+	0x82,
+	0x01,
+	0x27,
+	0x82,
+	0x01,
+	0x2F,
+	0x82,
+	0x01,
+	0x37,
+	0x82,
+	0x01,
+	0x3F,
+	0x82,
+	0x01,
+	0x47,
+	0x82,
+	0x01,
+	0x4F,
+	0x82,
+	0x01,
+	0x57,
+	0x82,
+	0x01,
+	0x5F,
+	0x82,
+	0x01,
+	0x67,
+	0x82,
+	0x01,
+	0x6F,
+	0x82,
+	0x01,
+	0x77,
+	0x82,
+	0x01,
+	0x7F,
+	0x82,
+	0x01,
+	0x87,
+	0x82,
+	0x01,
+	0x8F,
+	0x82,
+	0x01,
+	0x97,
+	0x82,
+	0x01,
+	0x9F,
+	0x82,
+	0x01,
+	0xA7,
+	0x82,
+	0x01,
+	0xAF,
+	0x82,
+	0x01,
+	0xB7,
+	0x82,
+	0x01,
+	0x5A,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x08,
+	0xC0,
+	0x00,
+	0x14,
+	0x80,
+	0x01,
+	0x20,
+	0x80,
+	0x02,
+	0x2C,
+	0x40,
+	0x03,
+	0x3C,
+	0x40,
+	0x04,
+	0x4C,
+	0x40,
+	0x05,
+	0x60,
+	0x80,
+	0x06,
+	0x70,
+	0x80,
+	0x07,
+	0x84,
+	0xC0,
+	0x08,
+	0x94,
+	0x00,
+	0x0A,
+	0xA8,
+	0x40,
+	0x0B,
+	0xBC,
+	0x80,
+	0x0C,
+	0xD4,
+	0xC0,
+	0x0D,
+	0xE8,
+	0x40,
+	0x0F,
+	0xFC,
+	0x80,
+	0x10,
+	0x14,
+	0x01,
+	0x12,
+	0x2C,
+	0x41,
+	0x13,
+	0x40,
+	0xC1,
+	0x14,
+	0x58,
+	0x41,
+	0x16,
+	0x70,
+	0xC1,
+	0x17,
+	0x88,
+	0x41,
+	0x19,
+	0xA0,
+	0xC1,
+	0x1A,
+	0xB8,
+	0x81,
+	0x1C,
+	0xD4,
+	0x01,
+	0x1E,
+	0xEC,
+	0x81,
+	0x1F,
+	0x04,
+	0x42,
+	0x21,
+	0x20,
+	0xC2,
+	0x22,
+	0x3C,
+	0x82,
+	0x24,
+	0x54,
+	0x42,
+	0x26,
+	0x70,
+	0xC2,
+	0x27,
+	0x8C,
+	0x82,
+	0x29,
+	0xA8,
+	0x42,
+	0x2B,
+	0xC4,
+	0x02,
+	0x2D,
+	0xDC,
+	0xC2,
+	0x2E,
+	0xFC,
+	0x82,
+	0x30,
+	0x18,
+	0x43,
+	0x32,
+	0x34,
+	0x03,
+	0x34,
+	0x50,
+	0x03,
+	0x36,
+	0x6C,
+	0xC3,
+	0x37,
+	0x8C,
+	0x83,
+	0x39,
+	0xA8,
+	0x83,
+	0x3B,
+	0xC8,
+	0x43,
+	0x3D,
+	0xE4,
+	0x43,
+	0x3F,
+	0x04,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0xC4,
+	0x46,
+	0x7C,
+	0xC4,
+	0x48,
+	0x9C,
+	0xC4,
+	0x4A,
+	0xBC,
+	0xC4,
+	0x4C,
+	0xDC,
+	0xC4,
+	0x4E,
+	0xFC,
+	0xC4,
+	0x50,
+	0x1C,
+	0xC5,
+	0x52,
+	0x3C,
+	0xC5,
+	0x54,
+	0x5C,
+	0xC5,
+	0x56,
+	0x7C,
+	0xC5,
+	0x58,
+	0x9C,
+	0xC5,
+	0x5A,
+	0xBC,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x46,
+	0x63,
+	0x44,
+	0x46,
+	0x65,
+	0x64,
+	0x46,
+	0x67,
+	0x88,
+	0x86,
+	0x69,
+	0xA8,
+	0x86,
+	0x6B,
+	0xCC,
+	0xC6,
+	0x6D,
+	0xEC,
+	0x06,
+	0x70,
+	0x10,
+	0x07,
+	0x72,
+	0x30,
+	0x47,
+	0x74,
+	0x54,
+	0x87,
+	0x76,
+	0x78,
+	0x87,
+	0x78,
+	0x9C,
+	0xC7,
+	0x7A,
+	0xBC,
+	0x07,
+	0x7D,
+	0xE0,
+	0x47,
+	0x7F,
+	0x04,
+	0x88,
+	0x81,
+	0x28,
+	0xC8,
+	0x83,
+	0x4C,
+	0x08,
+	0x86,
+	0x70,
+	0x48,
+	0x88,
+	0x94,
+	0x88,
+	0x8A,
+	0xB8,
+	0xC8,
+	0x8C,
+	0xDC,
+	0x08,
+	0x8F,
+	0x00,
+	0x49,
+	0x91,
+	0x24,
+	0x89,
+	0x93,
+	0x4C,
+	0xC9,
+	0x95,
+	0x70,
+	0x49,
+	0x98,
+	0x94,
+	0x89,
+	0x9A,
+	0xB8,
+	0xC9,
+	0x9C,
+	0xE0,
+	0x09,
+	0x9F,
+	0x04,
+	0x8A,
+	0xA1,
+	0x28,
+	0xCA,
+	0xA3,
+	0x50,
+	0x4A,
+	0xA6,
+	0x74,
+	0x8A,
+	0xA8,
+	0x9C,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x4A,
+	0xAD,
+	0xE8,
+	0xCA,
+	0xAF,
+	0x0C,
+	0x0B,
+	0xB2,
+	0x34,
+	0x8B,
+	0xB4,
+	0x5C,
+	0xCB,
+	0xB6,
+	0x80,
+	0x4B,
+	0xB9,
+	0xA8,
+	0xCB,
+	0xBB,
+	0xD0,
+	0x4B,
+	0xBE,
+	0xF4,
+	0x8B,
+	0xC0,
+	0x1C,
+	0x0C,
+	0xC3,
+	0x44,
+	0x8C,
+	0xC5,
+	0x6C,
+	0x0C,
+	0xC8,
+	0x94,
+	0x8C,
+	0xCA,
+	0xBC,
+	0xCC,
+	0xCC,
+	0xE0,
+	0x4C,
+	0xCF,
+	0x08,
+	0xCD,
+	0xD1,
+	0x30,
+	0x4D,
+	0xD4,
+	0x58,
+	0xCD,
+	0xD6,
+	0x80,
+	0x4D,
+	0xD9,
+	0xA8,
+	0xCD,
+	0xDB,
+	0xD0,
+	0x8D,
+	0xDE,
+	0xFC,
+	0x0D,
+	0xE1,
+	0x24,
+	0x8E,
+	0xE3,
+	0x4C,
+	0x0E,
+	0xE6,
+	0x74,
+	0x8E,
+	0xE8,
+	0x9C,
+	0x0E,
+	0xEB,
+	0xC4,
+	0xCE,
+	0xED,
+	0xF0,
+	0x4E,
+	0xF0,
+	0x18,
+	0xCF,
+	0xF2,
+	0x40,
+	0x4F,
+	0xF5,
+	0x6C,
+	0x0F,
+	0xF8,
+	0x94,
+	0x8F,
+	0xFA,
+	0xBC,
+	0x4F,
+	0xFD,
+	0xE8,
+	0xCF,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x08,
+	0xC0,
+	0x00,
+	0x14,
+	0x80,
+	0x01,
+	0x20,
+	0x80,
+	0x02,
+	0x2C,
+	0x40,
+	0x03,
+	0x3C,
+	0x40,
+	0x04,
+	0x4C,
+	0x40,
+	0x05,
+	0x60,
+	0x80,
+	0x06,
+	0x70,
+	0x80,
+	0x07,
+	0x84,
+	0xC0,
+	0x08,
+	0x94,
+	0x00,
+	0x0A,
+	0xA8,
+	0x40,
+	0x0B,
+	0xBC,
+	0x80,
+	0x0C,
+	0xD4,
+	0xC0,
+	0x0D,
+	0xE8,
+	0x40,
+	0x0F,
+	0xFC,
+	0x80,
+	0x10,
+	0x14,
+	0x01,
+	0x12,
+	0x2C,
+	0x41,
+	0x13,
+	0x40,
+	0xC1,
+	0x14,
+	0x58,
+	0x41,
+	0x16,
+	0x70,
+	0xC1,
+	0x17,
+	0x88,
+	0x41,
+	0x19,
+	0xA0,
+	0xC1,
+	0x1A,
+	0xB8,
+	0x81,
+	0x1C,
+	0xD4,
+	0x01,
+	0x1E,
+	0xEC,
+	0x81,
+	0x1F,
+	0x04,
+	0x42,
+	0x21,
+	0x20,
+	0xC2,
+	0x22,
+	0x3C,
+	0x82,
+	0x24,
+	0x54,
+	0x42,
+	0x26,
+	0x70,
+	0xC2,
+	0x27,
+	0x8C,
+	0x82,
+	0x29,
+	0xA8,
+	0x42,
+	0x2B,
+	0xC4,
+	0x02,
+	0x2D,
+	0xDC,
+	0xC2,
+	0x2E,
+	0xFC,
+	0x82,
+	0x30,
+	0x18,
+	0x43,
+	0x32,
+	0x34,
+	0x03,
+	0x34,
+	0x50,
+	0x03,
+	0x36,
+	0x6C,
+	0xC3,
+	0x37,
+	0x8C,
+	0x83,
+	0x39,
+	0xA8,
+	0x83,
+	0x3B,
+	0xC8,
+	0x43,
+	0x3D,
+	0xE4,
+	0x43,
+	0x3F,
+	0x04,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0xC4,
+	0x46,
+	0x7C,
+	0xC4,
+	0x48,
+	0x9C,
+	0xC4,
+	0x4A,
+	0xBC,
+	0xC4,
+	0x4C,
+	0xDC,
+	0xC4,
+	0x4E,
+	0xFC,
+	0xC4,
+	0x50,
+	0x1C,
+	0xC5,
+	0x52,
+	0x3C,
+	0xC5,
+	0x54,
+	0x5C,
+	0xC5,
+	0x56,
+	0x7C,
+	0xC5,
+	0x58,
+	0x9C,
+	0xC5,
+	0x5A,
+	0xBC,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x46,
+	0x63,
+	0x44,
+	0x46,
+	0x65,
+	0x64,
+	0x46,
+	0x67,
+	0x88,
+	0x86,
+	0x69,
+	0xA8,
+	0x86,
+	0x6B,
+	0xCC,
+	0xC6,
+	0x6D,
+	0xEC,
+	0x06,
+	0x70,
+	0x10,
+	0x07,
+	0x72,
+	0x30,
+	0x47,
+	0x74,
+	0x54,
+	0x87,
+	0x76,
+	0x78,
+	0x87,
+	0x78,
+	0x9C,
+	0xC7,
+	0x7A,
+	0xBC,
+	0x07,
+	0x7D,
+	0xE0,
+	0x47,
+	0x7F,
+	0x04,
+	0x88,
+	0x81,
+	0x28,
+	0xC8,
+	0x83,
+	0x4C,
+	0x08,
+	0x86,
+	0x70,
+	0x48,
+	0x88,
+	0x94,
+	0x88,
+	0x8A,
+	0xB8,
+	0xC8,
+	0x8C,
+	0xDC,
+	0x08,
+	0x8F,
+	0x00,
+	0x49,
+	0x91,
+	0x24,
+	0x89,
+	0x93,
+	0x4C,
+	0xC9,
+	0x95,
+	0x70,
+	0x49,
+	0x98,
+	0x94,
+	0x89,
+	0x9A,
+	0xB8,
+	0xC9,
+	0x9C,
+	0xE0,
+	0x09,
+	0x9F,
+	0x04,
+	0x8A,
+	0xA1,
+	0x28,
+	0xCA,
+	0xA3,
+	0x50,
+	0x4A,
+	0xA6,
+	0x74,
+	0x8A,
+	0xA8,
+	0x9C,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x4A,
+	0xAD,
+	0xE8,
+	0xCA,
+	0xAF,
+	0x0C,
+	0x0B,
+	0xB2,
+	0x34,
+	0x8B,
+	0xB4,
+	0x5C,
+	0xCB,
+	0xB6,
+	0x80,
+	0x4B,
+	0xB9,
+	0xA8,
+	0xCB,
+	0xBB,
+	0xD0,
+	0x4B,
+	0xBE,
+	0xF4,
+	0x8B,
+	0xC0,
+	0x1C,
+	0x0C,
+	0xC3,
+	0x44,
+	0x8C,
+	0xC5,
+	0x6C,
+	0x0C,
+	0xC8,
+	0x94,
+	0x8C,
+	0xCA,
+	0xBC,
+	0xCC,
+	0xCC,
+	0xE0,
+	0x4C,
+	0xCF,
+	0x08,
+	0xCD,
+	0xD1,
+	0x30,
+	0x4D,
+	0xD4,
+	0x58,
+	0xCD,
+	0xD6,
+	0x80,
+	0x4D,
+	0xD9,
+	0xA8,
+	0xCD,
+	0xDB,
+	0xD0,
+	0x8D,
+	0xDE,
+	0xFC,
+	0x0D,
+	0xE1,
+	0x24,
+	0x8E,
+	0xE3,
+	0x4C,
+	0x0E,
+	0xE6,
+	0x74,
+	0x8E,
+	0xE8,
+	0x9C,
+	0x0E,
+	0xEB,
+	0xC4,
+	0xCE,
+	0xED,
+	0xF0,
+	0x4E,
+	0xF0,
+	0x18,
+	0xCF,
+	0xF2,
+	0x40,
+	0x4F,
+	0xF5,
+	0x6C,
+	0x0F,
+	0xF8,
+	0x94,
+	0x8F,
+	0xFA,
+	0xBC,
+	0x4F,
+	0xFD,
+	0xE8,
+	0xCF,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x08,
+	0xC0,
+	0x00,
+	0x14,
+	0x80,
+	0x01,
+	0x20,
+	0x80,
+	0x02,
+	0x2C,
+	0x40,
+	0x03,
+	0x3C,
+	0x40,
+	0x04,
+	0x4C,
+	0x40,
+	0x05,
+	0x60,
+	0x80,
+	0x06,
+	0x70,
+	0x80,
+	0x07,
+	0x84,
+	0xC0,
+	0x08,
+	0x94,
+	0x00,
+	0x0A,
+	0xA8,
+	0x40,
+	0x0B,
+	0xBC,
+	0x80,
+	0x0C,
+	0xD4,
+	0xC0,
+	0x0D,
+	0xE8,
+	0x40,
+	0x0F,
+	0xFC,
+	0x80,
+	0x10,
+	0x14,
+	0x01,
+	0x12,
+	0x2C,
+	0x41,
+	0x13,
+	0x40,
+	0xC1,
+	0x14,
+	0x58,
+	0x41,
+	0x16,
+	0x70,
+	0xC1,
+	0x17,
+	0x88,
+	0x41,
+	0x19,
+	0xA0,
+	0xC1,
+	0x1A,
+	0xB8,
+	0x81,
+	0x1C,
+	0xD4,
+	0x01,
+	0x1E,
+	0xEC,
+	0x81,
+	0x1F,
+	0x04,
+	0x42,
+	0x21,
+	0x20,
+	0xC2,
+	0x22,
+	0x3C,
+	0x82,
+	0x24,
+	0x54,
+	0x42,
+	0x26,
+	0x70,
+	0xC2,
+	0x27,
+	0x8C,
+	0x82,
+	0x29,
+	0xA8,
+	0x42,
+	0x2B,
+	0xC4,
+	0x02,
+	0x2D,
+	0xDC,
+	0xC2,
+	0x2E,
+	0xFC,
+	0x82,
+	0x30,
+	0x18,
+	0x43,
+	0x32,
+	0x34,
+	0x03,
+	0x34,
+	0x50,
+	0x03,
+	0x36,
+	0x6C,
+	0xC3,
+	0x37,
+	0x8C,
+	0x83,
+	0x39,
+	0xA8,
+	0x83,
+	0x3B,
+	0xC8,
+	0x43,
+	0x3D,
+	0xE4,
+	0x43,
+	0x3F,
+	0x04,
+	0x04,
+	0x41,
+	0x20,
+	0x04,
+	0x43,
+	0x40,
+	0x04,
+	0x45,
+	0x60,
+	0xC4,
+	0x46,
+	0x7C,
+	0xC4,
+	0x48,
+	0x9C,
+	0xC4,
+	0x4A,
+	0xBC,
+	0xC4,
+	0x4C,
+	0xDC,
+	0xC4,
+	0x4E,
+	0xFC,
+	0xC4,
+	0x50,
+	0x1C,
+	0xC5,
+	0x52,
+	0x3C,
+	0xC5,
+	0x54,
+	0x5C,
+	0xC5,
+	0x56,
+	0x7C,
+	0xC5,
+	0x58,
+	0x9C,
+	0xC5,
+	0x5A,
+	0xBC,
+	0x05,
+	0x5D,
+	0xE0,
+	0x05,
+	0x5F,
+	0x00,
+	0x06,
+	0x61,
+	0x20,
+	0x46,
+	0x63,
+	0x44,
+	0x46,
+	0x65,
+	0x64,
+	0x46,
+	0x67,
+	0x88,
+	0x86,
+	0x69,
+	0xA8,
+	0x86,
+	0x6B,
+	0xCC,
+	0xC6,
+	0x6D,
+	0xEC,
+	0x06,
+	0x70,
+	0x10,
+	0x07,
+	0x72,
+	0x30,
+	0x47,
+	0x74,
+	0x54,
+	0x87,
+	0x76,
+	0x78,
+	0x87,
+	0x78,
+	0x9C,
+	0xC7,
+	0x7A,
+	0xBC,
+	0x07,
+	0x7D,
+	0xE0,
+	0x47,
+	0x7F,
+	0x04,
+	0x88,
+	0x81,
+	0x28,
+	0xC8,
+	0x83,
+	0x4C,
+	0x08,
+	0x86,
+	0x70,
+	0x48,
+	0x88,
+	0x94,
+	0x88,
+	0x8A,
+	0xB8,
+	0xC8,
+	0x8C,
+	0xDC,
+	0x08,
+	0x8F,
+	0x00,
+	0x49,
+	0x91,
+	0x24,
+	0x89,
+	0x93,
+	0x4C,
+	0xC9,
+	0x95,
+	0x70,
+	0x49,
+	0x98,
+	0x94,
+	0x89,
+	0x9A,
+	0xB8,
+	0xC9,
+	0x9C,
+	0xE0,
+	0x09,
+	0x9F,
+	0x04,
+	0x8A,
+	0xA1,
+	0x28,
+	0xCA,
+	0xA3,
+	0x50,
+	0x4A,
+	0xA6,
+	0x74,
+	0x8A,
+	0xA8,
+	0x9C,
+	0x0A,
+	0xAB,
+	0xC0,
+	0x4A,
+	0xAD,
+	0xE8,
+	0xCA,
+	0xAF,
+	0x0C,
+	0x0B,
+	0xB2,
+	0x34,
+	0x8B,
+	0xB4,
+	0x5C,
+	0xCB,
+	0xB6,
+	0x80,
+	0x4B,
+	0xB9,
+	0xA8,
+	0xCB,
+	0xBB,
+	0xD0,
+	0x4B,
+	0xBE,
+	0xF4,
+	0x8B,
+	0xC0,
+	0x1C,
+	0x0C,
+	0xC3,
+	0x44,
+	0x8C,
+	0xC5,
+	0x6C,
+	0x0C,
+	0xC8,
+	0x94,
+	0x8C,
+	0xCA,
+	0xBC,
+	0xCC,
+	0xCC,
+	0xE0,
+	0x4C,
+	0xCF,
+	0x08,
+	0xCD,
+	0xD1,
+	0x30,
+	0x4D,
+	0xD4,
+	0x58,
+	0xCD,
+	0xD6,
+	0x80,
+	0x4D,
+	0xD9,
+	0xA8,
+	0xCD,
+	0xDB,
+	0xD0,
+	0x8D,
+	0xDE,
+	0xFC,
+	0x0D,
+	0xE1,
+	0x24,
+	0x8E,
+	0xE3,
+	0x4C,
+	0x0E,
+	0xE6,
+	0x74,
+	0x8E,
+	0xE8,
+	0x9C,
+	0x0E,
+	0xEB,
+	0xC4,
+	0xCE,
+	0xED,
+	0xF0,
+	0x4E,
+	0xF0,
+	0x18,
+	0xCF,
+	0xF2,
+	0x40,
+	0x4F,
+	0xF5,
+	0x6C,
+	0x0F,
+	0xF8,
+	0x94,
+	0x8F,
+	0xFA,
+	0xBC,
+	0x4F,
+	0xFD,
+	0xE8,
+	0xCF,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x33,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x50,
+	0x00,
+	0x2D,
+	0x70,
+	0x06,
+	0xAF,
+	0x50,
+	0x0F,
+	0x27,
+	0x71,
+	0x16,
+	0x9B,
+	0x21,
+	0x1D,
+	0xFD,
+	0xF1,
+	0x22,
+	0x5F,
+	0x52,
+	0x28,
+	0xB2,
+	0x32,
+	0x2E,
+	0x18,
+	0xF3,
+	0x33,
+	0x62,
+	0xF3,
+	0x37,
+	0xA3,
+	0x43,
+	0x3C,
+	0xDF,
+	0x23,
+	0x40,
+	0x1D,
+	0xD4,
+	0x43,
+	0x55,
+	0x44,
+	0x47,
+	0x8E,
+	0xB4,
+	0x4A,
+	0xC4,
+	0xA4,
+	0x4D,
+	0xF4,
+	0x64,
+	0x51,
+	0x2E,
+	0x75,
+	0x54,
+	0x5E,
+	0xA5,
+	0x57,
+	0x96,
+	0xF5,
+	0x5A,
+	0xC8,
+	0x15,
+	0x5E,
+	0xF9,
+	0x05,
+	0x61,
+	0x2C,
+	0x56,
+	0x64,
+	0x5B,
+	0x16,
+	0x67,
+	0x89,
+	0x16,
+	0x6A,
+	0xB8,
+	0xF6,
+	0x6C,
+	0xE9,
+	0x36,
+	0x70,
+	0x1D,
+	0x87,
+	0x73,
+	0x4B,
+	0x47,
+	0x76,
+	0x7B,
+	0x37,
+	0x79,
+	0xAB,
+	0xF7,
+	0x7B,
+	0xD8,
+	0x37,
+	0x7F,
+	0x06,
+	0xF8,
+	0x81,
+	0x34,
+	0x58,
+	0x84,
+	0x5C,
+	0x18,
+	0x87,
+	0x88,
+	0xF8,
+	0x89,
+	0xB0,
+	0x68,
+	0x8C,
+	0xDE,
+	0x18,
+	0x8F,
+	0x06,
+	0x29,
+	0x92,
+	0x39,
+	0x89,
+	0x94,
+	0x54,
+	0xD9,
+	0x96,
+	0x81,
+	0x09,
+	0x99,
+	0xA0,
+	0x39,
+	0x9B,
+	0xC4,
+	0x29,
+	0x9D,
+	0xE5,
+	0x79,
+	0x9F,
+	0x07,
+	0x3A,
+	0xA1,
+	0x27,
+	0xBA,
+	0xA3,
+	0x49,
+	0x8A,
+	0xA5,
+	0x6E,
+	0xBA,
+	0xA7,
+	0x8A,
+	0xCA,
+	0xA9,
+	0xAB,
+	0xCA,
+	0xAB,
+	0xCB,
+	0xDA,
+	0xAD,
+	0xEB,
+	0xAA,
+	0xAF,
+	0x0A,
+	0x9B,
+	0xB1,
+	0x28,
+	0x8B,
+	0xB3,
+	0x46,
+	0x3B,
+	0xB5,
+	0x61,
+	0xEB,
+	0xB6,
+	0x80,
+	0xFB,
+	0xB8,
+	0x9C,
+	0xAB,
+	0xBA,
+	0xBB,
+	0x8B,
+	0xBC,
+	0xD4,
+	0x1B,
+	0xBE,
+	0xEC,
+	0x9B,
+	0xBF,
+	0x09,
+	0x7C,
+	0xC1,
+	0x25,
+	0x2C,
+	0xC3,
+	0x3C,
+	0xAC,
+	0xC4,
+	0x5C,
+	0x7C,
+	0xC6,
+	0x71,
+	0xFC,
+	0xC7,
+	0x8C,
+	0x9C,
+	0xC9,
+	0xA5,
+	0x0C,
+	0xCB,
+	0xBB,
+	0x9C,
+	0xCC,
+	0xD6,
+	0x1C,
+	0xCE,
+	0xED,
+	0x8C,
+	0xCF,
+	0x03,
+	0x1D,
+	0xD1,
+	0x1B,
+	0x6D,
+	0xD2,
+	0x32,
+	0xBD,
+	0xD3,
+	0x47,
+	0x3D,
+	0xD5,
+	0x5E,
+	0x8D,
+	0xD6,
+	0x74,
+	0x1D,
+	0xD8,
+	0x8B,
+	0x6D,
+	0xD9,
+	0xA1,
+	0xAD,
+	0xDA,
+	0xB4,
+	0x1D,
+	0xDC,
+	0xCA,
+	0x4D,
+	0xDD,
+	0xDF,
+	0x7D,
+	0xDE,
+	0xEE,
+	0xAD,
+	0xDF,
+	0x05,
+	0xDE,
+	0xE0,
+	0x17,
+	0x1E,
+	0xE2,
+	0x28,
+	0x1E,
+	0xE3,
+	0x3B,
+	0x4E,
+	0xE4,
+	0x4B,
+	0x3E,
+	0xE5,
+	0x5B,
+	0x3E,
+	0xE6,
+	0x6B,
+	0x2E,
+	0xE7,
+	0x79,
+	0x1E,
+	0xE8,
+	0x8A,
+	0x2E,
+	0xE9,
+	0x98,
+	0xFE,
+	0xE9,
+	0xA8,
+	0x1E,
+	0xEB,
+	0xB8,
+	0xEE,
+	0xEB,
+	0xC6,
+	0xEE,
+	0xEC,
+	0xD4,
+	0xBE,
+	0xED,
+	0xE2,
+	0xAE,
+	0xEE,
+	0xF1,
+	0x7E,
+	0xEF,
+	0xFD,
+	0x2E,
+	0xF0,
+	0x08,
+	0xDF,
+	0xF0,
+	0x13,
+	0xAF,
+	0xF1,
+	0x20,
+	0x5F,
+	0xF2,
+	0x2B,
+	0x0F,
+	0xF3,
+	0x38,
+	0xFF,
+	0xF3,
+	0x44,
+	0x9F,
+	0xF4,
+	0x4D,
+	0x2F,
+	0xF5,
+	0x58,
+	0xDF,
+	0xF5,
+	0x63,
+	0x7F,
+	0xF6,
+	0x6B,
+	0x0F,
+	0xF7,
+	0x74,
+	0x8F,
+	0xF7,
+	0x7C,
+	0x0F,
+	0xF8,
+	0x86,
+	0xEF,
+	0xF8,
+	0x95,
+	0xCF,
+	0xF9,
+	0xA1,
+	0x6F,
+	0xFA,
+	0xAB,
+	0xFF,
+	0xFA,
+	0xB2,
+	0x5F,
+	0xFB,
+	0xB8,
+	0xBF,
+	0xFB,
+	0xBE,
+	0x1F,
+	0xFC,
+	0xC4,
+	0x7F,
+	0xFC,
+	0xCA,
+	0xDF,
+	0xFC,
+	0xD0,
+	0x3F,
+	0xFD,
+	0xD6,
+	0x8F,
+	0xFD,
+	0xDB,
+	0xEF,
+	0xFD,
+	0xE0,
+	0x6F,
+	0xFE,
+	0xEB,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x30,
+	0x00,
+	0x10,
+	0x80,
+	0x03,
+	0x6B,
+	0x00,
+	0x0A,
+	0xD4,
+	0xE0,
+	0x10,
+	0x3F,
+	0x01,
+	0x17,
+	0x9E,
+	0xE1,
+	0x1C,
+	0xFC,
+	0x91,
+	0x22,
+	0x58,
+	0x42,
+	0x28,
+	0xAC,
+	0x72,
+	0x2D,
+	0xF8,
+	0x22,
+	0x32,
+	0x45,
+	0x83,
+	0x36,
+	0x88,
+	0x83,
+	0x3A,
+	0xCB,
+	0xB3,
+	0x3E,
+	0x0A,
+	0x74,
+	0x42,
+	0x45,
+	0xE4,
+	0x45,
+	0x7C,
+	0x84,
+	0x49,
+	0xB8,
+	0x24,
+	0x4D,
+	0xED,
+	0x74,
+	0x50,
+	0x26,
+	0x05,
+	0x54,
+	0x5D,
+	0x85,
+	0x57,
+	0x98,
+	0x15,
+	0x5B,
+	0xCB,
+	0x85,
+	0x5E,
+	0x04,
+	0xF6,
+	0x61,
+	0x37,
+	0xF6,
+	0x64,
+	0x6A,
+	0x56,
+	0x68,
+	0xA0,
+	0x86,
+	0x6B,
+	0xD1,
+	0xB6,
+	0x6E,
+	0x05,
+	0xF7,
+	0x71,
+	0x37,
+	0xE7,
+	0x74,
+	0x68,
+	0x27,
+	0x78,
+	0x9B,
+	0xE7,
+	0x7A,
+	0xC5,
+	0xE7,
+	0x7D,
+	0xF7,
+	0xF7,
+	0x80,
+	0x27,
+	0xA8,
+	0x83,
+	0x51,
+	0x78,
+	0x86,
+	0x7E,
+	0x78,
+	0x89,
+	0xA9,
+	0xD8,
+	0x8B,
+	0xD5,
+	0xC8,
+	0x8E,
+	0xFF,
+	0x48,
+	0x91,
+	0x29,
+	0xE9,
+	0x93,
+	0x49,
+	0x09,
+	0x96,
+	0x72,
+	0x59,
+	0x98,
+	0x94,
+	0x89,
+	0x9A,
+	0xBA,
+	0xA9,
+	0x9C,
+	0xDA,
+	0xE9,
+	0x9E,
+	0x01,
+	0xFA,
+	0xA0,
+	0x22,
+	0x3A,
+	0xA3,
+	0x44,
+	0x3A,
+	0xA5,
+	0x68,
+	0x7A,
+	0xA7,
+	0x86,
+	0x9A,
+	0xA9,
+	0xA8,
+	0x7A,
+	0xAB,
+	0xC9,
+	0xDA,
+	0xAD,
+	0xEB,
+	0x9A,
+	0xAF,
+	0x0B,
+	0x9B,
+	0xB1,
+	0x28,
+	0x8B,
+	0xB3,
+	0x47,
+	0x5B,
+	0xB5,
+	0x64,
+	0x0B,
+	0xB7,
+	0x83,
+	0x1B,
+	0xB9,
+	0x9E,
+	0xDB,
+	0xBA,
+	0xBD,
+	0xAB,
+	0xBC,
+	0xD8,
+	0x6B,
+	0xBE,
+	0xF2,
+	0x2B,
+	0xC0,
+	0x11,
+	0xDC,
+	0xC1,
+	0x2A,
+	0x6C,
+	0xC3,
+	0x44,
+	0x5C,
+	0xC5,
+	0x63,
+	0xDC,
+	0xC6,
+	0x7B,
+	0x9C,
+	0xC8,
+	0x95,
+	0x1C,
+	0xCA,
+	0xAC,
+	0x7C,
+	0xCB,
+	0xC4,
+	0x5C,
+	0xCD,
+	0xE0,
+	0xBC,
+	0xCE,
+	0xF7,
+	0x3C,
+	0xD0,
+	0x11,
+	0xBD,
+	0xD1,
+	0x27,
+	0x3D,
+	0xD3,
+	0x3C,
+	0x8D,
+	0xD4,
+	0x54,
+	0xED,
+	0xD5,
+	0x69,
+	0x8D,
+	0xD7,
+	0x84,
+	0xED,
+	0xD8,
+	0x99,
+	0x4D,
+	0xDA,
+	0xAE,
+	0x8D,
+	0xDB,
+	0xC3,
+	0xCD,
+	0xDC,
+	0xD6,
+	0x1D,
+	0xDE,
+	0xEA,
+	0x4D,
+	0xDF,
+	0x00,
+	0x8E,
+	0xE0,
+	0x10,
+	0xAE,
+	0xE1,
+	0x24,
+	0xDE,
+	0xE2,
+	0x36,
+	0x0E,
+	0xE4,
+	0x48,
+	0xFE,
+	0xE4,
+	0x57,
+	0xFE,
+	0xE5,
+	0x68,
+	0x0E,
+	0xE7,
+	0x78,
+	0xFE,
+	0xE7,
+	0x88,
+	0x0E,
+	0xE9,
+	0x97,
+	0xEE,
+	0xE9,
+	0xA7,
+	0x1E,
+	0xEB,
+	0xB7,
+	0xDE,
+	0xEB,
+	0xC4,
+	0xDE,
+	0xEC,
+	0xD4,
+	0xBE,
+	0xED,
+	0xE2,
+	0xAE,
+	0xEE,
+	0xF1,
+	0x7E,
+	0xEF,
+	0xFD,
+	0x3E,
+	0xF0,
+	0x08,
+	0xEF,
+	0xF0,
+	0x14,
+	0xBF,
+	0xF1,
+	0x21,
+	0x7F,
+	0xF2,
+	0x2C,
+	0x2F,
+	0xF3,
+	0x38,
+	0xFF,
+	0xF3,
+	0x44,
+	0x9F,
+	0xF4,
+	0x4E,
+	0x3F,
+	0xF5,
+	0x5A,
+	0x0F,
+	0xF6,
+	0x65,
+	0x9F,
+	0xF6,
+	0x6D,
+	0x1F,
+	0xF7,
+	0x75,
+	0x9F,
+	0xF7,
+	0x7D,
+	0x1F,
+	0xF8,
+	0x86,
+	0xCF,
+	0xF8,
+	0x91,
+	0x4F,
+	0xF9,
+	0x97,
+	0xAF,
+	0xF9,
+	0x9D,
+	0x1F,
+	0xFA,
+	0xA5,
+	0xAF,
+	0xFA,
+	0xAE,
+	0x2F,
+	0xFB,
+	0xB4,
+	0x8F,
+	0xFB,
+	0xBB,
+	0xEF,
+	0xFB,
+	0xC0,
+	0x3F,
+	0xFC,
+	0xC5,
+	0x7F,
+	0xFC,
+	0xCA,
+	0xCF,
+	0xFC,
+	0xCE,
+	0x1F,
+	0xFD,
+	0xD4,
+	0x6F,
+	0xFD,
+	0xD9,
+	0xCF,
+	0xFD,
+	0xDF,
+	0x4F,
+	0xFE,
+	0xEA,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x91,
+	0xF0,
+	0x0E,
+	0x37,
+	0xD1,
+	0x17,
+	0xC1,
+	0xA1,
+	0x1F,
+	0x34,
+	0x92,
+	0x26,
+	0x9C,
+	0x92,
+	0x2C,
+	0xF9,
+	0xB2,
+	0x32,
+	0x55,
+	0x83,
+	0x37,
+	0x9C,
+	0xC3,
+	0x3B,
+	0xDA,
+	0xB3,
+	0x3F,
+	0x15,
+	0x34,
+	0x43,
+	0x4A,
+	0x04,
+	0x46,
+	0x7B,
+	0x24,
+	0x49,
+	0xAD,
+	0x04,
+	0x4C,
+	0xD5,
+	0x94,
+	0x4E,
+	0xFB,
+	0x54,
+	0x51,
+	0x28,
+	0xA5,
+	0x53,
+	0x4B,
+	0xD5,
+	0x55,
+	0x70,
+	0xE5,
+	0x57,
+	0x93,
+	0x35,
+	0x5A,
+	0xB0,
+	0x05,
+	0x5C,
+	0xCD,
+	0xC5,
+	0x5D,
+	0xEA,
+	0x75,
+	0x5F,
+	0x03,
+	0xF6,
+	0x60,
+	0x29,
+	0x16,
+	0x64,
+	0x58,
+	0xF6,
+	0x66,
+	0x88,
+	0x16,
+	0x6A,
+	0xB7,
+	0xE6,
+	0x6C,
+	0xE5,
+	0xE6,
+	0x6F,
+	0x15,
+	0xB7,
+	0x72,
+	0x43,
+	0x77,
+	0x75,
+	0x6D,
+	0x57,
+	0x78,
+	0x9B,
+	0xC7,
+	0x7A,
+	0xC1,
+	0x77,
+	0x7D,
+	0xED,
+	0x47,
+	0x80,
+	0x1A,
+	0x08,
+	0x83,
+	0x3E,
+	0x48,
+	0x85,
+	0x6A,
+	0x38,
+	0x88,
+	0x99,
+	0xA8,
+	0x8A,
+	0xBD,
+	0x38,
+	0x8D,
+	0xE8,
+	0x98,
+	0x8F,
+	0x0A,
+	0x09,
+	0x92,
+	0x33,
+	0x39,
+	0x94,
+	0x4D,
+	0x49,
+	0x96,
+	0x74,
+	0x49,
+	0x98,
+	0x91,
+	0x49,
+	0x9A,
+	0xB5,
+	0x59,
+	0x9C,
+	0xD1,
+	0x29,
+	0x9E,
+	0xF3,
+	0x49,
+	0xA0,
+	0x11,
+	0x3A,
+	0xA2,
+	0x32,
+	0x2A,
+	0xA4,
+	0x4F,
+	0x1A,
+	0xA6,
+	0x72,
+	0xEA,
+	0xA7,
+	0x8E,
+	0xFA,
+	0xA9,
+	0xAC,
+	0xAA,
+	0xAB,
+	0xCC,
+	0xFA,
+	0xAD,
+	0xEB,
+	0x8A,
+	0xAF,
+	0x07,
+	0x6B,
+	0xB1,
+	0x23,
+	0x2B,
+	0xB3,
+	0x42,
+	0xDB,
+	0xB4,
+	0x5B,
+	0x8B,
+	0xB6,
+	0x75,
+	0x6B,
+	0xB8,
+	0x94,
+	0xFB,
+	0xB9,
+	0xAC,
+	0xBB,
+	0xBB,
+	0xC7,
+	0x4B,
+	0xBD,
+	0xE3,
+	0xDB,
+	0xBE,
+	0xFA,
+	0xAB,
+	0xC0,
+	0x17,
+	0x3C,
+	0xC2,
+	0x30,
+	0xBC,
+	0xC3,
+	0x47,
+	0x7C,
+	0xC5,
+	0x64,
+	0xEC,
+	0xC6,
+	0x7B,
+	0x8C,
+	0xC8,
+	0x93,
+	0xFC,
+	0xC9,
+	0xAA,
+	0x6C,
+	0xCB,
+	0xC2,
+	0x2C,
+	0xCD,
+	0xDC,
+	0x7C,
+	0xCE,
+	0xF2,
+	0xDC,
+	0xCF,
+	0x0A,
+	0x6D,
+	0xD1,
+	0x1E,
+	0xBD,
+	0xD2,
+	0x37,
+	0x1D,
+	0xD4,
+	0x4E,
+	0x7D,
+	0xD5,
+	0x60,
+	0xDD,
+	0xD6,
+	0x7B,
+	0x6D,
+	0xD8,
+	0x90,
+	0xDD,
+	0xD9,
+	0xA7,
+	0xFD,
+	0xDA,
+	0xBA,
+	0x5D,
+	0xDC,
+	0xCF,
+	0xAD,
+	0xDD,
+	0xE4,
+	0xCD,
+	0xDE,
+	0xF7,
+	0x3D,
+	0xE0,
+	0x0B,
+	0x4E,
+	0xE1,
+	0x20,
+	0x8E,
+	0xE2,
+	0x30,
+	0xBE,
+	0xE3,
+	0x44,
+	0xCE,
+	0xE4,
+	0x54,
+	0xBE,
+	0xE5,
+	0x64,
+	0xFE,
+	0xE6,
+	0x77,
+	0xEE,
+	0xE7,
+	0x87,
+	0x0E,
+	0xE9,
+	0x98,
+	0x0E,
+	0xEA,
+	0xAA,
+	0x2E,
+	0xEB,
+	0xB9,
+	0xFE,
+	0xEB,
+	0xC9,
+	0x2E,
+	0xED,
+	0xD9,
+	0x0E,
+	0xEE,
+	0xE9,
+	0x1E,
+	0xEF,
+	0xF7,
+	0xEE,
+	0xEF,
+	0x04,
+	0xAF,
+	0xF0,
+	0x10,
+	0x8F,
+	0xF1,
+	0x1F,
+	0x5F,
+	0xF2,
+	0x2C,
+	0x3F,
+	0xF3,
+	0x3A,
+	0x1F,
+	0xF4,
+	0x47,
+	0xDF,
+	0xF4,
+	0x53,
+	0xAF,
+	0xF5,
+	0x61,
+	0x6F,
+	0xF6,
+	0x6C,
+	0x3F,
+	0xF7,
+	0x7A,
+	0x0F,
+	0xF8,
+	0x87,
+	0xEF,
+	0xF8,
+	0x93,
+	0x8F,
+	0xF9,
+	0x9C,
+	0x1F,
+	0xFA,
+	0xA6,
+	0xBF,
+	0xFA,
+	0xB0,
+	0x4F,
+	0xFB,
+	0xB8,
+	0xCF,
+	0xFB,
+	0xC0,
+	0x4F,
+	0xFC,
+	0xC7,
+	0xAF,
+	0xFC,
+	0xCD,
+	0x0F,
+	0xFD,
+	0xD4,
+	0x8F,
+	0xFD,
+	0xDC,
+	0x0F,
+	0xFE,
+	0xE8,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x00,
+	0x30,
+	0x00,
+	0x10,
+	0x80,
+	0x03,
+	0x6B,
+	0x00,
+	0x0A,
+	0xD4,
+	0xE0,
+	0x10,
+	0x3F,
+	0x01,
+	0x17,
+	0x9E,
+	0xE1,
+	0x1C,
+	0xFC,
+	0x91,
+	0x22,
+	0x58,
+	0x42,
+	0x28,
+	0xAC,
+	0x72,
+	0x2D,
+	0xF8,
+	0x22,
+	0x32,
+	0x45,
+	0x83,
+	0x36,
+	0x88,
+	0x83,
+	0x3A,
+	0xCB,
+	0xB3,
+	0x3E,
+	0x0A,
+	0x74,
+	0x42,
+	0x45,
+	0xE4,
+	0x45,
+	0x7C,
+	0x84,
+	0x49,
+	0xB8,
+	0x24,
+	0x4D,
+	0xED,
+	0x74,
+	0x50,
+	0x26,
+	0x05,
+	0x54,
+	0x5D,
+	0x85,
+	0x57,
+	0x98,
+	0x15,
+	0x5B,
+	0xCB,
+	0x85,
+	0x5E,
+	0x04,
+	0xF6,
+	0x61,
+	0x37,
+	0xF6,
+	0x64,
+	0x6A,
+	0x56,
+	0x68,
+	0xA0,
+	0x86,
+	0x6B,
+	0xD1,
+	0xB6,
+	0x6E,
+	0x05,
+	0xF7,
+	0x71,
+	0x37,
+	0xE7,
+	0x74,
+	0x68,
+	0x27,
+	0x78,
+	0x9B,
+	0xE7,
+	0x7A,
+	0xC5,
+	0xE7,
+	0x7D,
+	0xF7,
+	0xF7,
+	0x80,
+	0x27,
+	0xA8,
+	0x83,
+	0x51,
+	0x78,
+	0x86,
+	0x7E,
+	0x78,
+	0x89,
+	0xA9,
+	0xD8,
+	0x8B,
+	0xD5,
+	0xC8,
+	0x8E,
+	0xFF,
+	0x48,
+	0x91,
+	0x29,
+	0xE9,
+	0x93,
+	0x49,
+	0x09,
+	0x96,
+	0x72,
+	0x59,
+	0x98,
+	0x94,
+	0x89,
+	0x9A,
+	0xBA,
+	0xA9,
+	0x9C,
+	0xDA,
+	0xE9,
+	0x9E,
+	0x01,
+	0xFA,
+	0xA0,
+	0x22,
+	0x3A,
+	0xA3,
+	0x44,
+	0x3A,
+	0xA5,
+	0x68,
+	0x7A,
+	0xA7,
+	0x86,
+	0x9A,
+	0xA9,
+	0xA8,
+	0x7A,
+	0xAB,
+	0xC9,
+	0xDA,
+	0xAD,
+	0xEB,
+	0x9A,
+	0xAF,
+	0x0B,
+	0x9B,
+	0xB1,
+	0x28,
+	0x8B,
+	0xB3,
+	0x47,
+	0x5B,
+	0xB5,
+	0x64,
+	0x0B,
+	0xB7,
+	0x83,
+	0x1B,
+	0xB9,
+	0x9E,
+	0xDB,
+	0xBA,
+	0xBD,
+	0xAB,
+	0xBC,
+	0xD8,
+	0x6B,
+	0xBE,
+	0xF2,
+	0x2B,
+	0xC0,
+	0x11,
+	0xDC,
+	0xC1,
+	0x2A,
+	0x6C,
+	0xC3,
+	0x44,
+	0x5C,
+	0xC5,
+	0x63,
+	0xDC,
+	0xC6,
+	0x7B,
+	0x9C,
+	0xC8,
+	0x95,
+	0x1C,
+	0xCA,
+	0xAC,
+	0x7C,
+	0xCB,
+	0xC4,
+	0x5C,
+	0xCD,
+	0xE0,
+	0xBC,
+	0xCE,
+	0xF7,
+	0x3C,
+	0xD0,
+	0x11,
+	0xBD,
+	0xD1,
+	0x27,
+	0x3D,
+	0xD3,
+	0x3C,
+	0x8D,
+	0xD4,
+	0x54,
+	0xED,
+	0xD5,
+	0x69,
+	0x8D,
+	0xD7,
+	0x84,
+	0xED,
+	0xD8,
+	0x99,
+	0x4D,
+	0xDA,
+	0xAE,
+	0x8D,
+	0xDB,
+	0xC3,
+	0xCD,
+	0xDC,
+	0xD6,
+	0x1D,
+	0xDE,
+	0xEA,
+	0x4D,
+	0xDF,
+	0x00,
+	0x8E,
+	0xE0,
+	0x10,
+	0xAE,
+	0xE1,
+	0x24,
+	0xDE,
+	0xE2,
+	0x36,
+	0x0E,
+	0xE4,
+	0x48,
+	0xFE,
+	0xE4,
+	0x57,
+	0xFE,
+	0xE5,
+	0x68,
+	0x0E,
+	0xE7,
+	0x78,
+	0xFE,
+	0xE7,
+	0x88,
+	0x0E,
+	0xE9,
+	0x97,
+	0xEE,
+	0xE9,
+	0xA7,
+	0x1E,
+	0xEB,
+	0xB7,
+	0xDE,
+	0xEB,
+	0xC4,
+	0xDE,
+	0xEC,
+	0xD4,
+	0xBE,
+	0xED,
+	0xE2,
+	0xAE,
+	0xEE,
+	0xF1,
+	0x7E,
+	0xEF,
+	0xFD,
+	0x3E,
+	0xF0,
+	0x08,
+	0xEF,
+	0xF0,
+	0x14,
+	0xBF,
+	0xF1,
+	0x21,
+	0x7F,
+	0xF2,
+	0x2C,
+	0x2F,
+	0xF3,
+	0x38,
+	0xFF,
+	0xF3,
+	0x44,
+	0x9F,
+	0xF4,
+	0x4E,
+	0x3F,
+	0xF5,
+	0x5A,
+	0x0F,
+	0xF6,
+	0x65,
+	0x9F,
+	0xF6,
+	0x6D,
+	0x1F,
+	0xF7,
+	0x75,
+	0x9F,
+	0xF7,
+	0x7D,
+	0x1F,
+	0xF8,
+	0x86,
+	0xCF,
+	0xF8,
+	0x91,
+	0x4F,
+	0xF9,
+	0x97,
+	0xAF,
+	0xF9,
+	0x9D,
+	0x1F,
+	0xFA,
+	0xA5,
+	0xAF,
+	0xFA,
+	0xAE,
+	0x2F,
+	0xFB,
+	0xB4,
+	0x8F,
+	0xFB,
+	0xBB,
+	0xEF,
+	0xFB,
+	0xC0,
+	0x3F,
+	0xFC,
+	0xC5,
+	0x7F,
+	0xFC,
+	0xCA,
+	0xCF,
+	0xFC,
+	0xCE,
+	0x1F,
+	0xFD,
+	0xD4,
+	0x6F,
+	0xFD,
+	0xD9,
+	0xCF,
+	0xFD,
+	0xDF,
+	0x4F,
+	0xFE,
+	0xEA,
+	0x0F,
+	0xFF,
+	0xFF,
+	0x0F,
+	0x00,
+	0x1E,
+	0x00,
+	0x00,
+	0x00,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xF1,
+	0xE2,
+	0xE6,
+	0xCC,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xDC,
+	0xB8,
+	0xF8,
+	0xF0,
+	0xFE,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x7F,
+	0x80,
+	0xE0,
+	0x00,
+	0x80,
+	0x7E,
+	0x00,
+	0xE0,
+	0x00,
+	0xE0,
+	0x80,
+	0x7E,
+	0xE0,
+	0x00,
+	0x7E,
+	0x80,
+	0x68,
+	0x80,
+	0x80,
+	0x10,
+	0x80,
+	0x69,
+	0x10,
+	0x80,
+	0x10,
+	0x80,
+	0x80,
+	0x68,
+	0x80,
+	0x10,
+	0x69,
+	0x80,
+	0x60,
+	0x84,
+	0x78,
+	0x80,
+	0x90,
+	0x61,
+	0x80,
+	0x78,
+	0x80,
+	0x78,
+	0x80,
+	0x60,
+	0x78,
+	0x80,
+	0x60,
+	0x84,
+	0x01,
+	0x96,
+	0x7C,
+	0x80,
+	0x96,
+	0x00,
+	0x80,
+	0x78,
+	0x80,
+	0x78,
+	0x96,
+	0x00,
+	0x6C,
+	0x80,
+	0x00,
+	0x96,
+	0x80,
+	0x70,
+	0x16,
+	0x88,
+	0x70,
+	0x80,
+	0x88,
+	0x56,
+	0x88,
+	0x56,
+	0x70,
+	0x80,
+	0x06,
+	0x88,
+	0x81,
+	0x70,
+	0x80,
+	0x60,
+	0x50,
+	0xE8,
+	0x70,
+	0x80,
+	0xE8,
+	0x10,
+	0xE8,
+	0x10,
+	0x60,
+	0x80,
+	0x50,
+	0xE8,
+	0x80,
+	0x60,
+	0x80,
+	0x48,
+	0x80,
+	0x70,
+	0x4C,
+	0x80,
+	0x70,
+	0x80,
+	0x70,
+	0x80,
+	0x4C,
+	0x81,
+	0x80,
+	0x70,
+	0x80,
+	0x48,
+	0x90,
+	0x68,
+	0x80,
+	0x66,
+	0x68,
+	0x94,
+	0x66,
+	0x80,
+	0x66,
+	0x80,
+	0x68,
+	0x95,
+	0x80,
+	0x66,
+	0x90,
+	0x68,
+	0x78,
+	0x80,
+	0x80,
+	0x00,
+	0x80,
+	0x78,
+	0x00,
+	0x80,
+	0x00,
+	0x80,
+	0x80,
+	0x78,
+	0x80,
+	0x00,
+	0x78,
+	0x80,
+	0x68,
+	0x80,
+	0x80,
+	0x76,
+	0x80,
+	0x68,
+	0x76,
+	0x81,
+	0x76,
+	0x80,
+	0x80,
+	0x68,
+	0x80,
+	0x76,
+	0x68,
+	0x80,
+	0x10,
+	0x80,
+	0x7E,
+	0x80,
+	0x84,
+	0x00,
+	0x80,
+	0x7E,
+	0x80,
+	0x7F,
+	0x94,
+	0x00,
+	0x7E,
+	0x80,
+	0x00,
+	0x90,
+	0x00,
+	0xF0,
+	0x68,
+	0x80,
+	0xF0,
+	0x04,
+	0x80,
+	0x68,
+	0x80,
+	0x69,
+	0xF0,
+	0x04,
+	0x68,
+	0x90,
+	0x00,
+	0xF0,
+	0xC0,
+	0x70,
+	0x61,
+	0x88,
+	0x70,
+	0x80,
+	0x88,
+	0x60,
+	0x88,
+	0x60,
+	0x70,
+	0x80,
+	0x61,
+	0x98,
+	0xC0,
+	0x70,
+	0x90,
+	0x66,
+	0x10,
+	0x88,
+	0x66,
+	0x80,
+	0x88,
+	0x50,
+	0x88,
+	0x50,
+	0x76,
+	0x80,
+	0x11,
+	0x88,
+	0x80,
+	0x76,
+	0xE6,
+	0x08,
+	0x80,
+	0x74,
+	0x08,
+	0xE6,
+	0x70,
+	0x81,
+	0x70,
+	0x80,
+	0x08,
+	0xE6,
+	0x80,
+	0x74,
+	0xE6,
+	0x08,
+	0x94,
+	0x48,
+	0x81,
+	0x60,
+	0x48,
+	0x90,
+	0x60,
+	0x80,
+	0x60,
+	0x80,
+	0x48,
+	0x90,
+	0x80,
+	0x60,
+	0x94,
+	0x48,
+	0x7F,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x02,
+	0x28,
+	0x02,
+	0x2D,
+	0x02,
+	0x2E,
+	0x02,
+	0x2F,
+	0x02,
+	0x32,
+	0x02,
+	0x33,
+	0x02,
+	0x26,
+	0x02,
+	0x31,
+	0x02,
+	0x30,
+	0x02,
+	0x2B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA5,
+	0x00,
+	0x5F,
+	0x00,
+	0x19,
+	0x00,
+	0xF3,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x06,
+	0x00,
+	0x11,
+	0x00,
+	0xF8,
+	0x00,
+	0x38,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x20,
+	0x40,
+	0x60,
+	0x00,
+	0x80,
+	0xA0,
+	0xC0,
+	0xE0,
+	0x00,
+	0x00,
+	0x20,
+	0x40,
+	0x60,
+	0x55,
+	0x80,
+	0xA0,
+	0xC0,
+	0xE0,
+	0x55,
+	0x00,
+	0x20,
+	0x40,
+	0x60,
+	0xAA,
+	0x80,
+	0xA0,
+	0xC0,
+	0xE0,
+	0xAA,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x36,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+};
+
+#endif
+
+
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_drv.c b/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_drv.c
index ece2ab8a72f0..0613d8fa4079 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_drv.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_drv.c
@@ -128,7 +128,6 @@ static void lcd_venc_set(struct lcd_config_s *pconf)
 {
 	unsigned int h_active, v_active;
 	unsigned int video_on_pixel, video_on_line;
-	unsigned int pre_de_vs = 0, pre_de_ve = 0, pre_de_hs = 0, pre_de_he = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
 	if (lcd_debug_print_flag)
@@ -156,27 +155,19 @@ static void lcd_venc_set(struct lcd_config_s *pconf)
 	lcd_vcbus_write(ENCL_VIDEO_HAVON_END,   h_active - 1 + video_on_pixel);
 	lcd_vcbus_write(ENCL_VIDEO_VAVON_BLINE, video_on_line);
 	lcd_vcbus_write(ENCL_VIDEO_VAVON_ELINE, v_active - 1  + video_on_line);
-	if ((pconf->lcd_basic.lcd_type == LCD_P2P) ||
-	    (pconf->lcd_basic.lcd_type == LCD_MLVDS)) {
-		switch (lcd_drv->data->chip_type) {
-		case LCD_CHIP_TL1:
-		case LCD_CHIP_TM2:
-			pre_de_vs = video_on_line - 1 - 4;
-			pre_de_ve = video_on_line - 1;
-			pre_de_hs = video_on_pixel + PRE_DE_DELAY;
-			pre_de_he = h_active - 1 + pre_de_hs;
-			break;
-		default:
-			pre_de_vs = video_on_line - 8;
-			pre_de_ve = v_active + pre_de_vs;
-			pre_de_hs = video_on_pixel + PRE_DE_DELAY;
-			pre_de_he = h_active - 1 + pre_de_hs;
-			break;
-		}
-		lcd_vcbus_write(ENCL_VIDEO_V_PRE_DE_BLINE, pre_de_vs);
-		lcd_vcbus_write(ENCL_VIDEO_V_PRE_DE_ELINE, pre_de_ve);
-		lcd_vcbus_write(ENCL_VIDEO_H_PRE_DE_BEGIN, pre_de_hs);
-		lcd_vcbus_write(ENCL_VIDEO_H_PRE_DE_END, pre_de_he);
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_P2P:
+		lcd_vcbus_write(ENCL_VIDEO_V_PRE_DE_BLINE,
+			video_on_line - 1 - 4);
+		lcd_vcbus_write(ENCL_VIDEO_V_PRE_DE_ELINE,
+			video_on_line - 1);
+		lcd_vcbus_write(ENCL_VIDEO_H_PRE_DE_BEGIN,
+			video_on_pixel + PRE_DE_DELAY);
+		lcd_vcbus_write(ENCL_VIDEO_H_PRE_DE_END,
+			h_active - 1 + video_on_pixel + PRE_DE_DELAY);
+		break;
+	default:
+		break;
 	}
 
 	lcd_vcbus_write(ENCL_VIDEO_HSO_BEGIN,   pconf->lcd_timing.hs_hs_addr);
@@ -195,8 +186,6 @@ static void lcd_venc_set(struct lcd_config_s *pconf)
 		lcd_vcbus_write(ENCL_INBUF_CNTL0, 0x200);
 		break;
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		/*[15:14]: 2'b10 or 2'b01, bit13:1*/
 		lcd_vcbus_write(ENCL_INBUF_CNTL1, (5 << 13) | (h_active - 1));
 		lcd_vcbus_write(ENCL_INBUF_CNTL0, 0x200);
@@ -227,8 +216,6 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
 		reg_cntl1 = HHI_LVDS_TX_PHY_CNTL1_TL1;
 		break;
@@ -244,25 +231,23 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 		phy_div = 1;
 
 	/* set fifo_clk_sel: div 7 */
-	lcd_ana_write(reg_cntl0, (1 << 6));
+	lcd_hiu_write(reg_cntl0, (1 << 6));
 	/* set cntl_ser_en:  8-channel to 1 */
-	lcd_ana_setb(reg_cntl0, 0xfff, 16, 12);
+	lcd_hiu_setb(reg_cntl0, 0xfff, 16, 12);
 	switch (lcd_drv->data->chip_type) { /* pn swap */
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		lcd_ana_setb(reg_cntl0, 1, 2, 1);
+		lcd_hiu_setb(reg_cntl0, 1, 2, 1);
 		break;
 	default:
 		break;
 	}
 
 	/* decoupling fifo enable, gated clock enable */
-	lcd_ana_write(reg_cntl1,
+	lcd_hiu_write(reg_cntl1,
 		(1 << 30) | ((phy_div - 1) << 25) | (1 << 24));
 	/* decoupling fifo write enable after fifo enable */
-	lcd_ana_setb(reg_cntl1, 1, 31, 1);
+	lcd_hiu_setb(reg_cntl1, 1, 31, 1);
 }
 
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
@@ -321,43 +306,8 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-		if (port_swap) {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x456789ab);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x0123);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x10ba9876);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x5432);
-			}
-		} else {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0xab012345);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x6789);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x76543210);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0xba98);
-			}
-		}
-		break;
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		if (port_swap) {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x345789ab);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x0612);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x210a9876);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x5b43);
-			}
-		} else {
-			if (lane_reverse) {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0xab12345);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0x60789);
-			} else {
-				lcd_vcbus_write(P2P_CH_SWAP0, 0x87643210);
-				lcd_vcbus_write(P2P_CH_SWAP1, 0xb5a9);
-			}
-		}
+		lcd_vcbus_write(P2P_CH_SWAP0, 0x76543210);
+		lcd_vcbus_write(P2P_CH_SWAP1, 0xba98);
 		break;
 	default:
 		lcd_vcbus_setb(LCD_PORT_SWAP, port_swap, 12, 1);
@@ -399,16 +349,16 @@ static void lcd_mlvds_control_set(struct lcd_config_s *pconf)
 	}
 
 	/* fifo_clk_sel[7:6]: 0=div6, 1=div 7, 2=div8, 3=div10 */
-	lcd_ana_write(HHI_LVDS_TX_PHY_CNTL0_TL1, (div_sel << 6));
+	lcd_hiu_write(HHI_LVDS_TX_PHY_CNTL0_TL1, (div_sel << 6));
 	/* serializer_en[27:16] */
-	lcd_ana_setb(HHI_LVDS_TX_PHY_CNTL0_TL1, 0xfff, 16, 12);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0_TL1, 0xfff, 16, 12);
 	/* pn swap[2] */
-	lcd_ana_setb(HHI_LVDS_TX_PHY_CNTL0_TL1, 1, 2, 1);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0_TL1, 1, 2, 1);
 
 	/* fifo enable[30], phy_clock gating[24] */
-	lcd_ana_write(HHI_LVDS_TX_PHY_CNTL1_TL1, (1 << 30) | (1 << 24));
+	lcd_hiu_write(HHI_LVDS_TX_PHY_CNTL1_TL1, (1 << 30) | (1 << 24));
 	/* fifo write enable[31] */
-	lcd_ana_setb(HHI_LVDS_TX_PHY_CNTL1_TL1, 1, 31, 1);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL1_TL1, 1, 31, 1);
 
 	channel_sel0 = pconf->lcd_control.mlvds_config->channel_sel0;
 	channel_sel1 = pconf->lcd_control.mlvds_config->channel_sel1;
@@ -418,9 +368,9 @@ static void lcd_mlvds_control_set(struct lcd_config_s *pconf)
 	lcd_tcon_enable(pconf);
 }
 
-static void lcd_mlvds_disable(struct lcd_config_s *pconf)
+static void lcd_mlvds_disable(void)
 {
-	lcd_tcon_disable(pconf);
+	lcd_tcon_disable();
 }
 
 #if 0
@@ -455,8 +405,6 @@ static void lcd_vbyone_clk_util_set(struct lcd_config_s *pconf)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
 		reg_cntl1 = HHI_LVDS_TX_PHY_CNTL1_TL1;
 		break;
@@ -484,25 +432,23 @@ static void lcd_vbyone_clk_util_set(struct lcd_config_s *pconf)
 		break;
 	}
 	/* set fifo_clk_sel */
-	lcd_ana_write(reg_cntl0, (div_sel << 6));
+	lcd_hiu_write(reg_cntl0, (div_sel << 6));
 	/* set cntl_ser_en:  8-channel to 1 */
-	lcd_ana_setb(reg_cntl0, 0xfff, 16, 12);
+	lcd_hiu_setb(reg_cntl0, 0xfff, 16, 12);
 	switch (lcd_drv->data->chip_type) { /* pn swap */
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		lcd_ana_setb(reg_cntl0, 1, 2, 1);
+		lcd_hiu_setb(reg_cntl0, 1, 2, 1);
 		break;
 	default:
 		break;
 	}
 
 	/* decoupling fifo enable, gated clock enable */
-	lcd_ana_write(reg_cntl1,
+	lcd_hiu_write(reg_cntl1,
 		(1 << 30) | ((phy_div - 1) << 25) | (1 << 24));
 	/* decoupling fifo write enable after fifo enable */
-	lcd_ana_setb(reg_cntl1, 1, 31, 1);
+	lcd_hiu_setb(reg_cntl1, 1, 31, 1);
 }
 
 static int lcd_vbyone_lanes_set(int lane_num, int byte_mode, int region_num,
@@ -600,8 +546,6 @@ static void lcd_vbyone_hw_filter(int flag)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		if (flag) {
 			period = vx1_conf->hw_filter_time & 0xff;
 			if (period >=
@@ -614,21 +558,13 @@ static void lcd_vbyone_hw_filter(int flag)
 			temp = (period >> 16) & 0xf;
 			lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_H, temp);
 			/* hpd */
-			temp = vx1_conf->hw_filter_cnt & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 8, 4);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INSGN_CTRL, temp, 8, 4);
-			}
+			temp = vx1_conf->hw_filter_cnt & 0xf;
+			temp = (temp == 0) ? 0x7 : temp;
+			lcd_vcbus_setb(VBO_INSGN_CTRL, temp, 8, 4);
 			/* lockn */
-			temp = (vx1_conf->hw_filter_cnt >> 8) & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 12, 4);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INSGN_CTRL, temp, 12, 4);
-			}
+			temp = (vx1_conf->hw_filter_cnt >> 8) & 0xf;
+			temp = (temp == 0) ? 0x7 : temp;
+			lcd_vcbus_setb(VBO_INSGN_CTRL, temp, 12, 4);
 		} else {
 			temp = (vx1_conf->hw_filter_time >> 8) & 0x1;
 			if (temp) {
@@ -636,69 +572,30 @@ static void lcd_vbyone_hw_filter(int flag)
 						0xff);
 				lcd_vcbus_write(VBO_INFILTER_TICK_PERIOD_H,
 						0x0);
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 8, 4);
-				lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 12, 4);
-				LCDPR("%s: %d disable for debug\n",
-				      __func__, flag);
+				lcd_vcbus_setb(VBO_INSGN_CTRL, 0x7, 8, 4);
+				lcd_vcbus_setb(VBO_INSGN_CTRL, 0x7, 12, 4);
+				LCDPR("%s: %d change to min for debug\n",
+				       __func__, flag);
 			}
 		}
 		break;
 	default:
-		if (flag) {
-			lcd_vcbus_setb(VBO_INFILTER_CTRL, 0xff, 8, 8);
-			/* hpd */
-			temp = vx1_conf->hw_filter_cnt & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, 0, 0, 3);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, temp, 0, 3);
-			}
-			/* lockn */
-			temp = (vx1_conf->hw_filter_cnt >> 8) & 0xff;
-			if (temp == 0xff) {
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, 0, 4, 3);
-			} else {
-				temp = (temp == 0) ? 0x7 : temp;
-				lcd_vcbus_setb(VBO_INFILTER_CTRL, temp, 4, 3);
-			}
-		} else {
-			temp = (vx1_conf->hw_filter_time >> 8) & 0x1;
-			if (temp) {
-				lcd_vcbus_write(VBO_INFILTER_CTRL, 0xff00);
-				LCDPR("%s: %d disable for debug\n",
-				      __func__, flag);
-			}
-		}
+		lcd_vcbus_write(VBO_INFILTER_CTRL, 0xff77);
 		break;
 	}
 }
 
 static void lcd_vbyone_sw_reset(void)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned int reg_cntl0;
-
-	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TL1:
-	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
-		break;
-	default:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0;
-		break;
-	}
-
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
 
 	/* force PHY to 0 */
-	lcd_ana_setb(reg_cntl0, 3, 8, 2);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
 	lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
 	udelay(5);
 	/* realease PHY */
-	lcd_ana_setb(reg_cntl0, 0, 8, 2);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
 	lcd_vcbus_write(VBO_SOFT_RST, 0);
 }
 
@@ -805,8 +702,6 @@ static void lcd_vbyone_control_set(struct lcd_config_s *pconf)
 	 * lcd_vcbus_setb(VBO_PXL_CTRL,0x3,VBO_PXL_CTR1_BIT,VBO_PXL_CTR1_WID);
 	 * set_vbyone_ctlbits(1,0,0);
 	 */
-	/* VBO_RGN_GEN clk always on */
-	lcd_vcbus_setb(VBO_GCLK_MAIN, 2, 2, 2);
 
 	/* PAD select: */
 	if ((lane_count == 1) || (lane_count == 2))
@@ -820,7 +715,7 @@ static void lcd_vbyone_control_set(struct lcd_config_s *pconf)
 	/* Mux pads in combo-phy: 0 for dsi; 1 for lvds or vbyone; 2 for edp */
 	/*lcd_hiu_write(HHI_DSI_LVDS_EDP_CNTL0, 0x1);*/
 
-	lcd_vbyone_hw_filter(1);
+	lcd_vbyone_hw_filter(0);
 	lcd_vcbus_setb(VBO_INSGN_CTRL, 0, 2, 2);
 	lcd_vcbus_setb(VBO_CTRL_L, 1, 0, 1);
 
@@ -866,8 +761,7 @@ void lcd_vbyone_interrupt_enable(int flag)
 			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 9);
 
 			/* set hold in FSM_ACQ */
-			if ((vx1_conf->vsync_intr_en == 3) |
-				(vx1_conf->vsync_intr_en == 4))
+			if (vx1_conf->vsync_intr_en == 3)
 				lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0, 0, 16);
 			else
 				lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0xffff, 0, 16);
@@ -880,8 +774,7 @@ void lcd_vbyone_interrupt_enable(int flag)
 			if (vx1_conf->vsync_intr_en) {
 				/* keep holder for vsync monitor enabled */
 				/* set hold in FSM_ACQ */
-				if ((vx1_conf->vsync_intr_en == 3) |
-					(vx1_conf->vsync_intr_en == 4))
+				if (vx1_conf->vsync_intr_en == 3)
 					lcd_vcbus_setb(VBO_FSM_HOLDER_L,
 						0, 0, 16);
 				else
@@ -919,11 +812,10 @@ static void lcd_vbyone_interrupt_init(struct aml_lcd_drv_s *lcd_drv)
 	lcd_vbyone_hw_filter(1);
 
 	/* set hold in FSM_ACQ */
-	if ((vx1_conf->vsync_intr_en == 3) |
-		(vx1_conf->vsync_intr_en == 4))
+	if (vx1_conf->vsync_intr_en == 3)
 		lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0, 0, 16);
 	else
-		lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0xffff, 0, 16);
+	lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0xffff, 0, 16);
 	/* set hold in FSM_CDR */
 	lcd_vcbus_setb(VBO_FSM_HOLDER_H, 0, 0, 16);
 	/* not wait lockn to 1 in FSM_ACQ */
@@ -1084,20 +976,6 @@ static void lcd_vx1_hpll_timer_handler(unsigned long arg)
 
 static void lcd_vx1_hold_reset(void)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	unsigned int reg_cntl0;
-
-	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TL1:
-	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
-		break;
-	default:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0;
-		break;
-	}
-
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
 
@@ -1111,13 +989,13 @@ static void lcd_vx1_hold_reset(void)
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
 
 	/* force PHY to 0 */
-	lcd_ana_setb(reg_cntl0, 3, 8, 2);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
 	lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
 	udelay(5);
 	/* clear lockn raising flag */
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 7, 1);
 	/* realease PHY */
-	lcd_ana_setb(reg_cntl0, 0, 8, 2);
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
 	/* clear lockn raising flag */
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 7, 1);
 	lcd_vcbus_write(VBO_SOFT_RST, 0);
@@ -1162,27 +1040,7 @@ static irqreturn_t lcd_vbyone_vsync_isr(int irq, void *dev_id)
 		return IRQ_HANDLED;
 	}
 
-	if (vx1_conf->vsync_intr_en == 4) {
-		if (vsync_cnt == 3) {
-			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0x3ff, 0, 10);
-			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 10);
-			vsync_cnt++;
-		} else if (vsync_cnt >= 5) {
-			vsync_cnt = 0;
-			if ((lcd_vcbus_read(VBO_INTR_STATE) & 0x40)) {
-				lcd_vbyone_hw_filter(0);
-				lcd_vbyone_sw_reset();
-				LCDPR("vx1 sw_reset 4\n");
-				while (lcd_vcbus_read(VBO_STATUS_L) & 0x4)
-					break;
-				lcd_vcbus_setb(VBO_INTR_STATE_CTRL,
-					       0x3ff, 0, 10);
-				lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 10);
-				lcd_vbyone_hw_filter(1);
-			}
-		} else
-			vsync_cnt++;
-	} else if (vx1_conf->vsync_intr_en == 3) {
+	if (vx1_conf->vsync_intr_en == 3) {
 		if (vsync_cnt < VSYNC_CNT_VX1_RESET)
 			vsync_cnt++;
 		else if (vsync_cnt == VSYNC_CNT_VX1_RESET) {
@@ -1255,26 +1113,8 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 	int encl_clk;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vbyone_config_s *vx1_conf;
-	unsigned int reg_cntl0;
-
-	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TL1:
-	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
-		break;
-	default:
-		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0;
-		break;
-	}
-
-	if ((lcd_drv->lcd_status & LCD_STATUS_IF_ON) == 0)
-		return IRQ_HANDLED;
 
 	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
-	if ((vx1_conf->vsync_intr_en == 2) |
-		(vx1_conf->vsync_intr_en == 4))
-		return IRQ_HANDLED;
 
 	lcd_vcbus_write(VBO_INTR_UNMASK, 0x0);  /* mask interrupt */
 
@@ -1291,14 +1131,13 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, data32_1, 0, 9);
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 9);
 	if (lcd_debug_print_flag) {
-		LCDPR
-		("vx1 intr status = 0x%04x, encl_clkmsr = %d, vysnc_cnt = %d\n",
-		 data32, encl_clk, vsync_cnt);
+		LCDPR("vx1 intr status = 0x%04x, encl_clkmsr = %d",
+			data32, encl_clk);
 	}
 
 	if (vx1_conf->vsync_intr_en == 3) {
 		if (data32 & 0x1000) {
-			if (vsync_cnt >= VSYNC_CNT_VX1_STABLE) {
+			if (vsync_cnt >= (VSYNC_CNT_VX1_RESET + 1)) {
 				vsync_cnt = 0;
 				LCDPR("vx1 lockn rise edge occurred\n");
 			}
@@ -1341,13 +1180,13 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 				lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
 				LCDPR("vx1 sw reset\n");
 				/* force PHY to 0 */
-				lcd_ana_setb(reg_cntl0, 3, 8, 2);
+				lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
 				lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
 				udelay(5);
 				/* clear lockn raising flag */
 				lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 7, 1);
 				/* realease PHY */
-				lcd_ana_setb(reg_cntl0, 0, 8, 2);
+				lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
 				/* clear lockn raising flag */
 				lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 7, 1);
 				lcd_vcbus_write(VBO_SOFT_RST, 0);
@@ -1374,13 +1213,13 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 				LCDPR("vx1 reset for timing err\n");
 			vx1_fsm_acq_st = 0;
 			/* force PHY to 0 */
-			lcd_ana_setb(reg_cntl0, 3, 8, 2);
+			lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
 			lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
 			udelay(5);
 			/* clear lockn raising flag */
 			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 7, 1);
 			/* realease PHY */
-			lcd_ana_setb(reg_cntl0, 0, 8, 2);
+			lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
 			/* clear lockn raising flag */
 			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 7, 1);
 			lcd_vcbus_write(VBO_SOFT_RST, 0);
@@ -1407,17 +1246,15 @@ static void lcd_p2p_control_set(struct lcd_config_s *pconf)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	unsigned int reg_cntl0, reg_cntl1;
-	unsigned int phy_div, p2p_type;
+	unsigned int phy_div;
 	unsigned int channel_sel0, channel_sel1;
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
 
 	/* phy_div: 0=div6, 1=div 7, 2=div8, 3=div10 */
-	p2p_type = pconf->lcd_control.p2p_config->p2p_type & 0x1f;
-	switch (p2p_type) {
+	switch (pconf->lcd_control.p2p_config->p2p_type) {
 	case P2P_CHPI: /* 8/10 coding */
-	case P2P_USIT:
 		phy_div = 3;
 		break;
 	default:
@@ -1428,8 +1265,6 @@ static void lcd_p2p_control_set(struct lcd_config_s *pconf)
 	switch (lcd_drv->data->chip_type) {
 	case LCD_CHIP_TL1:
 	case LCD_CHIP_TM2:
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
 		reg_cntl0 = HHI_LVDS_TX_PHY_CNTL0_TL1;
 		reg_cntl1 = HHI_LVDS_TX_PHY_CNTL1_TL1;
 		break;
@@ -1440,16 +1275,16 @@ static void lcd_p2p_control_set(struct lcd_config_s *pconf)
 	}
 
 	/* fifo_clk_sel[7:6]: 0=div6, 1=div 7, 2=div8, 3=div10 */
-	lcd_ana_write(reg_cntl0, (phy_div << 6));
+	lcd_hiu_write(reg_cntl0, (phy_div << 6));
 	/* serializer_en[27:16] */
-	lcd_ana_setb(reg_cntl0, 0xfff, 16, 12);
+	lcd_hiu_setb(reg_cntl0, 0xfff, 16, 12);
 	/* pn swap[2] */
-	lcd_ana_setb(reg_cntl0, 1, 2, 1);
+	lcd_hiu_setb(reg_cntl0, 1, 2, 1);
 
 	/* fifo enable[30], phy_clock gating[24] */
-	lcd_ana_write(reg_cntl1, (1 << 30) | (1 << 24));
+	lcd_hiu_write(reg_cntl1, (1 << 30) | (1 << 24));
 	/* fifo write enable[31] */
-	lcd_ana_setb(reg_cntl1, 1, 31, 1);
+	lcd_hiu_setb(reg_cntl1, 1, 31, 1);
 
 	channel_sel0 = pconf->lcd_control.p2p_config->channel_sel0;
 	channel_sel1 = pconf->lcd_control.p2p_config->channel_sel1;
@@ -1459,9 +1294,9 @@ static void lcd_p2p_control_set(struct lcd_config_s *pconf)
 	lcd_tcon_enable(pconf);
 }
 
-static void lcd_p2p_disable(struct lcd_config_s *pconf)
+static void lcd_p2p_disable(void)
 {
-	lcd_tcon_disable(pconf);
+	lcd_tcon_disable();
 }
 
 static unsigned int vbyone_lane_num[] = {
@@ -1539,7 +1374,6 @@ static void lcd_mlvds_config_set(struct lcd_config_s *pconf)
 	unsigned int lcd_bits, channel_num;
 	unsigned int channel_sel0, channel_sel1, pi_clk_sel = 0;
 	unsigned int i, temp;
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s\n", __func__);
@@ -1560,72 +1394,41 @@ static void lcd_mlvds_config_set(struct lcd_config_s *pconf)
 	/* pi_clk select */
 	channel_sel0 = pconf->lcd_control.mlvds_config->channel_sel0;
 	channel_sel1 = pconf->lcd_control.mlvds_config->channel_sel1;
-	switch (lcd_drv->data->chip_type) {
-	case LCD_CHIP_TL1:
-	case LCD_CHIP_TM2:
-		/* mlvds channel:    //tx 12 channels
-		 *    0: clk_a
-		 *    1: d0_a
-		 *    2: d1_a
-		 *    3: d2_a
-		 *    4: d3_a
-		 *    5: d4_a
-		 *    6: clk_b
-		 *    7: d0_b
-		 *    8: d1_b
-		 *    9: d2_b
-		 *   10: d3_b
-		 *   11: d4_b
-		 */
-		for (i = 0; i < 8; i++) {
-			temp = (channel_sel0 >> (i * 4)) & 0xf;
-			if ((temp == 0) || (temp == 6))
-				pi_clk_sel |= (1 << i);
-		}
-		for (i = 0; i < 4; i++) {
-			temp = (channel_sel1 >> (i * 4)) & 0xf;
-			if ((temp == 0) || (temp == 6))
-				pi_clk_sel |= (1 << (i + 8));
-		}
-		break;
-	case LCD_CHIP_T5:
-	case LCD_CHIP_T5D:
-		/* mlvds channel:    //tx 8 channels
-		 *    0: d0_a
-		 *    1: d1_a
-		 *    2: d2_a
-		 *    3: clk_a
-		 *    4: d0_b
-		 *    5: d1_b
-		 *    6: d2_b
-		 *    7: clk_b
-		 */
-		for (i = 0; i < 8; i++) {
-			temp = (channel_sel0 >> (i * 4)) & 0xf;
-			if ((temp == 3) || (temp == 7))
-				pi_clk_sel |= (1 << i);
-		}
-		for (i = 0; i < 4; i++) {
-			temp = (channel_sel1 >> (i * 4)) & 0xf;
-			if ((temp == 3) || (temp == 7))
-				pi_clk_sel |= (1 << (i + 8));
-		}
-		break;
-	default:
-		break;
+	/* mlvds channel:    //tx 12 channels
+	 *    0: clk_a
+	 *    1: d0_a
+	 *    2: d1_a
+	 *    3: d2_a
+	 *    4: d3_a
+	 *    5: d4_a
+	 *    6: clk_b
+	 *    7: d0_b
+	 *    8: d1_b
+	 *    9: d2_b
+	 *   10: d3_b
+	 *   11: d4_b
+	 */
+	for (i = 0; i < 8; i++) {
+		temp = (channel_sel0 >> (i*4)) & 0xf;
+		if ((temp == 0) || (temp == 6))
+			pi_clk_sel |= (1 << i);
+	}
+	for (i = 0; i < 4; i++) {
+		temp = (channel_sel1 >> (i*4)) & 0xf;
+		if ((temp == 0) || (temp == 6))
+			pi_clk_sel |= (1 << (i + 8));
 	}
-
 	pconf->lcd_control.mlvds_config->pi_clk_sel = pi_clk_sel;
 	if (lcd_debug_print_flag) {
-		LCDPR
-	("channel_sel0=0x%08x, channel_sel1=0x%08x, pi_clk_sel=0x%03x\n",
-	 channel_sel0, channel_sel1, pi_clk_sel);
+		LCDPR(
+		"channel_sel0=0x%08x, channel_sel1=0x%08x, pi_clk_sel=0x%03x\n",
+			channel_sel0, channel_sel1, pi_clk_sel);
 	}
 }
 
 static void lcd_p2p_config_set(struct lcd_config_s *pconf)
 {
-	unsigned int bit_rate, pclk, p2p_type;
+	unsigned int bit_rate, pclk;
 	unsigned int lcd_bits, lane_num;
 
 	if (lcd_debug_print_flag)
@@ -1634,8 +1437,7 @@ static void lcd_p2p_config_set(struct lcd_config_s *pconf)
 	lcd_bits = pconf->lcd_basic.lcd_bits;
 	lane_num = pconf->lcd_control.p2p_config->lane_num;
 	pclk = pconf->lcd_timing.lcd_clk / 1000;
-	p2p_type = pconf->lcd_control.p2p_config->p2p_type & 0x1f;
-	switch (p2p_type) {
+	switch (pconf->lcd_control.p2p_config->p2p_type) {
 	case P2P_CEDS:
 		if (pclk >= 600000)
 			bit_rate = pclk * 3 * lcd_bits / lane_num;
@@ -1809,17 +1611,11 @@ int lcd_tv_driver_init(void)
 		break;
 	case LCD_MLVDS:
 		lcd_mlvds_control_set(pconf);
-		if (pconf->customer_pinmux)
-			lcd_customer_pinmux_set(1);
-		else
-			lcd_mlvds_pinmux_set(1);
+		lcd_tcon_pinmux_set(1);
 		lcd_mlvds_phy_set(pconf, 1);
 		break;
 	case LCD_P2P:
-		if (pconf->customer_pinmux)
-			lcd_customer_pinmux_set(1);
-		else
-			lcd_p2p_pinmux_set(1);
+		lcd_tcon_pinmux_set(1);
 		lcd_p2p_phy_set(pconf, 1);
 		lcd_p2p_control_set(pconf);
 		break;
@@ -1859,20 +1655,14 @@ void lcd_tv_driver_disable(void)
 		lcd_vbyone_disable();
 		break;
 	case LCD_MLVDS:
-		lcd_mlvds_disable(pconf);
+		lcd_mlvds_disable();
 		lcd_mlvds_phy_set(pconf, 0);
-		if (pconf->customer_pinmux)
-			lcd_customer_pinmux_set(0);
-		else
-			lcd_mlvds_pinmux_set(0);
+		lcd_tcon_pinmux_set(0);
 		break;
 	case LCD_P2P:
-		lcd_p2p_disable(pconf);
+		lcd_p2p_disable();
 		lcd_p2p_phy_set(pconf, 0);
-		if (pconf->customer_pinmux)
-			lcd_customer_pinmux_set(0);
-		else
-			lcd_p2p_pinmux_set(0);
+		lcd_tcon_pinmux_set(0);
 		break;
 	default:
 		break;
diff --git a/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_tv.c b/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_tv.c
index 28fb9def3356..02d152d8ee6c 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_tv.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_tv/lcd_tv.c
@@ -50,15 +50,10 @@ static int lcd_init_on_flag;
  * lcd mode function
  * **************************************************
  */
-#define ACTIVE_FRAME_RATE_CNT     3
-#define LCD_STD_FRAME_RATE_MAX    5
-static unsigned int lcd_std_frame_rate[][3] = {
-	{60, 60,    1},
-	{59, 60000, 1001},
-	{50, 50,    1},
-	{48, 48,    1},
-	{47, 48000, 1001},
-	{60, 60,    1}
+static unsigned int lcd_std_frame_rate[] = {
+	50,
+	60,
+	48,
 };
 
 struct lcd_vmode_info_s {
@@ -67,7 +62,6 @@ struct lcd_vmode_info_s {
 	unsigned int width;
 	unsigned int height;
 	unsigned int frame_rate;
-	unsigned int frac;
 };
 
 enum lcd_vmode_e {
@@ -85,7 +79,6 @@ static struct lcd_vmode_info_s lcd_vmode_info[] = {
 		.width             = 1024,
 		.height            = 600,
 		.frame_rate        = 60,
-		.frac              = 0,
 	},
 	{
 		.name              = "768p",
@@ -93,7 +86,6 @@ static struct lcd_vmode_info_s lcd_vmode_info[] = {
 		.width             = 1366,
 		.height            = 768,
 		.frame_rate        = 60,
-		.frac              = 0,
 	},
 	{
 		.name              = "1080p",
@@ -101,7 +93,6 @@ static struct lcd_vmode_info_s lcd_vmode_info[] = {
 		.width             = 1920,
 		.height            = 1080,
 		.frame_rate        = 60,
-		.frac              = 0,
 	},
 	{
 		.name              = "2160p",
@@ -109,7 +100,6 @@ static struct lcd_vmode_info_s lcd_vmode_info[] = {
 		.width             = 3840,
 		.height            = 2160,
 		.frame_rate        = 60,
-		.frac              = 0,
 	},
 	{
 		.name              = "invalid",
@@ -117,7 +107,6 @@ static struct lcd_vmode_info_s lcd_vmode_info[] = {
 		.width             = 1920,
 		.height            = 1080,
 		.frame_rate        = 60,
-		.frac              = 0,
 	},
 };
 
@@ -126,9 +115,6 @@ static int lcd_vmode_is_mached(int index)
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lcd_config_s *pconf;
 
-	if (!lcd_drv)
-		return -1;
-
 	pconf = lcd_drv->lcd_config;
 	if ((pconf->lcd_basic.h_active == lcd_vmode_info[index].width) &&
 		(pconf->lcd_basic.v_active == lcd_vmode_info[index].height))
@@ -155,7 +141,7 @@ static int lcd_get_vmode(enum vmode_e mode)
 	return lcd_vmode;
 }
 
-static int lcd_outputmode_to_vmode(const char *mode)
+static int lcd_outputmode_to_lcd_vmode(const char *mode)
 {
 	int lcd_vmode = LCD_VMODE_MAX;
 	int i, count = ARRAY_SIZE(lcd_vmode_info) - 1;
@@ -180,7 +166,7 @@ static int lcd_outputmode_to_vmode(const char *mode)
 	return lcd_vmode;
 }
 
-static int lcd_outputmode_to_frame_rate(const char *mode)
+static int lcd_outputmode_to_lcd_frame_rate(const char *mode)
 {
 	int frame_rate = 0;
 	char temp[30], *p;
@@ -199,8 +185,8 @@ static int lcd_outputmode_to_frame_rate(const char *mode)
 	if (lcd_debug_print_flag)
 		LCDPR("outputmode=%s, frame_rate=%d\n", mode, n);
 
-	for (i = 0; i < LCD_STD_FRAME_RATE_MAX; i++) {
-		if (n == lcd_std_frame_rate[i][0]) {
+	for (i = 0; i < ARRAY_SIZE(lcd_std_frame_rate); i++) {
+		if (n == lcd_std_frame_rate[i]) {
 			frame_rate = n;
 			break;
 		}
@@ -208,33 +194,15 @@ static int lcd_outputmode_to_frame_rate(const char *mode)
 	return frame_rate;
 }
 
-static unsigned int lcd_std_frame_rate_index(unsigned int frame_rate)
-{
-	unsigned int i;
-
-	for (i = 0; i < LCD_STD_FRAME_RATE_MAX; i++) {
-		if (frame_rate == lcd_std_frame_rate[i][0])
-			return i;
-	}
-
-	LCDERR("%s: invalid frame_rate: %d\n", __func__, frame_rate);
-	return LCD_STD_FRAME_RATE_MAX;
-}
-
 static void lcd_vmode_vinfo_update(enum vmode_e mode)
 {
 	struct lcd_vmode_info_s *info;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lcd_config_s *pconf;
-	unsigned int index;
-
-	if (!lcd_drv)
-		return;
 
 	pconf = lcd_drv->lcd_config;
 	lcd_output_vmode = lcd_get_vmode(mode);
 	info = &lcd_vmode_info[lcd_output_vmode];
-	memset(lcd_output_name, 0, sizeof(lcd_output_name));
 	sprintf(lcd_output_name, "%s%dhz", info->name, info->frame_rate);
 	if (lcd_debug_print_flag) {
 		LCDPR("%s vmode = %d, lcd_vmode = %d, outputmode = %s\n",
@@ -248,18 +216,9 @@ static void lcd_vmode_vinfo_update(enum vmode_e mode)
 			pconf->lcd_basic.h_period) * 100) /
 			pconf->lcd_basic.v_period;
 		lcd_drv->std_duration.duration_den = 100;
-		lcd_drv->std_duration.frac = 0;
 	} else {
-		index = lcd_std_frame_rate_index(info->frame_rate);
-		if (info->frac) {
-			if (index < LCD_STD_FRAME_RATE_MAX)
-				index++;
-			lcd_drv->std_duration.frac = 1;
-		} else {
-			lcd_drv->std_duration.frac = 0;
-		}
-		lcd_drv->std_duration.duration_num = lcd_std_frame_rate[index][1];
-		lcd_drv->std_duration.duration_den = lcd_std_frame_rate[index][2];
+		lcd_drv->std_duration.duration_num = info->frame_rate;
+		lcd_drv->std_duration.duration_den = 1;
 	}
 
 	/* update vinfo */
@@ -277,7 +236,6 @@ static void lcd_vmode_vinfo_update(enum vmode_e mode)
 		lcd_drv->std_duration.duration_num;
 	lcd_drv->lcd_info->sync_duration_den =
 		lcd_drv->std_duration.duration_den;
-	lcd_drv->lcd_info->frac = lcd_drv->std_duration.frac;
 	lcd_drv->lcd_info->video_clk = pconf->lcd_timing.lcd_clk;
 	lcd_drv->lcd_info->htotal = pconf->lcd_basic.h_period;
 	lcd_drv->lcd_info->vtotal = pconf->lcd_basic.v_period;
@@ -306,37 +264,16 @@ static void lcd_vmode_vinfo_update(enum vmode_e mode)
 	lcd_optical_vinfo_update();
 }
 
-static unsigned int lcd_parse_vout_init_name(char *name)
-{
-	char *p, *frac_str;
-	unsigned int frac = 0;
-
-	p = strchr(name, ',');
-	if (!p) {
-		frac = 0;
-	} else {
-		frac_str = p + 1;
-		*p = '\0';
-		if (strcmp(frac_str, "frac") == 0)
-			frac = 1;
-	}
-
-	return frac;
-}
-
 /* ************************************************** *
  * vout server api
  * **************************************************
  */
-static enum vmode_e lcd_validate_vmode(char *mode, unsigned int frac)
+static enum vmode_e lcd_validate_vmode(char *mode)
 {
 	int lcd_vmode, frame_rate;
 	int ret;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	if (lcd_vout_serve_bypass) {
 		LCDPR("vout_serve bypass\n");
 		return VMODE_MAX;
@@ -344,47 +281,33 @@ static enum vmode_e lcd_validate_vmode(char *mode, unsigned int frac)
 	if (mode == NULL)
 		return VMODE_MAX;
 
-	lcd_vmode = lcd_outputmode_to_vmode(mode);
-	if (lcd_vmode >= LCD_VMODE_MAX)
-		return VMODE_MAX;
-
+	lcd_vmode = lcd_outputmode_to_lcd_vmode(mode);
 	ret = lcd_vmode_is_mached(lcd_vmode);
 	if (ret) {
 		LCDERR("%s: outputmode is not support\n", __func__);
 		return VMODE_MAX;
 	}
-	if (lcd_drv->lcd_config->lcd_timing.fr_adjust_type == 0xff) {
-		LCDPR("%s: fixed timing\n", __func__);
+	frame_rate = lcd_outputmode_to_lcd_frame_rate(mode);
+	if (lcd_drv->lcd_config->lcd_timing.fr_adjust_type == 0xff)
 		return lcd_vmode_info[lcd_vmode].mode;
-	}
-
-	frame_rate = lcd_outputmode_to_frame_rate(mode);
 	if (frame_rate == 0) {
 		LCDERR("%s: frame_rate is not support\n", __func__);
 		return VMODE_MAX;
-	}
-	if (frac) {
-		if (frame_rate != 60) {
-			LCDERR("%s: don't support frac under mode %s\n",
-			       __func__, mode);
-			return VMODE_MAX;
-		}
-		lcd_vmode_info[lcd_vmode].frac = 1;
 	} else {
-		lcd_vmode_info[lcd_vmode].frac = 0;
+		lcd_vmode_info[lcd_vmode].frame_rate = frame_rate;
+		if (lcd_vmode < LCD_VMODE_MAX)
+			return lcd_vmode_info[lcd_vmode].mode;
+		else
+			return VMODE_MAX;
 	}
-	lcd_vmode_info[lcd_vmode].frame_rate = frame_rate;
-
-	return lcd_vmode_info[lcd_vmode].mode;
 
+	return VMODE_MAX;
 }
 
 static struct vinfo_s *lcd_get_current_info(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return NULL;
 	return lcd_drv->lcd_info;
 }
 
@@ -393,9 +316,6 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	if (lcd_vout_serve_bypass) {
 		LCDPR("vout_serve bypass\n");
 		return 0;
@@ -439,11 +359,6 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 	return ret;
 }
 
-static int lcd_check_same_vmodeattr(char *mode)
-{
-	return 1;
-}
-
 static int lcd_vmode_is_supported(enum vmode_e mode)
 {
 	int lcd_vmode;
@@ -466,9 +381,6 @@ static int lcd_vout_disable(enum vmode_e cur_vmod)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	lcd_drv->lcd_status &= ~LCD_STATUS_VMODE_ACTIVE;
 
 	return 0;
@@ -479,9 +391,6 @@ static int lcd_vout_set_state(int index)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	lcd_vout_state |= (1 << index);
 	lcd_drv->viu_sel = index;
 
@@ -492,9 +401,6 @@ static int lcd_vout_clr_state(int index)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	lcd_vout_state &= ~(1 << index);
 	if (lcd_drv->viu_sel == index)
 		lcd_drv->viu_sel = LCD_VIU_SEL_NONE;
@@ -507,48 +413,40 @@ static int lcd_vout_get_state(void)
 	return lcd_vout_state;
 }
 
-static int lcd_vout_get_disp_cap(char *buf)
-{
-	int ret = 0, i;
-	struct lcd_vmode_info_s *info;
-
-	info = &lcd_vmode_info[lcd_output_vmode];
-	for (i = 0; i < ACTIVE_FRAME_RATE_CNT; i++)
-		ret += sprintf(buf + ret, "%s%dhz\n", info->name,
-			      lcd_std_frame_rate[i][0]);
-
-	return ret;
-}
-
 #ifdef CONFIG_AMLOGIC_VOUT_SERVE
 struct lcd_vframe_match_s {
+	int fps;
 	int frame_rate; /* *100 */
 	unsigned int duration_num;
 	unsigned int duration_den;
-	unsigned int frac;
 };
 
 static struct lcd_vframe_match_s lcd_vframe_match_table_1[] = {
-	{6000, 60, 1, 0},
-	{5994, 60000, 1001, 1},
-	{5000, 50, 1, 0}
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 6000, 60, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
 };
 
 static struct lcd_vframe_match_s lcd_vframe_match_table_2[] = {
-	{6000, 60, 1, 0},
-	{5994, 60000, 1001, 1},
-	{5000, 50, 1, 0},
-	{4800, 48, 1, 0},
-	{4795, 48000, 1001, 0}
+	{5000, 5000, 50, 1},
+	{2500, 5000, 50, 1},
+	{6000, 6000, 60, 1},
+	{3000, 6000, 60, 1},
+	{2400, 4800, 48, 1},
+	{2397, 5994, 5994, 100},
+	{2997, 5994, 5994, 100},
+	{5994, 5994, 5994, 100},
 };
 
 static int lcd_framerate_automation_set_mode(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	LCDPR("%s\n", __func__);
 
 	/* update interface timing */
@@ -558,19 +456,13 @@ static int lcd_framerate_automation_set_mode(void)
 		lcd_drv->lcd_config->lcd_timing.lcd_clk, VPU_VENCL);
 #endif
 
-	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE) {
-		if (lcd_drv->lcd_status & LCD_STATUS_IF_ON)
-			lcd_vbyone_interrupt_enable(0);
-	}
-
+	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE)
+		lcd_vbyone_interrupt_enable(0);
 	/* change clk parameter */
 	lcd_clk_change(lcd_drv->lcd_config);
 	lcd_venc_change(lcd_drv->lcd_config);
-
-	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE) {
-		if (lcd_drv->lcd_status & LCD_STATUS_IF_ON)
-			lcd_vbyone_wait_stable();
-	}
+	if (lcd_drv->lcd_config->lcd_basic.lcd_type == LCD_VBYONE)
+		lcd_vbyone_wait_stable();
 
 	lcd_vout_notify_mode_change();
 
@@ -583,13 +475,11 @@ static int lcd_set_vframe_rate_hint(int duration)
 #ifdef CONFIG_AMLOGIC_VOUT_SERVE
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vinfo_s *info;
+	int fr_policy;
 	unsigned int frame_rate = 6000;
-	unsigned int duration_num = 60, duration_den = 1, frac = 0;
+	unsigned int duration_num = 60, duration_den = 1;
 	struct lcd_vframe_match_s *vtable = lcd_vframe_match_table_1;
-	int i, n, find = 0;
-
-	if (!lcd_drv)
-		return -1;
+	int fps, i, n;
 
 	if (lcd_vout_serve_bypass) {
 		LCDPR("vout_serve bypass\n");
@@ -597,19 +487,17 @@ static int lcd_set_vframe_rate_hint(int duration)
 	}
 	if ((lcd_drv->lcd_status & LCD_STATUS_ENCL_ON) == 0) {
 		LCDPR("%s: lcd is disabled, exit\n", __func__);
-		return -1;
+		return 0;
 	}
 
 	if (lcd_drv->lcd_config->lcd_timing.fr_adjust_type == 0xff) {
 		LCDPR("%s: fixed timing, exit\n", __func__);
-		return -1;
+		return 0;
 	}
-
-	if (lcd_debug_print_flag)
-		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
-
 	info = lcd_drv->lcd_info;
-	switch (lcd_drv->fr_auto_policy) {
+
+	fr_policy = lcd_drv->fr_auto_policy;
+	switch (fr_policy) {
 	case 1:
 		vtable = lcd_vframe_match_table_1;
 		n = ARRAY_SIZE(lcd_vframe_match_table_1);
@@ -620,16 +508,63 @@ static int lcd_set_vframe_rate_hint(int duration)
 		break;
 	default:
 		LCDPR("%s: fr_auto_policy = %d, disabled\n",
-		      __func__, lcd_drv->fr_auto_policy);
+			__func__, fr_policy);
+		return 0;
+	}
+	fps = vout_get_vsource_fps(duration);
+	for (i = 0; i < n; i++) {
+		if (fps == vtable[i].fps) {
+			frame_rate = vtable[i].frame_rate;
+			duration_num = vtable[i].duration_num;
+			duration_den = vtable[i].duration_den;
+		}
+	}
+	LCDPR("%s: policy = %d, duration = %d, fps = %d, frame_rate = %d\n",
+		__func__, fr_policy, duration, fps, frame_rate);
+
+	/* if the sync_duration is same as current */
+	if ((duration_num == info->sync_duration_num) &&
+		(duration_den == info->sync_duration_den)) {
+		LCDPR("%s: sync_duration is the same, exit\n", __func__);
 		return 0;
 	}
 
-	if (duration == 0) { /* end hint */
+	/* update vinfo */
+	info->sync_duration_num = duration_num;
+	info->sync_duration_den = duration_den;
+	lcd_drv->fr_mode = 1;
+
+	lcd_framerate_automation_set_mode();
+#endif
+	return 0;
+}
+
+static int lcd_set_vframe_rate_end_hint(void)
+{
+#ifdef CONFIG_AMLOGIC_VOUT_SERVE
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vinfo_s *info;
+
+	if (lcd_vout_serve_bypass) {
+		LCDPR("vout_serve bypass\n");
+		return 0;
+	}
+	if ((lcd_drv->lcd_status & LCD_STATUS_ENCL_ON) == 0) {
+		LCDPR("%s: lcd is disabled, exit\n", __func__);
+		return 0;
+	}
+
+	if (lcd_drv->lcd_config->lcd_timing.fr_adjust_type == 0xff) {
+		LCDPR("%s: fixed timing, exit\n", __func__);
+		return 0;
+	}
+	if (lcd_debug_print_flag)
+		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
+	if (lcd_drv->fr_auto_policy) {
 		info = lcd_drv->lcd_info;
 		LCDPR("%s: return mode = %s, policy = %d\n", __func__,
 			info->name, lcd_drv->fr_auto_policy);
 
-		lcd_drv->fr_duration = 0;
 		if (lcd_drv->fr_mode == 0) {
 			LCDPR("%s: fr_mode is invalid, exit\n", __func__);
 			return 0;
@@ -638,59 +573,35 @@ static int lcd_set_vframe_rate_hint(int duration)
 		/* update vinfo */
 		info->sync_duration_num = lcd_drv->std_duration.duration_num;
 		info->sync_duration_den = lcd_drv->std_duration.duration_den;
-		info->frac = 0;
 		lcd_drv->fr_mode = 0;
-	} else {
-		for (i = 0; i < n; i++) {
-			if (duration == vtable[i].frame_rate) {
-				frame_rate = vtable[i].frame_rate;
-				duration_num = vtable[i].duration_num;
-				duration_den = vtable[i].duration_den;
-				frac = vtable[i].frac;
-				find = 1;
-				break;
-			}
-		}
-		if (find == 0) {
-			LCDERR("%s: can't support duration %d\n, exit\n",
-			       __func__, duration);
-			return -1;
-		}
 
-		LCDPR("%s: policy = %d, duration = %d, frame_rate = %d\n",
-		      __func__, lcd_drv->fr_auto_policy,
-		      duration, frame_rate);
-
-		lcd_drv->fr_duration = duration;
-		/* if the sync_duration is same as current */
-		if ((duration_num == info->sync_duration_num) &&
-			(duration_den == info->sync_duration_den)) {
-			LCDPR("%s: sync_duration is the same, exit\n",
-			      __func__);
-			return 0;
-		}
-
-		/* update vinfo */
-		info->sync_duration_num = duration_num;
-		info->sync_duration_den = duration_den;
-		info->frac = frac;
-		lcd_drv->fr_mode = 1;
+		lcd_framerate_automation_set_mode();
 	}
-
-	lcd_framerate_automation_set_mode();
 #endif
 	return 0;
 }
 
-static int lcd_get_vframe_rate_hint(void)
+static int lcd_set_vframe_rate_policy(int policy)
 {
 #ifdef CONFIG_AMLOGIC_VOUT_SERVE
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
+	if (lcd_vout_serve_bypass) {
+		LCDPR("vout_serve bypass\n");
 		return 0;
+	}
+	lcd_drv->fr_auto_policy = policy;
+	LCDPR("%s: %d\n", __func__, lcd_drv->fr_auto_policy);
+#endif
+	return 0;
+}
+
+static int lcd_get_vframe_rate_policy(void)
+{
+#ifdef CONFIG_AMLOGIC_VOUT_SERVE
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	return lcd_drv->fr_duration;
+	return lcd_drv->fr_auto_policy;
 #else
 	return 0;
 #endif
@@ -701,9 +612,6 @@ static int lcd_suspend(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	mutex_lock(&lcd_drv->power_mutex);
 	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
 	lcd_resume_flag = 0;
@@ -716,9 +624,6 @@ static int lcd_resume(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
-	if (!lcd_drv)
-		return -1;
-
 	if ((lcd_drv->lcd_status & LCD_STATUS_VMODE_ACTIVE) == 0)
 		return 0;
 
@@ -736,11 +641,7 @@ static int lcd_resume(void)
 		mutex_lock(&lcd_drv->power_mutex);
 		LCDPR("directly lcd late resume\n");
 		lcd_resume_flag = 1;
-		if (lcd_drv->boot_ctrl->lcd_init_level ==
-		    LCD_INIT_LEVEL_KERNEL_OFF)
-			aml_lcd_notifier_call_chain(LCD_EVENT_PREPARE, NULL);
-		else
-			aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
 		lcd_if_enable_retry(lcd_drv->lcd_config);
 		LCDPR("%s finished\n", __func__);
 		mutex_unlock(&lcd_drv->power_mutex);
@@ -751,37 +652,26 @@ static int lcd_resume(void)
 
 #endif
 
-int lcd_set_clock_drift(int ppm)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
-	if (!lcd_drv)
-		return -1;
-	lcd_clk_finetune(lcd_drv->lcd_config, ppm);
-	return 0;
-}
-
 static struct vout_server_s lcd_vout_server = {
 	.name = "lcd_vout_server",
 	.op = {
 		.get_vinfo = lcd_get_current_info,
 		.set_vmode = lcd_set_current_vmode,
 		.validate_vmode = lcd_validate_vmode,
-		.check_same_vmodeattr = lcd_check_same_vmodeattr,
 		.vmode_is_supported = lcd_vmode_is_supported,
 		.disable = lcd_vout_disable,
 		.set_state = lcd_vout_set_state,
 		.clr_state = lcd_vout_clr_state,
 		.get_state = lcd_vout_get_state,
-		.get_disp_cap = lcd_vout_get_disp_cap,
 		.set_vframe_rate_hint = lcd_set_vframe_rate_hint,
-		.get_vframe_rate_hint = lcd_get_vframe_rate_hint,
+		.set_vframe_rate_end_hint = lcd_set_vframe_rate_end_hint,
+		.set_vframe_rate_policy = lcd_set_vframe_rate_policy,
+		.get_vframe_rate_policy = lcd_get_vframe_rate_policy,
 		.set_bist = lcd_debug_test,
 #ifdef CONFIG_PM
 		.vout_suspend = lcd_suspend,
 		.vout_resume = lcd_resume,
 #endif
-		.set_clock_drift = lcd_set_clock_drift,
 	},
 };
 
@@ -791,29 +681,13 @@ static void lcd_vinfo_update_default(void)
 	struct vinfo_s *vinfo;
 	unsigned int h_active, v_active, h_total, v_total;
 	char *mode;
-	unsigned int index, frame_rate, frac;
-
-	if (!lcd_drv)
-		return;
 
 	if (lcd_drv->lcd_info == NULL) {
 		LCDERR("no lcd_info exist\n");
 		return;
 	}
 
-	mode = kstrdup(get_vout_mode_uboot(), GFP_KERNEL);
-	if (!mode) {
-		LCDERR("%s error\n", __func__);
-		return;
-	}
-	frac = lcd_parse_vout_init_name(mode);
-	frame_rate = lcd_outputmode_to_frame_rate(mode);
-	if (frac) {
-		if ((frame_rate != 60) && (frame_rate != 48)) {
-			LCDERR("%s frac error\n", __func__);
-			return;
-		}
-	}
+	mode = get_vout_mode_uboot();
 	h_active = lcd_vcbus_read(ENCL_VIDEO_HAVON_END)
 			- lcd_vcbus_read(ENCL_VIDEO_HAVON_BEGIN) + 1;
 	v_active = lcd_vcbus_read(ENCL_VIDEO_VAVON_ELINE)
@@ -821,11 +695,9 @@ static void lcd_vinfo_update_default(void)
 	h_total = lcd_vcbus_read(ENCL_VIDEO_MAX_PXCNT) + 1;
 	v_total = lcd_vcbus_read(ENCL_VIDEO_MAX_LNCNT) + 1;
 
-	memset(lcd_output_name, 0, sizeof(lcd_output_name));
-	snprintf(lcd_output_name, sizeof(lcd_output_name), "%s", mode);
 	vinfo = lcd_drv->lcd_info;
 	if (vinfo) {
-		vinfo->name = lcd_output_name;
+		vinfo->name = mode;
 		vinfo->mode = VMODE_LCD;
 		vinfo->width = h_active;
 		vinfo->height = v_active;
@@ -834,22 +706,13 @@ static void lcd_vinfo_update_default(void)
 		vinfo->aspect_ratio_den = v_active;
 		vinfo->screen_real_width = h_active;
 		vinfo->screen_real_height = v_active;
-		index = lcd_std_frame_rate_index(frame_rate);
-		if (frac) {
-			if (index < LCD_STD_FRAME_RATE_MAX)
-				index++;
-			vinfo->frac = 1;
-		} else {
-			vinfo->frac = 0;
-		}
-		vinfo->sync_duration_num = lcd_std_frame_rate[index][1];
-		vinfo->sync_duration_den = lcd_std_frame_rate[index][2];
+		vinfo->sync_duration_num = 60;
+		vinfo->sync_duration_den = 1;
 		vinfo->video_clk = 0;
 		vinfo->htotal = h_total;
 		vinfo->vtotal = v_total;
 		vinfo->fr_adj_type = VOUT_FR_ADJ_NONE;
 	}
-	kfree(mode);
 }
 
 void lcd_tv_vout_server_init(void)
@@ -861,7 +724,7 @@ void lcd_tv_vout_server_init(void)
 
 void lcd_tv_vout_server_remove(void)
 {
-	vout_unregister_server(&lcd_vout_server);
+	vout_register_server(&lcd_vout_server);
 }
 
 /* ************************************************** *
@@ -937,17 +800,8 @@ static int lcd_init_load_from_dts(struct lcd_config_s *pconf,
 		case LCD_VBYONE:
 			lcd_vbyone_pinmux_set(1);
 			break;
-		case LCD_MLVDS:
-			if (pconf->customer_pinmux)
-				lcd_customer_pinmux_set(1);
-			else
-				lcd_mlvds_pinmux_set(1);
-			break;
 		case LCD_P2P:
-			if (pconf->customer_pinmux)
-				lcd_customer_pinmux_set(1);
-			else
-				lcd_p2p_pinmux_set(1);
+			lcd_tcon_pinmux_set(1);
 			break;
 		default:
 			break;
@@ -993,15 +847,6 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 	}
 	pconf->lcd_basic.lcd_type = lcd_type_str_to_type(str);
 
-	ret = of_property_read_u32(child, "customer_pinmux", &val);
-	if (ret) {
-		if (lcd_debug_print_flag)
-			LCDPR("failed to get customer_pinmux\n");
-		pconf->customer_pinmux = 0;
-	} else {
-		pconf->customer_pinmux = (unsigned char)val;
-	}
-
 	ret = of_property_read_u32_array(child, "basic_setting", &para[0], 7);
 	if (ret) {
 		LCDERR("failed to get basic_setting\n");
@@ -1384,7 +1229,6 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		((*(p + LCD_UKEY_PCLK_MAX + 1)) << 8) |
 		((*(p + LCD_UKEY_PCLK_MAX + 2)) << 16) |
 		((*(p + LCD_UKEY_PCLK_MAX + 3)) << 24));
-	pconf->customer_pinmux = (*(p + LCD_UKEY_CUST_VAL_9) & 0x1);
 
 	/* interface: 20byte */
 	if (pconf->lcd_basic.lcd_type == LCD_VBYONE) {
@@ -1544,25 +1388,17 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 
 static void lcd_vmode_init(struct lcd_config_s *pconf)
 {
-	char *mode, *init_mode;
+	char *mode;
 	enum vmode_e vmode;
-	unsigned int frac;
 
-	init_mode = get_vout_mode_uboot();
-	mode = kstrdup(init_mode, GFP_KERNEL);
-	if (!mode) {
-		LCDERR("%s error\n", __func__);
-		return;
-	}
-	LCDPR("%s: mode: %s\n", __func__, mode);
-	frac = lcd_parse_vout_init_name(mode);
-	vmode = lcd_validate_vmode(mode, frac);
+	mode = get_vout_mode_uboot();
+	LCDPR("%s mode: %s\n", __func__, mode);
+	vmode = lcd_validate_vmode(mode);
 	if (vmode >= VMODE_MAX) {
-		LCDERR("%s: invalid vout_init_mode: %s\n", __func__, init_mode);
+		LCDERR("%s: invalid vout_init_mode: %s\n", __func__, mode);
 		vmode = VMODE_LCD;
 	}
 	lcd_vmode_vinfo_update(vmode & VMODE_MODE_BIT_MASK);
-	kfree(mode);
 }
 
 static void lcd_config_init(struct lcd_config_s *pconf)
@@ -1712,6 +1548,7 @@ int lcd_tv_probe(struct device *dev)
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	int ret;
 
+	memset(lcd_output_name, 0, sizeof(lcd_output_name));
 	lcd_drv->driver_init_pre = lcd_tv_driver_init_pre;
 	lcd_drv->driver_disable_post = lcd_tv_driver_disable_post;
 	lcd_drv->driver_init = lcd_tv_driver_init;
@@ -1748,6 +1585,8 @@ int lcd_tv_remove(struct device *dev)
 		break;
 	}
 
+	kfree(lcd_drv->lcd_info);
+	lcd_drv->lcd_info = NULL;
 	return 0;
 }
 
diff --git a/drivers/amlogic/media/vout/lcd/lcd_unifykey.c b/drivers/amlogic/media/vout/lcd/lcd_unifykey.c
index 99f21618d195..015c357bf3f8 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_unifykey.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_unifykey.c
@@ -33,13 +33,13 @@
 #define LCDUKEYERR(fmt, args...)  pr_info("lcd ukey err: error: "fmt"", ## args)
 
 #ifdef CONFIG_AMLOGIC_UNIFYKEY
-unsigned int cal_crc32(unsigned int crc, const unsigned char *buf, int buf_len)
-{
+static unsigned int cal_crc32(unsigned int crc, const unsigned char *buf,
+		int buf_len) {
 	unsigned int s_crc32[16] = {
 		0, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
 		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
 		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
-		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
+		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c,
 	};
 	unsigned int crcu32 = crc;
 	unsigned char b;
@@ -179,105 +179,6 @@ int lcd_unifykey_check(char *key_name)
 	return -1;
 }
 
-static int lcd_unifykey_check_tcon(char *key_name)
-{
-	unsigned int key_exist, keypermit, key_len, data_size;
-	unsigned char *buf;
-	int retry_cnt = 0;
-	unsigned int key_crc32, raw_crc32;
-	int ret;
-
-	if (!key_name) {
-		LCDUKEYERR("%s: key_name is null\n", __func__);
-		return -1;
-	}
-
-	key_exist = 0;
-	key_len = 0;
-	ret = key_unify_query(get_ukdev(), key_name, &key_exist, &keypermit);
-	if (ret < 0) {
-		if (lcd_debug_print_flag)
-			LCDUKEYERR("%s query exist error\n", key_name);
-		return -1;
-	}
-	if (key_exist == 0) {
-		if (lcd_debug_print_flag)
-			LCDUKEYERR("%s is not exist\n", key_name);
-		return -1;
-	}
-
-	ret = key_unify_size(get_ukdev(), key_name, &key_len);
-	if (ret < 0) {
-		LCDUKEYERR("%s query size error\n", key_name);
-		return -1;
-	}
-	if (key_len == 0) {
-		if (lcd_debug_print_flag)
-			LCDUKEY("%s size is zero\n", key_name);
-		return -1;
-	}
-	if (lcd_debug_print_flag)
-		LCDUKEY("%s size: %d\n", key_name, key_len);
-
-	buf = kzalloc((sizeof(unsigned char) * key_len), GFP_KERNEL);
-	if (!buf) {
-		LCDUKEYERR("%s: Not enough memory\n", __func__);
-		return -1;
-	}
-
-lcd_unifykey_check_tcon_read:
-	ret = key_unify_read(get_ukdev(), key_name, buf, key_len, &key_len);
-	if (ret < 0) {
-		LCDUKEYERR("%s unify read error\n", key_name);
-		goto lcd_unifykey_check_tcon_err;
-	}
-
-	/* check header */
-	if (key_len <= LCD_TCON_DATA_BLOCK_HEADER_SIZE) {
-		LCDUKEYERR("%s unify key_len %d error\n", key_name, key_len);
-		goto lcd_unifykey_check_tcon_err;
-	}
-	data_size = (buf[8] | (buf[9] << 8) |
-		     (buf[10] << 16) | (buf[11] << 24));
-	if (key_len != data_size) {  /* length check */
-		if (lcd_debug_print_flag) {
-			LCDUKEYERR("data_len %d is not match key_len %d\n",
-				   data_size, key_len);
-		}
-		if (retry_cnt < LCD_UKEY_RETRY_CNT_MAX) {
-			retry_cnt++;
-			memset(buf, 0, key_len);
-			goto lcd_unifykey_check_tcon_read;
-		}
-		LCDUKEYERR("%s: load unifykey failed\n", key_name);
-		goto lcd_unifykey_check_tcon_err;
-	}
-	raw_crc32 = (buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24));
-	key_crc32 = cal_crc32(0, &buf[4], (key_len - 4)); /* except crc32 */
-	if (lcd_debug_print_flag) {
-		LCDUKEY("crc32: 0x%08x, header_crc32: 0x%08x\n",
-			key_crc32, raw_crc32);
-	}
-	if (key_crc32 != raw_crc32) {  /* crc32 check */
-		LCDUKEYERR("crc32 0x%08x is not match header_crc32 0x%08x\n",
-			   raw_crc32, key_crc32);
-		if (retry_cnt < LCD_UKEY_RETRY_CNT_MAX) {
-			retry_cnt++;
-			memset(buf, 0, key_len);
-			goto lcd_unifykey_check_tcon_read;
-		}
-		LCDUKEYERR("%s: load unifykey failed\n", key_name);
-		goto lcd_unifykey_check_tcon_err;
-	}
-
-	kfree(buf);
-	return 0;
-
-lcd_unifykey_check_tcon_err:
-	kfree(buf);
-	return -1;
-}
-
 int lcd_unifykey_get(char *key_name, unsigned char *buf, int *len)
 {
 	int key_len;
@@ -303,31 +204,6 @@ int lcd_unifykey_get(char *key_name, unsigned char *buf, int *len)
 	return 0;
 }
 
-int lcd_unifykey_get_tcon(char *key_name, unsigned char *buf, int *len)
-{
-	int key_len;
-	int ret;
-
-	key_len = 0;
-	ret = lcd_unifykey_check_tcon(key_name);
-	if (ret < 0)
-		return -1;
-	ret = key_unify_size(get_ukdev(), key_name, &key_len);
-	if (key_len > *len) {
-		LCDUKEYERR("%s size(0x%x) is bigger than buf_size(0x%x)\n",
-			key_name, key_len, *len);
-		return -1;
-	}
-	*len = key_len;
-
-	ret = key_unify_read(get_ukdev(), key_name, buf, key_len, &key_len);
-	if (ret < 0) {
-		LCDUKEYERR("%s unify read error\n", key_name);
-		return -1;
-	}
-	return 0;
-}
-
 int lcd_unifykey_check_no_header(char *key_name)
 {
 	unsigned int key_exist, keypermit, key_len;
@@ -497,12 +373,6 @@ int lcd_unifykey_get(char *key_name, unsigned char *buf, int *len)
 	return -1;
 }
 
-int lcd_unifykey_get_tcon(char *key_name, unsigned char *buf, int *len)
-{
-	LCDUKEYERR("Don't support unifykey\n");
-	return -1;
-}
-
 int lcd_unifykey_check_no_header(char *key_name)
 {
 	LCDUKEYERR("Don't support unifykey\n");
diff --git a/drivers/amlogic/media/vout/lcd/lcd_vout.c b/drivers/amlogic/media/vout/lcd/lcd_vout.c
index 428fda515b1e..3e613bab59c9 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_vout.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_vout.c
@@ -54,11 +54,6 @@
 
 unsigned char lcd_debug_print_flag;
 unsigned char lcd_resume_flag;
-/* for driver probe init:
- *  0: none
- *  1: power on request
- */
-static unsigned char lcd_init_flag;
 static struct aml_lcd_drv_s *lcd_driver;
 
 struct mutex lcd_vout_mutex;
@@ -247,6 +242,7 @@ static struct lcd_config_s lcd_config_dft = {
 		.vlock_param = vlock_param,
 	},
 	.lcd_power = &lcd_power_config,
+	.lcd_boot_ctrl = &lcd_boot_ctrl_config,
 	.pinmux_flag = 0xff,
 	.change_flag = 0,
 	.retry_enable_flag = 0,
@@ -259,7 +255,6 @@ static struct lcd_config_s lcd_config_dft = {
 static struct vinfo_s lcd_vinfo = {
 	.name = "panel",
 	.mode = VMODE_LCD,
-	.frac = 0,
 	.viu_color_fmt = COLOR_FMT_RGB444,
 	.viu_mux = VIU_MUX_ENCL,
 	.vout_device = NULL,
@@ -281,6 +276,7 @@ static void lcd_power_ctrl(int status)
 #endif
 	unsigned int i, index, wait;
 	int value = -1;
+
 	LCDPR("%s: %d\n", __func__, status);
 	i = 0;
 	while (i < LCD_PWR_STEP_MAX) {
@@ -434,13 +430,9 @@ static void lcd_power_if_off(void)
 
 static void lcd_power_screen_black(void)
 {
-	unsigned long flags = 0;
-
 	mutex_lock(&lcd_vout_mutex);
 
-	spin_lock_irqsave(&lcd_driver->isr_lock, flags);
-	lcd_driver->lcd_mute_flag = 1;
-	spin_unlock_irqrestore(&lcd_driver->isr_lock, flags);
+	lcd_driver->lcd_mute_flag = (unsigned char)(1 | LCD_MUTE_UPDATE);
 	LCDPR("set mute\n");
 
 	mutex_unlock(&lcd_vout_mutex);
@@ -448,13 +440,9 @@ static void lcd_power_screen_black(void)
 
 static void lcd_power_screen_restore(void)
 {
-	unsigned long flags = 0;
-
 	mutex_lock(&lcd_vout_mutex);
 
-	spin_lock_irqsave(&lcd_driver->isr_lock, flags);
-	lcd_driver->lcd_mute_flag = 0;
-	spin_unlock_irqrestore(&lcd_driver->isr_lock, flags);
+	lcd_driver->lcd_mute_flag = (unsigned char)(0 | LCD_MUTE_UPDATE);
 	LCDPR("clear mute\n");
 
 	mutex_unlock(&lcd_vout_mutex);
@@ -462,8 +450,6 @@ static void lcd_power_screen_restore(void)
 
 static void lcd_module_reset(void)
 {
-	unsigned long flags = 0;
-
 	mutex_lock(&lcd_vout_mutex);
 
 	lcd_driver->lcd_status &= ~LCD_STATUS_ON;
@@ -476,9 +462,7 @@ static void lcd_module_reset(void)
 	lcd_driver->lcd_status |= LCD_STATUS_ON;
 	lcd_driver->lcd_config->change_flag = 0;
 
-	spin_lock_irqsave(&lcd_driver->isr_lock, flags);
-	lcd_driver->lcd_mute_flag = 0;
-	spin_unlock_irqrestore(&lcd_driver->isr_lock, flags);
+	lcd_driver->lcd_mute_flag = (unsigned char)(0 | LCD_MUTE_UPDATE);
 	LCDPR("clear mute\n");
 
 	mutex_unlock(&lcd_vout_mutex);
@@ -486,14 +470,8 @@ static void lcd_module_reset(void)
 
 static void lcd_resume_work(struct work_struct *p_work)
 {
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
 	mutex_lock(&lcd_driver->power_mutex);
-	if (lcd_drv->boot_ctrl->lcd_init_level ==
-	    LCD_INIT_LEVEL_KERNEL_OFF)
-		aml_lcd_notifier_call_chain(LCD_EVENT_PREPARE, NULL);
-	else
-		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
 	lcd_if_enable_retry(lcd_driver->lcd_config);
 	LCDPR("%s finished\n", __func__);
 	mutex_unlock(&lcd_driver->power_mutex);
@@ -524,53 +502,49 @@ static void lcd_auto_test(unsigned char flag)
 static int lcd_vsync_print_cnt;
 static inline void lcd_vsync_handler(void)
 {
+	int flag;
 #ifdef CONFIG_AMLOGIC_LCD_TABLET
 	struct lcd_config_s *pconf;
 #endif
-	unsigned long flags = 0;
 
 	if (lcd_driver == NULL)
 		return;
 
-	pconf = lcd_driver->lcd_config;
-	switch (pconf->lcd_basic.lcd_type) {
-	case LCD_MIPI:
 #ifdef CONFIG_AMLOGIC_LCD_TABLET
-		if (pconf->lcd_control.mipi_config->dread) {
-			if (pconf->lcd_control.mipi_config->dread->flag) {
-				lcd_mipi_test_read
-					(pconf->lcd_control.mipi_config->dread);
-				pconf->lcd_control.mipi_config->dread->flag = 0;
-			}
+	pconf = lcd_driver->lcd_config;
+	if (pconf->lcd_control.mipi_config->dread) {
+		if (pconf->lcd_control.mipi_config->dread->flag) {
+			lcd_mipi_test_read(
+				pconf->lcd_control.mipi_config->dread);
+			pconf->lcd_control.mipi_config->dread->flag = 0;
 		}
-#endif
-		break;
-	case LCD_MLVDS:
-	case LCD_P2P:
-		lcd_tcon_vsync_isr(lcd_driver);
-		break;
-	default:
-		break;
 	}
+#endif
 
-	spin_lock_irqsave(&lcd_driver->isr_lock, flags);
-	if (lcd_driver->lcd_mute_flag) {
-		if (lcd_driver->lcd_mute_state == 0) {
-			lcd_driver->lcd_mute_state = 1;
-			lcd_driver->lcd_screen_black();
-		}
-	} else {
-		if (lcd_driver->lcd_mute_state) {
-			lcd_driver->lcd_mute_state = 0;
-			lcd_driver->lcd_screen_restore();
+	if (lcd_driver->lcd_mute_flag & LCD_MUTE_UPDATE) {
+		flag = lcd_driver->lcd_mute_flag & 0x1;
+		if (flag) {
+			if (lcd_driver->lcd_mute_state == 0) {
+				lcd_driver->lcd_mute_state = 1;
+				lcd_driver->lcd_screen_black();
+			}
+		} else {
+			if (lcd_driver->lcd_mute_state) {
+				lcd_driver->lcd_mute_state = 0;
+				lcd_driver->lcd_screen_restore();
+			}
 		}
+		lcd_driver->lcd_mute_flag &= ~(LCD_MUTE_UPDATE);
 	}
 
-	if (lcd_driver->lcd_test_flag != lcd_driver->lcd_test_state) {
-		lcd_driver->lcd_test_state = lcd_driver->lcd_test_flag;
-		lcd_debug_test(lcd_driver->lcd_test_state);
+	if (lcd_driver->lcd_test_flag & LCD_TEST_UPDATE) {
+		flag = lcd_driver->lcd_test_flag & 0xf;
+		if (flag != lcd_driver->lcd_test_state) {
+			lcd_driver->lcd_test_state = (unsigned char)flag;
+			lcd_debug_test(flag);
+		}
+		lcd_driver->lcd_test_flag &= ~(LCD_TEST_UPDATE);
 	}
-	spin_unlock_irqrestore(&lcd_driver->isr_lock, flags);
 
 	if (lcd_vsync_print_cnt++ >= LCD_DEBUG_VSYNC_INTERVAL) {
 		lcd_vsync_print_cnt = 0;
@@ -805,6 +779,30 @@ static struct notifier_block lcd_bl_select_nb = {
 	.notifier_call = lcd_bl_select_notifier,
 };
 
+static int lcd_extern_select_notifier(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	unsigned int *index;
+	struct lcd_config_s *pconf = lcd_driver->lcd_config;
+
+	if ((event & LCD_EVENT_EXTERN_SEL) == 0)
+		return NOTIFY_DONE;
+	/* LCDPR("%s: 0x%lx\n", __func__, event); */
+
+	index = (unsigned int *)data;
+	*index = pconf->extern_index;
+	if (pconf->lcd_basic.lcd_type == LCD_MIPI) {
+		if (*index == LCD_EXTERN_INDEX_INVALID)
+			*index = pconf->lcd_control.mipi_config->extern_init;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block lcd_extern_select_nb = {
+	.notifier_call = lcd_extern_select_notifier,
+};
+
 static int lcd_vlock_param_notifier(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
@@ -851,6 +849,9 @@ static int lcd_notifier_register(void)
 	ret = aml_lcd_notifier_register(&lcd_bl_select_nb);
 	if (ret)
 		LCDERR("register aml_bl_select_notifier failed\n");
+	ret = aml_lcd_notifier_register(&lcd_extern_select_nb);
+	if (ret)
+		LCDERR("register lcd_extern_select_nb failed\n");
 	ret = aml_lcd_notifier_register(&lcd_vlock_param_nb);
 	if (ret)
 		LCDERR("register lcd_vlock_param_nb failed\n");
@@ -868,6 +869,7 @@ static void lcd_notifier_unregister(void)
 	aml_lcd_notifier_unregister(&lcd_power_encl_on_nb);
 
 	aml_lcd_notifier_unregister(&lcd_bl_select_nb);
+	aml_lcd_notifier_unregister(&lcd_extern_select_nb);
 	aml_lcd_notifier_unregister(&lcd_vlock_param_nb);
 }
 /* **************************************** */
@@ -1130,15 +1132,6 @@ static int lcd_mode_probe(struct device *dev)
 	lcd_notifier_register();
 	lcd_vsync_irq_init();
 
-	if (lcd_init_flag) {
-		LCDPR("power on for init_flag\n");
-		lcd_init_flag = 0;
-		mutex_lock(&lcd_driver->power_mutex);
-		aml_lcd_notifier_call_chain(LCD_EVENT_IF_POWER_ON, NULL);
-		lcd_if_enable_retry(lcd_driver->lcd_config);
-		mutex_unlock(&lcd_driver->power_mutex);
-	}
-
 	/* add notifier for video sync_duration info refresh */
 	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,
 		&lcd_driver->lcd_info->mode);
@@ -1170,32 +1163,12 @@ static int lcd_config_remove(struct device *dev)
 		LCDPR("invalid lcd mode\n");
 		break;
 	}
-	lcd_driver->lcd_info = NULL;
 
 	lcd_clk_config_remove();
 
 	return 0;
 }
 
-static void lcd_vout_server_remove(void)
-{
-	switch (lcd_driver->lcd_mode) {
-#ifdef CONFIG_AMLOGIC_LCD_TV
-	case LCD_MODE_TV:
-		lcd_tv_vout_server_remove();
-		break;
-#endif
-#ifdef CONFIG_AMLOGIC_LCD_TABLET
-	case LCD_MODE_TABLET:
-		lcd_tablet_vout_server_remove();
-		break;
-#endif
-	default:
-		LCDPR("%s: invalid lcd mode\n", __func__);
-		break;
-	}
-}
-
 static void lcd_config_probe_delayed(struct work_struct *work)
 {
 	int key_init_flag = 0;
@@ -1212,7 +1185,6 @@ static void lcd_config_probe_delayed(struct work_struct *work)
 	LCDPR("key_init_flag=%d, i=%d\n", key_init_flag, i);
 
 	if (key_init_flag == 0) {
-		lcd_vout_server_remove();
 		kfree(lcd_driver);
 		lcd_driver = NULL;
 		LCDERR("key is not ready, probe exit\n");
@@ -1221,7 +1193,6 @@ static void lcd_config_probe_delayed(struct work_struct *work)
 
 	ret = lcd_mode_probe(lcd_driver->dev);
 	if (ret) {
-		lcd_vout_server_remove();
 		kfree(lcd_driver);
 		lcd_driver = NULL;
 		LCDERR("probe exit\n");
@@ -1244,40 +1215,24 @@ static void lcd_config_default(void)
 			- lcd_vcbus_read(ENCL_VIDEO_HAVON_BEGIN) + 1;
 	pconf->lcd_basic.v_active = lcd_vcbus_read(ENCL_VIDEO_VAVON_ELINE)
 			- lcd_vcbus_read(ENCL_VIDEO_VAVON_BLINE) + 1;
-	lcd_init_flag = 0;
 	if (lcd_vcbus_read(ENCL_VIDEO_EN)) {
-		switch (lcd_boot_ctrl_config.lcd_init_level) {
-		case LCD_INIT_LEVEL_NORMAL:
-			lcd_driver->lcd_status = LCD_STATUS_ON;
-			break;
-		case LCD_INIT_LEVEL_PWR_OFF:
-			lcd_driver->lcd_status = LCD_STATUS_ENCL_ON;
-			break;
-		case LCD_INIT_LEVEL_KERNEL_ON:
-			lcd_init_flag = 1;
+		if (lcd_boot_ctrl_config.lcd_init_level)
 			lcd_driver->lcd_status = LCD_STATUS_ENCL_ON;
-			break;
-		default:
+		else
 			lcd_driver->lcd_status = LCD_STATUS_ON;
-			break;
-		}
 		lcd_resume_flag = 1;
 	} else {
 		lcd_driver->lcd_status = 0;
 		lcd_resume_flag = 0;
 	}
-	LCDPR("status: %d, init_flag: %d\n",
-	      lcd_driver->lcd_status, lcd_init_flag);
+	LCDPR("status: %d\n", lcd_driver->lcd_status);
 }
 
 static int lcd_config_probe(struct platform_device *pdev)
 {
-	const char *str = "none";
+	const char *str;
 	unsigned int val;
 	int ret = 0;
-#ifdef CONFIG_AMLOGIC_LCD_EXTERN
-	unsigned int i;
-#endif
 
 	if (lcd_driver->dev->of_node == NULL) {
 		LCDERR("dev of_node is null\n");
@@ -1285,11 +1240,6 @@ static int lcd_config_probe(struct platform_device *pdev)
 		return -1;
 	}
 
-#ifdef CONFIG_AMLOGIC_LCD_EXTERN
-	for (i = 0; i < EXTERN_MUL_MAX; i++)
-		lcd_driver->extern_mul_index[i] = LCD_EXTERN_INDEX_INVALID;
-#endif
-
 	lcd_driver->res_vsync_irq = NULL;
 	lcd_driver->res_vsync2_irq = NULL;
 	lcd_driver->res_vx1_irq = NULL;
@@ -1309,6 +1259,7 @@ static int lcd_config_probe(struct platform_device *pdev)
 		ret = of_property_read_string(lcd_driver->dev->of_node,
 		"mode", &str);
 		if (ret) {
+			str = "none";
 			LCDERR("failed to get mode\n");
 			return -1;
 		}
@@ -1316,16 +1267,6 @@ static int lcd_config_probe(struct platform_device *pdev)
 		break;
 	}
 
-	ret = of_property_read_u32(lcd_driver->dev->of_node,
-				   "pxp", &val);
-	if (ret) {
-		if (lcd_debug_print_flag)
-			LCDPR("failed to get lcd_pxp\n");
-		lcd_driver->lcd_pxp = 0;
-	} else {
-		lcd_driver->lcd_pxp = (unsigned char)val;
-	}
-
 	ret = of_property_read_u32(lcd_driver->dev->of_node,
 		"fr_auto_policy", &val);
 	if (ret) {
@@ -1381,17 +1322,6 @@ static int lcd_config_probe(struct platform_device *pdev)
 		LCDPR("detect lcd_auto_test: %d\n", lcd_driver->lcd_auto_test);
 	}
 
-	ret = of_property_read_u32(lcd_driver->dev->of_node,
-				   "resume_type", &val);
-	if (ret) {
-		if (lcd_debug_print_flag)
-			LCDPR("failed to get resume_type\n");
-		lcd_driver->lcd_resume_type = 1; /* default workqueue */
-	} else {
-		lcd_driver->lcd_resume_type = (unsigned char)val;
-		LCDPR("detect resume_type: %d\n", lcd_driver->lcd_resume_type);
-	}
-
 	lcd_driver->res_vsync_irq = platform_get_resource_byname(pdev,
 		IORESOURCE_IRQ, "vsync");
 	lcd_driver->res_vsync2_irq = platform_get_resource_byname(pdev,
@@ -1407,6 +1337,7 @@ static int lcd_config_probe(struct platform_device *pdev)
 	lcd_driver->lcd_test_flag = 0;
 	lcd_driver->lcd_mute_state = 0;
 	lcd_driver->lcd_mute_flag = 0;
+	lcd_driver->lcd_resume_type = 1; /* default workqueue */
 	lcd_driver->fr_mode = 0;
 	lcd_driver->viu_sel = LCD_VIU_SEL_NONE;
 	lcd_driver->vsync_none_timer_flag = 0;
@@ -1419,15 +1350,17 @@ static int lcd_config_probe(struct platform_device *pdev)
 
 	if (lcd_driver->lcd_key_valid) {
 		if (lcd_driver->workqueue) {
-			queue_work(lcd_driver->workqueue,
-				&lcd_driver->lcd_probe_work);
+			queue_delayed_work(lcd_driver->workqueue,
+				&lcd_driver->lcd_probe_delayed_work,
+				msecs_to_jiffies(2000));
 		} else {
-			schedule_work(&lcd_driver->lcd_probe_work);
+			schedule_delayed_work(
+				&lcd_driver->lcd_probe_delayed_work,
+				msecs_to_jiffies(2000));
 		}
 	} else {
 		ret = lcd_mode_probe(lcd_driver->dev);
 		if (ret) {
-			lcd_vout_server_remove();
 			kfree(lcd_driver);
 			lcd_driver = NULL;
 			LCDERR("probe exit\n");
@@ -1441,27 +1374,14 @@ static int lcd_config_probe(struct platform_device *pdev)
 			lcd_boot_ctrl_config.lcd_bits;
 		lcd_driver->lcd_config->lcd_control.ttl_config->sync_valid =
 			lcd_boot_ctrl_config.advanced_flag;
-			if (lcd_driver->lcd_config->customer_pinmux)
-				lcd_customer_pinmux_set(1);
-			else
-				lcd_ttl_pinmux_set(1);
+			lcd_ttl_pinmux_set(1);
 			break;
 		case LCD_VBYONE:
 			lcd_vbyone_pinmux_set(1);
 			break;
 		case LCD_MLVDS:
-			if (lcd_driver->lcd_config->customer_pinmux)
-				lcd_customer_pinmux_set(1);
-			else
-				lcd_mlvds_pinmux_set(1);
-			break;
 		case LCD_P2P:
-		lcd_driver->lcd_config->lcd_control.p2p_config->p2p_type =
-				lcd_boot_ctrl_config.advanced_flag;
-			if (lcd_driver->lcd_config->customer_pinmux)
-				lcd_customer_pinmux_set(1);
-			else
-				lcd_p2p_pinmux_set(1);
+			lcd_tcon_pinmux_set(1);
 			break;
 		default:
 			break;
@@ -1532,18 +1452,6 @@ static struct lcd_data_s lcd_data_tm2 = {
 	.reg_map_table = &lcd_reg_tl1[0],
 };
 
-static struct lcd_data_s lcd_data_t5 = {
-	.chip_type = LCD_CHIP_T5,
-	.chip_name = "t5",
-	.reg_map_table = &lcd_reg_t5[0],
-};
-
-static struct lcd_data_s lcd_data_t5d = {
-	.chip_type = LCD_CHIP_T5D,
-	.chip_name = "t5d",
-	.reg_map_table = &lcd_reg_t5[0],
-};
-
 static const struct of_device_id lcd_dt_match_table[] = {
 	{
 		.compatible = "amlogic, lcd-gxl",
@@ -1585,14 +1493,6 @@ static const struct of_device_id lcd_dt_match_table[] = {
 		.compatible = "amlogic, lcd-tm2",
 		.data = &lcd_data_tm2,
 	},
-	{
-		.compatible = "amlogic, lcd-t5",
-		.data = &lcd_data_t5,
-	},
-	{
-		.compatible = "amlogic, lcd-t5d",
-		.data = &lcd_data_t5d,
-	},
 	{},
 };
 #endif
@@ -1617,7 +1517,6 @@ static int lcd_probe(struct platform_device *pdev)
 		return -1;
 	}
 	lcd_driver->data = (struct lcd_data_s *)match->data;
-	lcd_driver->boot_ctrl = &lcd_boot_ctrl_config,
 	strcpy(lcd_driver->version, LCD_DRV_VERSION);
 	LCDPR("driver version: %s(%d-%s)\n",
 		lcd_driver->version,
@@ -1626,11 +1525,10 @@ static int lcd_probe(struct platform_device *pdev)
 
 	mutex_init(&lcd_vout_mutex);
 	mutex_init(&lcd_driver->power_mutex);
-	spin_lock_init(&lcd_driver->isr_lock);
 	lcd_vout_serve_bypass = 0;
 
 	/* init workqueue */
-	INIT_WORK(&lcd_driver->lcd_probe_work,
+	INIT_DELAYED_WORK(&lcd_driver->lcd_probe_delayed_work,
 		lcd_config_probe_delayed);
 	INIT_DELAYED_WORK(&lcd_test_delayed_work, lcd_auto_test_delayed);
 	lcd_driver->workqueue = create_singlethread_workqueue("lcd_work_queue");
@@ -1652,7 +1550,7 @@ static int lcd_remove(struct platform_device *pdev)
 	if (lcd_driver == NULL)
 		return 0;
 
-	cancel_work(&lcd_driver->lcd_probe_work);
+	cancel_delayed_work(&lcd_driver->lcd_probe_delayed_work);
 	cancel_work_sync(&(lcd_driver->lcd_resume_work));
 	if (lcd_driver->workqueue)
 		destroy_workqueue(lcd_driver->workqueue);
@@ -1793,7 +1691,7 @@ static int __init lcd_boot_ctrl_setup(char *str)
 	lcd_boot_ctrl_config.lcd_type = 0xf & lcd_ctrl;
 	lcd_boot_ctrl_config.lcd_bits = 0xf & (lcd_ctrl >> 4);
 	lcd_boot_ctrl_config.advanced_flag = 0xff & (lcd_ctrl >> 8);
-	lcd_boot_ctrl_config.lcd_init_level = 0x3 & (lcd_ctrl >> 18);
+	lcd_boot_ctrl_config.lcd_init_level = 0x1 & (lcd_ctrl >> 19);
 	lcd_boot_ctrl_config.debug_print_flag = 0xf & (lcd_ctrl >> 20);
 	lcd_boot_ctrl_config.debug_test_pattern = 0xf & (lcd_ctrl >> 24);
 	lcd_boot_ctrl_config.debug_para_source = 0x3 & (lcd_ctrl >> 28);
diff --git a/drivers/amlogic/media/vout/vout_serve/Makefile b/drivers/amlogic/media/vout/vout_serve/Makefile
index ad36252be157..a8b4a893ad8f 100644
--- a/drivers/amlogic/media/vout/vout_serve/Makefile
+++ b/drivers/amlogic/media/vout/vout_serve/Makefile
@@ -1,3 +1,3 @@
-obj-$(CONFIG_AMLOGIC_VOUT_SERVE)	+= vout_reg.o vout_sys_serve.o dummy_venc.o vout_notify.o vout_serve.o vout_func.o
+obj-$(CONFIG_AMLOGIC_VOUT_SERVE)	+= vout_notify.o vout_serve.o vout_func.o dummy_lcd.o
 obj-$(CONFIG_AMLOGIC_VOUT2_SERVE)	+= vout2_notify.o vout2_serve.o
 
diff --git a/drivers/amlogic/media/vout/vout_serve/dummy_lcd.c b/drivers/amlogic/media/vout/vout_serve/dummy_lcd.c
new file mode 100644
index 000000000000..0c637258fc35
--- /dev/null
+++ b/drivers/amlogic/media/vout/vout_serve/dummy_lcd.c
@@ -0,0 +1,661 @@
+/*
+ * drivers/amlogic/media/vout/vout_serve/dummy_lcd.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* Linux Headers */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#ifdef CONFIG_AMLOGIC_VPU
+#include <linux/amlogic/media/vpu/vpu.h>
+#endif
+#include <linux/amlogic/media/vout/vout_notify.h>
+
+/* Local Headers */
+#include "vout_func.h"
+#include "vout_reg.h"
+
+struct dummy_lcd_driver_s {
+	struct device *dev;
+	unsigned char status;
+	unsigned char viu_sel;
+
+	unsigned char clk_gate_state;
+
+	struct clk *encp_top_gate;
+	struct clk *encp_int_gate0;
+	struct clk *encp_int_gate1;
+};
+
+static struct dummy_lcd_driver_s *dummy_lcd_drv;
+
+/* **********************************************************
+ * dummy_lcd support
+ * **********************************************************
+ */
+static struct vinfo_s dummy_lcd_vinfo = {
+	.name              = "dummy_panel",
+	.mode              = VMODE_DUMMY_LCD,
+	.width             = 1920,
+	.height            = 1080,
+	.field_height      = 1080,
+	.aspect_ratio_num  = 16,
+	.aspect_ratio_den  = 9,
+	.sync_duration_num = 60,
+	.sync_duration_den = 1,
+	.video_clk         = 148500000,
+	.htotal            = 2200,
+	.vtotal            = 1125,
+	.fr_adj_type       = VOUT_FR_ADJ_NONE,
+	.viu_color_fmt     = COLOR_FMT_RGB444,
+	.viu_mux           = VIU_MUX_ENCP,
+	.vout_device       = NULL,
+};
+
+static void dummy_lcd_venc_set(void)
+{
+	unsigned int temp;
+
+	VOUTPR("%s\n", __func__);
+
+	vout_vcbus_write(ENCP_VIDEO_EN, 0);
+
+	vout_vcbus_write(ENCP_VIDEO_MODE, 0x8000);
+	vout_vcbus_write(ENCP_VIDEO_MODE_ADV, 0x0418);
+
+	temp = vout_vcbus_read(ENCL_VIDEO_MAX_PXCNT);
+	vout_vcbus_write(ENCP_VIDEO_MAX_PXCNT, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_MAX_LNCNT);
+	vout_vcbus_write(ENCP_VIDEO_MAX_LNCNT, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_HAVON_BEGIN);
+	vout_vcbus_write(ENCP_VIDEO_HAVON_BEGIN, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_HAVON_END);
+	vout_vcbus_write(ENCP_VIDEO_HAVON_END, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_VAVON_BLINE);
+	vout_vcbus_write(ENCP_VIDEO_VAVON_BLINE, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_VAVON_ELINE);
+	vout_vcbus_write(ENCP_VIDEO_VAVON_ELINE, temp);
+
+	temp = vout_vcbus_read(ENCL_VIDEO_HSO_BEGIN);
+	vout_vcbus_write(ENCP_VIDEO_HSO_BEGIN, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_HSO_END);
+	vout_vcbus_write(ENCP_VIDEO_HSO_END,   temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_VSO_BEGIN);
+	vout_vcbus_write(ENCP_VIDEO_VSO_BEGIN, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_VSO_END);
+	vout_vcbus_write(ENCP_VIDEO_VSO_END,   temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_VSO_BLINE);
+	vout_vcbus_write(ENCP_VIDEO_VSO_BLINE, temp);
+	temp = vout_vcbus_read(ENCL_VIDEO_VSO_ELINE);
+	vout_vcbus_write(ENCP_VIDEO_VSO_ELINE, temp);
+
+	temp = vout_vcbus_read(ENCL_VIDEO_VSO_ELINE);
+	vout_vcbus_write(ENCP_VIDEO_RGBIN_CTRL, temp);
+
+	vout_vcbus_write(ENCP_VIDEO_EN, 1);
+}
+
+static void dummy_lcd_clk_ctrl(int flag)
+{
+	unsigned int temp;
+
+	if (flag) {
+		temp = vout_hiu_getb(HHI_VIID_CLK_DIV, ENCL_CLK_SEL, 4);
+		vout_hiu_setb(HHI_VID_CLK_DIV, temp, ENCP_CLK_SEL, 4);
+
+		vout_hiu_setb(HHI_VID_CLK_CNTL2, 1, ENCP_GATE_VCLK, 1);
+	} else {
+		vout_hiu_setb(HHI_VID_CLK_CNTL2, 0, ENCP_GATE_VCLK, 1);
+	}
+}
+
+static void dummy_lcd_clk_gate_switch(int flag)
+{
+	if (flag) {
+		if (dummy_lcd_drv->clk_gate_state)
+			return;
+		if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_top_gate))
+			VOUTERR("%s: encp_top_gate\n", __func__);
+		else
+			clk_prepare_enable(dummy_lcd_drv->encp_top_gate);
+		if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate0))
+			VOUTERR("%s: encp_int_gate0\n", __func__);
+		else
+			clk_prepare_enable(dummy_lcd_drv->encp_int_gate0);
+		if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate1))
+			VOUTERR("%s: encp_int_gate1\n", __func__);
+		else
+			clk_prepare_enable(dummy_lcd_drv->encp_int_gate1);
+		dummy_lcd_drv->clk_gate_state = 1;
+	} else {
+		if (dummy_lcd_drv->clk_gate_state == 0)
+			return;
+		dummy_lcd_drv->clk_gate_state = 0;
+		if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate0))
+			VOUTERR("%s: encp_int_gate0\n", __func__);
+		else
+			clk_disable_unprepare(dummy_lcd_drv->encp_int_gate0);
+		if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate1))
+			VOUTERR("%s: encp_int_gate1\n", __func__);
+		else
+			clk_disable_unprepare(dummy_lcd_drv->encp_int_gate1);
+		if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_top_gate))
+			VOUTERR("%s: encp_top_gate\n", __func__);
+		else
+			clk_disable_unprepare(dummy_lcd_drv->encp_top_gate);
+	}
+}
+
+static void dummy_lcd_vinfo_update(void)
+{
+	unsigned int lcd_viu_sel = 0;
+	const struct vinfo_s *vinfo = NULL;
+
+	if (dummy_lcd_drv->viu_sel == 1) {
+		vinfo = get_current_vinfo2();
+		lcd_viu_sel = 2;
+	} else if (dummy_lcd_drv->viu_sel == 2) {
+		vinfo = get_current_vinfo();
+		lcd_viu_sel = 1;
+	}
+
+	if (vinfo) {
+		if (vinfo->mode != VMODE_LCD) {
+			VOUTERR("display%d is not panel\n", lcd_viu_sel);
+			vinfo = NULL;
+		}
+	}
+	if (!vinfo)
+		return;
+
+	dummy_lcd_vinfo.width = vinfo->width;
+	dummy_lcd_vinfo.height = vinfo->height;
+	dummy_lcd_vinfo.field_height = vinfo->field_height;
+	dummy_lcd_vinfo.aspect_ratio_num = vinfo->aspect_ratio_num;
+	dummy_lcd_vinfo.aspect_ratio_den = vinfo->aspect_ratio_den;
+	dummy_lcd_vinfo.sync_duration_num = vinfo->sync_duration_num;
+	dummy_lcd_vinfo.sync_duration_den = vinfo->sync_duration_den;
+	dummy_lcd_vinfo.video_clk = vinfo->video_clk;
+	dummy_lcd_vinfo.htotal = vinfo->htotal;
+	dummy_lcd_vinfo.vtotal = vinfo->vtotal;
+	dummy_lcd_vinfo.viu_color_fmt = vinfo->viu_color_fmt;
+}
+
+static struct vinfo_s *dummy_lcd_get_current_info(void)
+{
+	return &dummy_lcd_vinfo;
+}
+
+static int dummy_lcd_set_current_vmode(enum vmode_e mode)
+{
+	dummy_lcd_vinfo_update();
+
+#ifdef CONFIG_AMLOGIC_VPU
+	request_vpu_clk_vmod(dummy_lcd_vinfo.video_clk, VPU_VENCP);
+	switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_ON);
+#endif
+	dummy_lcd_clk_gate_switch(1);
+
+	dummy_lcd_clk_ctrl(1);
+	dummy_lcd_venc_set();
+
+	dummy_lcd_drv->status = 1;
+	VOUTPR("%s finished\n", __func__);
+
+	return 0;
+}
+
+static enum vmode_e dummy_lcd_validate_vmode(char *name)
+{
+	enum vmode_e vmode = VMODE_MAX;
+
+	if (strcmp(dummy_lcd_vinfo.name, name) == 0)
+		vmode = dummy_lcd_vinfo.mode;
+
+	return vmode;
+}
+
+static int dummy_lcd_vmode_is_supported(enum vmode_e mode)
+{
+	if (dummy_lcd_vinfo.mode == (mode & VMODE_MODE_BIT_MASK))
+		return true;
+
+	return false;
+}
+
+static int dummy_lcd_disable(enum vmode_e cur_vmod)
+{
+	dummy_lcd_drv->status = 0;
+
+	vout_vcbus_write(ENCP_VIDEO_EN, 0); /* disable encp */
+	dummy_lcd_clk_ctrl(0);
+	dummy_lcd_clk_gate_switch(0);
+#ifdef CONFIG_AMLOGIC_VPU
+	switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_DOWN);
+	release_vpu_clk_vmod(VPU_VENCP);
+#endif
+
+	VOUTPR("%s finished\n", __func__);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int dummy_lcd_lcd_suspend(void)
+{
+	dummy_lcd_disable(VMODE_DUMMY_LCD);
+	return 0;
+}
+
+static int dummy_lcd_lcd_resume(void)
+{
+	dummy_lcd_set_current_vmode(VMODE_DUMMY_LCD);
+	return 0;
+}
+
+#endif
+
+static int dummy_lcd_vout_state;
+static int dummy_lcd_vout_set_state(int bit)
+{
+	dummy_lcd_vout_state |= (1 << bit);
+	dummy_lcd_drv->viu_sel = bit;
+	return 0;
+}
+
+static int dummy_lcd_vout_clr_state(int bit)
+{
+	dummy_lcd_vout_state &= ~(1 << bit);
+	if (dummy_lcd_drv->viu_sel == bit)
+		dummy_lcd_drv->viu_sel = 0;
+	return 0;
+}
+
+static int dummy_lcd_vout_get_state(void)
+{
+	return dummy_lcd_vout_state;
+}
+
+static struct vout_server_s dummy_lcd_vout_server = {
+	.name = "dummy_lcd_vout_server",
+	.op = {
+		.get_vinfo          = dummy_lcd_get_current_info,
+		.set_vmode          = dummy_lcd_set_current_vmode,
+		.validate_vmode     = dummy_lcd_validate_vmode,
+		.vmode_is_supported = dummy_lcd_vmode_is_supported,
+		.disable            = dummy_lcd_disable,
+		.set_state          = dummy_lcd_vout_set_state,
+		.clr_state          = dummy_lcd_vout_clr_state,
+		.get_state          = dummy_lcd_vout_get_state,
+		.set_bist           = NULL,
+#ifdef CONFIG_PM
+		.vout_suspend       = dummy_lcd_lcd_suspend,
+		.vout_resume        = dummy_lcd_lcd_resume,
+#endif
+	},
+};
+
+#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
+static struct vout_server_s dummy_lcd_vout2_server = {
+	.name = "dummy_lcd_vout2_server",
+	.op = {
+		.get_vinfo          = dummy_lcd_get_current_info,
+		.set_vmode          = dummy_lcd_set_current_vmode,
+		.validate_vmode     = dummy_lcd_validate_vmode,
+		.vmode_is_supported = dummy_lcd_vmode_is_supported,
+		.disable            = dummy_lcd_disable,
+		.set_state          = dummy_lcd_vout_set_state,
+		.clr_state          = dummy_lcd_vout_clr_state,
+		.get_state          = dummy_lcd_vout_get_state,
+		.set_bist           = NULL,
+#ifdef CONFIG_PM
+		.vout_suspend       = dummy_lcd_lcd_suspend,
+		.vout_resume        = dummy_lcd_lcd_resume,
+#endif
+	},
+};
+#endif
+
+static void dummy_lcd_vout_server_init(void)
+{
+	vout_register_server(&dummy_lcd_vout_server);
+#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
+	vout2_register_server(&dummy_lcd_vout2_server);
+#endif
+}
+
+static void dummy_lcd_vout_server_remove(void)
+{
+	vout_unregister_server(&dummy_lcd_vout_server);
+#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
+	vout2_unregister_server(&dummy_lcd_vout2_server);
+#endif
+}
+
+/* ********************************************************* */
+static int dummy_lcd_vout_mode_update(void)
+{
+	enum vmode_e mode = VMODE_DUMMY_LCD;
+
+	VOUTPR("%s\n", __func__);
+
+	if (dummy_lcd_drv->viu_sel == 1)
+		vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE_PRE, &mode);
+	else if (dummy_lcd_drv->viu_sel == 2)
+		vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE_PRE, &mode);
+	dummy_lcd_set_current_vmode(mode);
+	if (dummy_lcd_drv->viu_sel == 1)
+		vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
+	else if (dummy_lcd_drv->viu_sel == 2)
+		vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
+
+	return 0;
+}
+
+static int dummy_lcd_vout_notify_callback(struct notifier_block *block,
+		unsigned long cmd, void *para)
+{
+	const struct vinfo_s *vinfo;
+
+	switch (cmd) {
+	case VOUT_EVENT_MODE_CHANGE:
+		vinfo = get_current_vinfo();
+		if (!vinfo)
+			break;
+		if (vinfo->mode != VMODE_LCD)
+			break;
+		dummy_lcd_vout_mode_update();
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
+static int dummy_lcd_vout2_notify_callback(struct notifier_block *block,
+		unsigned long cmd, void *para)
+{
+	const struct vinfo_s *vinfo;
+
+	switch (cmd) {
+	case VOUT_EVENT_MODE_CHANGE:
+		vinfo = get_current_vinfo2();
+		if (!vinfo)
+			break;
+		if (vinfo->mode != VMODE_LCD)
+			break;
+		dummy_lcd_vout_mode_update();
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+#endif
+
+static struct notifier_block dummy_lcd_vout_notifier = {
+	.notifier_call = dummy_lcd_vout_notify_callback,
+};
+
+#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
+static struct notifier_block dummy_lcd_vout2_notifier = {
+	.notifier_call = dummy_lcd_vout2_notify_callback,
+};
+#endif
+
+/* ********************************************************* */
+static const char *dummy_lcd_debug_usage_str = {
+"Usage:\n"
+"    echo test <index> > /sys/class/dummy_lcd/debug ; test pattern for encp\n"
+"    echo reg > /sys/class/dummy_lcd/debug ; dump regs for encp\n"
+};
+
+static ssize_t dummy_lcd_debug_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", dummy_lcd_debug_usage_str);
+}
+
+static unsigned int dummy_lcd_reg_dump_encp[] = {
+	VPU_VIU_VENC_MUX_CTRL,
+	ENCP_VIDEO_EN,
+	ENCP_VIDEO_MODE,
+	ENCP_VIDEO_MODE_ADV,
+	ENCP_VIDEO_MAX_PXCNT,
+	ENCP_VIDEO_MAX_LNCNT,
+	ENCP_VIDEO_HAVON_BEGIN,
+	ENCP_VIDEO_HAVON_END,
+	ENCP_VIDEO_VAVON_BLINE,
+	ENCP_VIDEO_VAVON_ELINE,
+	ENCP_VIDEO_HSO_BEGIN,
+	ENCP_VIDEO_HSO_END,
+	ENCP_VIDEO_VSO_BEGIN,
+	ENCP_VIDEO_VSO_END,
+	ENCP_VIDEO_VSO_BLINE,
+	ENCP_VIDEO_VSO_ELINE,
+	ENCP_VIDEO_RGBIN_CTRL,
+	0xffff,
+};
+
+static ssize_t dummy_lcd_debug_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int val, i;
+
+	switch (buf[0]) {
+	case 't':
+		ret = sscanf(buf, "test %d", &val);
+		if (ret == 1) {
+			pr_info("todo bist pattern\n");
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
+		break;
+	case 'r':
+		pr_info("dummy_lcd register dump:\n");
+		i = 0;
+		while (i < ARRAY_SIZE(dummy_lcd_reg_dump_encp)) {
+			if (dummy_lcd_reg_dump_encp[i] == 0xffff)
+				break;
+			pr_info("vcbus   [0x%04x] = 0x%08x\n",
+				dummy_lcd_reg_dump_encp[i],
+				vout_vcbus_read(dummy_lcd_reg_dump_encp[i]));
+			i++;
+		}
+		break;
+	default:
+		pr_info("invalid data\n");
+		break;
+	}
+
+	return count;
+}
+
+static struct class_attribute dummy_lcd_class_attrs[] = {
+	__ATTR(debug, 0644,
+		dummy_lcd_debug_show, dummy_lcd_debug_store),
+};
+
+static struct class *debug_class;
+static int dummy_lcd_creat_class(void)
+{
+	int i;
+
+	debug_class = class_create(THIS_MODULE, "dummy_lcd");
+	if (IS_ERR(debug_class)) {
+		VOUTERR("create debug class failed\n");
+		return -1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dummy_lcd_class_attrs); i++) {
+		if (class_create_file(debug_class, &dummy_lcd_class_attrs[i])) {
+			VOUTERR("create debug attribute %s failed\n",
+				dummy_lcd_class_attrs[i].attr.name);
+		}
+	}
+
+	return 0;
+}
+
+static int dummy_lcd_remove_class(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dummy_lcd_class_attrs); i++)
+		class_remove_file(debug_class, &dummy_lcd_class_attrs[i]);
+
+	class_destroy(debug_class);
+	debug_class = NULL;
+
+	return 0;
+}
+/* ********************************************************* */
+
+static void dummy_lcd_clktree_probe(void)
+{
+	dummy_lcd_drv->clk_gate_state = 0;
+
+	dummy_lcd_drv->encp_top_gate = devm_clk_get(dummy_lcd_drv->dev,
+			"encp_top_gate");
+	if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_top_gate))
+		VOUTERR("%s: get encp_top_gate error\n", __func__);
+
+	dummy_lcd_drv->encp_int_gate0 = devm_clk_get(dummy_lcd_drv->dev,
+			"encp_int_gate0");
+	if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate0))
+		VOUTERR("%s: get encp_int_gate0 error\n", __func__);
+
+	dummy_lcd_drv->encp_int_gate1 = devm_clk_get(dummy_lcd_drv->dev,
+			"encp_int_gate1");
+	if (IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate1))
+		VOUTERR("%s: get encp_int_gate1 error\n", __func__);
+}
+
+static void dummy_lcd_clktree_remove(void)
+{
+	if (!IS_ERR_OR_NULL(dummy_lcd_drv->encp_top_gate))
+		devm_clk_put(dummy_lcd_drv->dev, dummy_lcd_drv->encp_top_gate);
+	if (!IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate0))
+		devm_clk_put(dummy_lcd_drv->dev, dummy_lcd_drv->encp_int_gate0);
+	if (!IS_ERR_OR_NULL(dummy_lcd_drv->encp_int_gate1))
+		devm_clk_put(dummy_lcd_drv->dev, dummy_lcd_drv->encp_int_gate1);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id dummy_lcd_dt_match_table[] = {
+	{
+		.compatible = "amlogic, dummy_lcd",
+	},
+	{},
+};
+#endif
+
+static int dummy_lcd_probe(struct platform_device *pdev)
+{
+	dummy_lcd_drv = kzalloc(sizeof(struct dummy_lcd_driver_s), GFP_KERNEL);
+	if (!dummy_lcd_drv) {
+		VOUTERR("%s: dummy_lcd driver no enough memory\n", __func__);
+		return -ENOMEM;
+	}
+	dummy_lcd_drv->dev = &pdev->dev;
+
+	dummy_lcd_clktree_probe();
+	dummy_lcd_vout_server_init();
+
+	vout_register_client(&dummy_lcd_vout_notifier);
+#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
+	vout2_register_client(&dummy_lcd_vout2_notifier);
+#endif
+	dummy_lcd_creat_class();
+
+	VOUTPR("%s OK\n", __func__);
+
+	return 0;
+}
+
+static int dummy_lcd_remove(struct platform_device *pdev)
+{
+	if (dummy_lcd_drv == NULL)
+		return 0;
+
+	dummy_lcd_remove_class();
+	vout_unregister_client(&dummy_lcd_vout_notifier);
+#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
+	vout2_unregister_client(&dummy_lcd_vout2_notifier);
+#endif
+	dummy_lcd_vout_server_remove();
+	dummy_lcd_clktree_remove();
+
+	kfree(dummy_lcd_drv);
+	dummy_lcd_drv = NULL;
+
+	VOUTPR("%s\n", __func__);
+	return 0;
+}
+
+static void dummy_lcd_shutdown(struct platform_device *pdev)
+{
+	if (dummy_lcd_drv == NULL)
+		return;
+	if (dummy_lcd_drv->status)
+		dummy_lcd_disable(VMODE_DUMMY_LCD);
+}
+
+static struct platform_driver dummy_lcd_platform_driver = {
+	.probe = dummy_lcd_probe,
+	.remove = dummy_lcd_remove,
+	.shutdown = dummy_lcd_shutdown,
+	.driver = {
+		.name = "dummy_lcd",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = dummy_lcd_dt_match_table,
+#endif
+	},
+};
+
+static int __init dummy_lcd_init(void)
+{
+	if (platform_driver_register(&dummy_lcd_platform_driver)) {
+		VOUTERR("failed to register dummy_lcd driver module\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit dummy_lcd_exit(void)
+{
+	platform_driver_unregister(&dummy_lcd_platform_driver);
+}
+
+subsys_initcall(dummy_lcd_init);
+module_exit(dummy_lcd_exit);
+
diff --git a/drivers/amlogic/media/vout/vout_serve/dummy_venc.c b/drivers/amlogic/media/vout/vout_serve/dummy_venc.c
deleted file mode 100644
index d847d78202dc..000000000000
--- a/drivers/amlogic/media/vout/vout_serve/dummy_venc.c
+++ /dev/null
@@ -1,1691 +0,0 @@
-/*
- * drivers/amlogic/media/vout/vout_serve/dummy_venc.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-/* Linux Headers */
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/ctype.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/clk.h>
-#include <linux/delay.h>
-#ifdef CONFIG_AMLOGIC_VPU
-#include <linux/amlogic/media/vpu/vpu.h>
-#endif
-#include <linux/amlogic/media/vout/vout_notify.h>
-
-/* Local Headers */
-#include "vout_func.h"
-#include "vout_reg.h"
-
-struct dummy_venc_data_s {
-	unsigned int vid_clk_ctrl_reg;
-	unsigned int vid_clk_ctrl2_reg;
-	unsigned int vid_clk_div_reg;
-	unsigned int vid2_clk_ctrl_reg;
-	unsigned int vid2_clk_div_reg;
-	unsigned int vid_clk_mux;
-	unsigned int vid2_clk_mux;
-
-	void (*clktree_probe)(struct device *dev);
-	void (*clktree_remove)(struct device *dev);
-	void (*encp_clk_gate_switch)(int flag);
-	void (*enci_clk_gate_switch)(int flag);
-	void (*encl_clk_gate_switch)(int flag);
-};
-
-static struct dummy_venc_data_s *dummy_venc_data;
-
-struct dummy_venc_driver_s {
-	struct device *dev;
-	unsigned char status;
-	unsigned char viu_sel;
-
-	unsigned char clk_gate_state;
-
-	struct clk *top_gate;
-	struct clk *int_gate0;
-	struct clk *int_gate1;
-};
-
-static struct dummy_venc_driver_s *dummy_encp_drv;
-static struct dummy_venc_driver_s *dummy_enci_drv;
-static struct dummy_venc_driver_s *dummy_encl_drv;
-
-/* **********************************************************
- * dummy_encp support
- * **********************************************************
- */
-static unsigned int dummy_encp_index = 0xff;
-static struct vinfo_s dummy_encp_vinfo[] = {
-	{
-		.name              = "dummy_panel",
-		.mode              = VMODE_DUMMY_ENCP,
-		.frac              = 0,
-		.width             = 1920,
-		.height            = 1080,
-		.field_height      = 1080,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.video_clk         = 148500000,
-		.htotal            = 2200,
-		.vtotal            = 1125,
-		.fr_adj_type       = VOUT_FR_ADJ_NONE,
-		.viu_color_fmt     = COLOR_FMT_RGB444,
-		.viu_mux           = VIU_MUX_ENCP,
-		.vout_device       = NULL,
-	},
-	{
-		.name              = "dummy_p",
-		.mode              = VMODE_DUMMY_ENCP,
-		.frac              = 0,
-		.width             = 720,
-		.height            = 480,
-		.field_height      = 480,
-		.aspect_ratio_num  = 4,
-		.aspect_ratio_den  = 3,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-		.video_clk         = 25000000,
-		.htotal            = 952,
-		.vtotal            = 525,
-		.fr_adj_type       = VOUT_FR_ADJ_NONE,
-		.viu_color_fmt     = COLOR_FMT_YUV444,
-		.viu_mux           = VIU_MUX_ENCP,
-		.vout_device       = NULL,
-	},
-};
-
-static void dummy_encp_venc_set(void)
-{
-	unsigned int temp;
-
-	VOUTPR("%s: dummy_encp_index=%d\n", __func__, dummy_encp_index);
-
-	if (dummy_encp_index == 0) {
-		vout_vcbus_write(ENCP_VIDEO_EN, 0);
-
-		vout_vcbus_write(ENCP_VIDEO_MODE, 0x8000);
-		vout_vcbus_write(ENCP_VIDEO_MODE_ADV, 0x0418);
-
-		temp = vout_vcbus_read(ENCL_VIDEO_MAX_PXCNT);
-		vout_vcbus_write(ENCP_VIDEO_MAX_PXCNT, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_MAX_LNCNT);
-		vout_vcbus_write(ENCP_VIDEO_MAX_LNCNT, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_HAVON_BEGIN);
-		vout_vcbus_write(ENCP_VIDEO_HAVON_BEGIN, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_HAVON_END);
-		vout_vcbus_write(ENCP_VIDEO_HAVON_END, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_VAVON_BLINE);
-		vout_vcbus_write(ENCP_VIDEO_VAVON_BLINE, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_VAVON_ELINE);
-		vout_vcbus_write(ENCP_VIDEO_VAVON_ELINE, temp);
-
-		temp = vout_vcbus_read(ENCL_VIDEO_HSO_BEGIN);
-		vout_vcbus_write(ENCP_VIDEO_HSO_BEGIN, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_HSO_END);
-		vout_vcbus_write(ENCP_VIDEO_HSO_END,   temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_VSO_BEGIN);
-		vout_vcbus_write(ENCP_VIDEO_VSO_BEGIN, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_VSO_END);
-		vout_vcbus_write(ENCP_VIDEO_VSO_END,   temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_VSO_BLINE);
-		vout_vcbus_write(ENCP_VIDEO_VSO_BLINE, temp);
-		temp = vout_vcbus_read(ENCL_VIDEO_VSO_ELINE);
-		vout_vcbus_write(ENCP_VIDEO_VSO_ELINE, temp);
-
-		temp = vout_vcbus_read(ENCL_VIDEO_VSO_ELINE);
-		vout_vcbus_write(ENCP_VIDEO_RGBIN_CTRL, temp);
-
-		vout_vcbus_write(ENCP_VIDEO_EN, 1);
-	} else {
-		vout_vcbus_write(ENCP_VIDEO_EN, 0);
-
-		vout_vcbus_write(ENCP_VIDEO_MODE, 0x8000);
-		vout_vcbus_write(ENCP_VIDEO_MODE_ADV, 0x0418);
-
-		vout_vcbus_write(ENCP_VIDEO_MAX_PXCNT, 951);
-		vout_vcbus_write(ENCP_VIDEO_MAX_LNCNT, 524);
-		vout_vcbus_write(ENCP_VIDEO_HAVON_BEGIN, 80);
-		vout_vcbus_write(ENCP_VIDEO_HAVON_END, 799);
-		vout_vcbus_write(ENCP_VIDEO_VAVON_BLINE, 22);
-		vout_vcbus_write(ENCP_VIDEO_VAVON_ELINE, 501);
-
-		vout_vcbus_write(ENCP_VIDEO_HSO_BEGIN, 0);
-		vout_vcbus_write(ENCP_VIDEO_HSO_END,   20);
-		vout_vcbus_write(ENCP_VIDEO_VSO_BEGIN, 0);
-		vout_vcbus_write(ENCP_VIDEO_VSO_END,   0);
-		vout_vcbus_write(ENCP_VIDEO_VSO_BLINE, 0);
-		vout_vcbus_write(ENCP_VIDEO_VSO_ELINE, 5);
-
-		vout_vcbus_write(ENCP_VIDEO_RGBIN_CTRL, 1);
-
-		vout_vcbus_write(ENCP_VIDEO_EN, 1);
-	}
-}
-
-static void dummy_encp_clk_ctrl(int flag)
-{
-	unsigned int temp;
-
-	if (!dummy_venc_data) {
-		VOUTERR("%s: no dummy_venc_data\n", __func__);
-		return;
-	}
-
-	if (dummy_encp_index == 0) {
-		if (dummy_venc_data->vid2_clk_mux == 0xff) {
-			VOUTERR("%s: invalid vid2_clk, unsupport dummy_panel\n",
-				__func__);
-			return;
-		}
-		if (flag) {
-			temp = vout_hiu_getb(dummy_venc_data->vid2_clk_div_reg,
-					     ENCL_CLK_SEL, 4);
-			vout_hiu_setb(dummy_venc_data->vid_clk_div_reg,
-				      temp, ENCP_CLK_SEL, 4);
-
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl2_reg,
-				      1, ENCP_GATE_VCLK, 1);
-		} else {
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl2_reg,
-				      0, ENCP_GATE_VCLK, 1);
-		}
-	} else {
-		if (flag) {
-			/* clk source sel: fckl_div5 */
-			vout_hiu_setb(dummy_venc_data->vid_clk_div_reg,
-				      0xf, VCLK_XD0, 8);
-			udelay(5);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl_reg,
-				      dummy_venc_data->vid_clk_mux,
-				      VCLK_CLK_IN_SEL, 3);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl_reg,
-				      1, VCLK_EN0, 1);
-			udelay(5);
-			vout_hiu_setb(dummy_venc_data->vid_clk_div_reg,
-				      0, ENCP_CLK_SEL, 4);
-			vout_hiu_setb(dummy_venc_data->vid_clk_div_reg,
-				      1, VCLK_XD_EN, 1);
-			udelay(5);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl_reg,
-				      1, VCLK_DIV1_EN, 1);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl_reg,
-				      1, VCLK_SOFT_RST, 1);
-			udelay(10);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl_reg,
-				      0, VCLK_SOFT_RST, 1);
-			udelay(5);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl2_reg,
-				      1, ENCP_GATE_VCLK, 1);
-		} else {
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl2_reg,
-				      0, ENCP_GATE_VCLK, 1);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl_reg,
-				      0, VCLK_DIV1_EN, 1);
-			vout_hiu_setb(dummy_venc_data->vid_clk_ctrl_reg,
-				      0, VCLK_EN0, 1);
-			vout_hiu_setb(dummy_venc_data->vid_clk_div_reg,
-				      0, VCLK_XD_EN, 1);
-		}
-	}
-}
-
-static void dummy_encp_clk_gate_switch(int flag)
-{
-	if (flag) {
-		if (dummy_encp_drv->clk_gate_state)
-			return;
-		if (IS_ERR_OR_NULL(dummy_encp_drv->top_gate))
-			VOUTERR("%s: encp_top_gate\n", __func__);
-		else
-			clk_prepare_enable(dummy_encp_drv->top_gate);
-		if (IS_ERR_OR_NULL(dummy_encp_drv->int_gate0))
-			VOUTERR("%s: encp_int_gate0\n", __func__);
-		else
-			clk_prepare_enable(dummy_encp_drv->int_gate0);
-		if (IS_ERR_OR_NULL(dummy_encp_drv->int_gate1))
-			VOUTERR("%s: encp_int_gate1\n", __func__);
-		else
-			clk_prepare_enable(dummy_encp_drv->int_gate1);
-		dummy_encp_drv->clk_gate_state = 1;
-	} else {
-		if (dummy_encp_drv->clk_gate_state == 0)
-			return;
-		dummy_encp_drv->clk_gate_state = 0;
-		if (IS_ERR_OR_NULL(dummy_encp_drv->int_gate0))
-			VOUTERR("%s: encp_int_gate0\n", __func__);
-		else
-			clk_disable_unprepare(dummy_encp_drv->int_gate0);
-		if (IS_ERR_OR_NULL(dummy_encp_drv->int_gate1))
-			VOUTERR("%s: encp_int_gate1\n", __func__);
-		else
-			clk_disable_unprepare(dummy_encp_drv->int_gate1);
-		if (IS_ERR_OR_NULL(dummy_encp_drv->top_gate))
-			VOUTERR("%s: encp_top_gate\n", __func__);
-		else
-			clk_disable_unprepare(dummy_encp_drv->top_gate);
-	}
-}
-
-static void dummy_encp_vinfo_update(void)
-{
-	unsigned int lcd_viu_sel = 0;
-	const struct vinfo_s *vinfo = NULL;
-
-	/* only dummy_panel need update vinfo */
-	if (dummy_encp_index != 0)
-		return;
-
-	if (dummy_encp_drv->viu_sel == 1) {
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-		vinfo = get_current_vinfo2();
-		lcd_viu_sel = 2;
-#endif
-	} else if (dummy_encp_drv->viu_sel == 2) {
-		vinfo = get_current_vinfo();
-		lcd_viu_sel = 1;
-	}
-
-	if (vinfo) {
-		if (vinfo->mode != VMODE_LCD) {
-			VOUTERR("display%d is not panel\n",
-				lcd_viu_sel);
-			vinfo = NULL;
-		}
-	}
-	if (!vinfo)
-		return;
-
-	dummy_encp_vinfo[0].width = vinfo->width;
-	dummy_encp_vinfo[0].height = vinfo->height;
-	dummy_encp_vinfo[0].field_height = vinfo->field_height;
-	dummy_encp_vinfo[0].aspect_ratio_num = vinfo->aspect_ratio_num;
-	dummy_encp_vinfo[0].aspect_ratio_den = vinfo->aspect_ratio_den;
-	dummy_encp_vinfo[0].sync_duration_num = vinfo->sync_duration_num;
-	dummy_encp_vinfo[0].sync_duration_den = vinfo->sync_duration_den;
-	dummy_encp_vinfo[0].video_clk = vinfo->video_clk;
-	dummy_encp_vinfo[0].htotal = vinfo->htotal;
-	dummy_encp_vinfo[0].vtotal = vinfo->vtotal;
-	dummy_encp_vinfo[0].viu_color_fmt = vinfo->viu_color_fmt;
-}
-
-static struct vinfo_s *dummy_encp_get_current_info(void)
-{
-	if (dummy_encp_index > 1)
-		return NULL;
-
-	return &dummy_encp_vinfo[dummy_encp_index];
-}
-
-static int dummy_encp_set_current_vmode(enum vmode_e mode)
-{
-	if (dummy_encp_index > 1)
-		return -1;
-
-	dummy_encp_vinfo_update();
-
-#ifdef CONFIG_AMLOGIC_VPU
-	request_vpu_clk_vmod(dummy_encp_vinfo[dummy_encp_index].video_clk,
-			     VPU_VENCP);
-	switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_ON);
-#endif
-	if (dummy_venc_data && dummy_venc_data->encp_clk_gate_switch)
-		dummy_venc_data->encp_clk_gate_switch(1);
-
-	dummy_encp_clk_ctrl(1);
-	dummy_encp_venc_set();
-
-	dummy_encp_drv->status = 1;
-	VOUTPR("%s finished\n", __func__);
-
-	return 0;
-}
-
-static enum vmode_e dummy_encp_validate_vmode(char *name, unsigned int frac)
-{
-	enum vmode_e vmode = VMODE_MAX;
-	int i;
-
-	if (frac)
-		return VMODE_MAX;
-
-	for (i = 0; i < 2; i++) {
-		if (strcmp(dummy_encp_vinfo[i].name, name) == 0) {
-			vmode = dummy_encp_vinfo[i].mode;
-			dummy_encp_index = i;
-			break;
-		}
-	}
-
-	return vmode;
-}
-
-static int dummy_encp_vmode_is_supported(enum vmode_e mode)
-{
-	if ((mode & VMODE_MODE_BIT_MASK) == VMODE_DUMMY_ENCP)
-		return true;
-
-	return false;
-}
-
-static int dummy_encp_disable(enum vmode_e cur_vmod)
-{
-	dummy_encp_drv->status = 0;
-	dummy_encp_index = 0xff;
-
-	vout_vcbus_write(ENCP_VIDEO_EN, 0); /* disable encp */
-	dummy_encp_clk_ctrl(0);
-	if (dummy_venc_data && dummy_venc_data->encp_clk_gate_switch)
-		dummy_venc_data->encp_clk_gate_switch(0);
-#ifdef CONFIG_AMLOGIC_VPU
-	switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_DOWN);
-	release_vpu_clk_vmod(VPU_VENCP);
-#endif
-
-	VOUTPR("%s finished\n", __func__);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int dummy_encp_lcd_suspend(void)
-{
-	dummy_encp_drv->status = 0;
-
-	vout_vcbus_write(ENCP_VIDEO_EN, 0); /* disable encp */
-	dummy_encp_clk_ctrl(0);
-	if (dummy_venc_data && dummy_venc_data->encp_clk_gate_switch)
-		dummy_venc_data->encp_clk_gate_switch(0);
-#ifdef CONFIG_AMLOGIC_VPU
-	switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_DOWN);
-	release_vpu_clk_vmod(VPU_VENCP);
-#endif
-
-	return 0;
-}
-
-static int dummy_encp_lcd_resume(void)
-{
-	dummy_encp_set_current_vmode(VMODE_DUMMY_ENCP);
-	return 0;
-}
-#endif
-
-static int dummy_encp_vout_state;
-static int dummy_encp_vout_set_state(int bit)
-{
-	dummy_encp_vout_state |= (1 << bit);
-	dummy_encp_drv->viu_sel = bit;
-	return 0;
-}
-
-static int dummy_encp_vout_clr_state(int bit)
-{
-	dummy_encp_vout_state &= ~(1 << bit);
-	if (dummy_encp_drv->viu_sel == bit)
-		dummy_encp_drv->viu_sel = 0;
-	return 0;
-}
-
-static int dummy_encp_vout_get_state(void)
-{
-	return dummy_encp_vout_state;
-}
-
-static struct vout_server_s dummy_encp_vout_server = {
-	.name = "dummy_encp_vout_server",
-	.op = {
-		.get_vinfo          = dummy_encp_get_current_info,
-		.set_vmode          = dummy_encp_set_current_vmode,
-		.validate_vmode     = dummy_encp_validate_vmode,
-		.vmode_is_supported = dummy_encp_vmode_is_supported,
-		.disable            = dummy_encp_disable,
-		.set_state          = dummy_encp_vout_set_state,
-		.clr_state          = dummy_encp_vout_clr_state,
-		.get_state          = dummy_encp_vout_get_state,
-		.set_bist           = NULL,
-#ifdef CONFIG_PM
-		.vout_suspend       = dummy_encp_lcd_suspend,
-		.vout_resume        = dummy_encp_lcd_resume,
-#endif
-	},
-};
-
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-static struct vout_server_s dummy_encp_vout2_server = {
-	.name = "dummy_encp_vout2_server",
-	.op = {
-		.get_vinfo          = dummy_encp_get_current_info,
-		.set_vmode          = dummy_encp_set_current_vmode,
-		.validate_vmode     = dummy_encp_validate_vmode,
-		.vmode_is_supported = dummy_encp_vmode_is_supported,
-		.disable            = dummy_encp_disable,
-		.set_state          = dummy_encp_vout_set_state,
-		.clr_state          = dummy_encp_vout_clr_state,
-		.get_state          = dummy_encp_vout_get_state,
-		.set_bist           = NULL,
-#ifdef CONFIG_PM
-		.vout_suspend       = dummy_encp_lcd_suspend,
-		.vout_resume        = dummy_encp_lcd_resume,
-#endif
-	},
-};
-#endif
-
-static void dummy_encp_vout_server_init(void)
-{
-	vout_register_server(&dummy_encp_vout_server);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_register_server(&dummy_encp_vout2_server);
-#endif
-}
-
-static void dummy_encp_vout_server_remove(void)
-{
-	vout_unregister_server(&dummy_encp_vout_server);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_unregister_server(&dummy_encp_vout2_server);
-#endif
-}
-
-/* **********************************************************
- * dummy_enci support
- * **********************************************************
- */
-static struct vinfo_s dummy_enci_vinfo = {
-	.name              = "dummy_i",
-	.mode              = VMODE_DUMMY_ENCI,
-	.frac              = 0,
-	.width             = 720,
-	.height            = 480,
-	.field_height      = 240,
-	.aspect_ratio_num  = 4,
-	.aspect_ratio_den  = 3,
-	.sync_duration_num = 55,
-	.sync_duration_den = 1,
-	.video_clk         = 25000000,
-	.htotal            = 1716,
-	.vtotal            = 525,
-	.fr_adj_type       = VOUT_FR_ADJ_NONE,
-	.viu_color_fmt     = COLOR_FMT_YUV444,
-	.viu_mux           = VIU_MUX_ENCI,
-	.vout_device       = NULL,
-};
-
-static void dummy_enci_venc_set(void)
-{
-	VOUTPR("%s\n", __func__);
-
-	vout_vcbus_write(ENCI_VIDEO_EN, 0);
-
-	vout_vcbus_write(ENCI_CFILT_CTRL,                 0x12);
-	vout_vcbus_write(ENCI_CFILT_CTRL2,                0x12);
-	vout_vcbus_write(ENCI_VIDEO_MODE,                 0);
-	vout_vcbus_write(ENCI_VIDEO_MODE_ADV,             0);
-	vout_vcbus_write(ENCI_SYNC_HSO_BEGIN,             5);
-	vout_vcbus_write(ENCI_SYNC_HSO_END,               129);
-	vout_vcbus_write(ENCI_SYNC_VSO_EVNLN,             0x0003);
-	vout_vcbus_write(ENCI_SYNC_VSO_ODDLN,             0x0104);
-	vout_vcbus_write(ENCI_MACV_MAX_AMP,               0x810b);
-	vout_vcbus_write(VENC_VIDEO_PROG_MODE,            0xf0);
-	vout_vcbus_write(ENCI_VIDEO_MODE,                 0x08);
-	vout_vcbus_write(ENCI_VIDEO_MODE_ADV,             0x26);
-	vout_vcbus_write(ENCI_VIDEO_SCH,                  0x20);
-	vout_vcbus_write(ENCI_SYNC_MODE,                  0x07);
-	vout_vcbus_write(ENCI_YC_DELAY,                   0x333);
-	vout_vcbus_write(ENCI_VFIFO2VD_PIXEL_START,       0xe3);
-	vout_vcbus_write(ENCI_VFIFO2VD_PIXEL_END,         0x0683);
-	vout_vcbus_write(ENCI_VFIFO2VD_LINE_TOP_START,    0x12);
-	vout_vcbus_write(ENCI_VFIFO2VD_LINE_TOP_END,      0x102);
-	vout_vcbus_write(ENCI_VFIFO2VD_LINE_BOT_START,    0x13);
-	vout_vcbus_write(ENCI_VFIFO2VD_LINE_BOT_END,      0x103);
-	vout_vcbus_write(VENC_SYNC_ROUTE,                 0);
-	vout_vcbus_write(ENCI_DBG_PX_RST,                 0);
-	vout_vcbus_write(VENC_INTCTRL,                    0x2);
-	vout_vcbus_write(ENCI_VFIFO2VD_CTL,               0x4e01);
-	vout_vcbus_write(VENC_UPSAMPLE_CTRL0,             0x0061);
-	vout_vcbus_write(VENC_UPSAMPLE_CTRL1,             0x4061);
-	vout_vcbus_write(VENC_UPSAMPLE_CTRL2,             0x5061);
-	vout_vcbus_write(ENCI_DACSEL_0,                   0x0011);
-	vout_vcbus_write(ENCI_DACSEL_1,                   0x11);
-	vout_vcbus_write(ENCI_VIDEO_EN,                   1);
-	vout_vcbus_write(ENCI_VIDEO_SAT,                  0x12);
-	vout_vcbus_write(ENCI_SYNC_ADJ,                   0x9c00);
-	vout_vcbus_write(ENCI_VIDEO_CONT,                 0x3);
-}
-
-static void dummy_enci_clk_ctrl(int flag)
-{
-	unsigned int reg_ctrl, reg_div, reg_ctrl2;
-	unsigned int clk_mux, clk_sel;
-
-	if (!dummy_venc_data) {
-		VOUTERR("%s: no dummy_venc_data\n", __func__);
-		return;
-	}
-	if (dummy_venc_data->vid2_clk_mux == 0xff) {
-		reg_ctrl = dummy_venc_data->vid_clk_ctrl_reg;
-		reg_div = dummy_venc_data->vid_clk_div_reg;
-		clk_mux = dummy_venc_data->vid_clk_mux;
-		clk_sel = 0;
-	} else {
-		reg_ctrl = dummy_venc_data->vid2_clk_ctrl_reg;
-		reg_div = dummy_venc_data->vid2_clk_div_reg;
-		clk_mux = dummy_venc_data->vid2_clk_mux;
-		clk_sel = 8;
-	}
-	reg_ctrl2 = dummy_venc_data->vid_clk_ctrl2_reg;
-
-	if (flag) {
-		/* clk source sel: fckl_div5 */
-		vout_hiu_setb(reg_div, 0xf, VCLK2_XD, 8);
-		udelay(5);
-		vout_hiu_setb(reg_ctrl, clk_mux, VCLK2_CLK_IN_SEL, 3);
-		vout_hiu_setb(reg_ctrl, 1, VCLK2_EN, 1);
-		udelay(5);
-
-		vout_hiu_setb(dummy_venc_data->vid_clk_div_reg,
-			      clk_sel, ENCI_CLK_SEL, 4);
-		vout_hiu_setb(reg_div, 1, VCLK2_XD_EN, 1);
-		udelay(5);
-
-		vout_hiu_setb(reg_ctrl, 1, VCLK2_DIV1_EN, 1);
-		vout_hiu_setb(reg_ctrl, 1, VCLK2_SOFT_RST, 1);
-		udelay(10);
-		vout_hiu_setb(reg_ctrl, 0, VCLK2_SOFT_RST, 1);
-		udelay(5);
-		vout_hiu_setb(reg_ctrl2, 1, ENCI_GATE_VCLK, 1);
-	} else {
-		vout_hiu_setb(reg_ctrl2, 0, ENCI_GATE_VCLK, 1);
-		vout_hiu_setb(reg_ctrl, 0, VCLK2_DIV1_EN, 1);
-		vout_hiu_setb(reg_ctrl, 0, VCLK2_EN, 1);
-		vout_hiu_setb(reg_div, 0, VCLK2_XD_EN, 1);
-	}
-}
-
-static void dummy_enci_clk_gate_switch(int flag)
-{
-	if (flag) {
-		if (dummy_enci_drv->clk_gate_state)
-			return;
-		if (IS_ERR_OR_NULL(dummy_enci_drv->top_gate))
-			VOUTERR("%s: enci_top_gate\n", __func__);
-		else
-			clk_prepare_enable(dummy_enci_drv->top_gate);
-		if (IS_ERR_OR_NULL(dummy_enci_drv->int_gate0))
-			VOUTERR("%s: enci_int_gate0\n", __func__);
-		else
-			clk_prepare_enable(dummy_enci_drv->int_gate0);
-		if (IS_ERR_OR_NULL(dummy_enci_drv->int_gate1))
-			VOUTERR("%s: enci_int_gate1\n", __func__);
-		else
-			clk_prepare_enable(dummy_enci_drv->int_gate1);
-		dummy_enci_drv->clk_gate_state = 1;
-	} else {
-		if (dummy_enci_drv->clk_gate_state == 0)
-			return;
-		dummy_enci_drv->clk_gate_state = 0;
-		if (IS_ERR_OR_NULL(dummy_enci_drv->int_gate0))
-			VOUTERR("%s: enci_int_gate0\n", __func__);
-		else
-			clk_disable_unprepare(dummy_enci_drv->int_gate0);
-		if (IS_ERR_OR_NULL(dummy_enci_drv->int_gate1))
-			VOUTERR("%s: enci_int_gate1\n", __func__);
-		else
-			clk_disable_unprepare(dummy_enci_drv->int_gate1);
-		if (IS_ERR_OR_NULL(dummy_enci_drv->top_gate))
-			VOUTERR("%s: enci_top_gate\n", __func__);
-		else
-			clk_disable_unprepare(dummy_enci_drv->top_gate);
-	}
-}
-
-static struct vinfo_s *dummy_enci_get_current_info(void)
-{
-	return &dummy_enci_vinfo;
-}
-
-static int dummy_enci_set_current_vmode(enum vmode_e mode)
-{
-#ifdef CONFIG_AMLOGIC_VPU
-	request_vpu_clk_vmod(dummy_enci_vinfo.video_clk, VPU_VENCI);
-	switch_vpu_mem_pd_vmod(VPU_VENCI, VPU_MEM_POWER_ON);
-#endif
-	if (dummy_venc_data && dummy_venc_data->enci_clk_gate_switch)
-		dummy_venc_data->enci_clk_gate_switch(1);
-
-	dummy_enci_clk_ctrl(1);
-	dummy_enci_venc_set();
-
-	dummy_enci_drv->status = 1;
-	VOUTPR("%s finished\n", __func__);
-
-	return 0;
-}
-
-static enum vmode_e dummy_enci_validate_vmode(char *name, unsigned int frac)
-{
-	enum vmode_e vmode = VMODE_MAX;
-
-	if (frac)
-		return VMODE_MAX;
-
-	if (strcmp(dummy_enci_vinfo.name, name) == 0)
-		vmode = dummy_enci_vinfo.mode;
-
-	return vmode;
-}
-
-static int dummy_enci_vmode_is_supported(enum vmode_e mode)
-{
-	if ((mode & VMODE_MODE_BIT_MASK) == VMODE_DUMMY_ENCI)
-		return true;
-
-	return false;
-}
-
-static int dummy_enci_disable(enum vmode_e cur_vmod)
-{
-	dummy_enci_drv->status = 0;
-
-	vout_vcbus_write(ENCI_VIDEO_EN, 0); /* disable encp */
-	dummy_enci_clk_ctrl(0);
-	if (dummy_venc_data && dummy_venc_data->enci_clk_gate_switch)
-		dummy_venc_data->enci_clk_gate_switch(0);
-#ifdef CONFIG_AMLOGIC_VPU
-	switch_vpu_mem_pd_vmod(VPU_VENCI, VPU_MEM_POWER_DOWN);
-	release_vpu_clk_vmod(VPU_VENCI);
-#endif
-
-	VOUTPR("%s finished\n", __func__);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int dummy_enci_lcd_suspend(void)
-{
-	dummy_enci_disable(VMODE_DUMMY_ENCI);
-	return 0;
-}
-
-static int dummy_enci_lcd_resume(void)
-{
-	dummy_enci_set_current_vmode(VMODE_DUMMY_ENCI);
-	return 0;
-}
-
-#endif
-
-static int dummy_enci_vout_state;
-static int dummy_enci_vout_set_state(int bit)
-{
-	dummy_enci_vout_state |= (1 << bit);
-	dummy_enci_drv->viu_sel = bit;
-	return 0;
-}
-
-static int dummy_enci_vout_clr_state(int bit)
-{
-	dummy_enci_vout_state &= ~(1 << bit);
-	if (dummy_enci_drv->viu_sel == bit)
-		dummy_enci_drv->viu_sel = 0;
-	return 0;
-}
-
-static int dummy_enci_vout_get_state(void)
-{
-	return dummy_enci_vout_state;
-}
-
-static struct vout_server_s dummy_enci_vout_server = {
-	.name = "dummy_enci_vout_server",
-	.op = {
-		.get_vinfo          = dummy_enci_get_current_info,
-		.set_vmode          = dummy_enci_set_current_vmode,
-		.validate_vmode     = dummy_enci_validate_vmode,
-		.vmode_is_supported = dummy_enci_vmode_is_supported,
-		.disable            = dummy_enci_disable,
-		.set_state          = dummy_enci_vout_set_state,
-		.clr_state          = dummy_enci_vout_clr_state,
-		.get_state          = dummy_enci_vout_get_state,
-		.set_bist           = NULL,
-#ifdef CONFIG_PM
-		.vout_suspend       = dummy_enci_lcd_suspend,
-		.vout_resume        = dummy_enci_lcd_resume,
-#endif
-	},
-};
-
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-static struct vout_server_s dummy_enci_vout2_server = {
-	.name = "dummy_enci_vout2_server",
-	.op = {
-		.get_vinfo          = dummy_enci_get_current_info,
-		.set_vmode          = dummy_enci_set_current_vmode,
-		.validate_vmode     = dummy_enci_validate_vmode,
-		.vmode_is_supported = dummy_enci_vmode_is_supported,
-		.disable            = dummy_enci_disable,
-		.set_state          = dummy_enci_vout_set_state,
-		.clr_state          = dummy_enci_vout_clr_state,
-		.get_state          = dummy_enci_vout_get_state,
-		.set_bist           = NULL,
-#ifdef CONFIG_PM
-		.vout_suspend       = dummy_enci_lcd_suspend,
-		.vout_resume        = dummy_enci_lcd_resume,
-#endif
-	},
-};
-#endif
-
-static void dummy_enci_vout_server_init(void)
-{
-	vout_register_server(&dummy_enci_vout_server);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_register_server(&dummy_enci_vout2_server);
-#endif
-}
-
-static void dummy_enci_vout_server_remove(void)
-{
-	vout_unregister_server(&dummy_enci_vout_server);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_unregister_server(&dummy_enci_vout2_server);
-#endif
-}
-
-/* **********************************************************
- * dummy_encl support
- * **********************************************************
- */
-static struct vinfo_s dummy_encl_vinfo = {
-	.name              = "dummy_l",
-	.mode              = VMODE_DUMMY_ENCL,
-	.frac              = 0,
-	.width             = 720,
-	.height            = 480,
-	.field_height      = 480,
-	.aspect_ratio_num  = 4,
-	.aspect_ratio_den  = 3,
-	.sync_duration_num = 50,
-	.sync_duration_den = 1,
-	.video_clk         = 25000000,
-	.htotal            = 952,
-	.vtotal            = 525,
-	.viu_color_fmt     = COLOR_FMT_RGB444,
-	.viu_mux           = VIU_MUX_ENCL,
-	.vout_device       = NULL,
-};
-
-static void dummy_encl_venc_set(void)
-{
-	VOUTPR("%s\n", __func__);
-
-	vout_vcbus_write(ENCL_VIDEO_EN, 0);
-
-	vout_vcbus_write(ENCL_VIDEO_MODE, 0x8000);
-	vout_vcbus_write(ENCL_VIDEO_MODE_ADV, 0x18);
-	vout_vcbus_write(ENCL_VIDEO_FILT_CTRL, 0x1000);
-
-	vout_vcbus_write(ENCL_VIDEO_MAX_PXCNT, 951);
-	vout_vcbus_write(ENCL_VIDEO_MAX_LNCNT, 524);
-	vout_vcbus_write(ENCL_VIDEO_HAVON_BEGIN, 80);
-	vout_vcbus_write(ENCL_VIDEO_HAVON_END, 799);
-	vout_vcbus_write(ENCL_VIDEO_VAVON_BLINE, 22);
-	vout_vcbus_write(ENCL_VIDEO_VAVON_ELINE, 501);
-
-	vout_vcbus_write(ENCL_VIDEO_HSO_BEGIN, 0);
-	vout_vcbus_write(ENCL_VIDEO_HSO_END,   20);
-	vout_vcbus_write(ENCL_VIDEO_VSO_BEGIN, 0);
-	vout_vcbus_write(ENCL_VIDEO_VSO_END,   0);
-	vout_vcbus_write(ENCL_VIDEO_VSO_BLINE, 0);
-	vout_vcbus_write(ENCL_VIDEO_VSO_ELINE, 5);
-
-	vout_vcbus_write(ENCL_VIDEO_RGBIN_CTRL, 3);
-
-	vout_vcbus_write(ENCL_VIDEO_EN, 1);
-}
-
-static void dummy_encl_clk_ctrl(int flag)
-{
-	unsigned int reg_ctrl, reg_div, reg_ctrl2;
-	unsigned int clk_mux, clk_sel;
-
-	if (!dummy_venc_data) {
-		VOUTERR("%s: no dummy_venc_data\n", __func__);
-		return;
-	}
-	if (dummy_venc_data->vid2_clk_mux == 0xff) {
-		reg_ctrl = dummy_venc_data->vid_clk_ctrl_reg;
-		reg_div = dummy_venc_data->vid_clk_div_reg;
-		clk_mux = dummy_venc_data->vid_clk_mux;
-		clk_sel = 0;
-	} else {
-		reg_ctrl = dummy_venc_data->vid2_clk_ctrl_reg;
-		reg_div = dummy_venc_data->vid2_clk_div_reg;
-		clk_mux = dummy_venc_data->vid2_clk_mux;
-		clk_sel = 8;
-	}
-	reg_ctrl2 = dummy_venc_data->vid_clk_ctrl2_reg;
-
-	if (flag) {
-		/* clk source sel: fckl_div5 */
-		vout_hiu_setb(reg_div, 0xf, VCLK2_XD, 8);
-		udelay(5);
-		vout_hiu_setb(reg_ctrl, clk_mux, VCLK2_CLK_IN_SEL, 3);
-		vout_hiu_setb(reg_ctrl, 1, VCLK2_EN, 1);
-		udelay(5);
-		vout_hiu_setb(dummy_venc_data->vid_clk_div_reg,
-			      clk_sel, ENCL_CLK_SEL, 4);
-		vout_hiu_setb(reg_div, 1, VCLK2_XD_EN, 1);
-		udelay(5);
-		vout_hiu_setb(reg_ctrl, 1, VCLK2_DIV1_EN, 1);
-		vout_hiu_setb(reg_ctrl, 1, VCLK2_SOFT_RST, 1);
-		udelay(10);
-		vout_hiu_setb(reg_ctrl, 0, VCLK2_SOFT_RST, 1);
-		udelay(5);
-		vout_hiu_setb(reg_ctrl2, 1, ENCL_GATE_VCLK, 1);
-	} else {
-		vout_hiu_setb(reg_ctrl2, 0, ENCL_GATE_VCLK, 1);
-		vout_hiu_setb(reg_ctrl, 0, VCLK2_DIV1_EN, 1);
-		vout_hiu_setb(reg_ctrl, 0, VCLK2_EN, 1);
-		vout_hiu_setb(reg_div, 0, VCLK2_XD_EN, 1);
-	}
-}
-
-static void dummy_encl_clk_gate_switch(int flag)
-{
-	if (flag) {
-		if (dummy_encl_drv->clk_gate_state)
-			return;
-		if (IS_ERR_OR_NULL(dummy_encl_drv->top_gate))
-			VOUTERR("%s: encl_top_gate\n", __func__);
-		else
-			clk_prepare_enable(dummy_encl_drv->top_gate);
-		if (IS_ERR_OR_NULL(dummy_encl_drv->int_gate0))
-			VOUTERR("%s: encl_int_gate\n", __func__);
-		else
-			clk_prepare_enable(dummy_encl_drv->int_gate0);
-		dummy_encl_drv->clk_gate_state = 1;
-	} else {
-		if (dummy_encl_drv->clk_gate_state == 0)
-			return;
-		dummy_encl_drv->clk_gate_state = 0;
-		if (IS_ERR_OR_NULL(dummy_encl_drv->int_gate0))
-			VOUTERR("%s: encl_int_gate\n", __func__);
-		else
-			clk_disable_unprepare(dummy_encl_drv->int_gate0);
-		if (IS_ERR_OR_NULL(dummy_encl_drv->top_gate))
-			VOUTERR("%s: encl_top_gate\n", __func__);
-		else
-			clk_disable_unprepare(dummy_encl_drv->top_gate);
-	}
-}
-
-static struct vinfo_s *dummy_encl_get_current_info(void)
-{
-	return &dummy_encl_vinfo;
-}
-
-static int dummy_encl_set_current_vmode(enum vmode_e mode)
-{
-#ifdef CONFIG_AMLOGIC_VPU
-	request_vpu_clk_vmod(dummy_encl_vinfo.video_clk, VPU_VENCP);
-	switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_ON);
-#endif
-	if (dummy_venc_data && dummy_venc_data->encl_clk_gate_switch)
-		dummy_venc_data->encl_clk_gate_switch(1);
-
-	dummy_encl_clk_ctrl(1);
-	dummy_encl_venc_set();
-
-	dummy_encl_drv->status = 1;
-	VOUTPR("%s finished\n", __func__);
-
-	return 0;
-}
-
-static enum vmode_e dummy_encl_validate_vmode(char *name, unsigned int frac)
-{
-	enum vmode_e vmode = VMODE_MAX;
-
-	if (frac)
-		return VMODE_MAX;
-
-	if (strcmp(dummy_encl_vinfo.name, name) == 0)
-		vmode = dummy_encl_vinfo.mode;
-
-	return vmode;
-}
-
-static int dummy_encl_vmode_is_supported(enum vmode_e mode)
-{
-	if ((mode & VMODE_MODE_BIT_MASK) == VMODE_DUMMY_ENCL)
-		return true;
-
-	return false;
-}
-
-static int dummy_encl_disable(enum vmode_e cur_vmod)
-{
-	dummy_encl_drv->status = 0;
-
-	vout_vcbus_write(ENCL_VIDEO_EN, 0);
-	dummy_encl_clk_ctrl(0);
-	if (dummy_venc_data && dummy_venc_data->encl_clk_gate_switch)
-		dummy_venc_data->encl_clk_gate_switch(0);
-#ifdef CONFIG_AMLOGIC_VPU
-	switch_vpu_mem_pd_vmod(VPU_VENCL, VPU_MEM_POWER_DOWN);
-	release_vpu_clk_vmod(VPU_VENCL);
-#endif
-
-	VOUTPR("%s finished\n", __func__);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int dummy_encl_lcd_suspend(void)
-{
-	dummy_encl_disable(VMODE_DUMMY_ENCL);
-	return 0;
-}
-
-static int dummy_encl_lcd_resume(void)
-{
-	dummy_encl_set_current_vmode(VMODE_DUMMY_ENCL);
-	return 0;
-}
-
-#endif
-
-static int dummy_encl_vout_state;
-static int dummy_encl_vout_set_state(int bit)
-{
-	dummy_encl_vout_state |= (1 << bit);
-	dummy_encl_drv->viu_sel = bit;
-	return 0;
-}
-
-static int dummy_encl_vout_clr_state(int bit)
-{
-	dummy_encl_vout_state &= ~(1 << bit);
-	if (dummy_encl_drv->viu_sel == bit)
-		dummy_encl_drv->viu_sel = 0;
-	return 0;
-}
-
-static int dummy_encl_vout_get_state(void)
-{
-	return dummy_encl_vout_state;
-}
-
-static struct vout_server_s dummy_encl_vout_server = {
-	.name = "dummy_encl_vout_server",
-	.op = {
-		.get_vinfo          = dummy_encl_get_current_info,
-		.set_vmode          = dummy_encl_set_current_vmode,
-		.validate_vmode     = dummy_encl_validate_vmode,
-		.vmode_is_supported = dummy_encl_vmode_is_supported,
-		.disable            = dummy_encl_disable,
-		.set_state          = dummy_encl_vout_set_state,
-		.clr_state          = dummy_encl_vout_clr_state,
-		.get_state          = dummy_encl_vout_get_state,
-		.set_bist           = NULL,
-#ifdef CONFIG_PM
-		.vout_suspend       = dummy_encl_lcd_suspend,
-		.vout_resume        = dummy_encl_lcd_resume,
-#endif
-	},
-};
-
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-static struct vout_server_s dummy_encl_vout2_server = {
-	.name = "dummy_encl_vout2_server",
-	.op = {
-		.get_vinfo          = dummy_encl_get_current_info,
-		.set_vmode          = dummy_encl_set_current_vmode,
-		.validate_vmode     = dummy_encl_validate_vmode,
-		.vmode_is_supported = dummy_encl_vmode_is_supported,
-		.disable            = dummy_encl_disable,
-		.set_state          = dummy_encl_vout_set_state,
-		.clr_state          = dummy_encl_vout_clr_state,
-		.get_state          = dummy_encl_vout_get_state,
-		.set_bist           = NULL,
-#ifdef CONFIG_PM
-		.vout_suspend       = dummy_encl_lcd_suspend,
-		.vout_resume        = dummy_encl_lcd_resume,
-#endif
-	},
-};
-#endif
-
-static void dummy_encl_vout_server_init(void)
-{
-	vout_register_server(&dummy_encl_vout_server);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_register_server(&dummy_encl_vout2_server);
-#endif
-}
-
-static void dummy_encl_vout_server_remove(void)
-{
-	vout_unregister_server(&dummy_encl_vout_server);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_unregister_server(&dummy_encl_vout2_server);
-#endif
-}
-
-/* ********************************************************* */
-static int dummy_venc_vout_mode_update(void)
-{
-	enum vmode_e mode = VMODE_DUMMY_ENCP;
-
-	VOUTPR("%s\n", __func__);
-
-	if (dummy_encp_drv->viu_sel == 1)
-		vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE_PRE, &mode);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	else if (dummy_encp_drv->viu_sel == 2)
-		vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE_PRE, &mode);
-#endif
-	dummy_encp_set_current_vmode(mode);
-	if (dummy_encp_drv->viu_sel == 1)
-		vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	else if (dummy_encp_drv->viu_sel == 2)
-		vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
-#endif
-
-	return 0;
-}
-
-static int dummy_encp_vout_notify_callback(struct notifier_block *block,
-		unsigned long cmd, void *para)
-{
-	const struct vinfo_s *vinfo;
-
-	if (dummy_encp_drv->status == 0)
-		return 0;
-	if (dummy_encp_index != 0)
-		return 0;
-
-	switch (cmd) {
-	case VOUT_EVENT_MODE_CHANGE:
-		vinfo = get_current_vinfo();
-		if (!vinfo)
-			break;
-		if (vinfo->mode != VMODE_LCD)
-			break;
-		dummy_venc_vout_mode_update();
-		break;
-	default:
-		break;
-	}
-	return 0;
-}
-
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-static int dummy_encp_vout2_notify_callback(struct notifier_block *block,
-		unsigned long cmd, void *para)
-{
-	const struct vinfo_s *vinfo;
-
-	if (dummy_encp_drv->status == 0)
-		return 0;
-	if (dummy_encp_index != 0)
-		return 0;
-
-	switch (cmd) {
-	case VOUT_EVENT_MODE_CHANGE:
-		vinfo = get_current_vinfo2();
-		if (!vinfo)
-			break;
-		if (vinfo->mode != VMODE_LCD)
-			break;
-		dummy_venc_vout_mode_update();
-		break;
-	default:
-		break;
-	}
-	return 0;
-}
-#endif
-
-static struct notifier_block dummy_encp_vout_notifier = {
-	.notifier_call = dummy_encp_vout_notify_callback,
-};
-
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-static struct notifier_block dummy_encp_vout2_notifier = {
-	.notifier_call = dummy_encp_vout2_notify_callback,
-};
-#endif
-
-/* ********************************************************* */
-static const char *dummy_venc_debug_usage_str = {
-"Usage:\n"
-"    echo reg > /sys/class/dummy_venc/encp ; dump regs for encp\n"
-"    echo reg > /sys/class/dummy_venc/enci ; dump regs for enci\n"
-"    echo reg > /sys/class/dummy_venc/encl ; dump regs for encl\n"
-};
-
-static ssize_t dummy_venc_debug_show(struct class *class,
-		struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%s\n", dummy_venc_debug_usage_str);
-}
-
-static unsigned int dummy_encp_reg_dump[] = {
-	VPU_VIU_VENC_MUX_CTRL,
-	ENCP_VIDEO_EN,
-	ENCP_VIDEO_MODE,
-	ENCP_VIDEO_MODE_ADV,
-	ENCP_VIDEO_MAX_PXCNT,
-	ENCP_VIDEO_MAX_LNCNT,
-	ENCP_VIDEO_HAVON_BEGIN,
-	ENCP_VIDEO_HAVON_END,
-	ENCP_VIDEO_VAVON_BLINE,
-	ENCP_VIDEO_VAVON_ELINE,
-	ENCP_VIDEO_HSO_BEGIN,
-	ENCP_VIDEO_HSO_END,
-	ENCP_VIDEO_VSO_BEGIN,
-	ENCP_VIDEO_VSO_END,
-	ENCP_VIDEO_VSO_BLINE,
-	ENCP_VIDEO_VSO_ELINE,
-	ENCP_VIDEO_RGBIN_CTRL,
-	0xffff,
-};
-
-static unsigned int dummy_enci_reg_dump[] = {
-	VPU_VIU_VENC_MUX_CTRL,
-	ENCI_VIDEO_EN,
-	ENCI_CFILT_CTRL,
-	ENCI_CFILT_CTRL2,
-	ENCI_VIDEO_MODE,
-	ENCI_VIDEO_MODE_ADV,
-	ENCI_SYNC_HSO_BEGIN,
-	ENCI_SYNC_HSO_END,
-	ENCI_SYNC_VSO_EVNLN,
-	ENCI_SYNC_VSO_ODDLN,
-	ENCI_MACV_MAX_AMP,
-	VENC_VIDEO_PROG_MODE,
-	ENCI_VIDEO_SCH,
-	ENCI_SYNC_MODE,
-	ENCI_YC_DELAY,
-	ENCI_VFIFO2VD_PIXEL_START,
-	ENCI_VFIFO2VD_PIXEL_END,
-	ENCI_VFIFO2VD_LINE_TOP_START,
-	ENCI_VFIFO2VD_LINE_TOP_END,
-	ENCI_VFIFO2VD_LINE_BOT_START,
-	ENCI_VFIFO2VD_LINE_BOT_END,
-	VENC_SYNC_ROUTE,
-	ENCI_DBG_PX_RST,
-	VENC_INTCTRL,
-	ENCI_VFIFO2VD_CTL,
-	VENC_UPSAMPLE_CTRL0,
-	VENC_UPSAMPLE_CTRL1,
-	VENC_UPSAMPLE_CTRL2,
-	ENCI_DACSEL_0,
-	ENCI_DACSEL_1,
-	ENCI_VIDEO_SAT,
-	ENCI_SYNC_ADJ,
-	ENCI_VIDEO_CONT,
-	0xffff,
-};
-
-static unsigned int dummy_encl_reg_dump[] = {
-	VPU_VIU_VENC_MUX_CTRL,
-	ENCL_VIDEO_EN,
-	ENCL_VIDEO_MODE,
-	ENCL_VIDEO_MODE_ADV,
-	ENCL_VIDEO_MAX_PXCNT,
-	ENCL_VIDEO_MAX_LNCNT,
-	ENCL_VIDEO_HAVON_BEGIN,
-	ENCL_VIDEO_HAVON_END,
-	ENCL_VIDEO_VAVON_BLINE,
-	ENCL_VIDEO_VAVON_ELINE,
-	ENCL_VIDEO_HSO_BEGIN,
-	ENCL_VIDEO_HSO_END,
-	ENCL_VIDEO_VSO_BEGIN,
-	ENCL_VIDEO_VSO_END,
-	ENCL_VIDEO_VSO_BLINE,
-	ENCL_VIDEO_VSO_ELINE,
-	ENCL_VIDEO_RGBIN_CTRL,
-	0xffff,
-};
-
-static ssize_t dummy_encp_debug_store(struct class *class,
-				      struct class_attribute *attr,
-				      const char *buf, size_t count)
-{
-	unsigned int i;
-
-	switch (buf[0]) {
-	case 'r':
-		pr_info("dummy_encp register dump:\n");
-		i = 0;
-		while (i < ARRAY_SIZE(dummy_encp_reg_dump)) {
-			if (dummy_encp_reg_dump[i] == 0xffff)
-				break;
-			pr_info("vcbus   [0x%04x] = 0x%08x\n",
-				dummy_encp_reg_dump[i],
-				vout_vcbus_read(dummy_encp_reg_dump[i]));
-			i++;
-		}
-		break;
-	default:
-		pr_info("invalid data\n");
-		break;
-	}
-
-	return count;
-}
-
-static ssize_t dummy_enci_debug_store(struct class *class,
-				      struct class_attribute *attr,
-				      const char *buf, size_t count)
-{
-	unsigned int i;
-
-	switch (buf[0]) {
-	case 'r':
-		pr_info("dummy_enci register dump:\n");
-		i = 0;
-		while (i < ARRAY_SIZE(dummy_enci_reg_dump)) {
-			if (dummy_enci_reg_dump[i] == 0xffff)
-				break;
-			pr_info("vcbus   [0x%04x] = 0x%08x\n",
-				dummy_enci_reg_dump[i],
-				vout_vcbus_read(dummy_enci_reg_dump[i]));
-			i++;
-		}
-		break;
-	default:
-		pr_info("invalid data\n");
-		break;
-	}
-
-	return count;
-}
-
-static ssize_t dummy_encl_debug_store(struct class *class,
-				      struct class_attribute *attr,
-				      const char *buf, size_t count)
-{
-	unsigned int i;
-
-	switch (buf[0]) {
-	case 'r':
-		pr_info("dummy_encl register dump:\n");
-		i = 0;
-		while (i < ARRAY_SIZE(dummy_encl_reg_dump)) {
-			if (dummy_encl_reg_dump[i] == 0xffff)
-				break;
-			pr_info("vcbus   [0x%04x] = 0x%08x\n",
-				dummy_encl_reg_dump[i],
-				vout_vcbus_read(dummy_encl_reg_dump[i]));
-			i++;
-		}
-		break;
-	default:
-		pr_info("invalid data\n");
-		break;
-	}
-
-	return count;
-}
-
-static struct class_attribute dummy_venc_class_attrs[] = {
-	__ATTR(encp, 0644,
-	       dummy_venc_debug_show, dummy_encp_debug_store),
-	__ATTR(enci, 0644,
-	       dummy_venc_debug_show, dummy_enci_debug_store),
-	__ATTR(encl, 0644,
-	       dummy_venc_debug_show, dummy_encl_debug_store),
-};
-
-static struct class *debug_class;
-static int dummy_venc_creat_class(void)
-{
-	int i;
-
-	debug_class = class_create(THIS_MODULE, "dummy_venc");
-	if (IS_ERR(debug_class)) {
-		VOUTERR("create debug class failed\n");
-		return -1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(dummy_venc_class_attrs); i++) {
-		if (class_create_file(debug_class,
-				      &dummy_venc_class_attrs[i])) {
-			VOUTERR("create debug attribute %s failed\n",
-				dummy_venc_class_attrs[i].attr.name);
-		}
-	}
-
-	return 0;
-}
-
-static int dummy_venc_remove_class(void)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dummy_venc_class_attrs); i++)
-		class_remove_file(debug_class, &dummy_venc_class_attrs[i]);
-
-	class_destroy(debug_class);
-	debug_class = NULL;
-
-	return 0;
-}
-/* ********************************************************* */
-
-static void dummy_venc_clktree_probe(struct device *dev)
-{
-	/* encp */
-	dummy_encp_drv->clk_gate_state = 0;
-
-	dummy_encp_drv->top_gate = devm_clk_get(dev, "encp_top_gate");
-	if (IS_ERR_OR_NULL(dummy_encp_drv->top_gate))
-		VOUTERR("%s: get encp_top_gate error\n", __func__);
-
-	dummy_encp_drv->int_gate0 = devm_clk_get(dev, "encp_int_gate0");
-	if (IS_ERR_OR_NULL(dummy_encp_drv->int_gate0))
-		VOUTERR("%s: get encp_int_gate0 error\n", __func__);
-
-	dummy_encp_drv->int_gate1 = devm_clk_get(dev, "encp_int_gate1");
-	if (IS_ERR_OR_NULL(dummy_encp_drv->int_gate1))
-		VOUTERR("%s: get encp_int_gate1 error\n", __func__);
-
-	/* enci */
-	dummy_enci_drv->clk_gate_state = 0;
-
-	dummy_enci_drv->top_gate = devm_clk_get(dev, "enci_top_gate");
-	if (IS_ERR_OR_NULL(dummy_enci_drv->top_gate))
-		VOUTERR("%s: get enci_top_gate error\n", __func__);
-
-	dummy_enci_drv->int_gate0 = devm_clk_get(dev, "enci_int_gate0");
-	if (IS_ERR_OR_NULL(dummy_enci_drv->int_gate0))
-		VOUTERR("%s: get enci_int_gate0 error\n", __func__);
-
-	dummy_enci_drv->int_gate1 = devm_clk_get(dev, "enci_int_gate1");
-	if (IS_ERR_OR_NULL(dummy_enci_drv->int_gate1))
-		VOUTERR("%s: get enci_int_gate1 error\n", __func__);
-
-	/* encl */
-	dummy_encl_drv->clk_gate_state = 0;
-
-	dummy_encl_drv->top_gate = devm_clk_get(dev, "encl_top_gate");
-	if (IS_ERR_OR_NULL(dummy_encl_drv->top_gate))
-		VOUTERR("%s: get encl_top_gate error\n", __func__);
-
-	dummy_encl_drv->int_gate0 = devm_clk_get(dev, "encl_int_gate");
-	if (IS_ERR_OR_NULL(dummy_encl_drv->int_gate0))
-		VOUTERR("%s: get encl_int_gate error\n", __func__);
-}
-
-static void dummy_venc_clktree_remove(struct device *dev)
-{
-	if (!IS_ERR_OR_NULL(dummy_encp_drv->top_gate))
-		devm_clk_put(dev, dummy_encp_drv->top_gate);
-	if (!IS_ERR_OR_NULL(dummy_encp_drv->int_gate0))
-		devm_clk_put(dev, dummy_encp_drv->int_gate0);
-	if (!IS_ERR_OR_NULL(dummy_encp_drv->int_gate1))
-		devm_clk_put(dev, dummy_encp_drv->int_gate1);
-
-	if (!IS_ERR_OR_NULL(dummy_enci_drv->top_gate))
-		devm_clk_put(dev, dummy_enci_drv->top_gate);
-	if (!IS_ERR_OR_NULL(dummy_enci_drv->int_gate0))
-		devm_clk_put(dev, dummy_enci_drv->int_gate0);
-	if (!IS_ERR_OR_NULL(dummy_enci_drv->int_gate1))
-		devm_clk_put(dev, dummy_enci_drv->int_gate1);
-
-	if (!IS_ERR_OR_NULL(dummy_encl_drv->top_gate))
-		devm_clk_put(dev, dummy_encl_drv->top_gate);
-	if (!IS_ERR_OR_NULL(dummy_encl_drv->int_gate0))
-		devm_clk_put(dev, dummy_encl_drv->int_gate0);
-}
-
-static struct dummy_venc_data_s dummy_venc_match_data = {
-	.vid_clk_ctrl_reg = HHI_VID_CLK_CNTL,
-	.vid_clk_ctrl2_reg = HHI_VID_CLK_CNTL2,
-	.vid_clk_div_reg = HHI_VID_CLK_DIV,
-	.vid2_clk_ctrl_reg = HHI_VIID_CLK_CNTL,
-	.vid2_clk_div_reg = HHI_VIID_CLK_DIV,
-	.vid_clk_mux = 6, /* fckl_div5 */
-	.vid2_clk_mux = 6, /* fckl_div5 */
-
-	.clktree_probe = dummy_venc_clktree_probe,
-	.clktree_remove = dummy_venc_clktree_remove,
-	.encp_clk_gate_switch = dummy_encp_clk_gate_switch,
-	.enci_clk_gate_switch = dummy_enci_clk_gate_switch,
-	.encl_clk_gate_switch = dummy_encl_clk_gate_switch,
-};
-
-static struct dummy_venc_data_s dummy_venc_match_data_gxl = {
-	.vid_clk_ctrl_reg = HHI_VID_CLK_CNTL,
-	.vid_clk_ctrl2_reg = HHI_VID_CLK_CNTL2,
-	.vid_clk_div_reg = HHI_VID_CLK_DIV,
-	.vid2_clk_ctrl_reg = HHI_VIID_CLK_CNTL,
-	.vid2_clk_div_reg = HHI_VIID_CLK_DIV,
-	.vid_clk_mux = 3, /* fckl_div5 */
-	.vid2_clk_mux = 0xff, /* invalid */
-
-	.clktree_probe = dummy_venc_clktree_probe,
-	.clktree_remove = dummy_venc_clktree_remove,
-	.encp_clk_gate_switch = dummy_encp_clk_gate_switch,
-	.enci_clk_gate_switch = dummy_enci_clk_gate_switch,
-	.encl_clk_gate_switch = dummy_encl_clk_gate_switch,
-};
-
-static struct dummy_venc_data_s dummy_venc_match_data_new = {
-	.vid_clk_ctrl_reg = CLKCTRL_VID_CLK_CTRL,
-	.vid_clk_ctrl2_reg = CLKCTRL_VID_CLK_CTRL2,
-	.vid_clk_div_reg = CLKCTRL_VID_CLK_DIV,
-	.vid2_clk_ctrl_reg = CLKCTRL_VIID_CLK_CTRL,
-	.vid2_clk_div_reg = CLKCTRL_VIID_CLK_DIV,
-	.vid_clk_mux = 6, /* fckl_div5 */
-	.vid2_clk_mux = 6, /* fckl_div5 */
-
-	.clktree_probe = NULL,
-	.clktree_remove = NULL,
-	.encp_clk_gate_switch = NULL,
-	.enci_clk_gate_switch = NULL,
-	.encl_clk_gate_switch = NULL,
-};
-
-static const struct of_device_id dummy_venc_dt_match_table[] = {
-	{
-		.compatible = "amlogic, dummy_lcd",
-		.data = &dummy_venc_match_data,
-	},
-	{
-		.compatible = "amlogic, dummy_venc",
-		.data = &dummy_venc_match_data,
-	},
-	{
-		.compatible = "amlogic, dummy_venc-gxl",
-		.data = &dummy_venc_match_data_gxl,
-	},
-	{
-		.compatible = "amlogic, dummy_venc-gxlx",
-		.data = &dummy_venc_match_data_gxl,
-	},
-	{
-		.compatible = "amlogic, dummy_venc_sc2",
-		.data = &dummy_venc_match_data_new,
-	},
-	{}
-};
-
-static int dummy_venc_probe(struct platform_device *pdev)
-{
-	const struct of_device_id *match;
-
-	match = of_match_device(dummy_venc_dt_match_table, &pdev->dev);
-	if (!match) {
-		VOUTERR("%s: no match table\n", __func__);
-		return -1;
-	}
-	dummy_venc_data = (struct dummy_venc_data_s *)match->data;
-	if (!dummy_venc_data) {
-		VOUTERR("%s: no match data\n", __func__);
-		return -1;
-	}
-
-	dummy_encp_drv = kzalloc(sizeof(struct dummy_venc_driver_s),
-				 GFP_KERNEL);
-	if (!dummy_encp_drv) {
-		VOUTERR("%s: dummy_venc driver no enough memory\n", __func__);
-		return -ENOMEM;
-	}
-	dummy_encp_drv->dev = &pdev->dev;
-
-	dummy_enci_drv = kzalloc(sizeof(struct dummy_venc_driver_s),
-				 GFP_KERNEL);
-	if (!dummy_enci_drv) {
-		VOUTERR("%s: dummy_venc driver no enough memory\n", __func__);
-		kfree(dummy_encp_drv);
-		return -ENOMEM;
-	}
-	dummy_enci_drv->dev = &pdev->dev;
-
-	dummy_encl_drv = kzalloc(sizeof(struct dummy_venc_driver_s),
-				 GFP_KERNEL);
-	if (!dummy_encl_drv) {
-		VOUTERR("%s: dummy_venc driver no enough memory\n", __func__);
-		kfree(dummy_encp_drv);
-		kfree(dummy_enci_drv);
-		return -ENOMEM;
-	}
-	dummy_encl_drv->dev = &pdev->dev;
-
-	if (dummy_venc_data->clktree_probe)
-		dummy_venc_data->clktree_probe(&pdev->dev);
-
-	dummy_encp_vout_server_init();
-	dummy_enci_vout_server_init();
-	dummy_encl_vout_server_init();
-
-	/* only need for encp dummy_panel */
-	vout_register_client(&dummy_encp_vout_notifier);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_register_client(&dummy_encp_vout2_notifier);
-#endif
-
-	dummy_venc_creat_class();
-
-	VOUTPR("%s OK\n", __func__);
-
-	return 0;
-}
-
-static int dummy_venc_remove(struct platform_device *pdev)
-{
-	if (!dummy_venc_data)
-		return 0;
-	if (!dummy_encp_drv)
-		return 0;
-	if (!dummy_enci_drv)
-		return 0;
-	if (!dummy_encl_drv)
-		return 0;
-
-	dummy_venc_remove_class();
-	vout_unregister_client(&dummy_encp_vout_notifier);
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	vout2_unregister_client(&dummy_encp_vout2_notifier);
-#endif
-	dummy_encp_vout_server_remove();
-	dummy_enci_vout_server_remove();
-	dummy_encl_vout_server_remove();
-	if (dummy_venc_data->clktree_remove)
-		dummy_venc_data->clktree_remove(&pdev->dev);
-
-	kfree(dummy_encp_drv);
-	dummy_encp_drv = NULL;
-	kfree(dummy_enci_drv);
-	dummy_enci_drv = NULL;
-	kfree(dummy_encl_drv);
-	dummy_encl_drv = NULL;
-
-	VOUTPR("%s\n", __func__);
-	return 0;
-}
-
-static void dummy_venc_shutdown(struct platform_device *pdev)
-{
-	if (!dummy_encp_drv)
-		return;
-	if (dummy_encp_drv->status)
-		dummy_encp_disable(VMODE_DUMMY_ENCP);
-
-	if (!dummy_enci_drv)
-		return;
-	if (dummy_enci_drv->status)
-		dummy_enci_disable(VMODE_DUMMY_ENCI);
-
-	if (!dummy_encl_drv)
-		return;
-	if (dummy_encl_drv->status)
-		dummy_encl_disable(VMODE_DUMMY_ENCL);
-}
-
-static struct platform_driver dummy_venc_platform_driver = {
-	.probe = dummy_venc_probe,
-	.remove = dummy_venc_remove,
-	.shutdown = dummy_venc_shutdown,
-	.driver = {
-		.name = "dummy_venc",
-		.owner = THIS_MODULE,
-#ifdef CONFIG_OF
-		.of_match_table = dummy_venc_dt_match_table,
-#endif
-	},
-};
-
-static int __init dummy_venc_init(void)
-{
-	if (platform_driver_register(&dummy_venc_platform_driver)) {
-		VOUTERR("failed to register dummy_venc driver module\n");
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-static void __exit dummy_venc_exit(void)
-{
-	platform_driver_unregister(&dummy_venc_platform_driver);
-}
-
-subsys_initcall(dummy_venc_init);
-module_exit(dummy_venc_exit);
-
diff --git a/drivers/amlogic/media/vout/vout_serve/vout2_notify.c b/drivers/amlogic/media/vout/vout_serve/vout2_notify.c
index b93226328b08..029d06a1b9ba 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout2_notify.c
+++ b/drivers/amlogic/media/vout/vout_serve/vout2_notify.c
@@ -73,21 +73,12 @@ struct vinfo_s *get_current_vinfo2(void)
 			vinfo = p_module->curr_vout_server->op.get_vinfo();
 	}
 	if (vinfo == NULL) /* avoid crash mistake */
-		vinfo = get_invalid_vinfo(2, p_module->init_flag);
+		vinfo = get_invalid_vinfo(2);
 
 	return vinfo;
 }
 EXPORT_SYMBOL(get_current_vinfo2);
 
-/*
- *interface export to client who want to get display support list.
- */
-int get_vout2_disp_cap(char *buf)
-{
-	return vout_func_get_disp_cap(2, buf);
-}
-EXPORT_SYMBOL(get_vout2_disp_cap);
-
 /*
  *interface export to client who want to get current vmode.
  */
@@ -122,7 +113,7 @@ const char *get_name_by_vmode2(enum vmode_e mode)
 			vinfo = p_module->curr_vout_server->op.get_vinfo();
 	}
 	if (vinfo == NULL)
-		vinfo = get_invalid_vinfo(2, p_module->init_flag);
+		vinfo = get_invalid_vinfo(2);
 	str = vinfo->name;
 
 	return str;
@@ -138,21 +129,12 @@ int set_current_vmode2(enum vmode_e mode)
 }
 EXPORT_SYMBOL(set_current_vmode2);
 
-/*
- *interface export to client who want to check same vmode attr.
- */
-int vout2_check_same_vmodeattr(char *name)
-{
-	return vout_func_check_same_vmodeattr(2, name);
-}
-EXPORT_SYMBOL(vout2_check_same_vmodeattr);
-
 /*
  *interface export to client who want to set current vmode.
  */
-enum vmode_e validate_vmode2(char *name, unsigned int frac)
+enum vmode_e validate_vmode2(char *name)
 {
-	return vout_func_validate_vmode(2, name, frac);
+	return vout_func_validate_vmode(2, name);
 }
 EXPORT_SYMBOL(validate_vmode2);
 
@@ -165,16 +147,12 @@ int set_vframe2_rate_hint(int duration)
 }
 EXPORT_SYMBOL(set_vframe2_rate_hint);
 
-int get_vframe2_rate_hint(void)
-{
-	return vout_func_get_vframe_rate_hint(2);
-}
-EXPORT_SYMBOL(get_vframe2_rate_hint);
-
-/* dummy for temp */
+/*
+ *interface export to client who want to notify about source frame rate end.
+ */
 int set_vframe2_rate_end_hint(void)
 {
-	return vout_func_set_vframe_rate_hint(2, 0);
+	return vout_func_set_vframe_rate_end_hint(2);
 }
 EXPORT_SYMBOL(set_vframe2_rate_end_hint);
 
@@ -183,15 +161,7 @@ EXPORT_SYMBOL(set_vframe2_rate_end_hint);
  */
 int set_vframe2_rate_policy(int policy)
 {
-	struct vout_module_s *p_module = NULL;
-
-	p_module = vout_func_get_vout2_module();
-	if (!p_module)
-		return -1;
-
-	p_module->fr_policy = policy;
-
-	return 0;
+	return vout_func_set_vframe_rate_policy(2, policy);
 }
 EXPORT_SYMBOL(set_vframe2_rate_policy);
 
@@ -200,13 +170,7 @@ EXPORT_SYMBOL(set_vframe2_rate_policy);
  */
 int get_vframe2_rate_policy(void)
 {
-	struct vout_module_s *p_module = NULL;
-
-	p_module = vout_func_get_vout2_module();
-	if (!p_module)
-		return 0;
-
-	return p_module->fr_policy;
+	return vout_func_get_vframe_rate_policy(2);
 }
 EXPORT_SYMBOL(get_vframe2_rate_policy);
 
diff --git a/drivers/amlogic/media/vout/vout_serve/vout2_serve.c b/drivers/amlogic/media/vout/vout_serve/vout2_serve.c
index b017a72afaa4..05bc9f2999e4 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout2_serve.c
+++ b/drivers/amlogic/media/vout/vout_serve/vout2_serve.c
@@ -75,7 +75,6 @@ static const unsigned int vout2_cable[] = {
 };
 
 static struct vout_cdev_s *vout2_cdev;
-static struct device *vout2_dev;
 static struct clk *vpu_clkc;
 static unsigned char vpu_clkc_state;
 
@@ -88,7 +87,6 @@ static struct vinfo_s nulldisp_vinfo[] = {
 	{
 		.name              = "null",
 		.mode              = VMODE_NULL,
-		.frac              = 0,
 		.width             = 1920,
 		.height            = 1080,
 		.field_height      = 1080,
@@ -107,7 +105,6 @@ static struct vinfo_s nulldisp_vinfo[] = {
 	{
 		.name              = "invalid",
 		.mode              = VMODE_INVALID,
-		.frac              = 0,
 		.width             = 1920,
 		.height            = 1080,
 		.field_height      = 1080,
@@ -138,14 +135,11 @@ static int nulldisp_set_current_vmode(enum vmode_e mode)
 	return 0;
 }
 
-static enum vmode_e nulldisp_validate_vmode(char *name, unsigned int frac)
+static enum vmode_e nulldisp_validate_vmode(char *name)
 {
 	enum vmode_e vmode = VMODE_MAX;
 	int i;
 
-	if (frac)
-		return VMODE_MAX;
-
 	for (i = 0; i < ARRAY_SIZE(nulldisp_vinfo); i++) {
 		if (strcmp(nulldisp_vinfo[i].name, name) == 0) {
 			vmode = nulldisp_vinfo[i].mode;
@@ -214,29 +208,6 @@ char *get_vout2_mode_internal(void)
 }
 EXPORT_SYMBOL(get_vout2_mode_internal);
 
-#define MAX_UEVENT_LEN 64
-static int vout2_set_uevent(unsigned int vout_event, int val)
-{
-	char env[MAX_UEVENT_LEN];
-	char *envp[2];
-	int ret;
-
-	if (vout_event != VOUT_EVENT_MODE_CHANGE)
-		return 0;
-
-	if (!vout2_dev)
-		return -1;
-
-	memset(env, 0, sizeof(env));
-	envp[0] = env;
-	envp[1] = NULL;
-	snprintf(env, MAX_UEVENT_LEN, "vout2_setmode=%d", val);
-
-	ret = kobject_uevent_env(&vout2_dev->kobj, KOBJ_CHANGE, envp);
-
-	return ret;
-}
-
 static inline void vout2_setmode_wakeup_queue(void)
 {
 	if (vout2_cdev)
@@ -246,44 +217,37 @@ static inline void vout2_setmode_wakeup_queue(void)
 static int set_vout2_mode(char *name)
 {
 	enum vmode_e mode;
-	unsigned int frac;
 	int ret = 0;
 
 	vout_trim_string(name);
 	VOUTPR("vout2: vmode set to %s\n", name);
 
-	if ((strcmp(name, vout2_mode) == 0) &&
-	    (vout2_check_same_vmodeattr(name))) {
+	if (strcmp(name, local_name) == 0) {
 		VOUTPR("vout2: don't set the same mode as current\n");
 		return -1;
 	}
 
-	memset(local_name, 0, sizeof(local_name));
-	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", name);
-	frac = vout_parse_vout_name(local_name);
-
-	mode = validate_vmode2(local_name, frac);
+	mode = validate_vmode2(name);
 	if (mode == VMODE_MAX) {
 		VOUTERR("vout2: no matched vout2 mode\n");
 		return -1;
 	}
+	memset(local_name, 0, sizeof(local_name));
+	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", name);
 
 	extcon_set_state_sync(vout2_excton_setmode, EXTCON_TYPE_DISP, 1);
-	vout2_set_uevent(VOUT_EVENT_MODE_CHANGE, 1);
 
 	vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE_PRE, &mode);
 	ret = set_current_vmode2(mode);
 	if (ret) {
 		VOUTERR("vout2: new mode %s set error\n", name);
 	} else {
-		memset(vout2_mode, 0, sizeof(vout2_mode));
 		snprintf(vout2_mode, VMODE_NAME_LEN_MAX, "%s", name);
-		VOUTPR("vout2: new mode %s set ok\n", name);
+		VOUTPR("vout2: new mode %s set ok\n", vout2_mode);
 	}
 	vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
 
 	extcon_set_state_sync(vout2_excton_setmode, EXTCON_TYPE_DISP, 0);
-	vout2_set_uevent(VOUT_EVENT_MODE_CHANGE, 0);
 	vout2_setmode_wakeup_queue();
 
 	return ret;
@@ -292,25 +256,19 @@ static int set_vout2_mode(char *name)
 static int set_vout2_init_mode(void)
 {
 	enum vmode_e vmode;
-	unsigned int frac;
+	char init_mode_str[VMODE_NAME_LEN_MAX];
 	int ret = 0;
 
-	memset(local_name, 0, sizeof(local_name));
-	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", vout2_mode_uboot);
-	frac = vout_parse_vout_name(local_name);
-
-	vout2_init_vmode = validate_vmode2(local_name, frac);
+	snprintf(init_mode_str, VMODE_NAME_LEN_MAX, "%s", vout2_mode_uboot);
+	vout2_init_vmode = validate_vmode2(vout2_mode_uboot);
 	if (vout2_init_vmode >= VMODE_MAX) {
 		VOUTERR(
 		"vout2: no matched vout2_init mode %s, force to invalid\n",
 			vout2_mode_uboot);
 		nulldisp_index = 1;
 		vout2_init_vmode = nulldisp_vinfo[nulldisp_index].mode;
-		snprintf(local_name, VMODE_NAME_LEN_MAX, "%s",
-			 nulldisp_vinfo[nulldisp_index].name);
-	} else { /* recover vout_mode_uboot */
-		snprintf(local_name, VMODE_NAME_LEN_MAX, "%s",
-			 vout2_mode_uboot);
+		snprintf(init_mode_str, VMODE_NAME_LEN_MAX, "%s",
+			nulldisp_vinfo[nulldisp_index].name);
 	}
 	if (uboot_display)
 		vmode = vout2_init_vmode | VMODE_INIT_BIT_MASK;
@@ -329,13 +287,14 @@ static int set_vout2_init_mode(void)
 		}
 	}
 
+	memset(local_name, 0, sizeof(local_name));
+	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", init_mode_str);
 	ret = set_current_vmode2(vmode);
 	if (ret) {
-		VOUTERR("vout2: init mode %s set error\n", local_name);
+		VOUTERR("vout2: init mode %s set error\n", init_mode_str);
 	} else {
-		memset(vout2_mode, 0, sizeof(vout2_mode));
-		snprintf(vout2_mode, VMODE_NAME_LEN_MAX, local_name);
-		VOUTPR("vout2: init mode %s set ok\n", local_name);
+		snprintf(vout2_mode, VMODE_NAME_LEN_MAX, init_mode_str);
+		VOUTPR("vout2: init mode %s set ok\n", vout2_mode);
 	}
 
 	return ret;
@@ -387,22 +346,16 @@ static void set_vout2_axis(char *para)
 	int parsed[MAX_NUMBER_PARA] = {};
 
 	/* parse window para */
-	if (parse_para(para, 8, parsed) >= 4) {
-		pt = &disp_rect[0].x;
-		memcpy(pt, &parsed[0], sizeof(struct disp_rect_s));
-		pt = &disp_rect[1].x;
-		memcpy(pt, &parsed[4], sizeof(struct disp_rect_s));
-	}
+	if (parse_para(para, 8, parsed) >= 4)
+		memcpy(pt, parsed, sizeof(struct disp_rect_s) * OSD_COUNT);
 	/* if ((count >= 4) && (count < 8))
 	 *	disp_rect[1] = disp_rect[0];
 	 */
 
 	VOUTPR("vout2: osd0=> x:%d,y:%d,w:%d,h:%d\n"
 		"osd1=> x:%d,y:%d,w:%d,h:%d\n",
-			disp_rect[0].x, disp_rect[0].y,
-			disp_rect[0].w, disp_rect[0].h,
-			disp_rect[1].x, disp_rect[1].y,
-			disp_rect[1].w, disp_rect[1].h);
+			*pt, *(pt + 1), *(pt + 2), *(pt + 3),
+			*(pt + 4), *(pt + 5), *(pt + 6), *(pt + 7));
 	vout2_notifier_call_chain(VOUT_EVENT_OSD_DISP_AXIS, &disp_rect[0]);
 }
 
@@ -480,37 +433,6 @@ static ssize_t vout2_fr_policy_store(struct class *class,
 	return count;
 }
 
-static ssize_t vout2_fr_hint_show(struct class *class,
-				  struct class_attribute *attr, char *buf)
-{
-	int fr_hint;
-	int ret = 0;
-
-	fr_hint = get_vframe2_rate_hint();
-	ret = sprintf(buf, "%d\n", fr_hint);
-
-	return ret;
-}
-
-static ssize_t vout2_fr_hint_store(struct class *class,
-				   struct class_attribute *attr,
-				   const char *buf, size_t count)
-{
-	int fr_hint;
-	int ret = 0;
-
-	mutex_lock(&vout2_serve_mutex);
-	ret = kstrtoint(buf, 10, &fr_hint);
-	if (ret) {
-		mutex_unlock(&vout2_serve_mutex);
-		return -EINVAL;
-	}
-	set_vframe2_rate_hint(fr_hint);
-	mutex_unlock(&vout2_serve_mutex);
-
-	return count;
-}
-
 static ssize_t vout2_bist_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -555,7 +477,6 @@ static ssize_t vout2_vinfo_show(struct class *class,
 	len = sprintf(buf, "current vinfo2:\n"
 		"    name:                  %s\n"
 		"    mode:                  %d\n"
-		"    frac:                  %d\n"
 		"    width:                 %d\n"
 		"    height:                %d\n"
 		"    field_height:          %d\n"
@@ -570,7 +491,7 @@ static ssize_t vout2_vinfo_show(struct class *class,
 		"    video_clk:             %d\n"
 		"    viu_color_fmt:         %d\n"
 		"    viu_mux:               %d\n\n",
-		info->name, info->mode, info->frac,
+		info->name, info->mode,
 		info->width, info->height, info->field_height,
 		info->aspect_ratio_num, info->aspect_ratio_den,
 		info->sync_duration_num, info->sync_duration_den,
@@ -630,27 +551,13 @@ static ssize_t vout2_vinfo_show(struct class *class,
 	return len;
 }
 
-static ssize_t vout2_cap_show(struct class *class,
-			     struct class_attribute *attr, char *buf)
-{
-	int ret;
-
-	ret = get_vout2_disp_cap(buf);
-	if (!ret)
-		return sprintf(buf, "null\n");
-
-	return ret;
-}
-
 static struct class_attribute vout2_class_attrs[] = {
 	__ATTR(mode,      0644, vout2_mode_show, vout2_mode_store),
 	__ATTR(axis,      0644, vout2_axis_show, vout2_axis_store),
 	__ATTR(fr_policy, 0644,
 		vout2_fr_policy_show, vout2_fr_policy_store),
-	__ATTR(fr_hint,   0644, vout2_fr_hint_show, vout2_fr_hint_store),
 	__ATTR(bist,      0644, vout2_bist_show, vout2_bist_store),
 	__ATTR(vinfo,     0444, vout2_vinfo_show, NULL),
-	__ATTR(cap,       0644, vout2_cap_show, NULL)
 };
 
 static int vout2_attr_create(void)
@@ -673,7 +580,7 @@ static int vout2_attr_create(void)
 		}
 	}
 
-	/*VOUTPR("vout2: create vout2 attribute OK\n");*/
+	VOUTPR("vout2: create vout2 attribute OK\n");
 
 	return ret;
 }
@@ -701,7 +608,7 @@ static int vout2_io_open(struct inode *inode, struct file *file)
 {
 	struct vout_cdev_s *vcdev;
 
-	/*VOUTPR("%s\n", __func__);*/
+	VOUTPR("%s\n", __func__);
 	vcdev = container_of(inode->i_cdev, struct vout_cdev_s, cdev);
 	file->private_data = vcdev;
 	return 0;
@@ -709,7 +616,7 @@ static int vout2_io_open(struct inode *inode, struct file *file)
 
 static int vout2_io_release(struct inode *inode, struct file *file)
 {
-	/*VOUTPR("%s\n", __func__);*/
+	VOUTPR("%s\n", __func__);
 	file->private_data = NULL;
 	return 0;
 }
@@ -828,7 +735,7 @@ static int vout2_fops_create(void)
 
 	init_waitqueue_head(&vout2_cdev->setmode_queue);
 
-	/*VOUTPR("vout2: %s OK\n", __func__);*/
+	VOUTPR("vout2: %s OK\n", __func__);
 	return 0;
 
 vout2_fops_err3:
@@ -854,6 +761,7 @@ static void vout2_fops_remove(void)
 static int aml_vout2_suspend(struct platform_device *pdev, pm_message_t state)
 {
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+
 	if (early_suspend_flag)
 		return 0;
 
@@ -865,6 +773,7 @@ static int aml_vout2_suspend(struct platform_device *pdev, pm_message_t state)
 static int aml_vout2_resume(struct platform_device *pdev)
 {
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+
 	if (early_suspend_flag)
 		return 0;
 
@@ -1067,29 +976,10 @@ static void vout2_clktree_init(struct device *dev)
 	VOUTPR("vout2: clktree_init\n");
 }
 
-static void aml_vout2_get_dt_info(struct platform_device *pdev)
-{
-	int ret;
-	unsigned int para[2];
-
-	ret = of_property_read_u32(pdev->dev.of_node, "fr_policy", &para[0]);
-	if (!ret) {
-		ret = set_vframe2_rate_policy(para[0]);
-		if (ret)
-			VOUTERR("vout2: init fr_policy %d failed\n", para[0]);
-		else
-			VOUTPR("vout2: fr_policy:%d\n", para[0]);
-	}
-}
-
 static int aml_vout2_probe(struct platform_device *pdev)
 {
 	int ret = -1;
 
-	vout2_dev = &pdev->dev;
-
-	aml_vout2_get_dt_info(pdev);
-
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 	early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
 	early_suspend.suspend = aml_vout2_early_suspend;
@@ -1213,15 +1103,6 @@ static void vout2_init_mode_parse(char *str)
 		VOUTPR("vout2: %s: %d\n", str, uboot_display);
 		return;
 	}
-	if (strncmp(str, "frac", 4) == 0) { /* frac */
-		if ((strlen(vout2_mode_uboot) + strlen(str))
-		    < VMODE_NAME_LEN_MAX)
-			strcat(vout2_mode_uboot, str);
-		else
-			VOUTERR("%s: str len out of support\n", __func__);
-		VOUTPR("%s\n", str);
-		return;
-	}
 
 	/*
 	 * just save the vmode_name,
@@ -1229,7 +1110,7 @@ static void vout2_init_mode_parse(char *str)
 	 */
 	snprintf(vout2_mode_uboot, VMODE_NAME_LEN_MAX, "%s", str);
 	vout_trim_string(vout2_mode_uboot);
-	VOUTPR("vout2: %s\n", vout2_mode_uboot);
+	VOUTPR("vout2: %s\n", str);
 }
 
 static int __init get_vout2_init_mode(char *str)
@@ -1244,8 +1125,7 @@ static int __init get_vout2_init_mode(char *str)
 		return -EINVAL;
 
 	do {
-		if (!isalpha(*ptr) && !isdigit(*ptr) &&
-		    (*ptr != '_') && (*ptr != '-')) {
+		if (!isalpha(*ptr) && !isdigit(*ptr)) {
 			find = 1;
 			break;
 		}
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_func.c b/drivers/amlogic/media/vout/vout_serve/vout_func.c
index 08f2332bc972..eae62401d0b8 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout_func.c
+++ b/drivers/amlogic/media/vout/vout_serve/vout_func.c
@@ -36,13 +36,6 @@ static struct vout_module_s vout_module = {
 		&vout_module.vout_server_list
 	},
 	.curr_vout_server = NULL,
-	.init_flag = 0,
-	/* vout_fr_policy:
-	 *    0: disable
-	 *    1: nearby (only for 60->59.94 and 30->29.97)
-	 *    2: force (60/50/30/24/59.94/23.97)
-	 */
-	.fr_policy = 0,
 };
 
 #ifdef CONFIG_AMLOGIC_VOUT2_SERVE
@@ -52,13 +45,6 @@ static struct vout_module_s vout2_module = {
 		&vout2_module.vout_server_list
 	},
 	.curr_vout_server = NULL,
-	.init_flag = 0,
-	/* vout_fr_policy:
-	 *    0: disable
-	 *    1: nearby (only for 60->59.94 and 30->29.97)
-	 *    2: force (60/50/30/24/59.94/23.97)
-	 */
-	.fr_policy = 0,
 };
 #endif
 
@@ -80,12 +66,9 @@ static struct vinfo_s invalid_vinfo = {
 	.vout_device       = NULL,
 };
 
-struct vinfo_s *get_invalid_vinfo(int index, unsigned int flag)
+struct vinfo_s *get_invalid_vinfo(int index)
 {
-	if (flag) {
-		VOUTERR("invalid vinfo%d. current vmode is not supported\n",
-			index);
-	}
+	VOUTERR("invalid vinfo%d. current vmode is not supported\n", index);
 	return &invalid_vinfo;
 }
 EXPORT_SYMBOL(get_invalid_vinfo);
@@ -193,7 +176,6 @@ void vout_func_update_viu(int index)
 	struct vout_module_s *p_module = NULL;
 	unsigned int mux_bit = 0xff, mux_sel = VIU_MUX_MAX;
 	unsigned int clk_bit = 0xff, clk_sel = 0;
-	unsigned int flag = 0;
 
 	mutex_lock(&vout_mutex);
 
@@ -215,22 +197,13 @@ void vout_func_update_viu(int index)
 		return;
 	}
 	p_server = p_module->curr_vout_server;
-	flag = p_module->init_flag;
-
-#if 0
-	VOUTPR("%s: before: 0x%04x=0x%08x, 0x%04x=0x%08x\n",
-		__func__, VPU_VIU_VENC_MUX_CTRL,
-		vout_vcbus_read(VPU_VIU_VENC_MUX_CTRL),
-		VPU_VENCX_CLK_CTRL,
-		vout_vcbus_read(VPU_VENCX_CLK_CTRL));
-#endif
 
 	if (p_server) {
 		if (p_server->op.get_vinfo)
 			vinfo = p_server->op.get_vinfo();
 	}
 	if (vinfo == NULL)
-		vinfo = get_invalid_vinfo(index, flag);
+		vinfo = get_invalid_vinfo(index);
 
 	mux_sel = vinfo->viu_mux;
 	switch (mux_sel) {
@@ -255,13 +228,8 @@ void vout_func_update_viu(int index)
 		vout_vcbus_setb(VPU_VENCX_CLK_CTRL, clk_sel, clk_bit, 1);
 
 #if 0
-	VOUTPR("%s: %d, mux_sel=%d, mux_bit=%d, clk_sel=%d clk_bit=%d\n",
-		__func__, index, mux_sel, mux_bit, clk_sel, clk_bit);
-	VOUTPR("%s: after: 0x%04x=0x%08x, 0x%04x=0x%08x\n",
-		__func__, VPU_VIU_VENC_MUX_CTRL,
-		vout_vcbus_read(VPU_VIU_VENC_MUX_CTRL),
-		VPU_VENCX_CLK_CTRL,
-		vout_vcbus_read(VPU_VENCX_CLK_CTRL));
+	VOUTPR("%s: %d, mux_sel=%d, clk_sel=%d\n",
+		__func__, index, mux_sel, clk_sel);
 #endif
 	mutex_unlock(&vout_mutex);
 }
@@ -287,7 +255,6 @@ int vout_func_set_vmode(int index, enum vmode_e mode)
 		return -1;
 	}
 	ret = p_module->curr_vout_server->op.set_vmode(mode);
-	p_module->init_flag = 1;
 
 	mutex_unlock(&vout_mutex);
 
@@ -307,33 +274,10 @@ int vout_func_set_current_vmode(int index, enum vmode_e mode)
 }
 EXPORT_SYMBOL(vout_func_set_current_vmode);
 
-int vout_func_check_same_vmodeattr(int index, char *name)
-{
-	struct vout_server_s *p_server = NULL;
-	int ret = 1;
-
-	mutex_lock(&vout_mutex);
-
-	if (index == 1)
-		p_server = vout_module.curr_vout_server;
-#ifdef CONFIG_AMLOGIC_VOUT2_SERVE
-	else if (index == 2)
-		p_server = vout2_module.curr_vout_server;
-#endif
-
-	if (!IS_ERR_OR_NULL(p_server)) {
-		if (p_server->op.check_same_vmodeattr)
-			ret = p_server->op.check_same_vmodeattr(name);
-	}
-
-	mutex_unlock(&vout_mutex);
-	return ret;
-}
-
 /*
  *interface export to client who want to set current vmode.
  */
-enum vmode_e vout_func_validate_vmode(int index, char *name, unsigned int frac)
+enum vmode_e vout_func_validate_vmode(int index, char *name)
 {
 	enum vmode_e ret = VMODE_MAX;
 	struct vout_server_s  *p_server;
@@ -362,7 +306,7 @@ enum vmode_e vout_func_validate_vmode(int index, char *name, unsigned int frac)
 				continue;
 		}
 		if (p_server->op.validate_vmode) {
-			ret = p_server->op.validate_vmode(name, frac);
+			ret = p_server->op.validate_vmode(name);
 			if (ret != VMODE_MAX) /* valid vmode find. */
 				break;
 		}
@@ -373,45 +317,34 @@ enum vmode_e vout_func_validate_vmode(int index, char *name, unsigned int frac)
 }
 EXPORT_SYMBOL(vout_func_validate_vmode);
 
-int vout_func_get_disp_cap(int index, char *buf)
+int vout_func_set_vframe_rate_hint(int index, int duration)
 {
-	struct vout_server_s *p_server;
-	struct vout_module_s *p_module = NULL;
-	int state, len;
+	int ret = -1;
+	struct vout_server_s *p_server = NULL;
 
 	mutex_lock(&vout_mutex);
 
 	if (index == 1)
-		p_module = &vout_module;
+		p_server = vout_module.curr_vout_server;
 #ifdef CONFIG_AMLOGIC_VOUT2_SERVE
 	else if (index == 2)
-		p_module = &vout2_module;
+		p_server = vout2_module.curr_vout_server;
 #endif
 
-	if (!p_module) {
-		len = sprintf(buf, "vout%d: %s: vout_module is NULL\n",
-			      index, __func__);
-		mutex_unlock(&vout_mutex);
-		return len;
-	}
-
-	len = 0;
-	list_for_each_entry(p_server, &p_module->vout_server_list, list) {
-		if (p_server->op.get_state) {
-			state = p_server->op.get_state();
-			if (vout_func_check_state(index, state, p_server))
-				continue;
-		}
-		if (!p_server->op.get_disp_cap)
-			continue;
-		len += p_server->op.get_disp_cap(buf + len);
+	if (!IS_ERR_OR_NULL(p_server)) {
+		if (p_server->op.set_vframe_rate_hint)
+			ret = p_server->op.set_vframe_rate_hint(duration);
 	}
 
 	mutex_unlock(&vout_mutex);
-	return len;
+	return ret;
 }
+EXPORT_SYMBOL(vout_func_set_vframe_rate_hint);
 
-int vout_func_set_vframe_rate_hint(int index, int duration)
+/*
+ *interface export to client who want to notify about source frame rate end.
+ */
+int vout_func_set_vframe_rate_end_hint(int index)
 {
 	int ret = -1;
 	struct vout_server_s *p_server = NULL;
@@ -426,21 +359,21 @@ int vout_func_set_vframe_rate_hint(int index, int duration)
 #endif
 
 	if (!IS_ERR_OR_NULL(p_server)) {
-		if (p_server->op.set_vframe_rate_hint)
-			ret = p_server->op.set_vframe_rate_hint(duration);
+		if (p_server->op.set_vframe_rate_end_hint)
+			ret = p_server->op.set_vframe_rate_end_hint();
 	}
 
 	mutex_unlock(&vout_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(vout_func_set_vframe_rate_hint);
+EXPORT_SYMBOL(vout_func_set_vframe_rate_end_hint);
 
 /*
- *interface export to client who want to notify about source frame rate end.
+ *interface export to client who want to notify about source fr_policy.
  */
-int vout_func_get_vframe_rate_hint(int index)
+int vout_func_set_vframe_rate_policy(int index, int policy)
 {
-	int ret = 0;
+	int ret = -1;
 	struct vout_server_s *p_server = NULL;
 
 	mutex_lock(&vout_mutex);
@@ -453,16 +386,19 @@ int vout_func_get_vframe_rate_hint(int index)
 #endif
 
 	if (!IS_ERR_OR_NULL(p_server)) {
-		if (p_server->op.get_vframe_rate_hint)
-			ret = p_server->op.get_vframe_rate_hint();
+		if (p_server->op.set_vframe_rate_policy)
+			ret = p_server->op.set_vframe_rate_policy(policy);
 	}
 
 	mutex_unlock(&vout_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(vout_func_get_vframe_rate_hint);
+EXPORT_SYMBOL(vout_func_set_vframe_rate_policy);
 
-int vout_func_set_clock_drift(int index, int ppm)
+/*
+ *interface export to client who want to notify about source fr_policy.
+ */
+int vout_func_get_vframe_rate_policy(int index)
 {
 	int ret = -1;
 	struct vout_server_s *p_server = NULL;
@@ -477,14 +413,14 @@ int vout_func_set_clock_drift(int index, int ppm)
 #endif
 
 	if (!IS_ERR_OR_NULL(p_server)) {
-		if (p_server->op.set_clock_drift)
-			ret = p_server->op.set_clock_drift(ppm);
+		if (p_server->op.get_vframe_rate_policy)
+			ret = p_server->op.get_vframe_rate_policy();
 	}
 
 	mutex_unlock(&vout_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(vout_func_set_clock_drift);
+EXPORT_SYMBOL(vout_func_get_vframe_rate_policy);
 
 /*
  * interface export to client who want to set test bist.
@@ -595,21 +531,22 @@ EXPORT_SYMBOL(vout_func_vout_shutdown);
  *we can ensure TVMOD SET MODULE independent with these two function.
  */
 
-int vout_func_vout_register_server(int index, struct vout_server_s *mem_server)
+int vout_func_vout_register_server(int index,
+		struct vout_server_s *mem_server)
 {
 	struct list_head *p_iter;
 	struct vout_server_s *p_server;
 	struct vout_module_s *p_module = NULL;
 
-	if (!mem_server) {
+	if (mem_server == NULL) {
 		VOUTERR("vout%d: server is NULL\n", index);
 		return -1;
 	}
-	if (!mem_server->name) {
+	if (mem_server->name == NULL) {
 		VOUTERR("vout%d: server name is NULL\n", index);
 		return -1;
 	}
-	/* VOUTPR("vout%d: register server: %s\n", index, mem_server->name);*/
+	VOUTPR("vout%d: register server: %s\n", index, mem_server->name);
 
 	mutex_lock(&vout_mutex);
 
@@ -644,20 +581,16 @@ int vout_func_vout_register_server(int index, struct vout_server_s *mem_server)
 EXPORT_SYMBOL(vout_func_vout_register_server);
 
 int vout_func_vout_unregister_server(int index,
-				     struct vout_server_s *mem_server)
+		struct vout_server_s *mem_server)
 {
 	struct vout_server_s  *p_server;
 	struct vout_module_s *p_module = NULL;
 
-	if (!mem_server) {
+	if (mem_server == NULL) {
 		VOUTERR("vout%d: server is NULL\n", index);
 		return -1;
 	}
-	if (!mem_server->name) {
-		VOUTERR("vout%d: server name is NULL\n", index);
-		return -1;
-	}
-	/*VOUTPR("vout%d: unregister server: %s\n", index, mem_server->name);*/
+	VOUTPR("vout%d: unregister server: %s\n", index, mem_server->name);
 
 	mutex_lock(&vout_mutex);
 
@@ -696,48 +629,44 @@ int vout_func_vout_unregister_server(int index,
 }
 EXPORT_SYMBOL(vout_func_vout_unregister_server);
 
-int vout_get_hpd_state(void)
+/* fps = 9600/duration/100 hz */
+static int vsource_fps_table[][2] = {
+	/* duration    fps */
+	{1600,         6000,},
+	{1601,         5994,},
+	{1602,         5994,},
+	{1920,         5000,},
+	{3200,         3000,},
+	{3203,         2997,},
+	{3840,         2500,},
+	{4000,         2400,},
+	{4004,         2397,},
+};
+
+int vout_get_vsource_fps(int duration)
 {
-	int ret = 0;
+	int i;
+	int fps = 6000;
 
-#ifdef CONFIG_AMLOGIC_HDMITX
-	ret = get_hpd_state();
-#endif
+	for (i = 0; i < 9; i++) {
+		if (duration == vsource_fps_table[i][0]) {
+			fps = vsource_fps_table[i][1];
+			break;
+		}
+	}
 
-	return ret;
+	return fps;
 }
-EXPORT_SYMBOL(vout_get_hpd_state);
+EXPORT_SYMBOL(vout_get_vsource_fps);
 
-bool vout_get_tv_changed(void)
+int vout_get_hpd_state(void)
 {
-	bool ret = false;
+	int ret = 0;
 
 #ifdef CONFIG_AMLOGIC_HDMITX
-	ret = is_tv_changed();
+	ret = get_hpd_state();
 #endif
 
 	return ret;
 }
-
-/* return vout frac */
-unsigned int vout_parse_vout_name(char *name)
-{
-	char *p, *frac_str;
-	unsigned int frac = 0;
-
-	mutex_lock(&vout_mutex);
-
-	p = strchr(name, ',');
-	if (!p) {
-		frac = 0;
-	} else {
-		frac_str = p + 1;
-		*p = '\0';
-		if (strcmp(frac_str, "frac") == 0)
-			frac = 1;
-	}
-
-	mutex_unlock(&vout_mutex);
-
-	return frac;
-}
+EXPORT_SYMBOL(vout_get_hpd_state);
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_func.h b/drivers/amlogic/media/vout/vout_serve/vout_func.h
index 0714d7f74a05..5218a6c44c30 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout_func.h
+++ b/drivers/amlogic/media/vout/vout_serve/vout_func.h
@@ -47,14 +47,11 @@ struct vout_cdev_s {
 
 #ifdef CONFIG_AMLOGIC_HDMITX
 extern int get_hpd_state(void);
-bool is_tv_changed(void);
 #endif
 extern int vout_get_hpd_state(void);
-bool vout_get_tv_changed(void);
-
 extern void vout_trim_string(char *str);
 
-struct vinfo_s *get_invalid_vinfo(int index, unsigned int flag);
+extern struct vinfo_s *get_invalid_vinfo(int index);
 extern struct vout_module_s *vout_func_get_vout_module(void);
 #ifdef CONFIG_AMLOGIC_VOUT2_SERVE
 extern struct vout_module_s *vout_func_get_vout2_module(void);
@@ -64,12 +61,11 @@ extern void vout_func_set_state(int index, enum vmode_e mode);
 extern void vout_func_update_viu(int index);
 extern int vout_func_set_vmode(int index, enum vmode_e mode);
 extern int vout_func_set_current_vmode(int index, enum vmode_e mode);
-int vout_func_check_same_vmodeattr(int index, char *name);
-enum vmode_e vout_func_validate_vmode(int index, char *name, unsigned int frac);
-int vout_func_get_disp_cap(int index, char *buf);
-int vout_func_set_vframe_rate_hint(int index, int duration);
-int vout_func_get_vframe_rate_hint(int index);
-int vout_func_set_clock_drift(int index, int ppm);
+extern enum vmode_e vout_func_validate_vmode(int index, char *name);
+extern int vout_func_set_vframe_rate_hint(int index, int duration);
+extern int vout_func_set_vframe_rate_end_hint(int index);
+extern int vout_func_set_vframe_rate_policy(int index, int policy);
+extern int vout_func_get_vframe_rate_policy(int index);
 extern void vout_func_set_test_bist(int index, unsigned int bist);
 extern int vout_func_vout_suspend(int index);
 extern int vout_func_vout_resume(int index);
@@ -78,11 +74,10 @@ extern int vout_func_vout_register_server(int index,
 		struct vout_server_s *mem_server);
 extern int vout_func_vout_unregister_server(int index,
 		struct vout_server_s *mem_server);
-unsigned int vout_parse_vout_name(char *name);
+
 
 extern int set_current_vmode(enum vmode_e);
-int vout_check_same_vmodeattr(char *name);
-enum vmode_e validate_vmode(char *name, unsigned int frac);
+extern enum vmode_e validate_vmode(char *p);
 
 extern int vout_suspend(void);
 extern int vout_resume(void);
@@ -90,12 +85,15 @@ extern int vout_shutdown(void);
 
 #ifdef CONFIG_AMLOGIC_VOUT2_SERVE
 extern int set_current_vmode2(enum vmode_e);
-int vout2_check_same_vmodeattr(char *name);
-enum vmode_e validate_vmode2(char *name, unsigned int frac);
+extern enum vmode_e validate_vmode2(char *p);
 
 extern int vout2_suspend(void);
 extern int vout2_resume(void);
 extern int vout2_shutdown(void);
 #endif
 
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+extern int cvbs_cable_connected(void);
+#endif
+
 #endif
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_notify.c b/drivers/amlogic/media/vout/vout_serve/vout_notify.c
index 2373f0226466..3e2a5f33c1f8 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout_notify.c
+++ b/drivers/amlogic/media/vout/vout_serve/vout_notify.c
@@ -73,21 +73,12 @@ struct vinfo_s *get_current_vinfo(void)
 			vinfo = p_module->curr_vout_server->op.get_vinfo();
 	}
 	if (vinfo == NULL) /* avoid crash mistake */
-		vinfo = get_invalid_vinfo(1, p_module->init_flag);
+		vinfo = get_invalid_vinfo(1);
 
 	return vinfo;
 }
 EXPORT_SYMBOL(get_current_vinfo);
 
-/*
- *interface export to client who want to get display support list.
- */
-int get_vout_disp_cap(char *buf)
-{
-	return vout_func_get_disp_cap(1, buf);
-}
-EXPORT_SYMBOL(get_vout_disp_cap);
-
 /*
  *interface export to client who want to get current vmode.
  */
@@ -122,7 +113,7 @@ const char *get_name_by_vmode(enum vmode_e mode)
 			vinfo = p_module->curr_vout_server->op.get_vinfo();
 	}
 	if (vinfo == NULL)
-		vinfo = get_invalid_vinfo(1, p_module->init_flag);
+		vinfo = get_invalid_vinfo(1);
 	str = vinfo->name;
 
 	return str;
@@ -156,21 +147,12 @@ int set_current_vmode(enum vmode_e mode)
 }
 EXPORT_SYMBOL(set_current_vmode);
 
-/*
- *interface export to client who want to check same vmode attr.
- */
-int vout_check_same_vmodeattr(char *name)
-{
-	return vout_func_check_same_vmodeattr(1, name);
-}
-EXPORT_SYMBOL(vout_check_same_vmodeattr);
-
 /*
  *interface export to client who want to set current vmode.
  */
-enum vmode_e validate_vmode(char *name, unsigned int frac)
+enum vmode_e validate_vmode(char *name)
 {
-	return vout_func_validate_vmode(1, name, frac);
+	return vout_func_validate_vmode(1, name);
 }
 EXPORT_SYMBOL(validate_vmode);
 
@@ -183,22 +165,12 @@ int set_vframe_rate_hint(int duration)
 }
 EXPORT_SYMBOL(set_vframe_rate_hint);
 
-int get_vframe_rate_hint(void)
-{
-	return vout_func_get_vframe_rate_hint(1);
-}
-EXPORT_SYMBOL(get_vframe_rate_hint);
-
-int set_clock_drift(int ppm)
-{
-	return vout_func_set_clock_drift(1, ppm);
-}
-EXPORT_SYMBOL(set_clock_drift);
-
-/* dummy for temp */
+/*
+ *interface export to client who want to notify about source frame rate end.
+ */
 int set_vframe_rate_end_hint(void)
 {
-	return vout_func_set_vframe_rate_hint(1, 0);
+	return vout_func_set_vframe_rate_end_hint(1);
 }
 EXPORT_SYMBOL(set_vframe_rate_end_hint);
 
@@ -207,15 +179,7 @@ EXPORT_SYMBOL(set_vframe_rate_end_hint);
  */
 int set_vframe_rate_policy(int policy)
 {
-	struct vout_module_s *p_module = NULL;
-
-	p_module = vout_func_get_vout_module();
-	if (!p_module)
-		return -1;
-
-	p_module->fr_policy = policy;
-
-	return 0;
+	return vout_func_set_vframe_rate_policy(1, policy);
 }
 EXPORT_SYMBOL(set_vframe_rate_policy);
 
@@ -224,13 +188,7 @@ EXPORT_SYMBOL(set_vframe_rate_policy);
  */
 int get_vframe_rate_policy(void)
 {
-	struct vout_module_s *p_module = NULL;
-
-	p_module = vout_func_get_vout_module();
-	if (!p_module)
-		return 0;
-
-	return p_module->fr_policy;
+	return vout_func_get_vframe_rate_policy(1);
 }
 EXPORT_SYMBOL(get_vframe_rate_policy);
 
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_reg.c b/drivers/amlogic/media/vout/vout_serve/vout_reg.c
deleted file mode 100644
index a47efaa985d3..000000000000
--- a/drivers/amlogic/media/vout/vout_serve/vout_reg.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * drivers/amlogic/media/vout/vout_serve/vout_reg.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-#include <linux/delay.h>
-#include <linux/amlogic/iomap.h>
-#include <linux/amlogic/media/vout/vclk_serve.h>
-#include "vout_func.h"
-#include "vout_reg.h"
-
-/* ********************************
- * register access api
- * *********************************
- */
-unsigned int vout_hiu_read(unsigned int _reg)
-{
-	return vclk_clk_reg_read(_reg);
-};
-
-void vout_hiu_write(unsigned int _reg, unsigned int _value)
-{
-	vclk_clk_reg_write(_reg, _value);
-};
-
-void vout_hiu_setb(unsigned int _reg, unsigned int _value,
-		   unsigned int _start, unsigned int _len)
-{
-	vout_hiu_write(_reg, ((vout_hiu_read(_reg) &
-			~(((1L << (_len)) - 1) << (_start))) |
-			(((_value) & ((1L << (_len)) - 1)) << (_start))));
-}
-
-unsigned int vout_hiu_getb(unsigned int reg,
-			   unsigned int _start, unsigned int _len)
-{
-	return (vout_hiu_read(reg) >> _start) & ((1L << _len) - 1);
-}
-
-unsigned int vout_vcbus_read(unsigned int _reg)
-{
-	unsigned int ret = 0;
-
-#ifdef CONFIG_AMLOGIC_VPU
-	ret = vpu_vcbus_read(_reg);
-#else
-	ret = aml_read_vcbus(_reg);
-#endif
-
-	return ret;
-};
-
-void vout_vcbus_write(unsigned int _reg, unsigned int _value)
-{
-#ifdef CONFIG_AMLOGIC_VPU
-	vpu_vcbus_write(_reg, _value);
-#else
-	aml_write_vcbus(_reg, _value);
-#endif
-};
-
-void vout_vcbus_setb(unsigned int _reg, unsigned int _value,
-		     unsigned int _start, unsigned int _len)
-{
-	vout_vcbus_write(_reg, ((vout_vcbus_read(_reg) &
-			~(((1L << (_len)) - 1) << (_start))) |
-			(((_value) & ((1L << (_len)) - 1)) << (_start))));
-}
-
-unsigned int vout_vcbus_getb(unsigned int reg,
-			     unsigned int _start, unsigned int _len)
-{
-	return (vout_vcbus_read(reg) >> _start) & ((1L << _len) - 1);
-}
-
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_reg.h b/drivers/amlogic/media/vout/vout_serve/vout_reg.h
index 2857a0c31d51..54c265fb507d 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout_reg.h
+++ b/drivers/amlogic/media/vout/vout_serve/vout_reg.h
@@ -17,13 +17,7 @@
 
 #ifndef _VOUT_REG_H_
 #define _VOUT_REG_H_
-#include <linux/platform_device.h>
 #include <linux/amlogic/iomap.h>
-#ifdef CONFIG_AMLOGIC_VPU
-#include <linux/amlogic/media/vpu/vpu.h>
-#endif
-
-#define VOUT_REG_OFFSET(reg)          ((reg) << 2)
 
 /* [3: 2] cntl_viu2_sel_venc:
  *         0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT.
@@ -41,97 +35,6 @@
 #define VPP2_POSTBLEND_H_SIZE                      0x1921
 #define VPP_WRBAK_CTRL                             0x1df9
 
-#define ENCI_VIDEO_MODE                            0x1b00
-#define ENCI_VIDEO_MODE_ADV                        0x1b01
-#define ENCI_VIDEO_FSC_ADJ                         0x1b02
-#define ENCI_VIDEO_BRIGHT                          0x1b03
-#define ENCI_VIDEO_CONT                            0x1b04
-#define ENCI_VIDEO_SAT                             0x1b05
-#define ENCI_VIDEO_HUE                             0x1b06
-#define ENCI_VIDEO_SCH                             0x1b07
-#define ENCI_SYNC_MODE                             0x1b08
-#define ENCI_SYNC_CTRL                             0x1b09
-#define ENCI_SYNC_HSO_BEGIN                        0x1b0a
-#define ENCI_SYNC_HSO_END                          0x1b0b
-#define ENCI_SYNC_VSO_EVN                          5
-#define ENCI_SYNC_VSO_ODD                          0x1b0d
-#define ENCI_SYNC_VSO_EVNLN                        0x1b0e
-#define ENCI_SYNC_VSO_ODDLN                        0x1b0f
-#define ENCI_SYNC_HOFFST                           0x1b10
-#define ENCI_SYNC_VOFFST                           0x1b11
-#define ENCI_SYNC_ADJ                              0x1b12
-#define ENCI_RGB_SETTING                           0x1b13
-
-#define ENCI_DE_H_BEGIN                            0x1b16
-#define ENCI_DE_H_END                              0x1b17
-#define ENCI_DE_V_BEGIN_EVEN                       0x1b18
-#define ENCI_DE_V_END_EVEN                         0x1b19
-#define ENCI_DE_V_BEGIN_ODD                        0x1b1a
-#define ENCI_DE_V_END_ODD                          0x1b1b
-
-#define ENCI_DBG_PX_RST                            0x1b48
-#define ENCI_DBG_FLDLN_RST                         0x1b49
-#define ENCI_DBG_PX_INT                            0x1b4a
-#define ENCI_DBG_FLDLN_INT                         0x1b4b
-#define ENCI_DBG_MAXPX                             0x1b4c
-#define ENCI_DBG_MAXLN                             0x1b4d
-#define ENCI_MACV_MAX_AMP                          0x1b50
-#define ENCI_MACV_PULSE_LO                         0x1b51
-#define ENCI_MACV_PULSE_HI                         0x1b52
-#define ENCI_MACV_BKP_MAX                          0x1b53
-#define ENCI_CFILT_CTRL                            0x1b54
-#define ENCI_CFILT7                                0x1b55
-#define ENCI_YC_DELAY                              0x1b56
-#define ENCI_VIDEO_EN                              0x1b57
-
-#define VENC_SYNC_ROUTE                            0x1b60
-#define VENC_UPSAMPLE_CTRL0                        0x1b64
-#define VENC_UPSAMPLE_CTRL1                        0x1b65
-#define VENC_UPSAMPLE_CTRL2                        0x1b66
-#define VENC_VIDEO_PROG_MODE                       0x1b68
-#define VENC_INTCTRL                               0x1b6e
-
-#define ENCI_DVI_HSO_BEGIN                         0x1c00
-#define ENCI_DVI_HSO_END                           0x1c01
-#define ENCI_DVI_VSO_BLINE_EVN                     0x1c02
-#define ENCI_DVI_VSO_BLINE_ODD                     0x1c03
-#define ENCI_DVI_VSO_ELINE_EVN                     0x1c04
-#define ENCI_DVI_VSO_ELINE_ODD                     0x1c05
-#define ENCI_DVI_VSO_BEGIN_EVN                     0x1c06
-#define ENCI_DVI_VSO_BEGIN_ODD                     0x1c07
-#define ENCI_DVI_VSO_END_EVN                       0x1c08
-#define ENCI_DVI_VSO_END_ODD                       0x1c09
-
-#define ENCI_CFILT_CTRL2                           0x1c0a
-#define ENCI_DACSEL_0                              0x1c0b
-#define ENCI_DACSEL_1                              0x1c0c
-#define ENCP_DACSEL_0                              0x1c0d
-#define ENCP_DACSEL_1                              0x1c0e
-#define ENCP_MAX_LINE_SWITCH_POINT                 0x1c0f
-#define ENCI_TST_EN                                0x1c10
-#define ENCI_TST_MDSEL                             0x1c11
-#define ENCI_TST_Y                                 0x1c12
-#define ENCI_TST_CB                                0x1c13
-#define ENCI_TST_CR                                0x1c14
-#define ENCI_TST_CLRBAR_STRT                       0x1c15
-#define ENCI_TST_CLRBAR_WIDTH                      0x1c16
-#define ENCI_TST_VDCNT_STSET                       0x1c17
-
-#define ENCI_VFIFO2VD_CTL                          0x1c18
-
-#define ENCI_VFIFO2VD_PIXEL_START                  0x1c19
-
-#define ENCI_VFIFO2VD_PIXEL_END                    0x1c1a
-
-#define ENCI_VFIFO2VD_LINE_TOP_START               0x1c1b
-
-#define ENCI_VFIFO2VD_LINE_TOP_END                 0x1c1c
-
-#define ENCI_VFIFO2VD_LINE_BOT_START               0x1c1d
-
-#define ENCI_VFIFO2VD_LINE_BOT_END                 0x1c1e
-#define ENCI_VFIFO2VD_CTL2                         0x1c1f
-
 /* ENCL registers */
 #define ENCL_VIDEO_EN                              0x1ca0
 #define ENCL_VIDEO_Y_SCL                           0x1ca1
@@ -255,16 +158,6 @@
 #define ENCL_CLK_SEL           12
 #define VCLK2_XD                0
 
-#define HHI_VIID_CLK_CNTL                          0x4b
-#define VCLK2_EN               19
-#define VCLK2_CLK_IN_SEL       16
-#define VCLK2_SOFT_RST         15
-#define VCLK2_DIV12_EN          4
-#define VCLK2_DIV6_EN           3
-#define VCLK2_DIV4_EN           2
-#define VCLK2_DIV2_EN           1
-#define VCLK2_DIV1_EN           0
-
 #define HHI_VID_CLK_DIV                            0x59
 #define ENCI_CLK_SEL           28
 #define ENCP_CLK_SEL           24
@@ -275,17 +168,6 @@
 #define VCLK_XD1                8
 #define VCLK_XD0                0
 
-#define HHI_VID_CLK_CNTL                           0x5f
-#define VCLK_EN1               20
-#define VCLK_EN0               19
-#define VCLK_CLK_IN_SEL        16
-#define VCLK_SOFT_RST          15
-#define VCLK_DIV12_EN           4
-#define VCLK_DIV6_EN            3
-#define VCLK_DIV4_EN            2
-#define VCLK_DIV2_EN            1
-#define VCLK_DIV1_EN            0
-
 #define HHI_VID_CLK_CNTL2                          0x65
 #define HDMI_TX_PIXEL_GATE_VCLK  5
 #define VDAC_GATE_VCLK           4
@@ -294,25 +176,52 @@
 #define ENCT_GATE_VCLK           1
 #define ENCI_GATE_VCLK           0
 
-#define CLKCTRL_VID_CLK_CTRL                       0x0030
-#define CLKCTRL_VID_CLK_CTRL2                      0x0031
-#define CLKCTRL_VID_CLK_DIV                        0x0032
-#define CLKCTRL_VIID_CLK_DIV                       0x0033
-#define CLKCTRL_VIID_CLK_CTRL                      0x0034
-
-int vout_ioremap(struct platform_device *pdev);
-unsigned int vout_hiu_read(unsigned int _reg);
-void vout_hiu_write(unsigned int _reg, unsigned int _value);
-void vout_hiu_setb(unsigned int _reg, unsigned int _value,
-		   unsigned int _start, unsigned int _len);
-unsigned int vout_hiu_getb(unsigned int reg,
-			   unsigned int _start, unsigned int _len);
-
-unsigned int vout_vcbus_read(unsigned int _reg);
-void vout_vcbus_write(unsigned int _reg, unsigned int _value);
-void vout_vcbus_setb(unsigned int _reg, unsigned int _value,
-		     unsigned int _start, unsigned int _len);
-unsigned int vout_vcbus_getb(unsigned int reg,
-			     unsigned int _start, unsigned int _len);
+static inline unsigned int vout_vcbus_read(unsigned int _reg)
+{
+	return aml_read_vcbus(_reg);
+};
+
+static inline void vout_vcbus_write(unsigned int _reg, unsigned int _value)
+{
+	aml_write_vcbus(_reg, _value);
+};
+
+static inline void vout_vcbus_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	vout_vcbus_write(_reg, ((vout_vcbus_read(_reg) &
+			~(((1L << (_len)) - 1) << (_start))) |
+			(((_value) & ((1L << (_len)) - 1)) << (_start))));
+}
+
+static inline unsigned int vout_vcbus_getb(unsigned int reg,
+		unsigned int _start, unsigned int _len)
+{
+	return (vout_vcbus_read(reg) >> _start) & ((1L << _len) - 1);
+}
+
+static inline unsigned int vout_hiu_read(unsigned int _reg)
+{
+	return aml_read_hiubus(_reg);
+};
+
+static inline void vout_hiu_write(unsigned int _reg, unsigned int _value)
+{
+	aml_write_hiubus(_reg, _value);
+};
+
+static inline void vout_hiu_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	vout_hiu_write(_reg, ((vout_hiu_read(_reg) &
+			~(((1L << (_len)) - 1) << (_start))) |
+			(((_value) & ((1L << (_len)) - 1)) << (_start))));
+}
+
+static inline unsigned int vout_hiu_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len)
+{
+	return (vout_hiu_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
+}
 
 #endif
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_serve.c b/drivers/amlogic/media/vout/vout_serve/vout_serve.c
index 6e0f122578c0..3c719f42b583 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout_serve.c
+++ b/drivers/amlogic/media/vout/vout_serve/vout_serve.c
@@ -31,7 +31,6 @@
 #include <linux/interrupt.h>
 #include <linux/ctype.h>
 #include <linux/of.h>
-#include <linux/of_device.h>
 #include <linux/major.h>
 #include <linux/uaccess.h>
 #include <linux/extcon.h>
@@ -44,9 +43,8 @@
 
 /* Local Headers */
 #include "vout_func.h"
-#include "vout_reg.h"
 
-#if defined(CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND) && !defined(CONFIG_AMLOGIC_DRM)
+#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 #include <linux/amlogic/pm.h>
 static struct early_suspend early_suspend;
 static int early_suspend_flag;
@@ -66,11 +64,35 @@ static char vout_mode_uboot[VMODE_NAME_LEN_MAX] = "null";
 static char vout_mode[VMODE_NAME_LEN_MAX] __nosavedata;
 static char local_name[VMODE_NAME_LEN_MAX] = {0};
 static u32 vout_init_vmode = VMODE_INIT_NULL;
+#if !defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
 static int uboot_display;
+#endif
 static unsigned int bist_mode;
 
 static char vout_axis[64] __nosavedata;
 
+static char hdmimode[VMODE_NAME_LEN_MAX] = {
+	'i', 'n', 'v', 'a', 'l', 'i', 'd', '\0'
+};
+static char cvbsmode[VMODE_NAME_LEN_MAX] = {
+	'i', 'n', 'v', 'a', 'l', 'i', 'd', '\0'
+};
+static char hdmichecksum[VMODE_NAME_LEN_MAX] = {
+	'i', 'n', 'v', 'a', 'l', 'i', 'd', 'c', 'r', 'c', '\0'
+};
+static char invalidchecksum[VMODE_NAME_LEN_MAX] = {
+	'i', 'n', 'v', 'a', 'l', 'i', 'd', 'c', 'r', 'c', '\0'
+};
+static char emptychecksum[VMODE_NAME_LEN_MAX] = {0};
+
+static enum vmode_e last_vmode = VMODE_MAX;
+static int tvout_monitor_flag = 1;
+static unsigned int tvout_monitor_timeout_cnt = 20;
+/* 500ms: 1*HZ/2 */
+static unsigned int tvout_monitor_interval = 500;
+
+static struct delayed_work tvout_mode_work;
+
 static struct extcon_dev *vout_excton_setmode;
 static const unsigned int vout_cable[] = {
 	EXTCON_TYPE_DISP,
@@ -78,7 +100,6 @@ static const unsigned int vout_cable[] = {
 };
 
 static struct vout_cdev_s *vout_cdev;
-static struct device *vout_dev;
 
 /* **********************************************************
  * null display support
@@ -89,7 +110,6 @@ static struct vinfo_s nulldisp_vinfo[] = {
 	{
 		.name              = "null",
 		.mode              = VMODE_NULL,
-		.frac              = 0,
 		.width             = 1920,
 		.height            = 1080,
 		.field_height      = 1080,
@@ -108,7 +128,6 @@ static struct vinfo_s nulldisp_vinfo[] = {
 	{
 		.name              = "invalid",
 		.mode              = VMODE_INVALID,
-		.frac              = 0,
 		.width             = 1920,
 		.height            = 1080,
 		.field_height      = 1080,
@@ -139,14 +158,11 @@ static int nulldisp_set_current_vmode(enum vmode_e mode)
 	return 0;
 }
 
-static enum vmode_e nulldisp_validate_vmode(char *name, unsigned int frac)
+static enum vmode_e nulldisp_validate_vmode(char *name)
 {
 	enum vmode_e vmode = VMODE_MAX;
 	int i;
 
-	if (frac)
-		return VMODE_MAX;
-
 	for (i = 0; i < ARRAY_SIZE(nulldisp_vinfo); i++) {
 		if (strcmp(nulldisp_vinfo[i].name, name) == 0) {
 			vmode = nulldisp_vinfo[i].mode;
@@ -203,7 +219,6 @@ static struct vout_server_s nulldisp_vout_server = {
 		.set_state          = nulldisp_vout_set_state,
 		.clr_state          = nulldisp_vout_clr_state,
 		.get_state          = nulldisp_vout_get_state,
-		.get_disp_cap       = NULL,
 		.set_bist           = NULL,
 	},
 };
@@ -222,32 +237,11 @@ char *get_vout_mode_uboot(void)
 }
 EXPORT_SYMBOL(get_vout_mode_uboot);
 
-#define MAX_UEVENT_LEN 64
-
-static int vout_set_uevent(unsigned int vout_event, int val)
-{
-	char env[MAX_UEVENT_LEN];
-	char *envp[2];
-	int ret;
-
-	if (vout_event != VOUT_EVENT_MODE_CHANGE)
-		return 0;
-
-	if (!vout_dev)
-		return -1;
-
-	memset(env, 0, sizeof(env));
-	envp[0] = env;
-	envp[1] = NULL;
-	snprintf(env, MAX_UEVENT_LEN, "vout_setmode=%d", val);
-
-	ret = kobject_uevent_env(&vout_dev->kobj, KOBJ_CHANGE, envp);
-
-	return ret;
-}
-
 static inline void vout_setmode_wakeup_queue(void)
 {
+	if (tvout_monitor_flag)
+		return;
+
 	if (vout_cdev)
 		wake_up(&vout_cdev->setmode_queue);
 }
@@ -255,44 +249,37 @@ static inline void vout_setmode_wakeup_queue(void)
 int set_vout_mode(char *name)
 {
 	enum vmode_e mode;
-	unsigned int frac;
 	int ret = 0;
 
 	vout_trim_string(name);
 	VOUTPR("vmode set to %s\n", name);
 
-	if ((strcmp(name, vout_mode) == 0) &&
-	    (vout_check_same_vmodeattr(name))) {
+	if (strcmp(name, local_name) == 0) {
 		VOUTPR("don't set the same mode as current, exit\n");
 		return -1;
 	}
 
-	memset(local_name, 0, sizeof(local_name));
-	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", name);
-	frac = vout_parse_vout_name(local_name);
-
-	mode = validate_vmode(local_name, frac);
+	mode = validate_vmode(name);
 	if (mode == VMODE_MAX) {
 		VOUTERR("no matched vout mode, exit\n");
 		return -1;
 	}
+	memset(local_name, 0, sizeof(local_name));
+	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", name);
 
 	extcon_set_state_sync(vout_excton_setmode, EXTCON_TYPE_DISP, 1);
-	vout_set_uevent(VOUT_EVENT_MODE_CHANGE, 1);
 
 	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE_PRE, &mode);
 	ret = set_current_vmode(mode);
-	if (ret) {
+	if (ret)
 		VOUTERR("new mode %s set error\n", name);
-	} else {
-		memset(vout_mode, 0, sizeof(vout_mode));
+	else {
 		snprintf(vout_mode, VMODE_NAME_LEN_MAX, "%s", name);
-		VOUTPR("new mode %s set ok\n", name);
+		VOUTPR("new mode %s set ok\n", vout_mode);
 	}
 	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
 
 	extcon_set_state_sync(vout_excton_setmode, EXTCON_TYPE_DISP, 0);
-	vout_set_uevent(VOUT_EVENT_MODE_CHANGE, 0);
 	vout_setmode_wakeup_queue();
 
 	return ret;
@@ -301,39 +288,59 @@ int set_vout_mode(char *name)
 static int set_vout_init_mode(void)
 {
 	enum vmode_e vmode;
-	unsigned int frac;
+	char init_mode_str[VMODE_NAME_LEN_MAX];
 	int ret = 0;
 
-	memset(local_name, 0, sizeof(local_name));
-	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", vout_mode_uboot);
-	frac = vout_parse_vout_name(local_name);
-
-	vout_init_vmode = validate_vmode(local_name, frac);
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+#if defined(CONFIG_AMLOGIC_LCD)
+	snprintf(vout_mode_uboot, VMODE_NAME_LEN_MAX, "%s", "panel");
+#else
+	strncpy(vout_mode_uboot,
+			(vout_get_hpd_state() || !cvbs_cable_connected()) ?
+			hdmimode : cvbsmode,
+			sizeof(vout_mode_uboot));
+#endif
+#endif
+	snprintf(init_mode_str, VMODE_NAME_LEN_MAX, "%s", vout_mode_uboot);
+	vout_init_vmode = validate_vmode(vout_mode_uboot);
 	if (vout_init_vmode >= VMODE_MAX) {
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+#if defined(CONFIG_AMLOGIC_LCD)
+		VOUTERR("no matched vout mode %s, force to set panel\n",
+			vout_mode_uboot);
+		snprintf(init_mode_str, VMODE_NAME_LEN_MAX, "%s", "panel");
+		vout_init_vmode = validate_vmode("panel");
+#else
+		VOUTERR("no matched vout mode %s, force to set 1080p60hz\n",
+			vout_mode_uboot);
+		snprintf(init_mode_str, VMODE_NAME_LEN_MAX, "%s", "1080p60hz");
+		vout_init_vmode = validate_vmode("1080p60hz");
+#endif
+#else
 		VOUTERR("no matched vout_init mode %s, force to invalid\n",
 			vout_mode_uboot);
 		nulldisp_index = 1;
 		vout_init_vmode = nulldisp_vinfo[nulldisp_index].mode;
-		snprintf(local_name, VMODE_NAME_LEN_MAX, "%s",
-			 nulldisp_vinfo[nulldisp_index].name);
-	} else { /* recover vout_mode_uboot */
-		snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", vout_mode_uboot);
+		snprintf(init_mode_str, VMODE_NAME_LEN_MAX, "%s",
+			nulldisp_vinfo[nulldisp_index].name);
+#endif
 	}
+	last_vmode = vout_init_vmode;
 
-	if (uboot_display)
-		vmode = vout_init_vmode | VMODE_INIT_BIT_MASK;
-	else
-		vmode = vout_init_vmode;
+	vmode = vout_init_vmode;
+#if !defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	vmode |= VMODE_INIT_BIT_MASK;
+#endif
 
+	memset(local_name, 0, sizeof(local_name));
+	snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", init_mode_str);
 	ret = set_current_vmode(vmode);
 	if (ret)
-		VOUTERR("init mode %s set error\n", local_name);
+		VOUTERR("init mode %s set error\n", init_mode_str);
 	else {
-		memset(vout_mode, 0, sizeof(vout_mode));
-		snprintf(vout_mode, VMODE_NAME_LEN_MAX, "%s", local_name);
-		VOUTPR("init mode %s set ok\n", local_name);
+		snprintf(vout_mode, VMODE_NAME_LEN_MAX, "%s", init_mode_str);
+		VOUTPR("init mode %s set ok\n", vout_mode);
 	}
-	vout_notifier_call_chain(VOUT_EVENT_SYS_INIT, &vmode);
 
 	return ret;
 }
@@ -380,26 +387,20 @@ static void set_vout_axis(char *para)
 {
 	static struct disp_rect_s disp_rect[OSD_COUNT];
 	/* char count = OSD_COUNT * 4; */
-	int *pt;
+	int *pt = &disp_rect[0].x;
 	int parsed[MAX_NUMBER_PARA] = {};
 
 	/* parse window para */
-	if (parse_para(para, 8, parsed) >= 4) {
-		pt = &disp_rect[0].x;
-		memcpy(pt, &parsed[0], sizeof(struct disp_rect_s));
-		pt = &disp_rect[1].x;
-		memcpy(pt, &parsed[4], sizeof(struct disp_rect_s));
-	}
+	if (parse_para(para, 8, parsed) >= 4)
+		memcpy(pt, parsed, sizeof(struct disp_rect_s) * OSD_COUNT);
 	/* if ((count >= 4) && (count < 8))
 	 *	disp_rect[1] = disp_rect[0];
 	 */
 
 	VOUTPR("osd0=> x:%d,y:%d,w:%d,h:%d\n"
 		"osd1=> x:%d,y:%d,w:%d,h:%d\n",
-			disp_rect[0].x, disp_rect[0].y,
-			disp_rect[0].w, disp_rect[0].h,
-			disp_rect[1].x, disp_rect[1].y,
-			disp_rect[1].w, disp_rect[1].h);
+			*pt, *(pt + 1), *(pt + 2), *(pt + 3),
+			*(pt + 4), *(pt + 5), *(pt + 6), *(pt + 7));
 	vout_notifier_call_chain(VOUT_EVENT_OSD_DISP_AXIS, &disp_rect[0]);
 }
 
@@ -419,6 +420,7 @@ static ssize_t vout_mode_store(struct class *class,
 	char mode[VMODE_NAME_LEN_MAX];
 
 	mutex_lock(&vout_serve_mutex);
+	tvout_monitor_flag = 0;
 	snprintf(mode, VMODE_NAME_LEN_MAX, "%s", buf);
 	set_vout_mode(mode);
 	mutex_unlock(&vout_serve_mutex);
@@ -477,37 +479,6 @@ static ssize_t vout_fr_policy_store(struct class *class,
 	return count;
 }
 
-static ssize_t vout_fr_hint_show(struct class *class,
-				 struct class_attribute *attr, char *buf)
-{
-	int fr_hint;
-	int ret = 0;
-
-	fr_hint = get_vframe_rate_hint();
-	ret = sprintf(buf, "%d\n", fr_hint);
-
-	return ret;
-}
-
-static ssize_t vout_fr_hint_store(struct class *class,
-				  struct class_attribute *attr,
-				  const char *buf, size_t count)
-{
-	int fr_hint;
-	int ret = 0;
-
-	mutex_lock(&vout_serve_mutex);
-	ret = kstrtoint(buf, 10, &fr_hint);
-	if (ret) {
-		mutex_unlock(&vout_serve_mutex);
-		return -EINVAL;
-	}
-	set_vframe_rate_hint(fr_hint);
-	mutex_unlock(&vout_serve_mutex);
-
-	return count;
-}
-
 static ssize_t vout_bist_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -552,7 +523,6 @@ static ssize_t vout_vinfo_show(struct class *class,
 	len = sprintf(buf, "current vinfo:\n"
 		"    name:                  %s\n"
 		"    mode:                  %d\n"
-		"    frac:                  %d\n"
 		"    width:                 %d\n"
 		"    height:                %d\n"
 		"    field_height:          %d\n"
@@ -569,7 +539,7 @@ static ssize_t vout_vinfo_show(struct class *class,
 		"    viu_color_fmt:         %d\n"
 		"    viu_mux:               %d\n"
 		"    3d_info:               %d\n\n",
-		info->name, info->mode, info->frac,
+		info->name, info->mode,
 		info->width, info->height, info->field_height,
 		info->aspect_ratio_num, info->aspect_ratio_den,
 		info->sync_duration_num, info->sync_duration_den,
@@ -631,40 +601,13 @@ static ssize_t vout_vinfo_show(struct class *class,
 	return len;
 }
 
-static ssize_t vout_cap_show(struct class *class,
-			     struct class_attribute *attr, char *buf)
-{
-	int ret;
-
-	ret = get_vout_disp_cap(buf);
-	if (!ret)
-		return sprintf(buf, "null\n");
-
-	return ret;
-}
-
-static ssize_t vout_vinfo_name_show(struct class *class,
-		struct class_attribute *attr, char *buf)
-{
-	const struct vinfo_s *info = NULL;
-	int ret = 0;
-
-	info = get_current_vinfo();
-	if (info == NULL)
-		return sprintf(buf, "null");
-	ret = sprintf(buf, "%s\n", info->name);
-}
-
 static struct class_attribute vout_class_attrs[] = {
-	__ATTR(mode,       0644, vout_mode_show, vout_mode_store),
-	__ATTR(axis,       0644, vout_axis_show, vout_axis_store),
-	__ATTR(fr_policy,  0644,
+	__ATTR(mode,      0644, vout_mode_show, vout_mode_store),
+	__ATTR(axis,      0644, vout_axis_show, vout_axis_store),
+	__ATTR(fr_policy, 0644,
 		vout_fr_policy_show, vout_fr_policy_store),
-	__ATTR(fr_hint,    0644, vout_fr_hint_show, vout_fr_hint_store),
-	__ATTR(bist,       0644, vout_bist_show, vout_bist_store),
-	__ATTR(vinfo,      0444, vout_vinfo_show, NULL),
-	__ATTR(vinfo_name, 0444, vout_vinfo_name_show, NULL),
-	__ATTR(cap,        0644, vout_cap_show, NULL)
+	__ATTR(bist,      0644, vout_bist_show, vout_bist_store),
+	__ATTR(vinfo,     0444, vout_vinfo_show, NULL),
 };
 
 static int vout_attr_create(void)
@@ -687,7 +630,7 @@ static int vout_attr_create(void)
 		}
 	}
 
-	/*VOUTPR("create vout attribute OK\n");*/
+	VOUTPR("create vout attribute OK\n");
 
 	return ret;
 }
@@ -715,7 +658,7 @@ static int vout_io_open(struct inode *inode, struct file *file)
 {
 	struct vout_cdev_s *vcdev;
 
-	/*VOUTPR("%s\n", __func__);*/
+	VOUTPR("%s\n", __func__);
 	vcdev = container_of(inode->i_cdev, struct vout_cdev_s, cdev);
 	file->private_data = vcdev;
 	return 0;
@@ -723,7 +666,7 @@ static int vout_io_open(struct inode *inode, struct file *file)
 
 static int vout_io_release(struct inode *inode, struct file *file)
 {
-	/*VOUTPR("%s\n", __func__);*/
+	VOUTPR("%s\n", __func__);
 	file->private_data = NULL;
 	return 0;
 }
@@ -842,7 +785,7 @@ static int vout_fops_create(void)
 
 	init_waitqueue_head(&vout_cdev->setmode_queue);
 
-	/*VOUTPR("%s OK\n", __func__);*/
+	VOUTPR("%s OK\n", __func__);
 	return 0;
 
 vout_fops_err3:
@@ -867,7 +810,7 @@ static void vout_fops_remove(void)
 #ifdef CONFIG_PM
 static int aml_vout_suspend(struct platform_device *pdev, pm_message_t state)
 {
-#if defined(CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND) && !defined(CONFIG_AMLOGIC_DRM)
+#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 
 	if (early_suspend_flag)
 		return 0;
@@ -888,6 +831,7 @@ static int aml_vout_resume(struct platform_device *pdev)
 
 #endif
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+
 	if (early_suspend_flag)
 		return 0;
 
@@ -963,6 +907,140 @@ static void aml_vout_late_resume(struct early_suspend *h)
 }
 #endif
 
+/* ***************************************************** */
+/* hdmi/cvbs output mode monitor */
+/* ***************************************************** */
+static int refresh_tvout_mode(void)
+{
+	enum vmode_e cur_vmode = VMODE_MAX;
+	char cur_mode_str[VMODE_NAME_LEN_MAX];
+	int hpd_state = 0;
+	struct vinfo_s *info = get_current_vinfo();
+
+	if (tvout_monitor_flag == 0)
+		return 0;
+
+	hpd_state = vout_get_hpd_state();
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	/* Unless CVBS cable is not attached, we assumed that HDMI cable is attached */
+	if (!cvbs_cable_connected())
+		hpd_state = 1;
+#endif
+
+	if (hpd_state) {
+		/* Vout will check the checksum of EDID of uboot and kernel.
+		 * If checksum is different. Vout will set null to display/mode.
+		 * When systemcontrol bootup, it will set the correct mode and
+		 * colorspace according to current EDID from kernel.
+		 */
+		if ((memcmp(hdmichecksum, info->hdmichecksum, 10)) &&
+			(memcmp(emptychecksum, info->hdmichecksum, 10)) &&
+			(memcmp(invalidchecksum, hdmichecksum, 10))) {
+			VOUTPR("hdmi crc is diff between uboot and kernel\n");
+			cur_vmode = validate_vmode("null");
+			snprintf(cur_mode_str, VMODE_NAME_LEN_MAX, "null");
+
+		} else {
+			cur_vmode = validate_vmode(hdmimode);
+			snprintf(cur_mode_str, VMODE_NAME_LEN_MAX,
+				"%s", hdmimode);
+		}
+	} else {
+		cur_vmode = validate_vmode(cvbsmode);
+		snprintf(cur_mode_str, VMODE_NAME_LEN_MAX, "%s", cvbsmode);
+	}
+
+#if defined(CONFIG_AMLOGIC_LCD)
+	cur_vmode = validate_vmode("panel");
+	snprintf(cur_mode_str, VMODE_NAME_LEN_MAX, "%s", "panel");
+#endif
+
+	/* update current vout mode string */
+	memset(local_name, 0, sizeof(local_name));
+	strncpy(local_name, cur_mode_str, VMODE_NAME_LEN_MAX);
+
+	strncpy(vout_mode, cur_mode_str, VMODE_NAME_LEN_MAX);
+
+	if (cur_vmode >= VMODE_MAX) {
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+#if defined(CONFIG_AMLOGIC_LCD)
+		VOUTERR("%s: no matched vmode: %s, force to set panel\n",
+			__func__, cur_mode_str);
+		cur_vmode = validate_vmode("panel");
+		snprintf(cur_mode_str, VMODE_NAME_LEN_MAX, "%s", "panel");
+#else
+		VOUTERR("%s: no matched vmode: %s, force to set 1080p60hz\n",
+			__func__, cur_mode_str);
+		cur_vmode = validate_vmode("1080p60hz");
+		snprintf(cur_mode_str, VMODE_NAME_LEN_MAX, "%s", "1080p60hz");
+#endif
+#else
+		VOUTERR("%s: no matched cur_mode: %s, force to invalid\n",
+			__func__, cur_mode_str);
+		nulldisp_index = 1;
+		cur_vmode = nulldisp_vinfo[nulldisp_index].mode;
+		snprintf(cur_mode_str, VMODE_NAME_LEN_MAX, "%s",
+			nulldisp_vinfo[nulldisp_index].name);
+#endif
+	}
+
+	/* not box platform */
+	if ((cur_vmode != VMODE_HDMI) &&
+		(cur_vmode != VMODE_CVBS) &&
+		(cur_vmode != VMODE_NULL) &&
+		(cur_vmode != VMODE_INVALID))
+		return -1;
+
+	if (cur_vmode != last_vmode) {
+		VOUTPR("%s: mode chang to %s\n", __func__, cur_mode_str);
+		set_vout_mode(cur_mode_str);
+		last_vmode = cur_vmode;
+	}
+
+	return 0;
+}
+
+static void aml_tvout_mode_work(struct work_struct *work)
+{
+	if (tvout_monitor_timeout_cnt-- == 0) {
+		tvout_monitor_flag = 0;
+		VOUTPR("%s: monitor_timeout\n", __func__);
+		return;
+	}
+
+	mutex_lock(&vout_serve_mutex);
+	refresh_tvout_mode();
+	mutex_unlock(&vout_serve_mutex);
+
+	if (tvout_monitor_flag)
+		schedule_delayed_work(&tvout_mode_work,
+			msecs_to_jiffies(tvout_monitor_interval));
+	else
+		VOUTPR("%s: monitor stop\n", __func__);
+}
+
+static void aml_tvout_mode_monitor(void)
+{
+	if ((vout_init_vmode != VMODE_HDMI) &&
+		(vout_init_vmode != VMODE_CVBS) &&
+		(vout_init_vmode != VMODE_NULL) &&
+		(vout_init_vmode != VMODE_INVALID))
+		return;
+
+	VOUTPR("%s\n", __func__);
+	last_vmode = vout_init_vmode;
+	tvout_monitor_flag = 1;
+	INIT_DELAYED_WORK(&tvout_mode_work, aml_tvout_mode_work);
+
+	mutex_lock(&vout_serve_mutex);
+	refresh_tvout_mode();
+	mutex_unlock(&vout_serve_mutex);
+
+	schedule_delayed_work(&tvout_mode_work,
+		msecs_to_jiffies(tvout_monitor_interval));
+}
+
 static void aml_vout_extcon_register(struct platform_device *pdev)
 {
 	struct extcon_dev *edev;
@@ -997,14 +1075,17 @@ static void aml_vout_get_dt_info(struct platform_device *pdev)
 	int ret;
 	unsigned int para[2];
 
-	ret = of_property_read_u32(pdev->dev.of_node, "fr_policy", &para[0]);
+	/* e.g. dts: tvout_monitor = <100 250>
+	 * interval = 100(ms), timeout_cnt = 250
+	 */
+	ret = of_property_read_u32_array(pdev->dev.of_node,
+			"tvout_monitor", para, 2);
 	if (!ret) {
-		ret = set_vframe_rate_policy(para[0]);
-		if (ret)
-			VOUTERR("init fr_policy %d failed\n", para[0]);
-		else
-			VOUTPR("fr_policy:%d\n", para[0]);
+		tvout_monitor_interval = para[0];
+		tvout_monitor_timeout_cnt = para[1];
 	}
+	VOUTPR("tvout monitor interval:%d(ms), timeout cnt:%d\n",
+		tvout_monitor_interval, tvout_monitor_timeout_cnt);
 }
 
 /*****************************************************************
@@ -1012,21 +1093,10 @@ static void aml_vout_get_dt_info(struct platform_device *pdev)
  **	vout driver interface
  **
  ******************************************************************/
-static const struct of_device_id aml_vout_dt_match[] = {
-	{
-		.compatible = "amlogic, vout",
-	},
-	{ }
-};
-
 static int aml_vout_probe(struct platform_device *pdev)
 {
 	int ret = -1;
 
-	vout_dev = &pdev->dev;
-
-	aml_vout_get_dt_info(pdev);
-
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 	early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
 	early_suspend.suspend = aml_vout_early_suspend;
@@ -1040,7 +1110,9 @@ static int aml_vout_probe(struct platform_device *pdev)
 
 	vout_register_server(&nulldisp_vout_server);
 	aml_vout_extcon_register(pdev);
+	aml_vout_get_dt_info(pdev);
 	set_vout_init_mode();
+	aml_tvout_mode_monitor();
 
 	VOUTPR("%s OK\n", __func__);
 	return ret;
@@ -1066,6 +1138,11 @@ static void aml_vout_shutdown(struct platform_device *pdev)
 	vout_shutdown();
 }
 
+static const struct of_device_id aml_vout_dt_match[] = {
+	{ .compatible = "amlogic, vout",},
+	{ },
+};
+
 #ifdef CONFIG_HIBERNATION
 const struct dev_pm_ops vout_pm = {
 	.freeze		= aml_vout_freeze,
@@ -1113,6 +1190,7 @@ static __exit void vout_exit_module(void)
 subsys_initcall(vout_init_module);
 module_exit(vout_exit_module);
 
+#if !defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
 static int str2lower(char *str)
 {
 	while (*str != '\0') {
@@ -1141,15 +1219,6 @@ static void vout_init_mode_parse(char *str)
 		VOUTPR("%s: %d\n", str, uboot_display);
 		return;
 	}
-	if (strncmp(str, "frac", 4) == 0) { /* frac */
-		if ((strlen(vout_mode_uboot) + strlen(str))
-		    < VMODE_NAME_LEN_MAX)
-			strcat(vout_mode_uboot, str);
-		else
-			VOUTERR("%s: str len out of support\n", __func__);
-		VOUTPR("%s\n", str);
-		return;
-	}
 
 	/*
 	 * just save the vmode_name,
@@ -1157,7 +1226,7 @@ static void vout_init_mode_parse(char *str)
 	 */
 	snprintf(vout_mode_uboot, VMODE_NAME_LEN_MAX, "%s", str);
 	vout_trim_string(vout_mode_uboot);
-	VOUTPR("%s\n", vout_mode_uboot);
+	VOUTPR("%s\n", str);
 }
 
 static int __init get_vout_init_mode(char *str)
@@ -1172,8 +1241,7 @@ static int __init get_vout_init_mode(char *str)
 		return -EINVAL;
 
 	do {
-		if (!isalpha(*ptr) && !isdigit(*ptr) &&
-		    (*ptr != '_') && (*ptr != '-')) {
+		if (!isalpha(*ptr) && !isdigit(*ptr)) {
 			find = 1;
 			break;
 		}
@@ -1192,6 +1260,34 @@ static int __init get_vout_init_mode(char *str)
 	return 0;
 }
 __setup("vout=", get_vout_init_mode);
+#endif
+
+static int __init get_hdmi_mode(char *str)
+{
+	snprintf(hdmimode, VMODE_NAME_LEN_MAX, "%s", str);
+
+	VOUTPR("get hdmimode: %s\n", hdmimode);
+	return 0;
+}
+__setup("hdmimode=", get_hdmi_mode);
+
+static int __init get_cvbs_mode(char *str)
+{
+	snprintf(cvbsmode, VMODE_NAME_LEN_MAX, "%s", str);
+
+	VOUTPR("get cvbsmode: %s\n", cvbsmode);
+	return 0;
+}
+__setup("cvbsmode=", get_cvbs_mode);
+
+static int __init get_hdmi_checksum(char *str)
+{
+	snprintf(hdmichecksum, VMODE_NAME_LEN_MAX, "%s", str);
+
+	VOUTPR("get hdmi checksum: %s\n", hdmichecksum);
+	return 0;
+}
+__setup("hdmichecksum=", get_hdmi_checksum);
 
 MODULE_AUTHOR("Platform-BJ <platform.bj@amlogic.com>");
 MODULE_DESCRIPTION("VOUT Server Module");
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_sys_serve.c b/drivers/amlogic/media/vout/vout_serve/vout_sys_serve.c
deleted file mode 100644
index 2375b392dc7a..000000000000
--- a/drivers/amlogic/media/vout/vout_serve/vout_sys_serve.c
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * drivers/amlogic/media/vout/vout_serve/vout_sys_serve.c
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/amlogic/iomap.h>
-#include <linux/amlogic/media/vout/vout_notify.h>
-
-#define VSPR(fmt, args...)     pr_info("vout sys: " fmt "", ## args)
-#define VSERR(fmt, args...)    pr_err("vout sys: error: " fmt "", ## args)
-
-/* ********************************
- * mem map
- * *********************************
- */
-struct vs_reg_map_s {
-	unsigned int base_addr;
-	unsigned int size;
-	void __iomem *p;
-	char flag;
-};
-
-static struct vs_reg_map_s *vs_reg_map;
-
-static int vs_ioremap(struct platform_device *pdev)
-{
-	//int i;
-	//int *table;
-	struct resource *res;
-
-	vs_reg_map = kzalloc(sizeof(*vs_reg_map), GFP_KERNEL);
-	if (!vs_reg_map)
-		return -1;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		VSERR("%s: resource get error\n", __func__);
-		kfree(vs_reg_map);
-		vs_reg_map = NULL;
-		return -1;
-	}
-	vs_reg_map->base_addr = res->start;
-	vs_reg_map->size = resource_size(res);
-	vs_reg_map->p =
-		devm_ioremap_nocache(&pdev->dev, res->start, vs_reg_map->size);
-	if (!vs_reg_map->p) {
-		vs_reg_map->flag = 0;
-		VSERR("%s: reg map failed: 0x%x\n",
-			__func__, vs_reg_map->base_addr);
-		kfree(vs_reg_map);
-		vs_reg_map = NULL;
-		return -1;
-	}
-	vs_reg_map->flag = 1;
-	/*
-	 *VCLKPR("%s: reg mapped: 0x%x -> %px\n",
-	 *	 __func__, vs_reg_map->base_addr, vs_reg_map->p);
-	 */
-
-	return 0;
-}
-
-static inline void __iomem *check_vs_reg(void)
-{
-	if (!vs_reg_map)
-		return NULL;
-	if (vs_reg_map->flag == 0) {
-		VSERR("reg 0x%x mapped error\n", vs_reg_map->base_addr);
-		return NULL;
-	}
-
-	return vs_reg_map->p;
-}
-
-unsigned int vs_reg_read(void)
-{
-	void __iomem *p;
-	unsigned int ret = 0;
-
-	p = check_vs_reg();
-	if (p)
-		ret = readl(p);
-	else
-		ret = 0;
-
-	return ret;
-};
-
-static void vs_reg_write(unsigned int value)
-{
-	//unsigned long flags = 0;
-	void __iomem *p;
-
-	p = check_vs_reg();
-	if (p)
-		writel(value, p);
-};
-
-static void vout_sys_update_info(void)
-{
-	const struct vinfo_s *vinfo;
-	unsigned int data32;
-
-	vinfo = get_current_vinfo();
-	if (!vinfo)
-		return;
-	data32 = (vinfo->sync_duration_num << 16) |
-		vinfo->sync_duration_den;
-	vs_reg_write(data32);
-	VSPR("update date: 0x%08x\n", vs_reg_read());
-}
-
-static int vout_sys_notify_callback(struct notifier_block *block,
-				    unsigned long cmd, void *para)
-{
-	switch (cmd) {
-	case VOUT_EVENT_SYS_INIT:
-	case VOUT_EVENT_MODE_CHANGE:
-		vout_sys_update_info();
-		break;
-	default:
-		break;
-	}
-	return 0;
-}
-
-static struct notifier_block vout_sys_notifier = {
-	.notifier_call = vout_sys_notify_callback,
-};
-
-/*****************************************************************
- **
- **	vout driver interface
- **
- ******************************************************************/
-static const struct of_device_id vs_match_table[] = {
-	{
-		.compatible = "amlogic, vout_sys_serve",
-	},
-	{ }
-};
-
-static int aml_vs_probe(struct platform_device *pdev)
-{
-	vs_ioremap(pdev);
-
-	vout_register_client(&vout_sys_notifier);
-
-	VSPR("%s OK\n", __func__);
-	return 0;
-}
-
-static int aml_vs_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver aml_vs_driver = {
-	.probe     = aml_vs_probe,
-	.remove    = aml_vs_remove,
-	.driver = {
-		.name = "vout_sys",
-		.of_match_table = vs_match_table,
-	},
-};
-
-static int __init aml_vs_init_module(void)
-{
-	int ret = 0;
-
-	if (platform_driver_register(&aml_vs_driver)) {
-		VSERR("failed to register vout_sys_serve driver\n");
-		ret = -ENODEV;
-	}
-
-	return ret;
-}
-
-static __exit void aml_vs_exit_module(void)
-{
-	platform_driver_unregister(&aml_vs_driver);
-}
-
-subsys_initcall(aml_vs_init_module);
-module_exit(aml_vs_exit_module);
-
-MODULE_AUTHOR("Evoke Zhang <evoke.zhang@amlogic.com>");
-MODULE_DESCRIPTION("VOUT_SYS Server Module");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/mmc/aml_sd_emmc.c b/drivers/amlogic/mmc/aml_sd_emmc.c
index 3fa135f65320..c69c3c2bdfbe 100644
--- a/drivers/amlogic/mmc/aml_sd_emmc.c
+++ b/drivers/amlogic/mmc/aml_sd_emmc.c
@@ -42,6 +42,7 @@
 #include <linux/mmc/emmc_partitions.h>
 #include <linux/amlogic/amlsd.h>
 #include <linux/amlogic/aml_sd_emmc_v3.h>
+#include <linux/platform_data/emuelec.h>
 
 struct mmc_host *sdio_host;
 
@@ -2967,7 +2968,25 @@ static int meson_mmc_get_cd(struct mmc_host *mmc)
 
 int aml_signal_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)
 {
-	return aml_sd_voltage_switch(mmc, ios->signal_voltage);
+    if (emuelec_is_ogu) {
+        pr_info("Voltage switch: OGU logic\n");
+        struct amlsd_platform *pdata = mmc_priv(mmc);
+        int ret = 0;
+
+        if (pdata->vol_switch) {
+            ret = aml_sd_voltage_switch(mmc, ios->signal_voltage);
+            if (ret)
+                dev_warn(mmc_dev(mmc), "Voltage switch failed\n");
+        } else {
+            ret = mmc_regulator_set_vqmmc(mmc, ios);
+            if (ret)
+                dev_warn(mmc_dev(mmc), "Regulator switch failed\n");
+        }
+        return ret;
+    } else {
+        pr_info("Voltage switch: Generic logic\n");
+        return aml_sd_voltage_switch(mmc, ios->signal_voltage);
+    }
 }
 
 /* Check if the card is pulling dat[0:3] low */
@@ -3333,7 +3352,10 @@ static int meson_mmc_probe(struct platform_device *pdev)
 			writel(boot_poll_en, host->pinmux_base
 					+ (host->data->ds_pin_poll_en << 2));
 		}
-
+        if (emuelec_is_ogu) {
+            pr_info("MMC probe: OGU logic, try to get supply from regulator\n");
+            ret = mmc_regulator_get_supply(mmc);
+        }
 		if (aml_card_type_mmc(pdata)
 				&& (host->ctrl_ver < 3))
 			/**set emmc tx_phase regs here base on dts**/
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
index e0c09f3cb88c..a772a714df23 100644
--- a/drivers/base/dma-contiguous.c
+++ b/drivers/base/dma-contiguous.c
@@ -35,6 +35,7 @@
 #endif
 
 struct cma *dma_contiguous_default_area;
+EXPORT_SYMBOL_GPL(dma_contiguous_default_area);
 
 /*
  * Default global CMA area size can be defined in kernel's .config.
diff --git a/drivers/clk/clk-rk808.c b/drivers/clk/clk-rk808.c
index 6461f2820a5b..73c508eddcd1 100644
--- a/drivers/clk/clk-rk808.c
+++ b/drivers/clk/clk-rk808.c
@@ -22,8 +22,11 @@
 #include <linux/mfd/rk808.h>
 #include <linux/i2c.h>
 
+#define RK808_NR_OUTPUT 2
+
 struct rk808_clkout {
 	struct rk808 *rk808;
+	struct clk_onecell_data clk_data;
 	struct clk_hw		clkout1_hw;
 	struct clk_hw		clkout2_hw;
 };
@@ -82,18 +85,65 @@ static const struct clk_ops rk808_clkout2_ops = {
 	.recalc_rate = rk808_clkout_recalc_rate,
 };
 
-static struct clk_hw *
-of_clk_rk808_get(struct of_phandle_args *clkspec, void *data)
+static int rk817_clkout2_enable(struct clk_hw *hw, bool enable)
+{
+	struct rk808_clkout *rk808_clkout = container_of(hw,
+							 struct rk808_clkout,
+							 clkout2_hw);
+	struct rk808 *rk808 = rk808_clkout->rk808;
+
+	return regmap_update_bits(rk808->regmap, RK817_SYS_CFG(1),
+				  RK817_CLK32KOUT2_EN,
+				  enable ? RK817_CLK32KOUT2_EN : 0);
+}
+
+static int rk817_clkout2_prepare(struct clk_hw *hw)
 {
-	struct rk808_clkout *rk808_clkout = data;
-	unsigned int idx = clkspec->args[0];
+	return rk817_clkout2_enable(hw, true);
+}
+
+static void rk817_clkout2_unprepare(struct clk_hw *hw)
+{
+	rk817_clkout2_enable(hw, false);
+}
+
+static int rk817_clkout2_is_prepared(struct clk_hw *hw)
+{
+	struct rk808_clkout *rk808_clkout = container_of(hw,
+							 struct rk808_clkout,
+							 clkout2_hw);
+	struct rk808 *rk808 = rk808_clkout->rk808;
+	unsigned int val;
+
+	int ret = regmap_read(rk808->regmap, RK817_SYS_CFG(1), &val);
 
-	if (idx >= 2) {
-		pr_err("%s: invalid index %u\n", __func__, idx);
-		return ERR_PTR(-EINVAL);
+	if (ret < 0)
+		return ret;
+
+	return (val & RK817_CLK32KOUT2_EN) ? 1 : 0;
+}
+
+static const struct clk_ops rk817_clkout2_ops = {
+	.prepare = rk817_clkout2_prepare,
+	.unprepare = rk817_clkout2_unprepare,
+	.is_prepared = rk817_clkout2_is_prepared,
+	.recalc_rate = rk808_clkout_recalc_rate,
+};
+
+static const struct clk_ops *rkpmic_get_ops(long variant)
+{
+	switch (variant) {
+	case RK809_ID:
+	case RK817_ID:
+		return &rk817_clkout2_ops;
+	case RK805_ID:
+	case RK808_ID:
+	case RK816_ID:
+	case RK818_ID:
+		return &rk808_clkout2_ops;
 	}
 
-	return idx ? &rk808_clkout->clkout2_hw : &rk808_clkout->clkout1_hw;
+	return &rk808_clkout2_ops;
 }
 
 static int rk808_clkout_probe(struct platform_device *pdev)
@@ -102,8 +152,8 @@ static int rk808_clkout_probe(struct platform_device *pdev)
 	struct i2c_client *client = rk808->i2c;
 	struct device_node *node = client->dev.of_node;
 	struct clk_init_data init = {};
+	struct clk **clk_table;
 	struct rk808_clkout *rk808_clkout;
-	int ret;
 
 	rk808_clkout = devm_kzalloc(&client->dev,
 				    sizeof(*rk808_clkout), GFP_KERNEL);
@@ -112,6 +162,12 @@ static int rk808_clkout_probe(struct platform_device *pdev)
 
 	rk808_clkout->rk808 = rk808;
 
+	clk_table = devm_kcalloc(&client->dev, RK808_NR_OUTPUT,
+				 sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_table)
+		return -ENOMEM;
+
+	init.flags = CLK_IS_ROOT;
 	init.parent_names = NULL;
 	init.num_parents = 0;
 	init.name = "rk808-clkout1";
@@ -122,23 +178,29 @@ static int rk808_clkout_probe(struct platform_device *pdev)
 	of_property_read_string_index(node, "clock-output-names",
 				      0, &init.name);
 
-	ret = devm_clk_hw_register(&client->dev, &rk808_clkout->clkout1_hw);
-	if (ret)
-		return ret;
+	clk_table[0] = devm_clk_register(&client->dev,
+					 &rk808_clkout->clkout1_hw);
+	if (IS_ERR(clk_table[0]))
+		return PTR_ERR(clk_table[0]);
 
 	init.name = "rk808-clkout2";
-	init.ops = &rk808_clkout2_ops;
+	init.ops = rkpmic_get_ops(rk808->variant);
 	rk808_clkout->clkout2_hw.init = &init;
 
 	/* optional override of the clockname */
 	of_property_read_string_index(node, "clock-output-names",
 				      1, &init.name);
 
-	ret = devm_clk_hw_register(&client->dev, &rk808_clkout->clkout2_hw);
-	if (ret)
-		return ret;
+	clk_table[1] = devm_clk_register(&client->dev,
+					 &rk808_clkout->clkout2_hw);
+	if (IS_ERR(clk_table[1]))
+		return PTR_ERR(clk_table[1]);
+
+	rk808_clkout->clk_data.clks = clk_table;
+	rk808_clkout->clk_data.clk_num = RK808_NR_OUTPUT;
 
-	return of_clk_add_hw_provider(node, of_clk_rk808_get, rk808_clkout);
+	return of_clk_add_provider(node, of_clk_src_onecell_get,
+				   &rk808_clkout->clk_data);
 }
 
 static int rk808_clkout_remove(struct platform_device *pdev)
diff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
index 4215b5382092..9cde5cb6744e 100644
--- a/drivers/input/joystick/Kconfig
+++ b/drivers/input/joystick/Kconfig
@@ -330,4 +330,10 @@ config JOYSTICK_MAPLE
 	  To compile this as a module choose M here: the module will be called
 	  maplecontrol.
 
+config JOYSTICK_ODROID_GOU
+	tristate "ODROID-Go-Ultra joypad driver"
+	# depends on ARCH_MESON64_ODROID_COMMON
+	help
+	  Made for ODROID-GO-Ultra.
+
 endif
diff --git a/drivers/input/joystick/Makefile b/drivers/input/joystick/Makefile
index 92dc0de9dfed..9a1130db591b 100644
--- a/drivers/input/joystick/Makefile
+++ b/drivers/input/joystick/Makefile
@@ -32,4 +32,5 @@ obj-$(CONFIG_JOYSTICK_WARRIOR)		+= warrior.o
 obj-$(CONFIG_JOYSTICK_XPAD)		+= xpad.o
 obj-$(CONFIG_JOYSTICK_ZHENHUA)		+= zhenhua.o
 obj-$(CONFIG_JOYSTICK_WALKERA0701)	+= walkera0701.o
+obj-$(CONFIG_JOYSTICK_ODROID_GOU)	+= odroid-gou-joypad.o
 
diff --git a/drivers/input/joystick/odroid-gou-joypad.c b/drivers/input/joystick/odroid-gou-joypad.c
new file mode 100755
index 000000000000..0124a1074847
--- /dev/null
+++ b/drivers/input/joystick/odroid-gou-joypad.c
@@ -0,0 +1,949 @@
+/*
+ * SARADC joystick & GPIO Button driver for Linux(Hardkernel ODROIDGO-Seriese)
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <dt-bindings/iio/adc/amlogic-saradc.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "odroidgo_joypad"
+
+/*----------------------------------------------------------------------------*/
+#define	ADC_MAX_VOLTAGE		1800
+#define	ADC_DATA_TUNING(x, p)	((x * p) / 100)
+#define	ADC_TUNING_DEFAULT	180
+
+/*----------------------------------------------------------------------------*/
+/*
+	+--------------+--------+---------+
+	|  iio_channel | SELECT |  EVENT  |
+	+--------------+--------+---------+
+	|    ADC_AIN0  |  R-Y   | ABS_RY  |
+	+--------------+--------+---------+
+	|    ADC_AIN1  |  R-X   | ABS_RX  |
+	+--------------+--------+---------+
+	|    ADC_AIN2  |  L-Y   |  ABS_Y  |
+	+--------------+--------+---------+
+	|    ADC_AIN3  |  L-X   |  ABS_X  |
+	+--------------+--------+---------+
+*/
+/*----------------------------------------------------------------------------*/
+struct bt_adc {
+	/* report value (mV) */
+	int value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+	/* adc channel */
+	int channel;
+	/* adc data tuning value([percent), p = positive, n = negative */
+	int tuning_p, tuning_n;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	struct input_polled_dev	*poll_dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* analog mux & joystick control */
+	struct iio_channel *adc_ch[SARADC_CH_NUM];
+
+	/* adc input channel count */
+	int chan_count;
+	/* analog button */
+	struct bt_adc *adcs;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+
+	struct mutex lock;
+
+	/* adc debug channel */
+	int debug_ch;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int button_adc_fuzz(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct joypad *joypad, struct bt_adc *adc)
+{
+	int value;
+
+	if (iio_read_channel_processed(joypad->adc_ch[adc->channel], &value) < 0)
+		return 0;
+
+	value *= adc->scale;
+
+	return (adc->invert ? (adc->max - value) : value);
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->value = joypad_adc_read(joypad, adc);
+			if (!adc->value) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->cal = adc->value;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d\n",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "adc scale = %d\n", joypad->bt_adc_scale);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	NULL,
+};
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		if (value != gpio->old_value) {
+			input_event(poll_dev->input,
+				gpio->report_type,
+				gpio->linux_code,
+				(value == gpio->active_level) ? 1 : 0);
+			gpio->old_value = value;
+		}
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->value = adc->value - adc->cal;
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if (abs(adc->value) < joypad->bt_adc_deadzone)
+				adc->value = 0;
+		}
+
+		/* adc data tuning */
+		if (adc->tuning_n && adc->value < 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_n);
+		if (adc->tuning_p && adc->value > 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_p);
+
+		adc->value = adc->value > adc->max ? adc->max : adc->value;
+		adc->value = adc->value < adc->min ? adc->min : adc->value;
+
+		input_report_abs(poll_dev->input,
+			adc->report_type,
+			adc->invert ? adc->value * (-1) : adc->value);
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_iochannel_setup(struct device *dev, struct joypad *joypad)
+{
+	enum iio_chan_type type;
+	unsigned char cnt;
+	const char *uname;
+	int ret;
+
+	for (cnt = 0; cnt < joypad->chan_count; cnt++) {
+
+		ret = of_property_read_string_index(dev->of_node,
+				"io-channel-names", cnt, &uname);
+		if (ret < 0) {
+			dev_err(dev, "invalid channel name index[%d]\n", cnt);
+			return -EINVAL;
+		}
+
+		joypad->adc_ch[cnt] = devm_iio_channel_get(dev,
+				uname);
+		if (IS_ERR(joypad->adc_ch[cnt])) {
+			dev_err(dev, "iio channel get error\n");
+			return -EINVAL;
+		}
+		if (!joypad->adc_ch[cnt]->indio_dev)
+			return -ENXIO;
+	
+		if (iio_get_channel_type(joypad->adc_ch[cnt], &type))
+			return -EINVAL;
+	
+		if (type != IIO_VOLTAGE) {
+			dev_err(dev, "Incompatible channel type %d\n", type);
+			return -EINVAL;
+		}
+	}
+	return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn;
+
+	/* adc button struct init */
+	joypad->adcs = devm_kzalloc(dev, joypad->chan_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->scale = joypad->bt_adc_scale;
+		
+		adc->max = (ADC_MAX_VOLTAGE / 2);
+		adc->min = (ADC_MAX_VOLTAGE / 2) * (-1);
+		if (adc->scale) {
+			adc->max *= adc->scale;
+			adc->min *= adc->scale;
+		}
+		adc->channel = nbtn;
+		adc->invert = false;
+
+		switch (nbtn) {
+			case 0:
+				adc->report_type = ABS_RY;
+				if (device_property_read_u32(dev,
+					"abs_ry-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_ry-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 1:
+				adc->report_type = ABS_RX;
+				if (device_property_read_u32(dev,
+					"abs_rx-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_rx-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 2:
+				adc->report_type = ABS_Y;
+				if (device_property_read_u32(dev,
+					"abs_y-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_y-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 3:
+				adc->report_type = ABS_X;
+				if (device_property_read_u32(dev,
+					"abs_x-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_x-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			default :
+				dev_err(dev, "%s io channel count(%d) error!",
+					__func__, nbtn);
+				return -EINVAL;
+		}
+	}
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+			error = gpiod_set_pull(gpio_to_desc(gpio->num),
+				GPIOD_PULL_UP);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to set pull-up GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+	u32 joypad_revision = 0;
+	u32 joypad_product = 0;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+
+	input->name = DRV_NAME;
+	input->phys = DRV_NAME"/input0";
+
+	device_property_read_u32(dev, "joypad-revision", &joypad_revision);
+	device_property_read_u32(dev, "joypad-product", &joypad_product);
+	input->id.bustype = BUS_HOST;
+	input->id.vendor  = 0x484B;
+	input->id.product = (u16)joypad_product;
+	input->id.version = (u16)joypad_revision;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+	for(nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+		dev_info(dev,
+			"%s : adc tuning_p = %d, adc_tuning_n = %d\n\n",
+			__func__, adc->tuning_p, adc->tuning_n);
+	}
+
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	joypad->dev = dev;
+	joypad->poll_dev = poll_dev;
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	joypad->chan_count = of_property_count_strings(dev->of_node,
+		"io-channel-names");
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->chan_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->chan_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_iochannel_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	dev_info(dev, "%s : adc key cnt = %d, gpio key cnt = %d\n",
+			__func__, joypad->chan_count, joypad->bt_gpio_count);
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+static void joypad_shutdown(struct platform_device *pdev)
+{
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	input_unregister_polled_device(joypad->poll_dev);
+}
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "odroidgou-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.shutdown = joypad_shutdown,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
+
+/*----------------------------------------------------------------------------*/
+MODULE_AUTHOR("Hardkernel Co.,LTD");
+MODULE_DESCRIPTION("Keypad driver(ADC&GPIO) for ODROIDGO-Advance");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+/*----------------------------------------------------------------------------*/
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index ea1b5e441a96..d6d2e5f28825 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -464,6 +464,12 @@ config INPUT_RETU_PWRBUTTON
 	  To compile this driver as a module, choose M here. The module will
 	  be called retu-pwrbutton.
 
+config INPUT_RK8XX_PWRKEY
+	tristate "Rockchip RK8XX pwrkey driver"
+	depends on MFD_RK808
+	help
+	  Select this option to enable the pwrkey module of Rockchip RK8XX PMIC.
+
 config INPUT_TPS65218_PWRBUTTON
 	tristate "TPS65218 Power button driver"
 	depends on (MFD_TPS65217 || MFD_TPS65218)
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 13bf7dbba627..8734359ee5c7 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -63,6 +63,7 @@ obj-$(CONFIG_INPUT_PWM_BEEPER)		+= pwm-beeper.o
 obj-$(CONFIG_INPUT_RB532_BUTTON)	+= rb532_button.o
 obj-$(CONFIG_INPUT_REGULATOR_HAPTIC)	+= regulator-haptic.o
 obj-$(CONFIG_INPUT_RETU_PWRBUTTON)	+= retu-pwrbutton.o
+obj-$(CONFIG_INPUT_RK8XX_PWRKEY)	+= rk8xx-pwrkey.o
 obj-$(CONFIG_INPUT_AXP20X_PEK)		+= axp20x-pek.o
 obj-$(CONFIG_INPUT_GPIO_ROTARY_ENCODER)	+= rotary_encoder.o
 obj-$(CONFIG_INPUT_SGI_BTNS)		+= sgi_btns.o
diff --git a/drivers/input/misc/rk8xx-pwrkey.c b/drivers/input/misc/rk8xx-pwrkey.c
new file mode 100755
index 000000000000..1fbd95f8894b
--- /dev/null
+++ b/drivers/input/misc/rk8xx-pwrkey.c
@@ -0,0 +1,173 @@
+/*
+ * driver/input/misc/rk8xx-pwrkey.c
+ * Power Key driver for RK8xx PMIC Power Button.
+ *
+ * Copyright (C) 2017, Rockchip Technology Co., Ltd.
+ * Author: Chen Jianhong <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/errno.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+struct rk8xx_pwrkey {
+	struct rk808 *rk8xx;
+	struct input_dev *input_dev;
+	int report_key;
+};
+
+static struct input_dev *sinput_dev;
+
+void rk_send_power_key(int state)
+{
+	if (!sinput_dev)
+		return;
+	if (state) {
+		input_report_key(sinput_dev, KEY_POWER, 1);
+		input_sync(sinput_dev);
+	} else {
+		input_report_key(sinput_dev, KEY_POWER, 0);
+		input_sync(sinput_dev);
+	}
+}
+EXPORT_SYMBOL(rk_send_power_key);
+
+void rk_send_wakeup_key(void)
+{
+	if (!sinput_dev)
+		return;
+
+	input_report_key(sinput_dev, KEY_WAKEUP, 1);
+	input_sync(sinput_dev);
+	input_report_key(sinput_dev, KEY_WAKEUP, 0);
+	input_sync(sinput_dev);
+}
+EXPORT_SYMBOL(rk_send_wakeup_key);
+
+static irqreturn_t rk8xx_pwrkey_irq_falling(int irq, void *data)
+{
+	struct rk8xx_pwrkey *pwr = data;
+
+	input_report_key(pwr->input_dev, pwr->report_key, 1);
+	input_sync(pwr->input_dev);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rk8xx_pwrkey_irq_rising(int irq, void *data)
+{
+	struct rk8xx_pwrkey *pwr = data;
+
+	input_report_key(pwr->input_dev, pwr->report_key, 0);
+	input_sync(pwr->input_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int rk8xx_pwrkey_probe(struct platform_device *pdev)
+{
+	struct rk808 *rk8xx = dev_get_drvdata(pdev->dev.parent);
+	struct rk8xx_pwrkey *pwrkey;
+	int fall_irq, rise_irq, err;
+	struct device_node *np;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "pwrkey");
+	if (np) {
+		if (!of_device_is_available(np)) {
+			dev_info(&pdev->dev, "device is disabled\n");
+			return -EINVAL;
+		}
+	}
+
+	pwrkey = devm_kzalloc(&pdev->dev,
+			      sizeof(struct rk8xx_pwrkey), GFP_KERNEL);
+	if (!pwrkey)
+		return -ENOMEM;
+
+	pwrkey->input_dev = devm_input_allocate_device(&pdev->dev);
+	if (!pwrkey->input_dev) {
+		dev_err(&pdev->dev, "Can't allocate power button\n");
+		return -ENOMEM;
+	}
+
+	/* init struct input_dev */
+	pwrkey->rk8xx = rk8xx;
+	pwrkey->report_key = KEY_POWER;
+	pwrkey->input_dev->name = "rk8xx_pwrkey";
+	pwrkey->input_dev->phys = "rk8xx_pwrkey/input0";
+	pwrkey->input_dev->dev.parent = pdev->dev.parent;
+	pwrkey->input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	pwrkey->input_dev->keybit[BIT_WORD(pwrkey->report_key)] =
+					BIT_MASK(pwrkey->report_key);
+	platform_set_drvdata(pdev, pwrkey);
+
+	/* requeset rise and fall irqs */
+	rise_irq = platform_get_irq(pdev, 0);
+	if (rise_irq < 0) {
+		dev_err(&pdev->dev, "no IRQ for rise: %d\n", rise_irq);
+		return rise_irq;
+	}
+
+	fall_irq = platform_get_irq(pdev, 1);
+	if (fall_irq < 0) {
+		dev_err(&pdev->dev, "no IRQ for fall: %d\n", fall_irq);
+		return fall_irq;
+	}
+
+	err = devm_request_threaded_irq(&pdev->dev, fall_irq,
+					NULL, rk8xx_pwrkey_irq_falling,
+					IRQF_TRIGGER_FALLING,
+					"rk8xx_pwrkey_fall", pwrkey);
+	if (err) {
+		dev_err(&pdev->dev, "Can't get fall irq for pwrkey: %d\n", err);
+		return err;
+	}
+	err = devm_request_threaded_irq(&pdev->dev, rise_irq,
+					NULL, rk8xx_pwrkey_irq_rising,
+					IRQF_TRIGGER_RISING,
+					"rk8xx_pwrkey_rise", pwrkey);
+	if (err) {
+		dev_err(&pdev->dev, "Can't get rise irq for pwrkey: %d\n", err);
+		return err;
+	}
+
+	/* register input device */
+	err = input_register_device(pwrkey->input_dev);
+	if (err) {
+		dev_err(&pdev->dev, "Can't register power button: %d\n", err);
+		return err;
+	}
+	sinput_dev = pwrkey->input_dev;
+
+	return 0;
+}
+
+static struct platform_driver rk8xx_pwrkey_driver = {
+	.probe = rk8xx_pwrkey_probe,
+	.driver		= {
+		.name	= "rk8xx-pwrkey",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(rk8xx_pwrkey_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("RK8xx Power Button");
+MODULE_AUTHOR("Chen Jianhong <chenjh@rock-chips.com>");
diff --git a/drivers/mfd/rk808.c b/drivers/mfd/rk808.c
index 0f8acc5882a4..71bdc26a2c84 100644
--- a/drivers/mfd/rk808.c
+++ b/drivers/mfd/rk808.c
@@ -1,15 +1,11 @@
 /*
- * MFD core driver for Rockchip RK808/RK818
+ * MFD core driver for Rockchip RK808
  *
- * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
+ * Copyright (c) 2014-2018, Fuzhou Rockchip Electronics Co., Ltd
  *
  * Author: Chris Zhong <zyw@rock-chips.com>
  * Author: Zhang Qing <zhangqing@rock-chips.com>
  *
- * Copyright (C) 2016 PHYTEC Messtechnik GmbH
- *
- * Author: Wadim Egorov <w.egorov@phytec.de>
- *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
@@ -20,13 +16,25 @@
  * more details.
  */
 
+#include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
+#include <linux/kernel.h>
 #include <linux/mfd/rk808.h>
 #include <linux/mfd/core.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/reboot.h>
 #include <linux/regmap.h>
+#include <linux/syscore_ops.h>
+
+#define CONFIG_ARCH_MESON64_ODROID_COMMON
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/arm-smccc.h>
+#endif
 
 struct rk808_reg_data {
 	int addr;
@@ -62,22 +70,238 @@ static bool rk808_is_volatile_reg(struct device *dev, unsigned int reg)
 	return false;
 }
 
-static const struct regmap_config rk818_regmap_config = {
+static bool rk817_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	/*
+	 * Notes:
+	 * - Technically the ROUND_30s bit makes RTC_CTRL_REG volatile, but
+	 *   we don't use that feature.  It's better to cache.
+	 * - It's unlikely we care that RK808_DEVCTRL_REG is volatile since
+	 *   bits are cleared in case when we shutoff anyway, but better safe.
+	 */
+
+	switch (reg) {
+	case RK817_SECONDS_REG ... RK817_WEEKS_REG:
+	case RK817_RTC_STATUS_REG:
+	case RK817_INT_STS_REG0:
+	case RK817_INT_STS_REG1:
+	case RK817_INT_STS_REG2:
+	case RK817_SYS_STS:
+		return true;
+	}
+
+	return true;
+}
+
+static int (*pm_shutdown)(struct regmap *regmap);
+static int (*pm_shutdown_prepare)(struct rk808 *rk808);
+static struct i2c_client *rk808_i2c_client;
+static struct rk808_reg_data *suspend_reg, *resume_reg;
+static int suspend_reg_num, resume_reg_num;
+
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+static noinline int psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
+                                        u64 arg2)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc((unsigned long)function_id,
+			(unsigned long)arg0,
+			(unsigned long)arg1,
+			(unsigned long)arg2,
+			0, 0, 0, 0, &res);
+	return res.a0;
+}
+
+static void do_aml_poweroff(void)
+{
+       /* TODO: Add poweroff capability */
+	psci_fn_smc(0x82000042, 1, 0, 0);
+	psci_fn_smc(0x84000008, 0, 0, 0);
+}
+
+#endif
+
+
+static int rk808_shutdown(struct regmap *regmap)
+{
+	int ret;
+
+	ret = regmap_update_bits(regmap,
+				 RK808_DEVCTRL_REG,
+				 DEV_OFF_RST, DEV_OFF_RST);
+	return ret;
+}
+
+static int rk816_shutdown(struct regmap *regmap)
+{
+	int ret;
+
+	ret = regmap_update_bits(regmap,
+				 RK816_DEV_CTRL_REG,
+				 DEV_OFF, DEV_OFF);
+	return ret;
+}
+
+static int rk818_shutdown(struct regmap *regmap)
+{
+	int ret;
+
+	if (system_state == SYSTEM_POWER_OFF) {
+		ret = regmap_update_bits(regmap,
+					 RK818_DEVCTRL_REG,
+					 DEV_OFF, DEV_OFF);
+	}
+	else {
+		do_aml_poweroff();
+		ret = regmap_update_bits(regmap,
+					 RK818_DEVCTRL_REG,
+					 DEV_OFF_RST, DEV_OFF_RST);
+	}
+	return ret;
+}
+
+static int rk805_shutdown_prepare(struct rk808 *rk808)
+{
+	int ret;
+
+	/* close rtc int when power off */
+	regmap_update_bits(rk808->regmap,
+			   RK808_INT_STS_MSK_REG1,
+			   (0x3 << 5), (0x3 << 5));
+	regmap_update_bits(rk808->regmap,
+			   RK808_RTC_INT_REG,
+			   (0x3 << 2), (0x0 << 2));
+
+	/* pmic sleep shutdown function */
+	ret = regmap_update_bits(rk808->regmap,
+				 RK805_GPIO_IO_POL_REG,
+				 SLP_SD_MSK, SHUTDOWN_FUN);
+	return ret;
+}
+
+static int rk817_shutdown_prepare(struct rk808 *rk808)
+{
+	int ret;
+
+	/* close rtc int when power off */
+	regmap_update_bits(rk808->regmap,
+			   RK817_INT_STS_MSK_REG1,
+			   (0x3 << 5), (0x3 << 5));
+	regmap_update_bits(rk808->regmap,
+			   RK817_RTC_INT_REG,
+			   (0x3 << 2), (0x0 << 2));
+
+	if (rk808->pins && rk808->pins->p && rk808->pins->power_off) {
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPIN_FUNC_MSK,
+					 SLPPIN_NULL_FUN);
+		if (ret) {
+			pr_err("shutdown: config SLPPIN_NULL_FUN error!\n");
+			return 0;
+		}
+
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPOL_MSK,
+					 RK817_SLPPOL_H);
+		if (ret) {
+			pr_err("shutdown: config RK817_SLPPOL_H error!\n");
+			return 0;
+		}
+		ret = pinctrl_select_state(rk808->pins->p,
+					   rk808->pins->power_off);
+		if (ret)
+			pr_info("%s:failed to activate pwroff state\n",
+				__func__);
+		else
+			return ret;
+	}
+
+	/* pmic sleep shutdown function */
+	ret = regmap_update_bits(rk808->regmap,
+				 RK817_SYS_CFG(3),
+				 RK817_SLPPIN_FUNC_MSK, SLPPIN_DN_FUN);
+	return ret;
+}
+
+static bool rk818_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	/*
+	 * Notes:
+	 * - Technically the ROUND_30s bit makes RTC_CTRL_REG volatile, but
+	 *   we don't use that feature.  It's better to cache.
+	 * - It's unlikely we care that RK808_DEVCTRL_REG is volatile since
+	 *   bits are cleared in case when we shutoff anyway, but better safe.
+	 */
+
+	switch (reg) {
+	case RK808_SECONDS_REG ... RK808_WEEKS_REG:
+	case RK808_RTC_STATUS_REG:
+	case RK808_VB_MON_REG:
+	case RK808_THERMAL_REG:
+	case RK808_DCDC_EN_REG:
+	case RK808_LDO_EN_REG:
+	case RK808_DCDC_UV_STS_REG:
+	case RK808_LDO_UV_STS_REG:
+	case RK808_DCDC_PG_REG:
+	case RK808_LDO_PG_REG:
+	case RK808_DEVCTRL_REG:
+	case RK808_INT_STS_REG1:
+	case RK808_INT_STS_REG2:
+	case RK808_INT_STS_MSK_REG1:
+	case RK808_INT_STS_MSK_REG2:
+	case RK816_INT_STS_REG1:
+	case RK816_INT_STS_MSK_REG1:
+	case RK818_SUP_STS_REG ... RK818_SAVE_DATA19:
+		return true;
+	}
+
+	return false;
+}
+
+static const struct regmap_config rk808_regmap_config = {
 	.reg_bits = 8,
 	.val_bits = 8,
-	.max_register = RK818_USB_CTRL_REG,
+	.max_register = RK808_IO_POL_REG,
 	.cache_type = REGCACHE_RBTREE,
 	.volatile_reg = rk808_is_volatile_reg,
 };
 
-static const struct regmap_config rk808_regmap_config = {
+static const struct regmap_config rk805_regmap_config = {
 	.reg_bits = 8,
 	.val_bits = 8,
-	.max_register = RK808_IO_POL_REG,
+	.max_register = RK805_OFF_SOURCE_REG,
 	.cache_type = REGCACHE_RBTREE,
 	.volatile_reg = rk808_is_volatile_reg,
 };
 
+static const struct regmap_config rk816_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RK816_DATA18_REG,
+	.cache_type = REGCACHE_RBTREE,
+	.volatile_reg = rk818_is_volatile_reg,
+};
+
+static const struct regmap_config rk818_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RK818_SAVE_DATA19,
+	.cache_type = REGCACHE_RBTREE,
+	.volatile_reg = rk818_is_volatile_reg,
+};
+
+static const struct regmap_config rk817_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RK817_GPIO_INT_CFG,
+	.cache_type = REGCACHE_NONE,
+	.volatile_reg = rk817_is_volatile_reg,
+};
+
 static struct resource rtc_resources[] = {
 	{
 		.start  = RK808_IRQ_RTC_ALARM,
@@ -86,23 +310,61 @@ static struct resource rtc_resources[] = {
 	}
 };
 
-static const struct mfd_cell rk808s[] = {
-	{ .name = "rk808-clkout", },
-	{ .name = "rk808-regulator", },
+static struct resource rk816_rtc_resources[] = {
 	{
-		.name = "rk808-rtc",
-		.num_resources = ARRAY_SIZE(rtc_resources),
-		.resources = rtc_resources,
+		.start  = RK816_IRQ_RTC_ALARM,
+		.end    = RK816_IRQ_RTC_ALARM,
+		.flags  = IORESOURCE_IRQ,
+	}
+};
+
+static struct resource rk805_pwrkey_resources[] = {
+	{
+		.start  = RK805_IRQ_PWRON_RISE,
+		.end    = RK805_IRQ_PWRON_RISE,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = RK805_IRQ_PWRON_FALL,
+		.end    = RK805_IRQ_PWRON_FALL,
+		.flags  = IORESOURCE_IRQ,
 	},
 };
 
-static const struct mfd_cell rk818s[] = {
+
+static struct resource rk817_pwrkey_resources[] = {
+	{
+		.start  = RK817_IRQ_PWRON_RISE,
+		.end    = RK817_IRQ_PWRON_RISE,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = RK817_IRQ_PWRON_FALL,
+		.end    = RK817_IRQ_PWRON_FALL,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource rk816_pwrkey_resources[] = {
+	{
+		.start  = RK816_IRQ_PWRON_RISE,
+		.end    = RK816_IRQ_PWRON_RISE,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = RK816_IRQ_PWRON_FALL,
+		.end    = RK816_IRQ_PWRON_FALL,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static const struct mfd_cell rk808s[] = {
 	{ .name = "rk808-clkout", },
 	{ .name = "rk808-regulator", },
 	{
 		.name = "rk808-rtc",
 		.num_resources = ARRAY_SIZE(rtc_resources),
-		.resources = rtc_resources,
+		.resources = &rtc_resources[0],
 	},
 };
 
@@ -113,28 +375,11 @@ static const struct rk808_reg_data rk808_pre_init_reg[] = {
 	{ RK808_BUCK1_CONFIG_REG, BUCK1_RATE_MASK,  BUCK_ILMIN_200MA },
 	{ RK808_BUCK2_CONFIG_REG, BUCK2_RATE_MASK,  BUCK_ILMIN_200MA },
 	{ RK808_DCDC_UV_ACT_REG,  BUCK_UV_ACT_MASK, BUCK_UV_ACT_DISABLE},
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
 	{ RK808_VB_MON_REG,       MASK_ALL,         VB_LO_ACT |
 						    VB_LO_SEL_3500MV },
 };
 
-static const struct rk808_reg_data rk818_pre_init_reg[] = {
-	/* improve efficiency */
-	{ RK818_BUCK2_CONFIG_REG, BUCK2_RATE_MASK,  BUCK_ILMIN_250MA },
-	{ RK818_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK,  BUCK_ILMIN_250MA },
-	{ RK818_BOOST_CONFIG_REG, BOOST_ILMIN_MASK, BOOST_ILMIN_100MA },
-	{ RK818_USB_CTRL_REG,	  RK818_USB_ILIM_SEL_MASK,
-						    RK818_USB_ILMIN_2000MA },
-	/* close charger when usb lower then 3.4V */
-	{ RK818_USB_CTRL_REG,	  RK818_USB_CHG_SD_VSEL_MASK,
-						    (0x7 << 4) },
-	/* no action when vref */
-	{ RK818_H5V_EN_REG,	  BIT(1),	    RK818_REF_RDY_CTRL },
-	/* enable HDMI 5V */
-	{ RK818_H5V_EN_REG,	  BIT(0),	    RK818_H5V_EN },
-	{ RK808_VB_MON_REG,	  MASK_ALL,	    VB_LO_ACT |
-						    VB_LO_SEL_3500MV },
-};
-
 static const struct regmap_irq rk808_irqs[] = {
 	/* INT_STS */
 	[RK808_IRQ_VOUT_LO] = {
@@ -177,86 +422,337 @@ static const struct regmap_irq rk808_irqs[] = {
 	},
 };
 
-static const struct regmap_irq rk818_irqs[] = {
+static struct regmap_irq_chip rk808_irq_chip = {
+	.name = "rk808",
+	.irqs = rk808_irqs,
+	.num_irqs = ARRAY_SIZE(rk808_irqs),
+	.num_regs = 2,
+	.irq_reg_stride = 2,
+	.status_base = RK808_INT_STS_REG1,
+	.mask_base = RK808_INT_STS_MSK_REG1,
+	.ack_base = RK808_INT_STS_REG1,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk816s[] = {
+	{ .name = "rk808-clkout", },
+	{ .name = "rk808-regulator", },
+	{ .name = "rk8xx-gpio", },
+	{ .name = "rk816-battery", .of_compatible = "rk816-battery", },
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk816_pwrkey_resources),
+		.resources = &rk816_pwrkey_resources[0],
+	},
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rk816_rtc_resources),
+		.resources = &rk816_rtc_resources[0],
+	},
+};
+
+static const struct rk808_reg_data rk816_pre_init_reg[] = {
+	/* buck4 Max ILMIT*/
+	{ RK816_BUCK4_CONFIG_REG, REG_WRITE_MSK, BUCK4_MAX_ILIMIT },
+	/* hotdie temperature: 105c*/
+	{ RK816_THERMAL_REG, REG_WRITE_MSK, TEMP105C },
+	/* set buck 12.5mv/us */
+	{ RK816_BUCK1_CONFIG_REG, BUCK_RATE_MSK, BUCK_RATE_12_5MV_US },
+	{ RK816_BUCK2_CONFIG_REG, BUCK_RATE_MSK, BUCK_RATE_12_5MV_US },
+	/* enable RTC_PERIOD & RTC_ALARM int */
+	{ RK816_INT_STS_MSK_REG2, REG_WRITE_MSK, RTC_PERIOD_ALARM_INT_EN },
+	/* set bat 3.0 low and act shutdown */
+	{ RK816_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK816_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN },
+	/* enable PWRON rising/faling int */
+	{ RK816_INT_STS_MSK_REG1, REG_WRITE_MSK, RK816_PWRON_FALL_RISE_INT_EN },
+	/* enable PLUG IN/OUT int */
+	{ RK816_INT_STS_MSK_REG3, REG_WRITE_MSK, PLUGIN_OUT_INT_EN },
+	/* clear int flags */
+	{ RK816_INT_STS_REG1, REG_WRITE_MSK, ALL_INT_FLAGS_ST },
+	{ RK816_INT_STS_REG2, REG_WRITE_MSK, ALL_INT_FLAGS_ST },
+	{ RK816_INT_STS_REG3, REG_WRITE_MSK, ALL_INT_FLAGS_ST },
+	{ RK816_DCDC_EN_REG2, BOOST_EN_MASK, BOOST_DISABLE },
+	/* set write mask bit 1, otherwise 'is_enabled()' get wrong status */
+	{ RK816_LDO_EN_REG1, REGS_WMSK, REGS_WMSK },
+	{ RK816_LDO_EN_REG2, REGS_WMSK, REGS_WMSK },
+};
+
+static struct rk808_reg_data rk816_suspend_reg[] = {
+	/* set bat 3.4v low and act irq */
+	{ RK816_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK816_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ },
+};
+
+static struct rk808_reg_data rk816_resume_reg[] = {
+	/* set bat 3.0v low and act shutdown*/
+	{ RK816_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK816_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN },
+};
+
+static const struct regmap_irq rk816_irqs[] = {
 	/* INT_STS */
-	[RK818_IRQ_VOUT_LO] = {
-		.mask = RK818_IRQ_VOUT_LO_MSK,
+	[RK816_IRQ_PWRON_FALL] = {
+		.mask = RK816_IRQ_PWRON_FALL_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_VB_LO] = {
-		.mask = RK818_IRQ_VB_LO_MSK,
+	[RK816_IRQ_PWRON_RISE] = {
+		.mask = RK816_IRQ_PWRON_RISE_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_PWRON] = {
-		.mask = RK818_IRQ_PWRON_MSK,
+	[RK816_IRQ_VB_LOW] = {
+		.mask = RK816_IRQ_VB_LOW_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_PWRON] = {
+		.mask = RK816_IRQ_PWRON_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_PWRON_LP] = {
+		.mask = RK816_IRQ_PWRON_LP_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_HOTDIE] = {
+		.mask = RK816_IRQ_HOTDIE_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_RTC_ALARM] = {
+		.mask = RK816_IRQ_RTC_ALARM_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_RTC_PERIOD] = {
+		.mask = RK816_IRQ_RTC_PERIOD_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_USB_OV] = {
+		.mask = RK816_IRQ_USB_OV_MSK,
+		.reg_offset = 1,
+	},
+};
+
+static const struct regmap_irq rk816_battery_irqs[] = {
+	/* INT_STS */
+	[RK816_IRQ_PLUG_IN] = {
+		.mask = RK816_IRQ_PLUG_IN_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_PWRON_LP] = {
-		.mask = RK818_IRQ_PWRON_LP_MSK,
+	[RK816_IRQ_PLUG_OUT] = {
+		.mask = RK816_IRQ_PLUG_OUT_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_HOTDIE] = {
-		.mask = RK818_IRQ_HOTDIE_MSK,
+	[RK816_IRQ_CHG_OK] = {
+		.mask = RK816_IRQ_CHG_OK_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_RTC_ALARM] = {
-		.mask = RK818_IRQ_RTC_ALARM_MSK,
+	[RK816_IRQ_CHG_TE] = {
+		.mask = RK816_IRQ_CHG_TE_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_RTC_PERIOD] = {
-		.mask = RK818_IRQ_RTC_PERIOD_MSK,
+	[RK816_IRQ_CHG_TS] = {
+		.mask = RK816_IRQ_CHG_TS_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_USB_OV] = {
-		.mask = RK818_IRQ_USB_OV_MSK,
+	[RK816_IRQ_CHG_CVTLIM] = {
+		.mask = RK816_IRQ_CHG_CVTLIM_MSK,
+		.reg_offset = 0,
+	},
+	[RK816_IRQ_DISCHG_ILIM] = {
+		.mask = RK816_IRQ_DISCHG_ILIM_MSK,
 		.reg_offset = 0,
 	},
+};
+
+static struct regmap_irq_chip rk816_irq_chip = {
+	.name = "rk816",
+	.irqs = rk816_irqs,
+	.num_irqs = ARRAY_SIZE(rk816_irqs),
+	.num_regs = 2,
+	.irq_reg_stride = 3,
+	.status_base = RK816_INT_STS_REG1,
+	.mask_base = RK816_INT_STS_MSK_REG1,
+	.ack_base = RK816_INT_STS_REG1,
+	.init_ack_masked = true,
+};
+
+static struct regmap_irq_chip rk816_battery_irq_chip = {
+	.name = "rk816_battery",
+	.irqs = rk816_battery_irqs,
+	.num_irqs = ARRAY_SIZE(rk816_battery_irqs),
+	.num_regs = 1,
+	.status_base = RK816_INT_STS_REG3,
+	.mask_base = RK816_INT_STS_MSK_REG3,
+	.ack_base = RK816_INT_STS_REG3,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk818s[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{ .name = "rk818-regulator", },
+#else
+	{ .name = "rk808-clkout", },
+	{ .name = "rk808-regulator", },
+#endif
+	{ .name = "rk818-battery", .of_compatible = "rk818-battery", },
+	{ .name = "rk818-charger", },
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rtc_resources),
+		.resources = &rtc_resources[0],
+	},
+};
+
+static const struct rk808_reg_data rk818_pre_init_reg[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{ RK818_BUCK1_ON_VSEL_REG, 0x3f, 0x1a},//vdd_cpu_a : default 1.0375
+	{ RK818_BUCK1_SLP_VSEL_REG, 0x3f, 0x1a},//vdd_cpu_a : default 1.0375
+	{ RK818_BUCK2_ON_VSEL_REG, 0x3f, 0x0d},//vdd_ee : default 0.875
+	{ RK818_BUCK2_SLP_VSEL_REG, 0x3f, 0x0d},//vdd_ee : default 0.875
+	{ RK818_BUCK4_ON_VSEL_REG, 0x1f, 0x0c},//vdd_ao3v3 : default 3.3
+	{ RK818_BUCK4_SLP_VSEL_REG, 0x1f, 0x0c},//vdd_ao3v3 : default 3.3
+	{ RK818_LDO5_ON_VSEL_REG, 0x1f, 0x00},//vddio_ao1v8 : default 1.8
+	{ RK818_LDO5_SLP_VSEL_REG, 0x1f, 0x00},//vddio_ao1v8 : default 1.8
+	{ RK818_LDO6_ON_VSEL_REG, 0x1f, 0x11},//vdd_lcd : default 2.5
+	{ RK818_LDO6_SLP_VSEL_REG, 0x1f, 0x11},//vdd_lcd : default 2.5
+	{ RK818_LDO7_ON_VSEL_REG, 0x1f, 0x0a},//vddq_1v8 : default 1.8
+	{ RK818_LDO7_SLP_VSEL_REG, 0x1f, 0x0a},//vddq_1v8 : default 1.8
+	{ RK818_BOOST_LDO9_ON_VSEL_REG, 0x1f, 0x0f},//vddq_1v8 : default 1.8
+	{ RK818_BOOST_LDO9_SLP_VSEL_REG, 0x1f, 0x0f},//vddq_1v8 : default 1.8
+
+	{ RK818_H5V_EN_REG, REF_RDY_CTRL_MASK | H5V_EN_MASK,
+				REF_RDY_CTRL_ENABLE | H5V_EN_ENABLE },
+	{ RK818_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK,  BUCK_ILMIN_400MA },
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{ RK818_DCDC_EN_REG, SWITCH_EN_MASK | LDO9_EN_MASK,
+			LDO9_EN_ENABLE | SWITCH_EN_ENABLE },
+	{ RK818_SLEEP_SET_OFF_REG1, OTG_SLP_SET_MASK, OTG_SLP_SET_OFF },
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+#else
+	{ RK818_H5V_EN_REG, REF_RDY_CTRL_ENABLE | H5V_EN_MASK,
+					REF_RDY_CTRL_ENABLE | H5V_EN_ENABLE },
+	{ RK818_DCDC_EN_REG, BOOST_EN_MASK | SWITCH_EN_MASK,
+					BOOST_EN_ENABLE | SWITCH_EN_ENABLE },
+	{ RK818_SLEEP_SET_OFF_REG1, OTG_SLP_SET_MASK, OTG_SLP_SET_OFF },
+	{ RK818_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK,  BUCK_ILMIN_250MA },
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{ RK808_CLK32OUT_REG, CLK32KOUT2_FUNC_MASK, CLK32KOUT2_FUNC},
+#endif
+};
+
+static struct rk808_reg_data rk818_suspend_reg[] = {
+	/* set bat 3.4v low and act irq */
+	{ RK808_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK808_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ },
+};
+
+static struct rk808_reg_data rk818_resume_reg[] = {
+	/* set bat 3.0v low and act shutdown*/
+	{ RK808_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK808_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN },
+};
 
+static const struct regmap_irq rk818_irqs[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
 	/* INT_STS2 */
 	[RK818_IRQ_PLUG_IN] = {
-		.mask = RK818_IRQ_PLUG_IN_MSK,
+		.mask = PLUG_IN_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_PLUG_OUT] = {
-		.mask = RK818_IRQ_PLUG_OUT_MSK,
+		.mask = PLUG_OUT_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_OK] = {
-		.mask = RK818_IRQ_CHG_OK_MSK,
+		.mask = CHGOK_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_TE] = {
-		.mask = RK818_IRQ_CHG_TE_MSK,
+		.mask = CHGTE_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_TS1] = {
-		.mask = RK818_IRQ_CHG_TS1_MSK,
+		.mask = CHGTS1_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_TS2] = {
-		.mask = RK818_IRQ_TS2_MSK,
+		.mask = TS2_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_CVTLIM] = {
-		.mask = RK818_IRQ_CHG_CVTLIM_MSK,
+		.mask = CHG_CVTLIM_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_DISCHG_ILIM] = {
-		.mask = RK818_IRQ_DISCHG_ILIM_MSK,
+		.mask = DISCHG_ILIM_MASK,
 		.reg_offset = 1,
 	},
-};
-
-static struct regmap_irq_chip rk808_irq_chip = {
-	.name = "rk808",
-	.irqs = rk808_irqs,
-	.num_irqs = ARRAY_SIZE(rk808_irqs),
-	.num_regs = 2,
-	.irq_reg_stride = 2,
-	.status_base = RK808_INT_STS_REG1,
-	.mask_base = RK808_INT_STS_MSK_REG1,
-	.ack_base = RK808_INT_STS_REG1,
-	.init_ack_masked = true,
+#else
+	/* INT_STS */
+	[RK818_IRQ_VOUT_LO] = {
+		.mask = VOUT_LO_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_VB_LO] = {
+		.mask = VB_LO_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_PWRON] = {
+		.mask = PWRON_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_PWRON_LP] = {
+		.mask = PWRON_LP_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_HOTDIE] = {
+		.mask = HOTDIE_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_RTC_ALARM] = {
+		.mask = RTC_ALARM_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_RTC_PERIOD] = {
+		.mask = RTC_PERIOD_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_USB_OV] = {
+		.mask = USB_OV_MASK,
+		.reg_offset = 0,
+	},
+	/* INT_STS2 */
+	[RK818_IRQ_PLUG_IN] = {
+		.mask = PLUG_IN_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_PLUG_OUT] = {
+		.mask = PLUG_OUT_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_OK] = {
+		.mask = CHGOK_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_TE] = {
+		.mask = CHGTE_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_TS1] = {
+		.mask = CHGTS1_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_TS2] = {
+		.mask = TS2_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_CVTLIM] = {
+		.mask = CHG_CVTLIM_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_DISCHG_ILIM] = {
+		.mask = DISCHG_ILIM_MASK,
+		.reg_offset = 1,
+	},
+#endif
 };
 
 static struct regmap_irq_chip rk818_irq_chip = {
@@ -265,14 +761,206 @@ static struct regmap_irq_chip rk818_irq_chip = {
 	.num_irqs = ARRAY_SIZE(rk818_irqs),
 	.num_regs = 2,
 	.irq_reg_stride = 2,
-	.status_base = RK818_INT_STS_REG1,
-	.mask_base = RK818_INT_STS_MSK_REG1,
-	.ack_base = RK818_INT_STS_REG1,
+	.status_base = RK808_INT_STS_REG1,
+	.mask_base = RK808_INT_STS_MSK_REG1,
+	.ack_base = RK808_INT_STS_REG1,
 	.init_ack_masked = true,
 };
 
-static struct i2c_client *rk808_i2c_client;
-static void rk808_device_shutdown(void)
+static const struct regmap_irq rk805_irqs[] = {
+	[RK805_IRQ_PWRON_RISE] = {
+		.mask = RK805_IRQ_PWRON_RISE_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_VB_LOW] = {
+		.mask = RK805_IRQ_VB_LOW_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_PWRON] = {
+		.mask = RK805_IRQ_PWRON_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_PWRON_LP] = {
+		.mask = RK805_IRQ_PWRON_LP_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_HOTDIE] = {
+		.mask = RK805_IRQ_HOTDIE_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_RTC_ALARM] = {
+		.mask = RK805_IRQ_RTC_ALARM_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_RTC_PERIOD] = {
+		.mask = RK805_IRQ_RTC_PERIOD_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_PWRON_FALL] = {
+		.mask = RK805_IRQ_PWRON_FALL_MSK,
+		.reg_offset = 0,
+	},
+};
+
+static struct regmap_irq_chip rk805_irq_chip = {
+	.name = "rk805",
+	.irqs = rk805_irqs,
+	.num_irqs = ARRAY_SIZE(rk805_irqs),
+	.num_regs = 1,
+	.status_base = RK805_INT_STS_REG,
+	.mask_base = RK805_INT_STS_MSK_REG,
+	.ack_base = RK805_INT_STS_REG,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk805s[] = {
+	{ .name = "rk808-clkout", },
+	{ .name = "rk818-regulator", },
+	{ .name = "rk8xx-gpio", },
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk805_pwrkey_resources),
+		.resources = &rk805_pwrkey_resources[0],
+	},
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rtc_resources),
+		.resources = &rtc_resources[0],
+	},
+};
+
+static const struct rk808_reg_data rk805_pre_init_reg[] = {
+	{RK805_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK, BUCK_ILMIN_400MA},
+	{RK805_GPIO_IO_POL_REG, SLP_SD_MSK, SLEEP_FUN},
+	{RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{RK805_THERMAL_REG, TEMP_HOTDIE_MSK, TEMP115C},
+	{RK805_DCDC_VRP_REG, REG_WRITE_MSK, BUCK4_VRP_3PERCENT},
+};
+
+static struct rk808_reg_data rk805_suspend_reg[] = {
+	{RK805_BUCK3_CONFIG_REG, PWM_MODE_MSK, AUTO_PWM_MODE},
+};
+
+static struct rk808_reg_data rk805_resume_reg[] = {
+	{RK805_BUCK3_CONFIG_REG, PWM_MODE_MSK, FPWM_MODE},
+};
+
+#define REGMAP_IRQ_M(_id) \
+	[_id] = {				\
+		.mask = BIT(((_id) % 8)),	\
+		.reg_offset = ((_id) / 8),	\
+	}
+
+static const struct regmap_irq rk817_irqs[RK817_IRQ_END] = {
+	REGMAP_IRQ_M(0),
+	REGMAP_IRQ_M(1),
+	REGMAP_IRQ_M(2),
+	REGMAP_IRQ_M(3),
+	REGMAP_IRQ_M(4),
+	REGMAP_IRQ_M(5),
+	REGMAP_IRQ_M(6),
+	REGMAP_IRQ_M(7),
+	REGMAP_IRQ_M(8),
+	REGMAP_IRQ_M(9),
+	REGMAP_IRQ_M(10),
+	REGMAP_IRQ_M(11),
+	REGMAP_IRQ_M(12),
+	REGMAP_IRQ_M(13),
+	REGMAP_IRQ_M(14),
+	REGMAP_IRQ_M(15),
+	REGMAP_IRQ_M(16),
+	REGMAP_IRQ_M(17),
+	REGMAP_IRQ_M(18),
+	REGMAP_IRQ_M(19),
+	REGMAP_IRQ_M(20),
+	REGMAP_IRQ_M(21),
+	REGMAP_IRQ_M(22),
+	REGMAP_IRQ_M(23)
+};
+
+static struct regmap_irq_chip rk817_irq_chip = {
+	.name = "rk817",
+	.irqs = rk817_irqs,
+	.num_irqs = ARRAY_SIZE(rk817_irqs),
+	.num_regs = 3,
+	.irq_reg_stride = 2,
+	.status_base = RK817_INT_STS_REG0,
+	.mask_base = RK817_INT_STS_MSK_REG0,
+	.ack_base = RK817_INT_STS_REG0,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk817s[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{ .name = "rk808-regulator",},
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk817_pwrkey_resources),
+		.resources = &rk817_pwrkey_resources[0],
+	},
+	{
+		.name = "rk817-codec",
+		.of_compatible = "rockchip,rk817-codec",
+	},
+#else
+	{ .name = "rk808-clkout",},
+	{ .name = "rk808-regulator",},
+	{ .name = "rk817-battery", .of_compatible = "rk817,battery", },
+	{ .name = "rk817-charger", .of_compatible = "rk817,charger", },
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk817_pwrkey_resources),
+		.resources = &rk817_pwrkey_resources[0],
+	},
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rk817_rtc_resources),
+		.resources = &rk817_rtc_resources[0],
+	},
+	{
+		.name = "rk817-codec",
+		.of_compatible = "rockchip,rk817-codec",
+	},
+#endif
+};
+
+static const struct rk808_reg_data rk817_pre_init_reg[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{RK817_BUCK2_ON_VSEL_REG, 0x7f, 0x2B},	/*vddcpu_b : 1.0375 (default)*/
+	{RK817_BUCK3_ON_VSEL_REG, 0x7f, 0x20},	/*vcc_2v3 : 2.4 (default)*/
+
+	{RK817_POWER_EN_REG(0), 0xff, 0x66},
+	{RK817_POWER_EN_REG(1), 0xff, 0x88},
+	{RK817_SYS_CFG(1), RK817_HOTDIE_TEMP_MSK | RK817_TSD_TEMP_MSK,
+					   RK817_HOTDIE_105 | RK817_TSD_140},
+#else
+	{RK817_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{RK817_GPIO_INT_CFG, RK817_INT_POL_MSK, RK817_INT_POL_L},
+	{RK817_SYS_CFG(1), RK817_HOTDIE_TEMP_MSK | RK817_TSD_TEMP_MSK,
+					   RK817_HOTDIE_105 | RK817_TSD_140},
+#endif
+};
+
+static void rk808_device_shutdown_prepare(void)
+{
+	int ret;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	if (!rk808) {
+		dev_warn(&rk808_i2c_client->dev,
+			 "have no rk808, so do nothing here\n");
+		return;
+	}
+
+	if (pm_shutdown_prepare) {
+		ret = pm_shutdown_prepare(rk808);
+		if (ret)
+			dev_err(&rk808_i2c_client->dev,
+				"power off prepare error!\n");
+	}
+}
+
+static void rk808_syscore_shutdown(void)
 {
 	int ret;
 	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
@@ -283,18 +971,295 @@ static void rk808_device_shutdown(void)
 		return;
 	}
 
+	/* close rtc int when power off */
+	regmap_update_bits(rk808->regmap,
+			   RK808_INT_STS_MSK_REG1,
+			   (0x3 << 5), (0x3 << 5));
+	regmap_update_bits(rk808->regmap,
+			   RK808_RTC_INT_REG,
+			   (0x3 << 2), (0x0 << 2));
+	/*
+	 * For PMIC that power off supplies by write register via i2c bus,
+	 * it's better to do power off at syscore shutdown here.
+	 *
+	 * Because when run to kernel's "pm_power_off" call, i2c may has
+	 * been stopped or PMIC may not be able to get i2c transfer while
+	 * there are too many devices are competiting.
+	 */
+	/* power off supplies ! */
+	if (pm_shutdown) {
+		dev_info(&rk808_i2c_client->dev, "System power off\n");
+		ret = pm_shutdown(rk808->regmap);
+		if (ret)
+			dev_err(&rk808_i2c_client->dev,
+				"System power off error!\n");
+		mdelay(10);
+		dev_info(&rk808_i2c_client->dev,
+			 "Cpu should never reach here, stop!\n");
+		while (1)
+			;
+	}
+}
+
+static struct syscore_ops rk808_syscore_ops = {
+	.shutdown = rk808_syscore_shutdown,
+};
+
+/*
+ * RK8xx PMICs would do real power off in syscore shutdown, if "pm_power_off"
+ * is not assigned(e.g. PSCI is not enabled), we have to provide a dummy
+ * callback for it, otherwise there comes a halt in Reboot system call:
+ *
+ * if ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)
+ *		cmd = LINUX_REBOOT_CMD_HALT;
+ */
+static void rk808_pm_power_off_dummy(void)
+{
+	pr_info("Dummy power off for RK8xx PMICs, should never reach here!\n");
+
+	while (1)
+		;
+}
+
+static ssize_t rk8xx_dbg_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int ret;
+	char cmd;
+	u32 input[2], addr, data;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	ret = sscanf(buf, "%c ", &cmd);
+	switch (cmd) {
+	case 'w':
+		ret = sscanf(buf, "%c %x %x ", &cmd, &input[0], &input[1]);
+		if (ret != 3) {
+			pr_err("erro! cmd format: echo w [addr] [value]\n");
+			goto out;
+		}
+		addr = input[0] & 0xff;
+		data = input[1] & 0xff;
+		pr_info("cmd : %c %x %x\n\n", cmd, input[0], input[1]);
+		regmap_write(rk808->regmap, addr, data);
+		regmap_read(rk808->regmap, addr, &data);
+		pr_info("new: %x %x\n", addr, data);
+		break;
+	case 'r':
+		ret = sscanf(buf, "%c %x ", &cmd, &input[0]);
+		if (ret != 2) {
+			pr_err("erro! cmd format: echo r [addr]\n");
+			goto out;
+		}
+		pr_info("cmd : %c %x\n\n", cmd, input[0]);
+		addr = input[0] & 0xff;
+		regmap_read(rk808->regmap, addr, &data);
+		pr_info("%x %x\n", input[0], data);
+		break;
+	default:
+		pr_err("Unknown command\n");
+		break;
+	}
+
+out:
+	return count;
+}
+
+static int rk817_pinctrl_init(struct device *dev, struct rk808 *rk808)
+{
+	int ret;
+	struct platform_device	*pinctrl_dev;
+	struct pinctrl_state *default_st;
+
+	pinctrl_dev = platform_device_alloc("rk805-pinctrl", -1);
+	if (!pinctrl_dev) {
+		dev_err(dev, "Alloc pinctrl dev failed!\n");
+		return -ENOMEM;
+	}
+
+	pinctrl_dev->dev.parent = dev;
+
+	ret = platform_device_add(pinctrl_dev);
+
+	if (ret) {
+		platform_device_put(pinctrl_dev);
+		dev_err(dev, "Add rk805-pinctrl dev failed!\n");
+		return ret;
+	}
+	if (dev->pins && !IS_ERR(dev->pins->p)) {
+		dev_info(dev, "had get a pinctrl!\n");
+		return 0;
+	}
+
+	rk808->pins = devm_kzalloc(dev, sizeof(struct rk808_pin_info),
+				   GFP_KERNEL);
+	if (!rk808->pins)
+		return -ENOMEM;
+
+	rk808->pins->p = devm_pinctrl_get(dev);
+	if (IS_ERR(rk808->pins->p)) {
+		rk808->pins->p = NULL;
+		dev_err(dev, "no pinctrl handle\n");
+		return 0;
+	}
+
+	default_st = pinctrl_lookup_state(rk808->pins->p,
+					  PINCTRL_STATE_DEFAULT);
+
+	if (IS_ERR(default_st)) {
+		dev_dbg(dev, "no default pinctrl state\n");
+			return -EINVAL;
+	}
+
+	ret = pinctrl_select_state(rk808->pins->p, default_st);
+	if (ret) {
+		dev_dbg(dev, "failed to activate default pinctrl state\n");
+		return -EINVAL;
+	}
+
+	rk808->pins->power_off = pinctrl_lookup_state(rk808->pins->p,
+						      "pmic-power-off");
+	if (IS_ERR(rk808->pins->power_off)) {
+		rk808->pins->power_off = NULL;
+		dev_dbg(dev, "no power-off pinctrl state\n");
+	}
+
+	rk808->pins->sleep = pinctrl_lookup_state(rk808->pins->p,
+						  "pmic-sleep");
+	if (IS_ERR(rk808->pins->sleep)) {
+		rk808->pins->sleep = NULL;
+		dev_dbg(dev, "no sleep-setting state\n");
+	}
+
+	rk808->pins->reset = pinctrl_lookup_state(rk808->pins->p,
+						  "pmic-reset");
+	if (IS_ERR(rk808->pins->reset)) {
+		rk808->pins->reset = NULL;
+		dev_dbg(dev, "no reset-setting pinctrl state\n");
+		return 0;
+	}
+
 	ret = regmap_update_bits(rk808->regmap,
-				 RK808_DEVCTRL_REG,
-				 DEV_OFF_RST, DEV_OFF_RST);
+				 RK817_SYS_CFG(3),
+				 RK817_SLPPOL_MSK,
+				 RK817_SLPPOL_L);
+	if (ret) {
+		dev_err(dev, "init: config RK817_SLPPOL_L error!\n");
+		return -1;
+	}
+
+	ret = pinctrl_select_state(rk808->pins->p, rk808->pins->reset);
+
 	if (ret)
-		dev_err(&rk808_i2c_client->dev, "power off error!\n");
+		dev_dbg(dev, "failed to activate reset-setting pinctrl state\n");
+
+	return 0;
 }
 
+struct rk817_reboot_data_t {
+	struct rk808 *rk808;
+	struct notifier_block reboot_notifier;
+};
+
+static struct rk817_reboot_data_t rk817_reboot_data;
+
+static int rk817_reboot_notifier_handler(struct notifier_block *nb,
+					 unsigned long action, void *cmd)
+{
+	struct rk817_reboot_data_t *data;
+	int ret;
+	struct device *dev;
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	int value, power_en_active0, power_en_active1;
+
+	regmap_read(data->rk808->regmap, RK817_POWER_EN_SAVE0,
+		&power_en_active0);
+	regmap_read(data->rk808->regmap, RK817_POWER_EN_SAVE1,
+		&power_en_active1);
+	value = power_en_active0 & 0x0f;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(0), value | 0xf0);
+	value = (power_en_active0 & 0xf0) >> 4;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(1), value | 0xf0);
+	value = power_en_active1 & 0x0f;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(2), value | 0xf0);
+	value = (power_en_active1 & 0xf0) >> 4;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(3), value | 0xf0);
+#endif
+
+	if (action != SYS_RESTART)
+		return NOTIFY_OK;
+
+	if (!cmd || !strlen(cmd) || !strcmp(cmd, "normal"))
+		return NOTIFY_OK;
+
+	data = container_of(nb, struct rk817_reboot_data_t, reboot_notifier);
+	dev = &data->rk808->i2c->dev;
+
+	ret = regmap_update_bits(data->rk808->regmap, RK817_SYS_CFG(3),
+				 RK817_RST_FUNC_MSK, RK817_RST_FUNC_REG);
+	if (ret)
+		dev_err(dev, "reboot: force RK817_RST_FUNC_REG error!\n");
+	else
+		dev_info(dev, "reboot: force RK817_RST_FUNC_REG ok!\n");
+	return NOTIFY_OK;
+}
+
+static void rk817_of_property_prepare(struct rk808 *rk808, struct device *dev)
+{
+	u32 inner;
+	int ret, func, msk, val;
+	struct device_node *np = dev->of_node;
+	struct regmap *regmap = rk808->regmap;
+return;
+	ret = of_property_read_u32_index(np, "fb-inner-reg-idxs", 0, &inner);
+	if (!ret && inner == RK817_ID_DCDC3)
+		regmap_update_bits(regmap, RK817_POWER_CONFIG,
+				   RK817_BUCK3_FB_RES_MSK,
+				   RK817_BUCK3_FB_RES_INTER);
+	else
+		regmap_update_bits(regmap, RK817_POWER_CONFIG,
+				   RK817_BUCK3_FB_RES_MSK,
+				   RK817_BUCK3_FB_RES_EXT);
+	dev_info(dev, "support dcdc3 fb mode:%d, %d\n", ret, inner);
+
+	ret = of_property_read_u32(np, "pmic-reset-func", &func);
+
+	msk = RK817_SLPPIN_FUNC_MSK | RK817_RST_FUNC_MSK;
+	val = SLPPIN_NULL_FUN;
+
+	if (!ret && func < RK817_RST_FUNC_CNT) {
+		val |= RK817_RST_FUNC_MSK &
+		       (func << RK817_RST_FUNC_SFT);
+	} else {
+		val |= RK817_RST_FUNC_REG;
+	}
+
+	regmap_update_bits(regmap, RK817_SYS_CFG(3), msk, val);
+
+	dev_info(dev, "support pmic reset mode:%d,%d\n", ret, func);
+
+	rk817_reboot_data.rk808 = rk808;
+	rk817_reboot_data.reboot_notifier.notifier_call =
+		rk817_reboot_notifier_handler;
+	ret = register_reboot_notifier(&rk817_reboot_data.reboot_notifier);
+	if (ret)
+		dev_err(dev, "failed to register reboot nb\n");
+}
+
+static struct kobject *rk8xx_kobj;
+static struct device_attribute rk8xx_attrs =
+		__ATTR(rk8xx_dbg, 0200, NULL, rk8xx_dbg_store);
+
 static const struct of_device_id rk808_of_match[] = {
+	{ .compatible = "rockchip,rk805" },
 	{ .compatible = "rockchip,rk808" },
+	{ .compatible = "rockchip,rk809" },
+	{ .compatible = "rockchip,rk816" },
+	{ .compatible = "rockchip,rk817" },
 	{ .compatible = "rockchip,rk818" },
 	{ },
 };
+
 MODULE_DEVICE_TABLE(of, rk808_of_match);
 
 static int rk808_probe(struct i2c_client *client,
@@ -302,119 +1267,406 @@ static int rk808_probe(struct i2c_client *client,
 {
 	struct device_node *np = client->dev.of_node;
 	struct rk808 *rk808;
+	int (*pm_shutdown_fn)(struct regmap *regmap) = NULL;
+	int (*pm_shutdown_prepare_fn)(struct rk808 *rk808) = NULL;
 	const struct rk808_reg_data *pre_init_reg;
-	const struct mfd_cell *cells;
-	int nr_pre_init_regs;
-	int nr_cells;
-	int pm_off = 0;
-	int ret;
-	int i;
-
+	const struct regmap_config *regmap_config;
+	const struct regmap_irq_chip *irq_chip, *battery_irq_chip = NULL;
+	const struct mfd_cell *cell;
+	u8 on_source = 0, off_source = 0;
+	int msb, lsb, reg_num=0, cell_num;
+	int ret, i, pm_off = 0;
+	unsigned int on, off;
+	u8 pmic_id_msb = RK808_ID_MSB, pmic_id_lsb = RK808_ID_LSB;
+	void (*of_property_prepare_fn)(struct rk808 *rk808,
+				       struct device *dev) = NULL;
+	int (*pinctrl_init)(struct device *dev, struct rk808 *rk808) = NULL;
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	int irq_gpio;
+	char sysfs_name[8];
+#endif
 	rk808 = devm_kzalloc(&client->dev, sizeof(*rk808), GFP_KERNEL);
 	if (!rk808)
 		return -ENOMEM;
 
-	rk808->variant = i2c_smbus_read_word_data(client, RK808_ID_MSB);
-	if (rk808->variant < 0) {
-		dev_err(&client->dev, "Failed to read the chip id at 0x%02x\n",
+	if (of_device_is_compatible(np, "rockchip,rk817") ||
+	    of_device_is_compatible(np, "rockchip,rk809")) {
+		pmic_id_msb = RK817_ID_MSB;
+		pmic_id_lsb = RK817_ID_LSB;
+	}
+	/* read Chip variant */
+	msb = i2c_smbus_read_byte_data(client, pmic_id_msb);
+	if (msb < 0) {
+		dev_err(&client->dev, "failed to read the chip id at 0x%x\n",
 			RK808_ID_MSB);
-		return rk808->variant;
+		return msb;
 	}
 
-	dev_dbg(&client->dev, "Chip id: 0x%x\n", (unsigned int)rk808->variant);
+	lsb = i2c_smbus_read_byte_data(client, pmic_id_lsb);
+	if (lsb < 0) {
+		dev_err(&client->dev, "failed to read the chip id at 0x%x\n",
+			RK808_ID_LSB);
+		return lsb;
+	}
 
+	rk808->variant = ((msb << 8) | lsb) & RK8XX_ID_MSK;
+	sprintf(sysfs_name, "rk%lx", rk808->variant);
+	dev_info(&client->dev, "Pmic Chip id: 0x%lx, sysfs: %s\n", rk808->variant,sysfs_name);
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	irq_gpio = of_get_named_gpio(np, "gpio-irq", 0);
+	if (irq_gpio < 0) {
+		dev_err(&client->dev, "No interrupt pin, no core IRQ\n");
+		return -EINVAL;
+	}
+	else dev_info(&client->dev, "Pmic irq gpio pin : %d\n", irq_gpio);
+
+	ret = gpio_request(irq_gpio, "pmic_irq");
+	if (ret)
+		dev_err(&client->dev,"interrupt_pin request failed(%d)\n", ret);
+
+	ret = gpio_direction_input(irq_gpio);
+	if (ret)
+		dev_err(&client->dev,"set interrupt_pin input failed(%d)\n", ret);
+
+	client->irq = gpio_to_irq(irq_gpio);
+	if (client->irq)
+		dev_info(&client->dev, "Pmic irq gpio irq number : %d\n", client->irq);
+
+#endif
+	/* set Chip platform init data*/
 	switch (rk808->variant) {
+	case RK816_ID:
+		cell = rk816s;
+		cell_num = ARRAY_SIZE(rk816s);
+		pre_init_reg = rk816_pre_init_reg;
+		reg_num = ARRAY_SIZE(rk816_pre_init_reg);
+		regmap_config = &rk816_regmap_config;
+		irq_chip = &rk816_irq_chip;
+		battery_irq_chip = &rk816_battery_irq_chip;
+		pm_shutdown_fn = rk816_shutdown;
+		on_source = RK816_ON_SOURCE_REG;
+		off_source = RK816_OFF_SOURCE_REG;
+		suspend_reg = rk816_suspend_reg;
+		suspend_reg_num = ARRAY_SIZE(rk816_suspend_reg);
+		resume_reg = rk816_resume_reg;
+		resume_reg_num = ARRAY_SIZE(rk816_resume_reg);
+		break;
 	case RK808_ID:
-		rk808->regmap_cfg = &rk808_regmap_config;
-		rk808->regmap_irq_chip = &rk808_irq_chip;
+		cell = rk808s;
+		cell_num = ARRAY_SIZE(rk808s);
 		pre_init_reg = rk808_pre_init_reg;
-		nr_pre_init_regs = ARRAY_SIZE(rk808_pre_init_reg);
-		cells = rk808s;
-		nr_cells = ARRAY_SIZE(rk808s);
+		reg_num = ARRAY_SIZE(rk808_pre_init_reg);
+		regmap_config = &rk808_regmap_config;
+		irq_chip = &rk808_irq_chip;
+		pm_shutdown_fn = rk808_shutdown;
+		break;
+	case RK805_ID:
+		cell = rk805s;
+		cell_num = ARRAY_SIZE(rk805s);
+		pre_init_reg = rk805_pre_init_reg;
+		reg_num = ARRAY_SIZE(rk805_pre_init_reg);
+		regmap_config = &rk805_regmap_config;
+		irq_chip = &rk805_irq_chip;
+		pm_shutdown_prepare_fn = rk805_shutdown_prepare;
+		on_source = RK805_ON_SOURCE_REG;
+		off_source = RK805_OFF_SOURCE_REG;
+		suspend_reg = rk805_suspend_reg;
+		suspend_reg_num = ARRAY_SIZE(rk805_suspend_reg);
+		resume_reg = rk805_resume_reg;
+		resume_reg_num = ARRAY_SIZE(rk805_resume_reg);
 		break;
 	case RK818_ID:
-		rk808->regmap_cfg = &rk818_regmap_config;
-		rk808->regmap_irq_chip = &rk818_irq_chip;
+		cell = rk818s;
+		cell_num = ARRAY_SIZE(rk818s);
 		pre_init_reg = rk818_pre_init_reg;
-		nr_pre_init_regs = ARRAY_SIZE(rk818_pre_init_reg);
-		cells = rk818s;
-		nr_cells = ARRAY_SIZE(rk818s);
+		reg_num = ARRAY_SIZE(rk818_pre_init_reg);
+		regmap_config = &rk818_regmap_config;
+		irq_chip = &rk818_irq_chip;
+		pm_shutdown_fn = rk818_shutdown;
+		on_source = RK818_ON_SOURCE_REG;
+		off_source = RK818_OFF_SOURCE_REG;
+		suspend_reg = rk818_suspend_reg;
+		suspend_reg_num = ARRAY_SIZE(rk818_suspend_reg);
+		resume_reg = rk818_resume_reg;
+		resume_reg_num = ARRAY_SIZE(rk818_resume_reg);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		cell = rk817s;
+		cell_num = ARRAY_SIZE(rk817s);
+		pre_init_reg = rk817_pre_init_reg;
+		reg_num = ARRAY_SIZE(rk817_pre_init_reg);
+		regmap_config = &rk817_regmap_config;
+		irq_chip = &rk817_irq_chip;
+		pm_shutdown_prepare_fn = rk817_shutdown_prepare;
+		on_source = RK817_ON_SOURCE_REG;
+		off_source = RK817_OFF_SOURCE_REG;
+		of_property_prepare_fn = rk817_of_property_prepare;
+		pinctrl_init = rk817_pinctrl_init;
 		break;
 	default:
-		dev_err(&client->dev, "Unsupported RK8XX ID %lu\n",
+		dev_err(&client->dev, "unsupported RK8XX ID 0x%lx\n",
 			rk808->variant);
 		return -EINVAL;
 	}
 
-	rk808->i2c = client;
-	i2c_set_clientdata(client, rk808);
-
-	rk808->regmap = devm_regmap_init_i2c(client, rk808->regmap_cfg);
+	rk808->regmap = devm_regmap_init_i2c(client, regmap_config);
 	if (IS_ERR(rk808->regmap)) {
 		dev_err(&client->dev, "regmap initialization failed\n");
 		return PTR_ERR(rk808->regmap);
 	}
 
-	if (!client->irq) {
-		dev_err(&client->dev, "No interrupt support, no core IRQ\n");
-		return -EINVAL;
+	/* on & off source */
+	if (on_source && off_source) {
+		ret = regmap_read(rk808->regmap, on_source, &on);
+		if (ret) {
+			dev_err(&client->dev, "read 0x%x failed\n", on_source);
+			return ret;
+		}
+
+		ret = regmap_read(rk808->regmap, off_source, &off);
+		if (ret) {
+			dev_err(&client->dev, "read 0x%x failed\n", off_source);
+			return ret;
+		}
+
+		dev_info(&client->dev, "source: on=0x%02x, off=0x%02x\n",
+			 on, off);
+	}
+
+	if(reg_num) {
+		for (i = 0; i < reg_num; i++) {
+			ret = regmap_update_bits(rk808->regmap,
+						 pre_init_reg[i].addr,
+						 pre_init_reg[i].mask,
+						 pre_init_reg[i].value);
+			if (ret) {
+				dev_err(&client->dev,
+					"0x%x write err\n",
+					pre_init_reg[i].addr);
+				return ret;
+			}
+		}
 	}
 
-	ret = regmap_add_irq_chip(rk808->regmap, client->irq,
-				  IRQF_ONESHOT, -1,
-				  rk808->regmap_irq_chip, &rk808->irq_data);
+	if (of_property_prepare_fn)
+		of_property_prepare_fn(rk808, &client->dev);
+
+	i2c_set_clientdata(client, rk808);
+	rk808->i2c = client;
+	rk808_i2c_client = client;
+
+	if (pinctrl_init) {
+		ret = pinctrl_init(&client->dev, rk808);
+		if (ret)
+			return ret;
+	}
+
+	ret = regmap_add_irq_chip(rk808->regmap,
+				client->irq, IRQF_ONESHOT | IRQF_SHARED, -1,
+				irq_chip, &rk808->irq_data);
 	if (ret) {
 		dev_err(&client->dev, "Failed to add irq_chip %d\n", ret);
 		return ret;
 	}
 
-	for (i = 0; i < nr_pre_init_regs; i++) {
-		ret = regmap_update_bits(rk808->regmap,
-					pre_init_reg[i].addr,
-					pre_init_reg[i].mask,
-					pre_init_reg[i].value);
+	if (battery_irq_chip) {
+		ret = regmap_add_irq_chip(rk808->regmap,
+					client->irq, IRQF_ONESHOT | IRQF_SHARED, -1,
+					irq_chip, &rk808->battery_irq_data);
 		if (ret) {
 			dev_err(&client->dev,
-				"0x%x write err\n",
-				pre_init_reg[i].addr);
+				"Failed to add batterry irq_chip %d\n", ret);
+			regmap_del_irq_chip(client->irq, rk808->irq_data);
 			return ret;
 		}
 	}
 
-	ret = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_NONE,
-			      cells, nr_cells, NULL, 0,
-			      regmap_irq_get_domain(rk808->irq_data));
+	ret = mfd_add_devices(&client->dev, -1,
+			      cell, cell_num,
+			      NULL, 0, regmap_irq_get_domain(rk808->irq_data));
 	if (ret) {
 		dev_err(&client->dev, "failed to add MFD devices %d\n", ret);
 		goto err_irq;
 	}
 
 	pm_off = of_property_read_bool(np,
-				"rockchip,system-power-controller");
-	if (pm_off && !pm_power_off) {
-		rk808_i2c_client = client;
-		pm_power_off = rk808_device_shutdown;
+				       "rockchip,system-power-controller");
+	if (pm_off) {
+		if (pm_shutdown_prepare_fn) {
+			pm_shutdown_prepare = pm_shutdown_prepare_fn;
+			pm_power_off_prepare = rk808_device_shutdown_prepare;
+		}
+		if (pm_shutdown_fn) {
+			pm_shutdown = pm_shutdown_fn;
+			register_syscore_ops(&rk808_syscore_ops);
+		}
+
+		/*
+		 * If not assigned(e.g. PSCI is not enable), we provide a
+		 * dummy for it to avoid halt in Reboot system call.
+		 */
+		if (!pm_power_off)
+			pm_power_off = rk808_pm_power_off_dummy;
+	}
+
+	rk8xx_kobj = kobject_create_and_add(sysfs_name, NULL);
+	if (rk8xx_kobj) {
+		ret = sysfs_create_file(rk8xx_kobj, &rk8xx_attrs.attr);
+		if (ret)
+			dev_err(&client->dev, "create rk8xx sysfs error\n");
 	}
 
 	return 0;
 
 err_irq:
 	regmap_del_irq_chip(client->irq, rk808->irq_data);
+	if (battery_irq_chip)
+		regmap_del_irq_chip(client->irq, rk808->battery_irq_data);
 	return ret;
 }
 
+static void rk8xx_shutdown(struct i2c_client *client)
+{
+	struct rk808 *rk808 = i2c_get_clientdata(client);
+
+	if (system_state == SYSTEM_POWER_OFF) {
+		dev_info(&client->dev, "%s[%d]Chip id: 0x%lx\n",__func__,__LINE__, rk808->variant);
+
+		switch (rk808->variant) {
+		case RK817_ID:
+			regmap_write(rk808->regmap, RK817_POWER_EN_REG(1), 0x00 | 0xf0);
+			regmap_write(rk808->regmap, RK817_POWER_EN_REG(2), 0x00 | 0xf0);
+			regmap_write(rk808->regmap, RK817_POWER_EN_REG(3), 0x00 | 0xf0);
+			break;
+		default:
+			dev_info(&client->dev, "unsupported RK8XX ID 0x%lx\n",
+				rk808->variant);
+		}
+	}
+
+	return;
+}
+
+static int rk808_suspend(struct device *dev)
+{
+	int i, ret;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	for (i = 0; i < suspend_reg_num; i++) {
+		ret = regmap_update_bits(rk808->regmap,
+					 suspend_reg[i].addr,
+					 suspend_reg[i].mask,
+					 suspend_reg[i].value);
+		if (ret) {
+			dev_err(dev, "0x%x write err\n",
+				suspend_reg[i].addr);
+			return ret;
+		}
+	}
+
+	if (rk808->pins && rk808->pins->p && rk808->pins->sleep) {
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPIN_FUNC_MSK,
+					 SLPPIN_NULL_FUN);
+		if (ret) {
+			dev_err(dev, "suspend: config SLPPIN_NULL_FUN error!\n");
+			return -1;
+		}
+
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPOL_MSK,
+					 RK817_SLPPOL_H);
+		if (ret) {
+			dev_err(dev, "suspend: config RK817_SLPPOL_H error!\n");
+			return -1;
+		}
+
+		ret = pinctrl_select_state(rk808->pins->p, rk808->pins->sleep);
+		if (ret) {
+			dev_err(dev, "failed to act slp pinctrl state\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int rk808_resume(struct device *dev)
+{
+	int i, ret;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	for (i = 0; i < resume_reg_num; i++) {
+		ret = regmap_update_bits(rk808->regmap,
+					 resume_reg[i].addr,
+					 resume_reg[i].mask,
+					 resume_reg[i].value);
+		if (ret) {
+			dev_err(dev, "0x%x write err\n",
+				resume_reg[i].addr);
+			return ret;
+		}
+	}
+
+	if (rk808->pins && rk808->pins->p && rk808->pins->reset) {
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPIN_FUNC_MSK,
+					 SLPPIN_NULL_FUN);
+		if (ret) {
+			dev_err(dev, "resume: config SLPPIN_NULL_FUN error!\n");
+			return -1;
+		}
+
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPOL_MSK,
+					 RK817_SLPPOL_L);
+		if (ret) {
+			dev_err(dev, "resume: config RK817_SLPPOL_L error!\n");
+			return -1;
+		}
+
+		ret = pinctrl_select_state(rk808->pins->p, rk808->pins->reset);
+		if (ret)
+			dev_dbg(dev, "failed to act reset pinctrl state\n");
+	}
+
+	return 0;
+}
+
 static int rk808_remove(struct i2c_client *client)
 {
 	struct rk808 *rk808 = i2c_get_clientdata(client);
 
 	regmap_del_irq_chip(client->irq, rk808->irq_data);
-	pm_power_off = NULL;
+	mfd_remove_devices(&client->dev);
+
+	if (pm_power_off == rk808_pm_power_off_dummy)
+		pm_power_off = NULL;
+	if (pm_power_off_prepare == rk808_device_shutdown_prepare)
+		pm_power_off_prepare = NULL;
+	if (pm_shutdown)
+		unregister_syscore_ops(&rk808_syscore_ops);
 
 	return 0;
 }
 
+static const struct dev_pm_ops rk808_pm_ops = {
+	.suspend = rk808_suspend,
+	.resume =  rk808_resume,
+};
+
 static const struct i2c_device_id rk808_ids[] = {
+	{ "rk805" },
 	{ "rk808" },
+	{ "rk809" },
+	{ "rk816" },
+	{ "rk817" },
 	{ "rk818" },
 	{ },
 };
@@ -424,16 +1676,29 @@ static struct i2c_driver rk808_i2c_driver = {
 	.driver = {
 		.name = "rk808",
 		.of_match_table = rk808_of_match,
+		.pm = &rk808_pm_ops,
 	},
 	.probe    = rk808_probe,
+	.shutdown = rk8xx_shutdown,
 	.remove   = rk808_remove,
 	.id_table = rk808_ids,
 };
 
-module_i2c_driver(rk808_i2c_driver);
+static int __init rk808_pmic_init(void)
+{
+	return i2c_add_driver(&rk808_i2c_driver);
+}
+
+subsys_initcall(rk808_pmic_init);
+
+static void __exit rk808_pmic_exit(void)
+{
+	i2c_del_driver(&rk808_i2c_driver);
+}
+module_exit(rk808_pmic_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Chris Zhong <zyw@rock-chips.com>");
 MODULE_AUTHOR("Zhang Qing <zhangqing@rock-chips.com>");
-MODULE_AUTHOR("Wadim Egorov <w.egorov@phytec.de>");
-MODULE_DESCRIPTION("RK808/RK818 PMIC driver");
+MODULE_AUTHOR("Chen jianhong <chenjh@rock-chips.com>");
+MODULE_DESCRIPTION("RK808 PMIC driver");
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index b0c0fa0444dd..33a74fd3297c 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -255,6 +255,15 @@ config PINCTRL_ZYNQ
 	select GENERIC_PINCONF
 	help
 	  This selects the pinctrl driver for Xilinx Zynq.
+      
+config PINCTRL_RK805
+	tristate "Pinctrl and GPIO driver for RK805 PMIC"
+	depends on MFD_RK808
+	select GPIOLIB
+	select PINMUX
+	select GENERIC_PINCONF
+	help
+	  This selects the pinctrl driver for RK805.
 
 source "drivers/pinctrl/aspeed/Kconfig"
 source "drivers/pinctrl/bcm/Kconfig"
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 11bad373dfe0..5e628257ba72 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_PINCTRL_LPC18XX)	+= pinctrl-lpc18xx.o
 obj-$(CONFIG_PINCTRL_TB10X)	+= pinctrl-tb10x.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
 obj-$(CONFIG_PINCTRL_ZYNQ)	+= pinctrl-zynq.o
+obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
 
 obj-$(CONFIG_ARCH_ASPEED)	+= aspeed/
 obj-y				+= bcm/
diff --git a/drivers/pinctrl/pinctrl-rk805.c b/drivers/pinctrl/pinctrl-rk805.c
new file mode 100755
index 000000000000..8810aabb7555
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-rk805.c
@@ -0,0 +1,689 @@
+/*
+ * Pinctrl driver for Rockchip RK805 PMIC
+ *
+ * Copyright (c) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Author: Joseph Chen <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under  the terms of the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * Based on the pinctrl-as3722 driver
+ */
+
+#include <linux/gpio/driver.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/rk808.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+
+#include "core.h"
+#include "pinconf.h"
+#include "pinctrl-utils.h"
+
+struct rk805_pin_function {
+	const char *name;
+	const char *const *groups;
+	unsigned int ngroups;
+	int mux_option;
+};
+
+struct rk805_pin_group {
+	const char *name;
+	const unsigned int pins[1];
+	unsigned int npins;
+};
+
+/*
+ * @reg: gpio setting register;
+ * @fun_mask: functions select mask value, when set is gpio;
+ * @dir_mask: input or output mask value, when set is output, otherwise input;
+ * @val_mask: gpio set value, when set is level high, otherwise low;
+ *
+ * Different PMIC has different pin features, belowing 3 mask members are not
+ * all necessary for every PMIC. For example, RK805 has 2 pins that can be used
+ * as output only GPIOs, so func_mask and dir_mask are not needed. RK816 has 1
+ * pin that can be used as TS/GPIO, so fun_mask, dir_mask and val_mask are all
+ * necessary.
+ */
+struct rk805_pin_config {
+	u8 reg;
+	u8 fun_msk;
+	u8 dir_msk;
+	u8 val_msk;
+};
+
+struct rk805_pctrl_info {
+	struct rk808 *rk808;
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	struct gpio_chip gpio_chip;
+	struct pinctrl_desc pinctrl_desc;
+	const struct rk805_pin_function *functions;
+	unsigned int num_functions;
+	const struct rk805_pin_group *groups;
+	int num_pin_groups;
+	const struct pinctrl_pin_desc *pins;
+	unsigned int num_pins;
+	struct rk805_pin_config *pin_cfg;
+};
+
+enum rk805_pinmux_option {
+	RK805_PINMUX_GPIO,
+};
+
+enum {
+	RK805_GPIO0,
+	RK805_GPIO1,
+};
+
+static const char *const rk805_gpio_groups[] = {
+	"gpio0",
+	"gpio1",
+};
+
+/* RK805: 2 output only GPIOs */
+static const struct pinctrl_pin_desc rk805_pins_desc[] = {
+	PINCTRL_PIN(RK805_GPIO0, "gpio0"),
+	PINCTRL_PIN(RK805_GPIO1, "gpio1"),
+};
+
+static const struct rk805_pin_function rk805_pin_functions[] = {
+	{
+		.name = "gpio",
+		.groups = rk805_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk805_gpio_groups),
+		.mux_option = RK805_PINMUX_GPIO,
+	},
+};
+
+static const struct rk805_pin_group rk805_pin_groups[] = {
+	{
+		.name = "gpio0",
+		.pins = { RK805_GPIO0 },
+		.npins = 1,
+	},
+	{
+		.name = "gpio1",
+		.pins = { RK805_GPIO1 },
+		.npins = 1,
+	},
+};
+
+#define RK805_GPIO0_VAL_MSK	BIT(0)
+#define RK805_GPIO1_VAL_MSK	BIT(1)
+
+static struct rk805_pin_config rk805_gpio_cfgs[] = {
+	{
+		.reg = RK805_OUT_REG,
+		.val_msk = RK805_GPIO0_VAL_MSK,
+	},
+	{
+		.reg = RK805_OUT_REG,
+		.val_msk = RK805_GPIO1_VAL_MSK,
+	},
+};
+
+enum rk817_pinmux_option {
+	RK817_PINMUX_FUN0 = 0,
+	RK817_PINMUX_FUN1,
+	RK817_PINMUX_FUN2,
+	RK817_PINMUX_FUN3
+};
+
+enum {
+	RK817_GPIO_SLP,
+	RK817_GPIO_TS,
+	RK817_GPIO_GT
+};
+
+/* for rk809 only a sleep pin */
+static const char *const rk817_gpio_groups[] = {
+	"gpio_slp",
+	"gpio_ts",
+	"gpio_gt",
+};
+
+static const struct pinctrl_pin_desc rk817_pins_desc[] = {
+	PINCTRL_PIN(RK817_GPIO_SLP, "gpio_slp"), /* sleep pin */
+	PINCTRL_PIN(RK817_GPIO_TS, "gpio_ts"), /* ts pin */
+	PINCTRL_PIN(RK817_GPIO_GT, "gpio_gt")/* gate pin */
+};
+
+static const struct rk805_pin_function rk817_pin_functions[] = {
+	{
+		.name = "pin_fun0",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN0,
+	},
+	{
+		.name = "pin_fun1",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN1,
+	},
+	{
+		.name = "pin_fun2",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN2,
+	},
+	{
+		.name = "pin_fun3",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN3,
+	},
+};
+
+/* for rk809 only a sleep pin */
+static const struct rk805_pin_group rk817_pin_groups[] = {
+	{
+		.name = "gpio_slp",
+		.pins = { RK817_GPIO_SLP },
+		.npins = 1,
+	},
+	{
+		.name = "gpio_ts",
+		.pins = { RK817_GPIO_TS },
+		.npins = 1,
+	},
+	{
+		.name = "gpio_gt",
+		.pins = { RK817_GPIO_GT },
+		.npins = 1,
+	}
+};
+
+#define RK817_GPIOTS_VAL_MSK	BIT(3)
+#define RK817_GPIOGT_VAL_MSK	BIT(6)
+#define RK817_GPIOTS_FUNC_MSK	BIT(2)
+#define RK817_GPIOGT_FUNC_MSK	BIT(5)
+#define RK817_GPIOTS_DIR_MSK	BIT(4)
+#define RK817_GPIOGT_DIR_MSK	BIT(7)
+
+static struct rk805_pin_config rk817_gpio_cfgs[] = {
+	{
+		.reg = RK817_SYS_CFG(3),
+		.val_msk = 0,
+		.fun_msk = RK817_SLPPIN_FUNC_MSK,
+		.dir_msk = 0
+	},
+	{
+		.reg = RK817_GPIO_INT_CFG,
+		.val_msk = RK817_GPIOTS_VAL_MSK,
+		.fun_msk = RK817_GPIOTS_FUNC_MSK,
+		.dir_msk = RK817_GPIOTS_DIR_MSK
+	},
+	{
+		.reg = RK817_GPIO_INT_CFG,
+		.val_msk = RK817_GPIOGT_VAL_MSK,
+		.fun_msk = RK817_GPIOGT_FUNC_MSK,
+		.dir_msk = RK817_GPIOGT_DIR_MSK
+	}
+};
+
+/* generic gpio chip */
+static int rk805_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	struct rk805_pctrl_info *pci = gpiochip_get_data(chip);
+	int ret, val;
+
+	if (!pci->pin_cfg[offset].val_msk) {
+		dev_dbg(pci->dev, "getting gpio%d value is not support\n",
+			offset);
+		return -1;
+	}
+
+	ret = regmap_read(pci->rk808->regmap, pci->pin_cfg[offset].reg, &val);
+	if (ret) {
+		dev_err(pci->dev, "get gpio%d value failed\n", offset);
+		return ret;
+	}
+
+	return !!(val & pci->pin_cfg[offset].val_msk);
+}
+
+static void rk805_gpio_set(struct gpio_chip *chip,
+			   unsigned int offset,
+			   int value)
+{
+	struct rk805_pctrl_info *pci = gpiochip_get_data(chip);
+	int ret;
+
+	if (!pci->pin_cfg[offset].val_msk)
+		return;
+
+	ret = regmap_update_bits(pci->rk808->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].val_msk,
+				 value ? pci->pin_cfg[offset].val_msk : 0);
+	if (ret)
+		dev_err(pci->dev, "set gpio%d value %d failed\n",
+			offset, value);
+}
+
+static int rk805_gpio_direction_input(struct gpio_chip *chip,
+				      unsigned int offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int rk805_gpio_direction_output(struct gpio_chip *chip,
+				       unsigned int offset, int value)
+{
+	rk805_gpio_set(chip, offset, value);
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static int rk805_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
+{
+	struct rk805_pctrl_info *pci = gpiochip_get_data(chip);
+	unsigned int val;
+	int ret;
+
+	/* default output*/
+	if (!pci->pin_cfg[offset].dir_msk)
+		return 0;
+
+	ret = regmap_read(pci->rk808->regmap,
+			  pci->pin_cfg[offset].reg,
+			  &val);
+	if (ret) {
+		dev_err(pci->dev, "get gpio%d direction failed\n", offset);
+		return ret;
+	}
+
+	return !(val & pci->pin_cfg[offset].dir_msk);
+}
+
+static struct gpio_chip rk805_gpio_chip = {
+	.label			= "rk805-gpio",
+	.request		= gpiochip_generic_request,
+	.free			= gpiochip_generic_free,
+	.get_direction		= rk805_gpio_get_direction,
+	.get			= rk805_gpio_get,
+	.set			= rk805_gpio_set,
+	.direction_input	= rk805_gpio_direction_input,
+	.direction_output	= rk805_gpio_direction_output,
+	.can_sleep		= true,
+	.base			= -1,
+	.owner			= THIS_MODULE,
+};
+
+static struct gpio_chip rk817_gpio_chip = {
+	.label			= "rk817-gpio",
+	.request		= gpiochip_generic_request,
+	.free			= gpiochip_generic_free,
+	.get_direction		= rk805_gpio_get_direction,
+	.get			= rk805_gpio_get,
+	.set			= rk805_gpio_set,
+	.direction_input	= rk805_gpio_direction_input,
+	.direction_output	= rk805_gpio_direction_output,
+	.can_sleep		= true,
+	.base			= -1,
+	.owner			= THIS_MODULE,
+};
+
+/* generic pinctrl */
+static int rk805_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->num_pin_groups;
+}
+
+static const char *rk805_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+						unsigned int group)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->groups[group].name;
+}
+
+static int rk805_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+					unsigned int group,
+					const unsigned int **pins,
+					unsigned int *num_pins)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	*pins = pci->groups[group].pins;
+	*num_pins = pci->groups[group].npins;
+
+	return 0;
+}
+
+static const struct pinctrl_ops rk805_pinctrl_ops = {
+	.get_groups_count = rk805_pinctrl_get_groups_count,
+	.get_group_name = rk805_pinctrl_get_group_name,
+	.get_group_pins = rk805_pinctrl_get_group_pins,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+static int rk805_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->num_functions;
+}
+
+static const char *rk805_pinctrl_get_func_name(struct pinctrl_dev *pctldev,
+					       unsigned int function)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->functions[function].name;
+}
+
+static int rk805_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,
+					 unsigned int function,
+					 const char *const **groups,
+					 unsigned int *const num_groups)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups = pci->functions[function].groups;
+	*num_groups = pci->functions[function].ngroups;
+
+	return 0;
+}
+
+static int _rk805_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				  unsigned int offset,
+				  int mux)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	if (!pci->pin_cfg[offset].fun_msk)
+		return 0;
+
+	if (mux == RK805_PINMUX_GPIO)  {
+		ret = regmap_update_bits(pci->rk808->regmap,
+					 pci->pin_cfg[offset].reg,
+					 pci->pin_cfg[offset].fun_msk,
+					 pci->pin_cfg[offset].fun_msk);
+		if (ret) {
+			dev_err(pci->dev, "set gpio%d GPIO failed\n", offset);
+			return ret;
+		}
+	} else {
+		dev_err(pci->dev, "Couldn't find function mux %d\n", mux);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int _rk817_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				  unsigned int offset,
+				  int mux)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	if (!pci->pin_cfg[offset].fun_msk)
+		return 0;
+
+	mux <<= ffs(pci->pin_cfg[offset].fun_msk) - 1;
+	ret = regmap_update_bits(pci->rk808->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].fun_msk, mux);
+
+	if (ret)
+		dev_err(pci->dev, "set gpio%d func%d failed\n", offset, mux);
+
+	return ret;
+}
+
+static int rk805_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				 unsigned int function,
+				 unsigned int group)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int mux = pci->functions[function].mux_option;
+	int offset = group;
+
+	switch (pci->rk808->variant) {
+	case RK805_ID:
+		return _rk805_pinctrl_set_mux(pctldev, offset, mux);
+
+	case RK809_ID:
+	case RK817_ID:
+		return _rk817_pinctrl_set_mux(pctldev, offset, mux);
+	default:
+		dev_err(pci->dev, "Couldn't find the variant id\n");
+		return -EINVAL;
+	}
+}
+
+static int rk805_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+					struct pinctrl_gpio_range *range,
+					unsigned int offset, bool input)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	/* set direction */
+	if (!pci->pin_cfg[offset].dir_msk)
+		return 0;
+
+	ret = regmap_update_bits(pci->rk808->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].dir_msk,
+				 input ? 0 : pci->pin_cfg[offset].dir_msk);
+	if (ret) {
+		dev_err(pci->dev, "set gpio%d direction failed\n", offset);
+		return ret;
+	}
+
+	return ret;
+}
+
+static const struct pinmux_ops rk805_pinmux_ops = {
+	.get_functions_count	= rk805_pinctrl_get_funcs_count,
+	.get_function_name	= rk805_pinctrl_get_func_name,
+	.get_function_groups	= rk805_pinctrl_get_func_groups,
+	.set_mux		= rk805_pinctrl_set_mux,
+	.gpio_set_direction	= rk805_pmx_gpio_set_direction,
+};
+
+static int rk805_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned int pin, unsigned long *config)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param = pinconf_to_config_param(*config);
+	u32 arg = 0;
+
+	switch (param) {
+	case PIN_CONFIG_OUTPUT:
+		arg = rk805_gpio_get(&pci->gpio_chip, pin);
+		break;
+	default:
+		dev_err(pci->dev, "Properties not supported\n");
+		return -ENOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, (u16)arg);
+
+	return 0;
+}
+
+static int rk805_pinconf_set(struct pinctrl_dev *pctldev,
+			     unsigned int pin, unsigned long *configs,
+			     unsigned int num_configs)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param;
+	u32 i, arg = 0;
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+		case PIN_CONFIG_OUTPUT:
+			rk805_pmx_gpio_set_direction(pctldev, NULL, pin, false);
+			rk805_gpio_set(&pci->gpio_chip, pin, arg);
+			break;
+		case PIN_CONFIG_INPUT_ENABLE:
+			if (arg)
+				rk805_pmx_gpio_set_direction(pctldev, NULL,
+							     pin, true);
+			break;
+		default:
+			dev_err(pci->dev, "Properties not supported\n");
+			return -ENOTSUPP;
+		}
+	}
+
+	return 0;
+}
+
+static const struct pinconf_ops rk805_pinconf_ops = {
+	.pin_config_get = rk805_pinconf_get,
+	.pin_config_set = rk805_pinconf_set,
+};
+
+static struct pinctrl_desc rk805_pinctrl_desc = {
+	.name = "rk805-pinctrl",
+	.pctlops = &rk805_pinctrl_ops,
+	.pmxops = &rk805_pinmux_ops,
+	.confops = &rk805_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static struct pinctrl_desc rk817_pinctrl_desc = {
+	.name = "rk817-pinctrl",
+	.pctlops = &rk805_pinctrl_ops,
+	.pmxops = &rk805_pinmux_ops,
+	.confops = &rk805_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static int rk805_pinctrl_probe(struct platform_device *pdev)
+{
+	struct rk805_pctrl_info *pci;
+	struct device_node *np;
+	int ret;
+
+	pci = devm_kzalloc(&pdev->dev, sizeof(*pci), GFP_KERNEL);
+	if (!pci)
+		return -ENOMEM;
+
+	pci->dev = &pdev->dev;
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "pinctrl_rk8xx");
+	if (np)
+		pci->dev->of_node = np;
+	else
+		pci->dev->of_node = pdev->dev.parent->of_node;
+	pci->rk808 = dev_get_drvdata(pdev->dev.parent);
+
+	platform_set_drvdata(pdev, pci);
+
+	switch (pci->rk808->variant) {
+	case RK805_ID:
+		pci->pinctrl_desc = rk805_pinctrl_desc;
+		pci->gpio_chip = rk805_gpio_chip;
+		pci->pins = rk805_pins_desc;
+		pci->num_pins = ARRAY_SIZE(rk805_pins_desc);
+		pci->functions = rk805_pin_functions;
+		pci->num_functions = ARRAY_SIZE(rk805_pin_functions);
+		pci->groups = rk805_pin_groups;
+		pci->num_pin_groups = ARRAY_SIZE(rk805_pin_groups);
+		pci->pinctrl_desc.pins = rk805_pins_desc;
+		pci->pinctrl_desc.npins = ARRAY_SIZE(rk805_pins_desc);
+		pci->pin_cfg = rk805_gpio_cfgs;
+		pci->gpio_chip.ngpio = ARRAY_SIZE(rk805_gpio_cfgs);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		pci->pinctrl_desc = rk817_pinctrl_desc;
+		pci->gpio_chip = rk817_gpio_chip;
+		pci->pins = rk817_pins_desc;
+		pci->num_pins = ARRAY_SIZE(rk817_pins_desc);
+		pci->functions = rk817_pin_functions;
+		pci->num_functions = ARRAY_SIZE(rk817_pin_functions);
+		pci->groups = rk817_pin_groups;
+		pci->num_pin_groups = ARRAY_SIZE(rk817_pin_groups);
+		pci->pinctrl_desc.pins = rk817_pins_desc;
+		pci->pinctrl_desc.npins = ARRAY_SIZE(rk817_pins_desc);
+		pci->pin_cfg = rk817_gpio_cfgs;
+		pci->gpio_chip.ngpio = ARRAY_SIZE(rk817_gpio_cfgs);
+		/* for rk809 only a sleep pin */
+		if (pci->rk808->variant == RK809_ID) {
+			pci->pinctrl_desc.npins = 1;
+			pci->num_pin_groups = 1;
+			pci->num_pins = 1;
+			pci->gpio_chip.ngpio = 1;
+		}
+		break;
+	default:
+		dev_err(&pdev->dev, "unsupported RK805 ID %lu\n",
+			pci->rk808->variant);
+		return -EINVAL;
+	}
+
+	pci->gpio_chip.parent = &pdev->dev;
+
+	if (np)
+		pci->gpio_chip.of_node = np;
+	else
+		pci->gpio_chip.of_node = pdev->dev.parent->of_node;
+
+	/* Add gpiochip */
+	ret = devm_gpiochip_add_data(&pdev->dev, &pci->gpio_chip, pci);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Couldn't add gpiochip\n");
+		return ret;
+	}
+
+	/* Add pinctrl */
+	pci->pctl = devm_pinctrl_register(&pdev->dev, &pci->pinctrl_desc, pci);
+	if (IS_ERR(pci->pctl)) {
+		dev_err(&pdev->dev, "Couldn't add pinctrl\n");
+		return PTR_ERR(pci->pctl);
+	}
+
+	/* Add pin range */
+	ret = gpiochip_add_pin_range(&pci->gpio_chip, dev_name(&pdev->dev),
+				     0, 0, pci->gpio_chip.ngpio);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Couldn't add gpiochip pin range\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver rk805_pinctrl_driver = {
+	.probe = rk805_pinctrl_probe,
+	.driver = {
+		.name = "rk805-pinctrl",
+	},
+};
+
+static int __init rk805_pinctrl_driver_register(void)
+{
+	return platform_driver_register(&rk805_pinctrl_driver);
+}
+fs_initcall_sync(rk805_pinctrl_driver_register);
+
+MODULE_DESCRIPTION("RK805 pin control and GPIO driver");
+MODULE_AUTHOR("Joseph Chen <chenjh@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 0de9a958b29a..6eef9d9b996b 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -496,6 +496,22 @@ config BATTERY_RT5033
 	  The fuelgauge calculates and determines the battery state of charge
 	  according to battery open circuit voltage.
 
+config BATTERY_RK818
+	tristate "RK818 Battery driver"
+	depends on MFD_RK808
+	default n
+	help
+	  If you say yes here you will get support for the battery of RK818 PMIC.
+	  This driver can give support for Rk818 Battery Charge Interface.
+
+config CHARGER_RK818
+	tristate "RK818 Charger driver"
+	depends on MFD_RK808
+	default n
+	help
+	  If you say yes here you will get support for the charger of RK818 PMIC.
+	  This driver can give support for Rk818 Charger Interface.
+      
 config CHARGER_RT9455
 	tristate "Richtek RT9455 battery charger driver"
 	depends on I2C
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 36c599d9a495..3368abe76cc9 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -72,3 +72,5 @@ obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_CHARGER_TPS65217)	+= tps65217_charger.o
 obj-$(CONFIG_AXP288_FUEL_GAUGE) += axp288_fuel_gauge.o
 obj-$(CONFIG_AXP288_CHARGER)	+= axp288_charger.o
+obj-$(CONFIG_BATTERY_RK818)	+= rk818_battery.o
+obj-$(CONFIG_CHARGER_RK818)	+= rk818_charger.o
diff --git a/drivers/power/supply/rk818_battery.c b/drivers/power/supply/rk818_battery.c
new file mode 100644
index 000000000000..d3190bdfbd5c
--- /dev/null
+++ b/drivers/power/supply/rk818_battery.c
@@ -0,0 +1,3623 @@
+/*
+ * rk818 battery driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/gpio.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/iio.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/jiffies.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/power/rk_usbbc.h>
+#include <linux/regmap.h>
+#include <linux/rk_keys.h>
+#include <linux/rtc.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include "rk818_battery.h"
+
+static int dbg_enable = 0;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define BAT_INFO(fmt, args...) pr_info("rk818-bat: "fmt, ##args)
+
+/* default param */
+#define DEFAULT_BAT_RES			135
+#define DEFAULT_SLP_ENTER_CUR		300
+#define DEFAULT_SLP_EXIT_CUR		300
+#define DEFAULT_SLP_FILTER_CUR		100
+#define DEFAULT_PWROFF_VOL_THRESD	3400
+#define DEFAULT_MONITOR_SEC		5
+#define DEFAULT_ALGR_VOL_THRESD1	3850
+#define DEFAULT_ALGR_VOL_THRESD2	3950
+#define DEFAULT_MAX_SOC_OFFSET		60
+#define DEFAULT_FB_TEMP			TEMP_105C
+#define DEFAULT_ZERO_RESERVE_DSOC	10
+#define DEFAULT_POFFSET			42
+#define DEFAULT_COFFSET			0x832
+#define DEFAULT_SAMPLE_RES		20
+#define DEFAULT_ENERGY_MODE		0
+#define INVALID_COFFSET_MIN		0x780
+#define INVALID_COFFSET_MAX		0x980
+#define INVALID_VOL_THRESD		2500
+
+/* sample resistor and division */
+#define SAMPLE_RES_10MR			10
+#define SAMPLE_RES_20MR			20
+#define SAMPLE_RES_DIV1			1
+#define SAMPLE_RES_DIV2			2
+
+/* virtual params */
+#define VIRTUAL_CURRENT			1000
+#define VIRTUAL_VOLTAGE			3888
+#define VIRTUAL_SOC			66
+#define VIRTUAL_PRESET			1
+#define VIRTUAL_TEMPERATURE		188
+#define VIRTUAL_STATUS			POWER_SUPPLY_STATUS_CHARGING
+
+/* charge */
+#define FINISH_CHRG_CUR1			1000
+#define FINISH_CHRG_CUR2		1500
+#define FINISH_MAX_SOC_DELAY		20
+#define TERM_CHRG_DSOC			88
+#define TERM_CHRG_CURR			600
+#define TERM_CHRG_K			650
+#define SIMULATE_CHRG_INTV		8
+#define SIMULATE_CHRG_CURR		400
+#define SIMULATE_CHRG_K			1500
+#define FULL_CHRG_K			400
+
+/* zero algorithm */
+#define PWROFF_THRESD			3400
+#define MIN_ZERO_DSOC_ACCURACY		10	/*0.01%*/
+#define MIN_ZERO_OVERCNT		100
+#define MIN_ACCURACY			1
+#define DEF_PWRPATH_RES			50
+#define	WAIT_DSOC_DROP_SEC		15
+#define	WAIT_SHTD_DROP_SEC		30
+#define ZERO_GAP_XSOC1			10
+#define ZERO_GAP_XSOC2			5
+#define ZERO_GAP_XSOC3			3
+#define ZERO_LOAD_LVL1			1400
+#define ZERO_LOAD_LVL2			600
+#define ZERO_GAP_CALIB			5
+
+#define ADC_CALIB_THRESHOLD		4
+#define ADC_CALIB_LMT_MIN		3
+#define ADC_CALIB_CNT			5
+#define NTC_CALC_FACTOR			7
+
+/* time */
+#define	POWER_ON_SEC_BASE		1
+#define MINUTE(x)			((x) * 60)
+
+/* sleep */
+#define SLP_CURR_MAX			40
+#define SLP_CURR_MIN			6
+#define DISCHRG_TIME_STEP1		MINUTE(10)
+#define DISCHRG_TIME_STEP2		MINUTE(60)
+#define SLP_DSOC_VOL_THRESD		3600
+#define REBOOT_PERIOD_SEC		180
+#define REBOOT_MAX_CNT			80
+
+/* fcc */
+#define MIN_FCC				500
+
+/* TS detect battery temperature */
+#define ADC_CUR_MSK			0x03
+#define ADC_CUR_20UA			0x00
+#define ADC_CUR_40UA			0x01
+#define ADC_CUR_60UA			0x02
+#define ADC_CUR_80UA			0x03
+
+#define NTC_CALC_FACTOR_80UA		7
+#define NTC_CALC_FACTOR_60UA		9
+#define NTC_CALC_FACTOR_40UA		13
+#define NTC_CALC_FACTOR_20UA		27
+#define NTC_80UA_MAX_MEASURE		27500
+#define NTC_60UA_MAX_MEASURE		36666
+#define NTC_40UA_MAX_MEASURE		55000
+#define NTC_20UA_MAX_MEASURE		110000
+
+#define INPUT_CUR80MA			(0x01)
+
+static const char *bat_status[] = {
+	"charge off", "dead charge", "trickle charge", "cc cv",
+	"finish", "usb over vol", "bat temp error", "timer error",
+};
+
+struct rk818_battery {
+	struct platform_device		*pdev;
+	struct rk808			*rk818;
+	struct i2c_client		*client;
+	struct regmap			*regmap;
+	struct device			*dev;
+	struct power_supply		*bat;
+	struct power_supply		*usb_psy;
+	struct power_supply		*ac_psy;
+	struct battery_platform_data	*pdata;
+	struct workqueue_struct		*bat_monitor_wq;
+	struct delayed_work		bat_delay_work;
+	struct delayed_work		calib_delay_work;
+	struct notifier_block           fb_nb;
+	struct timer_list		caltimer;
+	time_t				rtc_base;
+	int				bat_res;
+	int				chrg_status;
+	bool				is_initialized;
+	bool				is_first_power_on;
+	u8				res_div;
+	int				current_max;
+	int				voltage_max;
+	int				current_avg;
+	int				voltage_avg;
+	int				voltage_ocv;
+	int				voltage_relax;
+	int				voltage_k;
+	int				voltage_b;
+	int				remain_cap;
+	int				design_cap;
+	int				nac;
+	int				fcc;
+	int				qmax;
+	int				dsoc;
+	int				rsoc;
+	int				poffset;
+	int				age_ocv_soc;
+	bool				age_allow_update;
+	int				age_level;
+	int				age_ocv_cap;
+	int				age_voltage;
+	int				age_adjust_cap;
+	unsigned long			age_keep_sec;
+	int				zero_timeout_cnt;
+	int				zero_remain_cap;
+	int				zero_dsoc;
+	int				zero_linek;
+	u64				zero_drop_sec;
+	u64				shtd_drop_sec;
+	int				sm_remain_cap;
+	int				sm_linek;
+	int				sm_chrg_dsoc;
+	int				sm_dischrg_dsoc;
+	int				algo_rest_val;
+	int				algo_rest_mode;
+	int				sleep_sum_cap;
+	int				sleep_remain_cap;
+	unsigned long			sleep_dischrg_sec;
+	unsigned long			sleep_sum_sec;
+	bool				sleep_chrg_online;
+	u8				sleep_chrg_status;
+	bool				adc_allow_update;
+	int                             fb_blank;
+	bool				s2r; /*suspend to resume*/
+	u32				work_mode;
+	int				temperature;
+	u32				monitor_ms;
+	u32				pwroff_min;
+	u32				adc_calib_cnt;
+	unsigned long			finish_base;
+	unsigned long			boot_base;
+	unsigned long			flat_match_sec;
+	unsigned long			plug_in_base;
+	unsigned long			plug_out_base;
+	u8				halt_cnt;
+	bool				is_halt;
+	bool				is_max_soc_offset;
+	bool				is_sw_reset;
+	bool				is_ocv_calib;
+	bool				is_first_on;
+	bool				is_force_calib;
+	int				last_dsoc;
+	int				ocv_pre_dsoc;
+	int				ocv_new_dsoc;
+	int				max_pre_dsoc;
+	int				max_new_dsoc;
+	int				force_pre_dsoc;
+	int				force_new_dsoc;
+	int				dbg_cap_low0;
+	int				dbg_pwr_dsoc;
+	int				dbg_pwr_rsoc;
+	int				dbg_pwr_vol;
+	int				dbg_chrg_min[10];
+	int				dbg_meet_soc;
+	int				dbg_calc_dsoc;
+	int				dbg_calc_rsoc;
+	u8				ac_in;
+	u8				usb_in;
+	int				is_charging;
+	unsigned long			charge_count;
+};
+
+#define DIV(x)	((x) ? (x) : 1)
+
+static u64 get_boot_sec(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return ts.tv_sec;
+}
+
+static unsigned long base2sec(unsigned long x)
+{
+	if (x)
+		return (get_boot_sec() > x) ? (get_boot_sec() - x) : 0;
+	else
+		return 0;
+}
+
+static unsigned long base2min(unsigned long x)
+{
+	return base2sec(x) / 60;
+}
+
+static u32 interpolate(int value, u32 *table, int size)
+{
+	u8 i;
+	u16 d;
+
+	for (i = 0; i < size; i++) {
+		if (value < table[i])
+			break;
+	}
+
+	if ((i > 0) && (i < size)) {
+		d = (value - table[i - 1]) * (MAX_INTERPOLATE / (size - 1));
+		d /= table[i] - table[i - 1];
+		d = d + (i - 1) * (MAX_INTERPOLATE / (size - 1));
+	} else {
+		d = i * ((MAX_INTERPOLATE + size / 2) / size);
+	}
+
+	if (d > 1000)
+		d = 1000;
+
+	return d;
+}
+
+/* (a*b)/c */
+static int32_t ab_div_c(u32 a, u32 b, u32 c)
+{
+	bool sign;
+	u32 ans = MAX_INT;
+	int tmp;
+
+	sign = ((((a ^ b) ^ c) & 0x80000000) != 0);
+	if (c != 0) {
+		if (sign)
+			c = -c;
+		tmp = (a * b + (c >> 1)) / c;
+		if (tmp < MAX_INT)
+			ans = tmp;
+	}
+
+	if (sign)
+		ans = -ans;
+
+	return ans;
+}
+
+static int rk818_bat_read(struct rk818_battery *di, u8 reg)
+{
+	int ret, val;
+
+	ret = regmap_read(di->regmap, reg, &val);
+	if (ret)
+		dev_err(di->dev, "read reg:0x%x failed\n", reg);
+
+	return val;
+}
+
+static int rk818_bat_write(struct rk818_battery *di, u8 reg, u8 buf)
+{
+	int ret;
+
+	ret = regmap_write(di->regmap, reg, buf);
+	if (ret)
+		dev_err(di->dev, "i2c write reg: 0x%2x error\n", reg);
+
+	return ret;
+}
+
+static int rk818_bat_set_bits(struct rk818_battery *di, u8 reg, u8 mask, u8 buf)
+{
+	int ret;
+
+	ret = regmap_update_bits(di->regmap, reg, mask, buf);
+	if (ret)
+		dev_err(di->dev, "write reg:0x%x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_bat_clear_bits(struct rk818_battery *di, u8 reg, u8 mask)
+{
+	int ret;
+
+	ret = regmap_update_bits(di->regmap, reg, mask, 0);
+	if (ret)
+		dev_err(di->dev, "clr reg:0x%02x failed\n", reg);
+
+	return ret;
+}
+
+static void rk818_bat_dump_regs(struct rk818_battery *di, u8 start, u8 end)
+{
+	int i;
+
+	if (!dbg_enable)
+		return;
+
+	DBG("dump regs from: 0x%x-->0x%x\n", start, end);
+	for (i = start; i < end; i++)
+		DBG("0x%x: 0x%0x\n", i, rk818_bat_read(di, i));
+}
+
+static bool rk818_bat_chrg_online(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_VB_MON_REG);
+
+	return (buf & PLUG_IN_STS) ? true : false;
+}
+
+static int rk818_bat_get_coulomb_cap(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_GASCNT3_REG) << 24;
+	val |= rk818_bat_read(di, RK818_GASCNT2_REG) << 16;
+	val |= rk818_bat_read(di, RK818_GASCNT1_REG) << 8;
+	val |= rk818_bat_read(di, RK818_GASCNT0_REG) << 0;
+
+	return (val / 2390) * di->res_div;
+}
+
+static int rk818_bat_get_rsoc(struct rk818_battery *di)
+{
+	int remain_cap;
+
+	remain_cap = rk818_bat_get_coulomb_cap(di);
+	return (remain_cap + di->fcc / 200) * 100 / DIV(di->fcc);
+}
+
+static ssize_t bat_info_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	char cmd;
+	struct rk818_battery *di = dev_get_drvdata(dev);
+
+	sscanf(buf, "%c", &cmd);
+
+	if (cmd == 'n')
+		rk818_bat_set_bits(di, RK818_MISC_MARK_REG,
+				   FG_RESET_NOW, FG_RESET_NOW);
+	else if (cmd == 'm')
+		rk818_bat_set_bits(di, RK818_MISC_MARK_REG,
+				   FG_RESET_LATE, FG_RESET_LATE);
+	else if (cmd == 'c')
+		rk818_bat_clear_bits(di, RK818_MISC_MARK_REG,
+				     FG_RESET_LATE | FG_RESET_NOW);
+	else if (cmd == 'r')
+		BAT_INFO("0x%2x\n", rk818_bat_read(di, RK818_MISC_MARK_REG));
+	else
+		BAT_INFO("command error\n");
+
+	return count;
+}
+
+static struct device_attribute rk818_bat_attr[] = {
+	__ATTR(bat, 0664, NULL, bat_info_store),
+};
+
+static void rk818_bat_enable_gauge(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf |= GG_EN;
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+}
+
+static void rk818_bat_save_age_level(struct rk818_battery *di, u8 level)
+{
+	rk818_bat_write(di, RK818_UPDAT_LEVE_REG, level);
+}
+
+static u8 rk818_bat_get_age_level(struct  rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_UPDAT_LEVE_REG);
+}
+
+static int rk818_bat_get_vcalib0(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_VCALIB0_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_VCALIB0_REGH) << 8;
+
+	DBG("<%s>. voffset0: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_vcalib1(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_VCALIB1_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_VCALIB1_REGH) << 8;
+
+	DBG("<%s>. voffset1: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_ioffset(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_IOFFSET_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_IOFFSET_REGH) << 8;
+
+	DBG("<%s>. ioffset: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_coffset(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_CAL_OFFSET_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_CAL_OFFSET_REGH) << 8;
+
+	DBG("<%s>. coffset: 0x%x\n", __func__, val);
+	return val;
+}
+
+static void rk818_bat_set_coffset(struct rk818_battery *di, int val)
+{
+	u8 buf;
+
+	if ((val < INVALID_COFFSET_MIN) || (val > INVALID_COFFSET_MAX)) {
+		BAT_INFO("set invalid coffset=0x%x\n", val);
+		return;
+	}
+
+	buf = (val >> 8) & 0xff;
+	rk818_bat_write(di, RK818_CAL_OFFSET_REGH, buf);
+	buf = (val >> 0) & 0xff;
+	rk818_bat_write(di, RK818_CAL_OFFSET_REGL, buf);
+	DBG("<%s>. coffset: 0x%x\n", __func__, val);
+}
+
+static void rk818_bat_init_voltage_kb(struct rk818_battery *di)
+{
+	int vcalib0, vcalib1;
+
+	vcalib0 = rk818_bat_get_vcalib0(di);
+	vcalib1 = rk818_bat_get_vcalib1(di);
+	di->voltage_k = (4200 - 3000) * 1000 / DIV(vcalib1 - vcalib0);
+	di->voltage_b = 4200 - (di->voltage_k * vcalib1) / 1000;
+
+	DBG("voltage_k=%d(*1000),voltage_b=%d\n", di->voltage_k, di->voltage_b);
+}
+
+static int rk818_bat_get_ocv_voltage(struct rk818_battery *di)
+{
+	int vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_OCV_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_OCV_REGH) << 8;
+
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static int rk818_bat_get_avg_voltage(struct rk818_battery *di)
+{
+	int vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_VOL_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_VOL_REGH) << 8;
+
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static bool is_rk818_bat_relax_mode(struct rk818_battery *di)
+{
+	u8 status;
+
+	status = rk818_bat_read(di, RK818_GGSTS_REG);
+	if (!(status & RELAX_VOL1_UPD) || !(status & RELAX_VOL2_UPD))
+		return false;
+	else
+		return true;
+}
+
+static u16 rk818_bat_get_relax_vol1(struct rk818_battery *di)
+{
+	u16 vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_RELAX_VOL1_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_RELAX_VOL1_REGH) << 8;
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static u16 rk818_bat_get_relax_vol2(struct rk818_battery *di)
+{
+	u16 vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_RELAX_VOL2_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_RELAX_VOL2_REGH) << 8;
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static u16 rk818_bat_get_relax_voltage(struct rk818_battery *di)
+{
+	u16 relax_vol1, relax_vol2;
+
+	if (!is_rk818_bat_relax_mode(di))
+		return 0;
+
+	relax_vol1 = rk818_bat_get_relax_vol1(di);
+	relax_vol2 = rk818_bat_get_relax_vol2(di);
+
+	return relax_vol1 > relax_vol2 ? relax_vol1 : relax_vol2;
+}
+
+static int rk818_bat_get_avg_current(struct rk818_battery *di)
+{
+	int cur, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGH) << 8;
+
+	if (val & 0x800)
+		val -= 4096;
+	cur = val * di->res_div * 1506 / 1000;
+
+	return cur;
+}
+
+static int rk818_bat_vol_to_ocvsoc(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, ocv_soc;
+
+	ocv_table = di->pdata->ocv_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	ocv_soc = ab_div_c(temp, MAX_PERCENTAGE, MAX_INTERPOLATE);
+
+	return ocv_soc;
+}
+
+static int rk818_bat_vol_to_ocvcap(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, cap;
+
+	ocv_table = di->pdata->ocv_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	cap = ab_div_c(temp, di->fcc, MAX_INTERPOLATE);
+
+	return cap;
+}
+
+static int rk818_bat_vol_to_zerosoc(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, ocv_soc;
+
+	ocv_table = di->pdata->zero_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	ocv_soc = ab_div_c(temp, MAX_PERCENTAGE, MAX_INTERPOLATE);
+
+	return ocv_soc;
+}
+
+static int rk818_bat_vol_to_zerocap(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, cap;
+
+	ocv_table = di->pdata->zero_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	cap = ab_div_c(temp, di->fcc, MAX_INTERPOLATE);
+
+	return cap;
+}
+
+static int rk818_bat_get_iadc(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGH) << 8;
+	if (val > 2047)
+		val -= 4096;
+
+	return val;
+}
+
+static bool rk818_bat_adc_calib(struct rk818_battery *di)
+{
+	int i, ioffset, coffset, adc, save_coffset;
+
+	if ((di->chrg_status != CHARGE_FINISH) ||
+	    (di->adc_calib_cnt > ADC_CALIB_CNT) ||
+	    (base2min(di->boot_base) < ADC_CALIB_LMT_MIN) ||
+	    (abs(di->current_avg) < ADC_CALIB_THRESHOLD))
+		return false;
+
+	di->adc_calib_cnt++;
+	save_coffset = rk818_bat_get_coffset(di);
+	for (i = 0; i < 5; i++) {
+		adc = rk818_bat_get_iadc(di);
+		if (!rk818_bat_chrg_online(di)) {
+			rk818_bat_set_coffset(di, save_coffset);
+			BAT_INFO("quit, charger plugout when calib adc\n");
+			return false;
+		}
+		coffset = rk818_bat_get_coffset(di);
+		rk818_bat_set_coffset(di, coffset + adc);
+		msleep(2000);
+		adc = rk818_bat_get_iadc(di);
+		if (abs(adc) < ADC_CALIB_THRESHOLD) {
+			coffset = rk818_bat_get_coffset(di);
+			ioffset = rk818_bat_get_ioffset(di);
+			di->poffset = coffset - ioffset;
+			rk818_bat_write(di, RK818_POFFSET_REG, di->poffset);
+			BAT_INFO("new offset:c=0x%x, i=0x%x, p=0x%x\n",
+				 coffset, ioffset, di->poffset);
+			return true;
+		} else {
+			BAT_INFO("coffset calib again %d.., max_cnt=%d\n",
+				 i, di->adc_calib_cnt);
+			rk818_bat_set_coffset(di, coffset);
+			msleep(2000);
+		}
+	}
+
+	rk818_bat_set_coffset(di, save_coffset);
+
+	return false;
+}
+
+static void rk818_bat_set_ioffset_sample(struct rk818_battery *di)
+{
+	u8 ggcon;
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggcon &= ~ADC_CAL_MIN_MSK;
+	ggcon |= ADC_CAL_8MIN;
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+}
+
+static void rk818_bat_set_ocv_sample(struct rk818_battery *di)
+{
+	u8 ggcon;
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggcon &= ~OCV_SAMP_MIN_MSK;
+	ggcon |= OCV_SAMP_8MIN;
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+}
+
+static void rk818_bat_restart_relax(struct rk818_battery *di)
+{
+	u8 ggsts;
+
+	ggsts = rk818_bat_read(di, RK818_GGSTS_REG);
+	ggsts &= ~RELAX_VOL12_UPD_MSK;
+	rk818_bat_write(di, RK818_GGSTS_REG, ggsts);
+}
+
+static void rk818_bat_set_relax_sample(struct rk818_battery *di)
+{
+	u8 buf;
+	int enter_thres, exit_thres;
+	struct battery_platform_data *pdata = di->pdata;
+
+	enter_thres = pdata->sleep_enter_current * 1000 / 1506 / DIV(di->res_div);
+	exit_thres = pdata->sleep_exit_current * 1000 / 1506 / DIV(di->res_div);
+
+	/* set relax enter and exit threshold */
+	buf = enter_thres & 0xff;
+	rk818_bat_write(di, RK818_RELAX_ENTRY_THRES_REGL, buf);
+	buf = (enter_thres >> 8) & 0xff;
+	rk818_bat_write(di, RK818_RELAX_ENTRY_THRES_REGH, buf);
+
+	buf = exit_thres & 0xff;
+	rk818_bat_write(di, RK818_RELAX_EXIT_THRES_REGL, buf);
+	buf = (exit_thres >> 8) & 0xff;
+	rk818_bat_write(di, RK818_RELAX_EXIT_THRES_REGH, buf);
+
+	/* reset relax update state */
+	rk818_bat_restart_relax(di);
+	DBG("<%s>. sleep_enter_current = %d, sleep_exit_current = %d\n",
+	    __func__, pdata->sleep_enter_current, pdata->sleep_exit_current);
+}
+
+static bool is_rk818_bat_exist(struct rk818_battery *di)
+{
+	return (rk818_bat_read(di, RK818_SUP_STS_REG) & BAT_EXS) ? true : false;
+}
+
+static bool is_rk818_bat_first_pwron(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_GGSTS_REG);
+	buf &= ~BAT_CON;
+	rk818_bat_write(di, RK818_GGSTS_REG, buf);
+	return true;
+}
+
+static u8 rk818_bat_get_pwroff_min(struct rk818_battery *di)
+{
+	u8 cur, last;
+
+	cur = rk818_bat_read(di, RK818_NON_ACT_TIMER_CNT_REG);
+	last = rk818_bat_read(di, RK818_NON_ACT_TIMER_CNT_SAVE_REG);
+	rk818_bat_write(di, RK818_NON_ACT_TIMER_CNT_SAVE_REG, cur);
+
+	return (cur != last) ? cur : 0;
+}
+
+static u8 is_rk818_bat_initialized(struct rk818_battery *di)
+{
+	u8 val = rk818_bat_read(di, RK818_MISC_MARK_REG);
+
+	if (val & FG_INIT) {
+		val &= ~FG_INIT;
+		rk818_bat_write(di, RK818_MISC_MARK_REG, val);
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static bool is_rk818_bat_ocv_valid(struct rk818_battery *di)
+{
+	return (!di->is_initialized && di->pwroff_min >= 30) ? true : false;
+}
+
+static void rk818_bat_init_age_algorithm(struct rk818_battery *di)
+{
+	int age_level, ocv_soc, ocv_cap, ocv_vol;
+
+	if (di->is_first_power_on || is_rk818_bat_ocv_valid(di)) {
+		DBG("<%s> enter.\n", __func__);
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		if (ocv_soc < 20) {
+			di->age_voltage = ocv_vol;
+			di->age_ocv_cap = ocv_cap;
+			di->age_ocv_soc = ocv_soc;
+			di->age_adjust_cap = 0;
+
+			if (ocv_soc <= 0)
+				di->age_level = 100;
+			else if (ocv_soc < 5)
+				di->age_level = 95;
+			else if (ocv_soc < 10)
+				di->age_level = 90;
+			else
+				di->age_level = 80;
+
+			age_level = rk818_bat_get_age_level(di);
+			if (age_level > di->age_level) {
+				di->age_allow_update = false;
+				age_level -= 5;
+				if (age_level <= 80)
+					age_level = 80;
+				rk818_bat_save_age_level(di, age_level);
+			} else {
+				di->age_allow_update = true;
+				di->age_keep_sec = get_boot_sec();
+			}
+
+			BAT_INFO("init_age_algorithm: "
+				 "age_vol:%d, age_ocv_cap:%d, "
+				 "age_ocv_soc:%d, old_age_level:%d, "
+				 "age_allow_update:%d, new_age_level:%d\n",
+				 di->age_voltage, di->age_ocv_cap,
+				 ocv_soc, age_level, di->age_allow_update,
+				 di->age_level);
+		}
+	}
+}
+
+static enum power_supply_property rk818_bat_props[] = {
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+static int rk818_bat_get_usb_psy(struct device *dev, void *data)
+{
+	struct rk818_battery *di = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_USB) {
+		di->usb_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int rk818_bat_get_ac_psy(struct device *dev, void *data)
+{
+	struct rk818_battery *di = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_MAINS) {
+		di->ac_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void rk818_bat_get_chrg_psy(struct rk818_battery *di)
+{
+	if (!di->usb_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)di,
+				      rk818_bat_get_usb_psy);
+	if (!di->ac_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)di,
+				      rk818_bat_get_ac_psy);
+}
+
+static int rk818_bat_get_charge_state(struct rk818_battery *di)
+{
+	union power_supply_propval val;
+	int ret;
+
+	if (!di->usb_psy || !di->ac_psy)
+		rk818_bat_get_chrg_psy(di);
+
+	if (di->usb_psy) {
+		ret = di->usb_psy->desc->get_property(di->usb_psy,
+						      POWER_SUPPLY_PROP_ONLINE,
+						      &val);
+		if (!ret)
+			di->usb_in = val.intval;
+	}
+
+	if (di->ac_psy) {
+		ret = di->ac_psy->desc->get_property(di->ac_psy,
+						     POWER_SUPPLY_PROP_ONLINE,
+						     &val);
+		if (!ret)
+			di->ac_in = val.intval;
+	}
+
+	DBG("%s: ac_online=%d, usb_online=%d\n",
+	    __func__, di->ac_in, di->usb_in);
+
+	return (di->usb_in || di->ac_in);
+}
+
+static int rk818_get_capacity_leve(struct rk818_battery *di)
+{
+	if (di->pdata->bat_mode == MODE_VIRTUAL)
+		return POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;
+
+	if (di->dsoc < 1)
+		return POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;
+	else if (di->dsoc <= 20)
+		return POWER_SUPPLY_CAPACITY_LEVEL_LOW;
+	else if (di->dsoc <= 70)
+		return POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;
+	else if (di->dsoc <= 90)
+		return POWER_SUPPLY_CAPACITY_LEVEL_HIGH;
+	else
+		return POWER_SUPPLY_CAPACITY_LEVEL_FULL;
+}
+
+static int rk818_battery_time_to_full(struct rk818_battery *di)
+{
+	int time_sec;
+	int cap_temp;
+
+	if (di->pdata->bat_mode == MODE_VIRTUAL) {
+		time_sec = 3600;
+	} else if (di->voltage_avg > 0) {
+		cap_temp = di->pdata->design_capacity - di->remain_cap;
+		if (cap_temp < 0)
+			cap_temp = 0;
+		time_sec = (3600 * cap_temp) / di->voltage_avg;
+	} else {
+		time_sec = 3600 * 24; /* One day */
+	}
+
+	return time_sec;
+}
+
+static int rk818_battery_get_property(struct power_supply *psy,
+				      enum power_supply_property psp,
+				      union power_supply_propval *val)
+{
+	struct rk818_battery *di = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = di->current_avg * 1000;/*uA*/
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_CURRENT * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = di->voltage_avg * 1000;/*uV*/
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_VOLTAGE * 1000;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = is_rk818_bat_exist(di);
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_PRESET;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = di->dsoc;
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_SOC;
+		DBG("<%s>. report dsoc: %d\n", __func__, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		val->intval = rk818_get_capacity_leve(di);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = di->temperature;
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_TEMPERATURE;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_STATUS;
+		else if (di->dsoc == 100)
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if (rk818_bat_get_charge_state(di))
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		val->intval = di->charge_count;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = di->pdata->design_capacity * 1000;/* uAh */
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		val->intval = rk818_battery_time_to_full(di);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = di->voltage_max;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = di->current_max;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct power_supply_desc rk818_bat_desc = {
+	.name		= "battery",
+	.type		= POWER_SUPPLY_TYPE_BATTERY,
+	.properties	= rk818_bat_props,
+	.num_properties	= ARRAY_SIZE(rk818_bat_props),
+	.get_property	= rk818_battery_get_property,
+};
+
+static int rk818_bat_init_power_supply(struct rk818_battery *di)
+{
+	struct power_supply_config psy_cfg = { .drv_data = di, };
+
+	di->bat = devm_power_supply_register(di->dev, &rk818_bat_desc, &psy_cfg);
+	if (IS_ERR(di->bat)) {
+		dev_err(di->dev, "register bat power supply fail\n");
+		return PTR_ERR(di->bat);
+	}
+
+	return 0;
+}
+
+static void rk818_bat_save_cap(struct rk818_battery *di, int cap)
+{
+	u8 buf;
+	static u32 old_cap;
+
+	if (cap >= di->qmax)
+		cap = di->qmax;
+	if (cap <= 0)
+		cap = 0;
+	if (old_cap == cap)
+		return;
+
+	old_cap = cap;
+	buf = (cap >> 24) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG3, buf);
+	buf = (cap >> 16) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG2, buf);
+	buf = (cap >> 8) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG1, buf);
+	buf = (cap >> 0) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG0, buf);
+}
+
+static int rk818_bat_get_prev_cap(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG3) << 24;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG2) << 16;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG1) << 8;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG0) << 0;
+
+	return val;
+}
+
+static void rk818_bat_save_fcc(struct rk818_battery *di, u32 fcc)
+{
+	u8 buf;
+
+	buf = (fcc >> 24) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG3, buf);
+	buf = (fcc >> 16) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG2, buf);
+	buf = (fcc >> 8) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG1, buf);
+	buf = (fcc >> 0) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG0, buf);
+
+	BAT_INFO("save fcc: %d\n", fcc);
+}
+
+static int rk818_bat_get_fcc(struct rk818_battery *di)
+{
+	u32 fcc = 0;
+
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG3) << 24;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG2) << 16;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG1) << 8;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG0) << 0;
+
+	if (fcc < MIN_FCC) {
+		BAT_INFO("invalid fcc(%d), use design cap", fcc);
+		fcc = di->pdata->design_capacity;
+		rk818_bat_save_fcc(di, fcc);
+	} else if (fcc > di->pdata->design_qmax) {
+		BAT_INFO("invalid fcc(%d), use qmax", fcc);
+		fcc = di->pdata->design_qmax;
+		rk818_bat_save_fcc(di, fcc);
+	}
+
+	return fcc;
+}
+
+static void rk818_bat_init_coulomb_cap(struct rk818_battery *di, u32 capacity)
+{
+	u8 buf;
+	u32 cap;
+
+	cap = capacity * 2390 / DIV(di->res_div);
+	buf = (cap >> 24) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG3, buf);
+	buf = (cap >> 16) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG2, buf);
+	buf = (cap >> 8) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG1, buf);
+	buf = ((cap >> 0) & 0xff);
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG0, buf);
+
+	DBG("<%s>. new coulomb cap = %d\n", __func__, capacity);
+	di->remain_cap = capacity;
+	di->rsoc = rk818_bat_get_rsoc(di);
+}
+
+static void rk818_bat_save_dsoc(struct rk818_battery *di, u8 save_soc)
+{
+	static int last_soc = -1;
+
+	if (last_soc != save_soc) {
+		rk818_bat_write(di, RK818_SOC_REG, save_soc);
+		last_soc = save_soc;
+	}
+}
+
+static int rk818_bat_get_prev_dsoc(struct rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_SOC_REG);
+}
+
+static void rk818_bat_save_reboot_cnt(struct rk818_battery *di, u8 save_cnt)
+{
+	rk818_bat_write(di, RK818_REBOOT_CNT_REG, save_cnt);
+}
+
+static int rk818_bat_fb_notifier(struct notifier_block *nb,
+				 unsigned long event, void *data)
+{
+	struct rk818_battery *di;
+	struct fb_event *evdata = data;
+
+	if (event != FB_EARLY_EVENT_BLANK && event != FB_EVENT_BLANK)
+		return NOTIFY_OK;
+
+	di = container_of(nb, struct rk818_battery, fb_nb);
+	di->fb_blank = *(int *)evdata->data;
+
+	return 0;
+}
+
+static int rk818_bat_register_fb_notify(struct rk818_battery *di)
+{
+	memset(&di->fb_nb, 0, sizeof(di->fb_nb));
+	di->fb_nb.notifier_call = rk818_bat_fb_notifier;
+
+	return fb_register_client(&di->fb_nb);
+}
+
+static int rk818_bat_unregister_fb_notify(struct rk818_battery *di)
+{
+	return fb_unregister_client(&di->fb_nb);
+}
+
+static u8 rk818_bat_get_halt_cnt(struct rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_HALT_CNT_REG);
+}
+
+static void rk818_bat_inc_halt_cnt(struct rk818_battery *di)
+{
+	u8 cnt;
+
+	cnt = rk818_bat_read(di, RK818_HALT_CNT_REG);
+	rk818_bat_write(di, RK818_HALT_CNT_REG, ++cnt);
+}
+
+static bool is_rk818_bat_last_halt(struct rk818_battery *di)
+{
+	int pre_cap = rk818_bat_get_prev_cap(di);
+	int now_cap = rk818_bat_get_coulomb_cap(di);
+
+	/* over 10%: system halt last time */
+	if (abs(now_cap - pre_cap) > (di->fcc / 10)) {
+		rk818_bat_inc_halt_cnt(di);
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void rk818_bat_first_pwron(struct rk818_battery *di)
+{
+	int ocv_vol;
+
+	rk818_bat_save_fcc(di, di->design_cap);
+	ocv_vol = rk818_bat_get_ocv_voltage(di);
+	di->fcc = rk818_bat_get_fcc(di);
+	di->nac = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+	di->rsoc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+	di->dsoc = di->rsoc;
+	di->is_first_on = true;
+
+	DBG("first on: dsoc=%d, rsoc=%d cap=%d, fcc=%d, ov=%d\n",
+		 di->dsoc, di->rsoc, di->nac, di->fcc, ocv_vol);
+}
+
+static void rk818_bat_not_first_pwron(struct rk818_battery *di)
+{
+	int now_cap, pre_soc, pre_cap, ocv_cap, ocv_soc, ocv_vol;
+
+	di->fcc = rk818_bat_get_fcc(di);
+	pre_soc = rk818_bat_get_prev_dsoc(di);
+	pre_cap = rk818_bat_get_prev_cap(di);
+	now_cap = rk818_bat_get_coulomb_cap(di);
+	di->is_halt = is_rk818_bat_last_halt(di);
+	di->halt_cnt = rk818_bat_get_halt_cnt(di);
+	di->is_initialized = is_rk818_bat_initialized(di);
+	di->is_ocv_calib = is_rk818_bat_ocv_valid(di);
+
+	if (di->is_initialized) {
+		BAT_INFO("initialized yet..\n");
+		goto finish;
+	} else if (di->is_halt) {
+		BAT_INFO("system halt last time... cap: pre=%d, now=%d\n",
+			 pre_cap, now_cap);
+		if (now_cap < 0)
+			now_cap = 0;
+		rk818_bat_init_coulomb_cap(di, now_cap);
+		pre_cap = now_cap;
+		pre_soc = di->rsoc;
+		goto finish;
+	} else if (di->is_ocv_calib) {
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		pre_cap = ocv_cap;
+		di->ocv_pre_dsoc = pre_soc;
+		di->ocv_new_dsoc = ocv_soc;
+		if (abs(ocv_soc - pre_soc) >= di->pdata->max_soc_offset) {
+			di->ocv_pre_dsoc = pre_soc;
+			di->ocv_new_dsoc = ocv_soc;
+			di->is_max_soc_offset = true;
+			BAT_INFO("trigger max soc offset, dsoc: %d -> %d\n",
+				 pre_soc, ocv_soc);
+			pre_soc = ocv_soc;
+		}
+		BAT_INFO("OCV calib: cap=%d, rsoc=%d\n", ocv_cap, ocv_soc);
+	} else if (di->pwroff_min > 0) {
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		di->force_pre_dsoc = pre_soc;
+		di->force_new_dsoc = ocv_soc;
+		if (abs(ocv_soc - pre_soc) >= 80) {
+			di->is_force_calib = true;
+			BAT_INFO("dsoc force calib: %d -> %d\n",
+				 pre_soc, ocv_soc);
+			pre_soc = ocv_soc;
+			pre_cap = ocv_cap;
+		}
+	}
+
+finish:
+	di->dsoc = pre_soc;
+	di->nac = pre_cap;
+	if (di->nac < 0)
+		di->nac = 0;
+
+	BAT_INFO("dsoc=%d cap=%d v=%d ov=%d rv=%d min=%d psoc=%d pcap=%d\n",
+		 di->dsoc, di->nac, rk818_bat_get_avg_voltage(di),
+		 rk818_bat_get_ocv_voltage(di), rk818_bat_get_relax_voltage(di),
+		 di->pwroff_min, rk818_bat_get_prev_dsoc(di),
+		 rk818_bat_get_prev_cap(di));
+}
+
+static bool rk818_bat_ocv_sw_reset(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	if (((buf & FG_RESET_LATE) && di->pwroff_min >= 30) ||
+	    (buf & FG_RESET_NOW)) {
+		buf &= ~FG_RESET_LATE;
+		buf &= ~FG_RESET_NOW;
+		rk818_bat_write(di, RK818_MISC_MARK_REG, buf);
+		BAT_INFO("manual reset fuel gauge\n");
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void rk818_bat_init_rsoc(struct rk818_battery *di)
+{
+	di->is_first_power_on = is_rk818_bat_first_pwron(di);
+	di->is_sw_reset = rk818_bat_ocv_sw_reset(di);
+	di->pwroff_min = rk818_bat_get_pwroff_min(di);
+
+	if (di->is_first_power_on || di->is_sw_reset)
+		rk818_bat_first_pwron(di);
+	else
+		rk818_bat_not_first_pwron(di);
+}
+
+static u8 rk818_bat_get_chrg_status(struct rk818_battery *di)
+{
+	u8 status;
+
+	status = rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK;
+	switch (status) {
+	case CHARGE_OFF:
+		DBG("CHARGE-OFF ...\n");
+		break;
+	case DEAD_CHARGE:
+		BAT_INFO("DEAD CHARGE...\n");
+		break;
+	case TRICKLE_CHARGE:
+		BAT_INFO("TRICKLE CHARGE...\n ");
+		break;
+	case CC_OR_CV:
+		DBG("CC or CV...\n");
+		break;
+	case CHARGE_FINISH:
+		DBG("CHARGE FINISH...\n");
+		break;
+	case USB_OVER_VOL:
+		BAT_INFO("USB OVER VOL...\n");
+		break;
+	case BAT_TMP_ERR:
+		BAT_INFO("BAT TMP ERROR...\n");
+		break;
+	case TIMER_ERR:
+		BAT_INFO("TIMER ERROR...\n");
+		break;
+	case USB_EXIST:
+		BAT_INFO("USB EXIST...\n");
+		break;
+	case USB_EFF:
+		BAT_INFO("USB EFF...\n");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return status;
+}
+
+static u8 rk818_bat_parse_fb_temperature(struct rk818_battery *di)
+{
+	u8 reg;
+	int index, fb_temp;
+
+	reg = DEFAULT_FB_TEMP;
+	fb_temp = di->pdata->fb_temp;
+	for (index = 0; index < ARRAY_SIZE(feedback_temp_array); index++) {
+		if (fb_temp < feedback_temp_array[index])
+			break;
+		reg = (index << FB_TEMP_SHIFT);
+	}
+
+	return reg;
+}
+
+static u8 rk818_bat_parse_finish_ma(struct rk818_battery *di, int fcc)
+{
+	u8 ma;
+
+	if (di->pdata->sample_res == SAMPLE_RES_10MR)
+		ma = FINISH_100MA;
+	else if (fcc > 5000)
+		ma = FINISH_250MA;
+	else if (fcc >= 4000)
+		ma = FINISH_200MA;
+	else if (fcc >= 3000)
+		ma = FINISH_150MA;
+	else
+		ma = FINISH_100MA;
+
+	return ma;
+}
+
+static void rk818_bat_init_chrg_config(struct rk818_battery *di)
+{
+	u8 usb_ctrl, chrg_ctrl2, chrg_ctrl3;
+	u8 thermal, ggcon, finish_ma, fb_temp;
+
+	finish_ma = rk818_bat_parse_finish_ma(di, di->fcc);
+	fb_temp = rk818_bat_parse_fb_temperature(di);
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	chrg_ctrl2 = rk818_bat_read(di, RK818_CHRG_CTRL_REG2);
+	chrg_ctrl3 = rk818_bat_read(di, RK818_CHRG_CTRL_REG3);
+
+	/* set charge finish current */
+	chrg_ctrl3 |= CHRG_TERM_DIG_SIGNAL;
+	chrg_ctrl2 &= ~FINISH_CUR_MSK;
+	chrg_ctrl2 |= finish_ma;
+
+	/* disable cccv mode */
+	chrg_ctrl3 &= ~CHRG_TIMER_CCCV_EN;
+
+	/* set feed back temperature */
+	if (di->pdata->fb_temp)
+		usb_ctrl |= CHRG_CT_EN;
+	else
+		usb_ctrl &= ~CHRG_CT_EN;
+	thermal &= ~FB_TEMP_MSK;
+	thermal |= fb_temp;
+
+	/* adc current mode */
+	ggcon |= ADC_CUR_MODE;
+
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+	rk818_bat_write(di, RK818_THERMAL_REG, thermal);
+	rk818_bat_write(di, RK818_USB_CTRL_REG, usb_ctrl);
+	rk818_bat_write(di, RK818_CHRG_CTRL_REG2, chrg_ctrl2);
+	rk818_bat_write(di, RK818_CHRG_CTRL_REG3, chrg_ctrl3);
+}
+
+static void rk818_bat_init_coffset(struct rk818_battery *di)
+{
+	int coffset, ioffset;
+
+	ioffset = rk818_bat_get_ioffset(di);
+	di->poffset = rk818_bat_read(di, RK818_POFFSET_REG);
+	if (!di->poffset)
+		di->poffset = DEFAULT_POFFSET;
+
+	coffset = di->poffset + ioffset;
+	if (coffset < INVALID_COFFSET_MIN || coffset > INVALID_COFFSET_MAX)
+		coffset = DEFAULT_COFFSET;
+
+	rk818_bat_set_coffset(di, coffset);
+
+	DBG("<%s>. offset: p=0x%x, i=0x%x, c=0x%x\n",
+	    __func__, di->poffset, ioffset, rk818_bat_get_coffset(di));
+}
+
+static void rk818_bat_caltimer_isr(unsigned long data)
+{
+	struct rk818_battery *di = (struct rk818_battery *)data;
+
+	mod_timer(&di->caltimer, jiffies + MINUTE(8) * HZ);
+	queue_delayed_work(di->bat_monitor_wq, &di->calib_delay_work,
+			   msecs_to_jiffies(10));
+}
+
+static void rk818_bat_internal_calib(struct work_struct *work)
+{
+	int ioffset, poffset;
+	struct rk818_battery *di = container_of(work,
+			struct rk818_battery, calib_delay_work.work);
+
+	/* calib coffset */
+	poffset = rk818_bat_read(di, RK818_POFFSET_REG);
+	if (poffset)
+		di->poffset = poffset;
+	else
+		di->poffset = DEFAULT_POFFSET;
+
+	ioffset = rk818_bat_get_ioffset(di);
+	rk818_bat_set_coffset(di, ioffset + di->poffset);
+
+	/* calib voltage kb */
+	rk818_bat_init_voltage_kb(di);
+	DBG("caltimer: ioffset=0x%x, coffset=0x%x, poffset=%d\n",
+		 ioffset, rk818_bat_get_coffset(di), di->poffset);
+}
+
+static void rk818_bat_init_caltimer(struct rk818_battery *di)
+{
+	setup_timer(&di->caltimer, rk818_bat_caltimer_isr, (unsigned long)di);
+	di->caltimer.expires = jiffies + MINUTE(8) * HZ;
+	add_timer(&di->caltimer);
+	INIT_DELAYED_WORK(&di->calib_delay_work, rk818_bat_internal_calib);
+}
+
+static void rk818_bat_init_zero_table(struct rk818_battery *di)
+{
+	int i, diff, min, max;
+	size_t ocv_size, length;
+
+	ocv_size = di->pdata->ocv_size;
+	length = sizeof(di->pdata->zero_table) * ocv_size;
+	di->pdata->zero_table =
+			devm_kzalloc(di->dev, length, GFP_KERNEL);
+	if (!di->pdata->zero_table) {
+		di->pdata->zero_table = di->pdata->ocv_table;
+		dev_err(di->dev, "malloc zero table fail\n");
+		return;
+	}
+
+	min = di->pdata->pwroff_vol,
+	max = di->pdata->ocv_table[ocv_size - 4];
+	diff = (max - min) / DIV(ocv_size - 1);
+	for (i = 0; i < ocv_size; i++)
+		di->pdata->zero_table[i] = min + (i * diff);
+
+	for (i = 0; i < ocv_size; i++)
+		DBG("zero[%d] = %d\n", i, di->pdata->zero_table[i]);
+
+	for (i = 0; i < ocv_size; i++)
+		DBG("ocv[%d] = %d\n", i, di->pdata->ocv_table[i]);
+}
+
+static void rk818_bat_calc_sm_linek(struct rk818_battery *di)
+{
+	int linek, current_avg;
+	u8 diff, delta;
+
+	delta = abs(di->dsoc - di->rsoc);
+	diff = delta * 3;/* speed:3/4 */
+	current_avg = rk818_bat_get_avg_current(di);
+	if (current_avg >= 0) {
+		if (di->dsoc < di->rsoc)
+			linek = 1000 * (delta + diff) / DIV(diff);
+		else if (di->dsoc > di->rsoc)
+			linek = 1000 * diff / DIV(delta + diff);
+		else
+			linek = 1000;
+		di->dbg_meet_soc = (di->dsoc >= di->rsoc) ?
+				   (di->dsoc + diff) : (di->rsoc + diff);
+	} else {
+		if (di->dsoc < di->rsoc)
+			linek = -1000 * diff / DIV(delta + diff);
+		else if (di->dsoc > di->rsoc)
+			linek = -1000 * (delta + diff) / DIV(diff);
+		else
+			linek = -1000;
+		di->dbg_meet_soc = (di->dsoc >= di->rsoc) ?
+				   (di->dsoc - diff) : (di->rsoc - diff);
+	}
+
+	di->sm_linek = linek;
+	di->sm_remain_cap = di->remain_cap;
+	di->dbg_calc_dsoc = di->dsoc;
+	di->dbg_calc_rsoc = di->rsoc;
+
+	DBG("<%s>.diff=%d, k=%d, cur=%d\n", __func__, diff, linek, current_avg);
+}
+
+static void rk818_bat_calc_zero_linek(struct rk818_battery *di)
+{
+	int dead_voltage, ocv_voltage;
+	int voltage_avg, current_avg, vsys;
+	int ocv_cap, dead_cap, xsoc;
+	int ocv_soc, dead_soc;
+	int pwroff_vol;
+	int i, cnt = 0, vol_old, vol_now;
+	int org_linek = 0, min_gap_xsoc;
+
+	if ((abs(di->current_avg) < 500) && (di->dsoc > 10))
+		pwroff_vol = di->pdata->pwroff_vol + 50;
+	else
+		pwroff_vol = di->pdata->pwroff_vol;
+
+	do {
+		vol_old = rk818_bat_get_avg_voltage(di);
+		msleep(100);
+		vol_now = rk818_bat_get_avg_voltage(di);
+		cnt++;
+	} while ((vol_old == vol_now) && (cnt < 11));
+
+	voltage_avg = 0;
+	for (i = 0; i < 10; i++) {
+		voltage_avg += rk818_bat_get_avg_voltage(di);
+		msleep(100);
+	}
+
+	/* calc estimate ocv voltage */
+	voltage_avg /= 10;
+	current_avg = rk818_bat_get_avg_current(di);
+	vsys = voltage_avg + (current_avg * DEF_PWRPATH_RES) / 1000;
+
+	DBG("ZERO0: shtd_vol: org = %d, now = %d, zero_reserve_dsoc = %d\n",
+	    di->pdata->pwroff_vol, pwroff_vol, di->pdata->zero_reserve_dsoc);
+
+	dead_voltage = pwroff_vol - current_avg *
+				(di->bat_res + DEF_PWRPATH_RES) / 1000;
+	ocv_voltage = voltage_avg - (current_avg * di->bat_res) / 1000;
+	DBG("ZERO0: dead_voltage(shtd) = %d, ocv_voltage(now) = %d\n",
+	    dead_voltage, ocv_voltage);
+
+	/* calc estimate soc and cap */
+	dead_soc = rk818_bat_vol_to_zerosoc(di, dead_voltage);
+	dead_cap = rk818_bat_vol_to_zerocap(di, dead_voltage);
+	DBG("ZERO0: dead_soc = %d, dead_cap = %d\n",
+	    dead_soc, dead_cap);
+
+	ocv_soc = rk818_bat_vol_to_zerosoc(di, ocv_voltage);
+	ocv_cap = rk818_bat_vol_to_zerocap(di, ocv_voltage);
+	DBG("ZERO0: ocv_soc = %d, ocv_cap = %d\n",
+	    ocv_soc, ocv_cap);
+
+	/* xsoc: available rsoc */
+	xsoc = ocv_soc - dead_soc;
+
+	/* min_gap_xsoc: reserve xsoc */
+	if (abs(current_avg) > ZERO_LOAD_LVL1)
+		min_gap_xsoc = ZERO_GAP_XSOC3;
+	else if (abs(current_avg) > ZERO_LOAD_LVL2)
+		min_gap_xsoc = ZERO_GAP_XSOC2;
+	else
+		min_gap_xsoc = ZERO_GAP_XSOC1;
+
+	if ((xsoc <= 30) && (di->dsoc >= di->pdata->zero_reserve_dsoc))
+		min_gap_xsoc = min_gap_xsoc + ZERO_GAP_CALIB;
+
+	di->zero_remain_cap = di->remain_cap;
+	di->zero_timeout_cnt = 0;
+	if ((di->dsoc <= 1) && (xsoc > 0)) {
+		di->zero_linek = 400;
+		di->zero_drop_sec = 0;
+	} else if (xsoc >= 0) {
+		di->zero_drop_sec = 0;
+		di->zero_linek = (di->zero_dsoc + xsoc / 2) / DIV(xsoc);
+		org_linek = di->zero_linek;
+		/* battery energy mode to use up voltage */
+		if ((di->pdata->energy_mode) &&
+		    (xsoc - di->dsoc >= ZERO_GAP_XSOC3) &&
+		    (di->dsoc <= 10) && (di->zero_linek < 300)) {
+			di->zero_linek = 300;
+			DBG("ZERO-new: zero_linek adjust step0...\n");
+		/* reserve enough power yet, slow down any way */
+		} else if ((xsoc - di->dsoc >= min_gap_xsoc) ||
+			   ((xsoc - di->dsoc >= ZERO_GAP_XSOC2) &&
+			    (di->dsoc <= 10) && (xsoc > 15))) {
+			if (xsoc <= 20 &&
+			    di->dsoc >= di->pdata->zero_reserve_dsoc)
+				di->zero_linek = 1200;
+			else if (xsoc - di->dsoc >= 2 * min_gap_xsoc)
+				di->zero_linek = 400;
+			else if (xsoc - di->dsoc >= 3 + min_gap_xsoc)
+				di->zero_linek = 600;
+			else
+				di->zero_linek = 800;
+			DBG("ZERO-new: zero_linek adjust step1...\n");
+		/* control zero mode beginning enter */
+		} else if ((di->zero_linek > 1800) && (di->dsoc > 70)) {
+			di->zero_linek = 1800;
+			DBG("ZERO-new: zero_linek adjust step2...\n");
+		/* dsoc close to xsoc: it must reserve power */
+		} else if ((di->zero_linek > 1000) && (di->zero_linek < 1200)) {
+			di->zero_linek = 1200;
+			DBG("ZERO-new: zero_linek adjust step3...\n");
+		/* dsoc[5~15], dsoc < xsoc */
+		} else if ((di->dsoc <= 15 && di->dsoc > 5) &&
+			   (di->zero_linek <= 1200)) {
+			/* slow down */
+			if (xsoc - di->dsoc >= min_gap_xsoc)
+				di->zero_linek = 800;
+			/* reserve power */
+			else
+				di->zero_linek = 1200;
+			DBG("ZERO-new: zero_linek adjust step4...\n");
+		/* dsoc[5, 100], dsoc < xsoc */
+		} else if ((di->zero_linek < 1000) && (di->dsoc >= 5)) {
+			if ((xsoc - di->dsoc) < min_gap_xsoc) {
+				/* reserve power */
+				di->zero_linek = 1200;
+			} else {
+				if (abs(di->current_avg) > 500)/* heavy */
+					di->zero_linek = 900;
+				else
+					di->zero_linek = 1000;
+			}
+			DBG("ZERO-new: zero_linek adjust step5...\n");
+		/* dsoc[0~5], dsoc < xsoc */
+		} else if ((di->zero_linek < 1000) && (di->dsoc <= 5)) {
+			if ((xsoc - di->dsoc) <= 3)
+				di->zero_linek = 1200;
+			else
+				di->zero_linek = 800;
+				DBG("ZERO-new: zero_linek adjust step6...\n");
+		}
+	} else {
+		/* xsoc < 0 */
+		di->zero_linek = 1000;
+		if (!di->zero_drop_sec)
+			di->zero_drop_sec = get_boot_sec();
+		if (base2sec(di->zero_drop_sec) >= WAIT_DSOC_DROP_SEC) {
+			DBG("ZERO0: t=%lu\n", base2sec(di->zero_drop_sec));
+			di->zero_drop_sec = 0;
+			di->dsoc--;
+			di->zero_dsoc = (di->dsoc + 1) * 1000 -
+						MIN_ACCURACY;
+		}
+	}
+
+	if (voltage_avg < pwroff_vol - 70) {
+		if (!di->shtd_drop_sec)
+			di->shtd_drop_sec = get_boot_sec();
+		if (base2sec(di->shtd_drop_sec) > WAIT_SHTD_DROP_SEC) {
+			BAT_INFO("voltage extreme low...soc:%d->0\n", di->dsoc);
+			di->shtd_drop_sec = 0;
+			di->dsoc = 0;
+		}
+	} else {
+		di->shtd_drop_sec = 0;
+	}
+
+	DBG("ZERO-new: org_linek=%d, zero_linek=%d, dsoc=%d, Xsoc=%d, "
+	    "rsoc=%d, gap=%d, v=%d, vsys=%d\n"
+	    "ZERO-new: di->zero_dsoc=%d, zero_remain_cap=%d, zero_drop=%ld, "
+	    "sht_drop=%ld\n\n",
+	    org_linek, di->zero_linek, di->dsoc, xsoc, di->rsoc,
+	    min_gap_xsoc, voltage_avg, vsys, di->zero_dsoc, di->zero_remain_cap,
+	    base2sec(di->zero_drop_sec), base2sec(di->shtd_drop_sec));
+}
+
+static void rk818_bat_finish_algo_prepare(struct rk818_battery *di)
+{
+	di->finish_base = get_boot_sec();
+	if (!di->finish_base)
+		di->finish_base = 1;
+}
+
+static void rk818_bat_smooth_algo_prepare(struct rk818_battery *di)
+{
+	int tmp_soc;
+
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc)
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc)
+		di->sm_dischrg_dsoc =
+		(di->dsoc + 1) * 1000 - MIN_ACCURACY;
+
+	DBG("<%s>. tmp_soc=%d, dsoc=%d, dsoc:sm_dischrg=%d, sm_chrg=%d\n",
+	    __func__, tmp_soc, di->dsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+
+	rk818_bat_calc_sm_linek(di);
+}
+
+static void rk818_bat_zero_algo_prepare(struct rk818_battery *di)
+{
+	int tmp_dsoc;
+
+	di->zero_timeout_cnt = 0;
+	tmp_dsoc = di->zero_dsoc / 1000;
+	if (tmp_dsoc != di->dsoc)
+		di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+
+	DBG("<%s>. first calc, reinit linek\n", __func__);
+
+	rk818_bat_calc_zero_linek(di);
+}
+
+static void rk818_bat_calc_zero_algorithm(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0;
+
+	tmp_soc = di->zero_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when discharge slow down, take sm chrg into calc */
+	if (di->dsoc < di->rsoc) {
+		/* take sm charge rest into calc */
+		tmp_soc = di->sm_chrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_chrg_dsoc - di->dsoc * 1000;
+			di->sm_chrg_dsoc = di->dsoc * 1000;
+			di->zero_dsoc += sm_delta_dsoc;
+			DBG("ZERO1: take sm chrg,delta=%d\n", sm_delta_dsoc);
+		}
+	}
+
+	/* when discharge speed up, take sm dischrg into calc */
+	if (di->dsoc > di->rsoc) {
+		/* take sm discharge rest into calc */
+		tmp_soc = di->sm_dischrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_dischrg_dsoc -
+				((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 -
+								MIN_ACCURACY;
+			di->zero_dsoc += sm_delta_dsoc;
+			DBG("ZERO1: take sm dischrg,delta=%d\n", sm_delta_dsoc);
+		}
+	}
+
+	/* check overflow */
+	if (di->zero_dsoc > (di->dsoc + 1) * 1000 - MIN_ACCURACY) {
+		DBG("ZERO1: zero dsoc overflow: %d\n", di->zero_dsoc);
+		di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->zero_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		/* avoid dsoc jump when heavy load */
+		if ((di->dsoc - tmp_soc) > 1) {
+			di->dsoc--;
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			DBG("ZERO1: heavy load...\n");
+		} else {
+			di->dsoc = tmp_soc;
+		}
+		di->zero_drop_sec = 0;
+	}
+
+out:
+	DBG("ZERO1: zero_dsoc(Y0)=%d, dsoc=%d, rsoc=%d, tmp_soc=%d\n",
+	    di->zero_dsoc, di->dsoc, di->rsoc, tmp_soc);
+	DBG("ZERO1: sm_dischrg_dsoc=%d, sm_chrg_dsoc=%d\n",
+	    di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+}
+
+static void rk818_bat_zero_algorithm(struct rk818_battery *di)
+{
+	int delta_cap = 0, delta_soc = 0;
+
+	di->zero_timeout_cnt++;
+	delta_cap = di->zero_remain_cap - di->remain_cap;
+	delta_soc = di->zero_linek * (delta_cap * 100) / DIV(di->fcc);
+
+	DBG("ZERO1: zero_linek=%d, zero_dsoc(Y0)=%d, dsoc=%d, rsoc=%d\n"
+	    "ZERO1: delta_soc(X0)=%d, delta_cap=%d, zero_remain_cap = %d\n"
+	    "ZERO1: timeout_cnt=%d, sm_dischrg=%d, sm_chrg=%d\n\n",
+	    di->zero_linek, di->zero_dsoc, di->dsoc, di->rsoc,
+	    delta_soc, delta_cap, di->zero_remain_cap,
+	    di->zero_timeout_cnt, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+
+	if ((delta_soc >= MIN_ZERO_DSOC_ACCURACY) ||
+	    (di->zero_timeout_cnt > MIN_ZERO_OVERCNT) ||
+	    (di->zero_linek == 0)) {
+		DBG("ZERO1:--------- enter calc -----------\n");
+		di->zero_timeout_cnt = 0;
+		di->zero_dsoc -= delta_soc;
+		rk818_bat_calc_zero_algorithm(di);
+		rk818_bat_calc_zero_linek(di);
+	}
+}
+
+static void rk818_bat_dump_time_table(struct rk818_battery *di)
+{
+	u8 i;
+	static int old_index;
+	static int old_min;
+	int mod = di->dsoc % 10;
+	int index = di->dsoc / 10;
+	u32 time;
+
+	if (rk818_bat_chrg_online(di))
+		time = base2min(di->plug_in_base);
+	else
+		time = base2min(di->plug_out_base);
+
+	if ((mod == 0) && (index > 0) && (old_index != index)) {
+		di->dbg_chrg_min[index - 1] = time - old_min;
+		old_min = time;
+		old_index = index;
+	}
+
+	for (i = 1; i < 11; i++)
+		DBG("Time[%d]=%d, ", (i * 10), di->dbg_chrg_min[i - 1]);
+	DBG("\n");
+}
+
+static void rk818_bat_debug_info(struct rk818_battery *di)
+{
+	u8 sup_tst, ggcon, ggsts, vb_mod, ts_ctrl, reboot_cnt;
+	u8 usb_ctrl, chrg_ctrl1, thermal;
+	u8 int_sts1, int_sts2;
+	u8 int_msk1, int_msk2;
+	u8 chrg_ctrl2, chrg_ctrl3, rtc, misc, dcdc_en;
+	char *work_mode[] = {"ZERO", "FINISH", "UN", "UN", "SMOOTH"};
+	char *bat_mode[] = {"BAT", "VIRTUAL"};
+
+	if (rk818_bat_chrg_online(di))
+		di->plug_out_base = get_boot_sec();
+	else
+		di->plug_in_base = get_boot_sec();
+
+	rk818_bat_dump_time_table(di);
+
+	if (!dbg_enable)
+		return;
+
+	ts_ctrl = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	misc = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggsts = rk818_bat_read(di, RK818_GGSTS_REG);
+	sup_tst = rk818_bat_read(di, RK818_SUP_STS_REG);
+	vb_mod = rk818_bat_read(di, RK818_VB_MON_REG);
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	chrg_ctrl1 = rk818_bat_read(di, RK818_CHRG_CTRL_REG1);
+	chrg_ctrl2 = rk818_bat_read(di, RK818_CHRG_CTRL_REG2);
+	chrg_ctrl3 = rk818_bat_read(di, RK818_CHRG_CTRL_REG3);
+	rtc = rk818_bat_read(di, 0);
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	int_sts1 = rk818_bat_read(di, RK818_INT_STS_REG1);
+	int_sts2 = rk818_bat_read(di, RK818_INT_STS_REG2);
+	int_msk1 = rk818_bat_read(di, RK818_INT_STS_MSK_REG1);
+	int_msk2 = rk818_bat_read(di, RK818_INT_STS_MSK_REG2);
+	dcdc_en = rk818_bat_read(di, RK818_DCDC_EN_REG);
+	reboot_cnt = rk818_bat_read(di, RK818_REBOOT_CNT_REG);
+
+	DBG("\n------- DEBUG REGS, [Ver: %s] -------------------\n"
+	    "GGCON=0x%2x, GGSTS=0x%2x, RTC=0x%2x, DCDC_EN2=0x%2x\n"
+	    "SUP_STS= 0x%2x, VB_MOD=0x%2x, USB_CTRL=0x%2x\n"
+	    "THERMAL=0x%2x, MISC_MARK=0x%2x, TS_CTRL=0x%2x\n"
+	    "CHRG_CTRL:REG1=0x%2x, REG2=0x%2x, REG3=0x%2x\n"
+	    "INT_STS:  REG1=0x%2x, REG2=0x%2x\n"
+	    "INT_MSK:  REG1=0x%2x, REG2=0x%2x\n",
+	    DRIVER_VERSION, ggcon, ggsts, rtc, dcdc_en,
+	    sup_tst, vb_mod, usb_ctrl,
+	    thermal, misc, ts_ctrl,
+	    chrg_ctrl1, chrg_ctrl2, chrg_ctrl3,
+	    int_sts1, int_sts2, int_msk1, int_msk2
+	   );
+
+	DBG("###############################################################\n"
+	    "Dsoc=%d, Rsoc=%d, Vavg=%d, Iavg=%d, Cap=%d, Fcc=%d, d=%d\n"
+	    "K=%d, Mode=%s, Oldcap=%d, Is=%d, Ip=%d, Vs=%d\n"
+	    "fb_temp=%d, bat_temp=%d, sample_res=%d, USB=%d, DC=%d\n"
+	    "off:i=0x%x, c=0x%x, p=%d, Rbat=%d, age_ocv_cap=%d, fb=%d, hot=%d\n"
+	    "adp:finish=%lu, boot_min=%lu, sleep_min=%lu, adc=%d, Vsys=%d\n"
+	    "bat:%s, meet: soc=%d, calc: dsoc=%d, rsoc=%d, Vocv=%d\n"
+	    "pwr: dsoc=%d, rsoc=%d, vol=%d, halt: st=%d, cnt=%d, reboot=%d\n"
+	    "ocv_c=%d: %d -> %d; max_c=%d: %d -> %d; force_c=%d: %d -> %d\n"
+	    "min=%d, init=%d, sw=%d, below0=%d, first=%d, changed=%d\n"
+	    "###############################################################\n",
+	    di->dsoc, di->rsoc, di->voltage_avg, di->current_avg,
+	    di->remain_cap, di->fcc, di->rsoc - di->dsoc,
+	    di->sm_linek, work_mode[di->work_mode], di->sm_remain_cap,
+	    di->res_div * chrg_cur_sel_array[chrg_ctrl1 & 0x0f],
+	    chrg_cur_input_array[usb_ctrl & 0x0f],
+	    chrg_vol_sel_array[(chrg_ctrl1 & 0x70) >> 4],
+	    feedback_temp_array[(thermal & 0x0c) >> 2], di->temperature,
+	    di->pdata->sample_res, di->usb_in, di->ac_in,
+	    rk818_bat_get_ioffset(di),
+	    rk818_bat_get_coffset(di), di->poffset, di->bat_res,
+	    di->age_adjust_cap, di->fb_blank, !!(thermal & HOTDIE_STS),
+	    base2min(di->finish_base),
+	    base2min(di->boot_base), di->sleep_sum_sec / 60,
+	    di->adc_allow_update,
+	    di->voltage_avg + di->current_avg * DEF_PWRPATH_RES / 1000,
+	    bat_mode[di->pdata->bat_mode], di->dbg_meet_soc, di->dbg_calc_dsoc,
+	    di->dbg_calc_rsoc, di->voltage_ocv, di->dbg_pwr_dsoc,
+	    di->dbg_pwr_rsoc, di->dbg_pwr_vol, di->is_halt, di->halt_cnt,
+	    reboot_cnt, di->is_ocv_calib, di->ocv_pre_dsoc, di->ocv_new_dsoc,
+	    di->is_max_soc_offset, di->max_pre_dsoc, di->max_new_dsoc,
+	    di->is_force_calib, di->force_pre_dsoc, di->force_new_dsoc,
+	    di->pwroff_min, di->is_initialized, di->is_sw_reset,
+	    di->dbg_cap_low0, di->is_first_on, di->last_dsoc
+	   );
+}
+
+static void rk818_bat_init_capacity(struct rk818_battery *di, u32 cap)
+{
+	int delta_cap;
+
+	delta_cap = cap - di->remain_cap;
+	if (!delta_cap)
+		return;
+
+	di->age_adjust_cap += delta_cap;
+	rk818_bat_init_coulomb_cap(di, cap);
+	rk818_bat_smooth_algo_prepare(di);
+	rk818_bat_zero_algo_prepare(di);
+}
+
+static void rk818_bat_update_age_fcc(struct rk818_battery *di)
+{
+	int fcc, remain_cap, age_keep_min, lock_fcc;
+
+	lock_fcc = rk818_bat_get_coulomb_cap(di);
+	remain_cap = lock_fcc - di->age_ocv_cap - di->age_adjust_cap;
+	age_keep_min = base2min(di->age_keep_sec);
+
+	DBG("%s: lock_fcc=%d, age_ocv_cap=%d, age_adjust_cap=%d, remain_cap=%d,"
+	    "age_allow_update=%d, age_keep_min=%d\n",
+	    __func__, lock_fcc, di->age_ocv_cap, di->age_adjust_cap, remain_cap,
+	    di->age_allow_update, age_keep_min);
+
+	if ((di->chrg_status == CHARGE_FINISH) && (di->age_allow_update) &&
+	    (age_keep_min < 1200)) {
+		di->age_allow_update = false;
+		fcc = remain_cap * 100 / DIV(100 - di->age_ocv_soc);
+		BAT_INFO("lock_fcc=%d, calc_cap=%d, age: soc=%d, cap=%d, "
+			 "level=%d, fcc:%d->%d?\n",
+			 lock_fcc, remain_cap, di->age_ocv_soc,
+			 di->age_ocv_cap, di->age_level, di->fcc, fcc);
+
+		if ((fcc < di->qmax) && (fcc > MIN_FCC)) {
+			BAT_INFO("fcc:%d->%d!\n", di->fcc, fcc);
+			di->fcc = fcc;
+			rk818_bat_init_capacity(di, di->fcc);
+			rk818_bat_save_fcc(di, di->fcc);
+			rk818_bat_save_age_level(di, di->age_level);
+		}
+	}
+}
+
+static void rk818_bat_wait_finish_sig(struct rk818_battery *di)
+{
+	int chrg_finish_vol = di->pdata->max_chrg_voltage;
+
+	if (!rk818_bat_chrg_online(di))
+		return;
+
+	if ((di->chrg_status == CHARGE_FINISH) && (di->adc_allow_update) &&
+	    (di->voltage_avg > chrg_finish_vol - 150)) {
+		rk818_bat_update_age_fcc(di);
+		if (rk818_bat_adc_calib(di))
+			di->adc_allow_update = false;
+	}
+}
+
+static void rk818_bat_finish_algorithm(struct rk818_battery *di)
+{
+	unsigned long finish_sec, soc_sec;
+	int plus_soc, finish_current, rest = 0;
+
+	/* rsoc */
+	if ((di->remain_cap != di->fcc) &&
+	    (rk818_bat_get_chrg_status(di) == CHARGE_FINISH)) {
+		di->age_adjust_cap += (di->fcc - di->remain_cap);
+		rk818_bat_init_coulomb_cap(di, di->fcc);
+	}
+
+	/* dsoc */
+	if (di->dsoc < 100) {
+		if (!di->finish_base)
+			di->finish_base = get_boot_sec();
+		finish_current = (di->rsoc - di->dsoc) >  FINISH_MAX_SOC_DELAY ?
+					FINISH_CHRG_CUR2 : FINISH_CHRG_CUR1;
+		finish_sec = base2sec(di->finish_base);
+		soc_sec = di->fcc * 3600 / 100 / DIV(finish_current);
+		plus_soc = finish_sec / DIV(soc_sec);
+		if (finish_sec > soc_sec) {
+			rest = finish_sec % soc_sec;
+			di->dsoc += plus_soc;
+			di->finish_base = get_boot_sec();
+			if (di->finish_base > rest)
+				di->finish_base = get_boot_sec() - rest;
+		}
+		DBG("<%s>.CHARGE_FINISH:dsoc<100,dsoc=%d\n"
+		    "soc_time=%lu, sec_finish=%lu, plus_soc=%d, rest=%d\n",
+		    __func__, di->dsoc, soc_sec, finish_sec, plus_soc, rest);
+	}
+}
+
+static void rk818_bat_calc_smooth_dischrg(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0, zero_delta_dsoc = 0;
+
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when dischrge slow down, take sm charge rest into calc */
+	if (di->dsoc < di->rsoc) {
+		tmp_soc = di->sm_chrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_chrg_dsoc - di->dsoc * 1000;
+			di->sm_chrg_dsoc = di->dsoc * 1000;
+			di->sm_dischrg_dsoc += sm_delta_dsoc;
+			DBG("<%s>. take sm dischrg, delta=%d\n",
+			    __func__, sm_delta_dsoc);
+		}
+	}
+
+	/* when discharge speed up, take zero discharge rest into calc */
+	if (di->dsoc > di->rsoc) {
+		tmp_soc = di->zero_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			zero_delta_dsoc = di->zero_dsoc - ((di->dsoc + 1) *
+						1000 - MIN_ACCURACY);
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			di->sm_dischrg_dsoc += zero_delta_dsoc;
+			DBG("<%s>. take zero schrg, delta=%d\n",
+			    __func__, zero_delta_dsoc);
+		}
+	}
+
+	/* check up overflow */
+	if ((di->sm_dischrg_dsoc) > ((di->dsoc + 1) * 1000 - MIN_ACCURACY)) {
+		DBG("<%s>. dischrg_dsoc up overflow\n", __func__);
+		di->sm_dischrg_dsoc = (di->dsoc + 1) *
+					1000 - MIN_ACCURACY;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		di->dsoc = tmp_soc;
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+	}
+out:
+	DBG("<%s>. dsoc=%d, rsoc=%d, dsoc:sm_dischrg=%d, sm_chrg=%d, zero=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc,
+	    di->zero_dsoc);
+
+}
+
+static void rk818_bat_calc_smooth_chrg(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0, zero_delta_dsoc = 0;
+
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when charge slow down, take zero & sm dischrg into calc */
+	if (di->dsoc > di->rsoc) {
+		/* take sm discharge rest into calc */
+		tmp_soc = di->sm_dischrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_dischrg_dsoc -
+					((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 -
+							MIN_ACCURACY;
+			di->sm_chrg_dsoc += sm_delta_dsoc;
+			DBG("<%s>. take sm dischrg, delta=%d\n",
+			   __func__, sm_delta_dsoc);
+		}
+
+		/* take zero discharge rest into calc */
+		tmp_soc = di->zero_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			zero_delta_dsoc = di->zero_dsoc -
+			((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			di->sm_chrg_dsoc += zero_delta_dsoc;
+			DBG("<%s>. take zero dischrg, delta=%d\n",
+			    __func__, zero_delta_dsoc);
+		}
+	}
+
+	/* check down overflow */
+	if (di->sm_chrg_dsoc < di->dsoc * 1000) {
+		DBG("<%s>. chrg_dsoc down overflow\n", __func__);
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		di->dsoc = tmp_soc;
+		di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+	}
+out:
+	DBG("<%s>.dsoc=%d, rsoc=%d, dsoc: sm_dischrg=%d, sm_chrg=%d, zero=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc,
+	    di->zero_dsoc);
+}
+
+static void rk818_bat_smooth_algorithm(struct rk818_battery *di)
+{
+	int ydsoc = 0, delta_cap = 0, old_cap = 0;
+	unsigned long tgt_sec = 0;
+
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+
+	/* full charge: slow down */
+	if ((di->dsoc == 99) && (di->chrg_status == CC_OR_CV) &&
+	    (di->current_avg > 0)) {
+		di->sm_linek = FULL_CHRG_K;
+	/* terminal charge, slow down */
+	} else if ((di->current_avg >= TERM_CHRG_CURR) &&
+	    (di->chrg_status == CC_OR_CV) && (di->dsoc >= TERM_CHRG_DSOC)) {
+		di->sm_linek = TERM_CHRG_K;
+		DBG("<%s>. terminal mode..\n", __func__);
+	/* simulate charge, speed up */
+	} else if ((di->current_avg <= SIMULATE_CHRG_CURR) &&
+		   (di->current_avg > 0) && (di->chrg_status == CC_OR_CV) &&
+		   (di->dsoc < TERM_CHRG_DSOC) &&
+		   ((di->rsoc - di->dsoc) >= SIMULATE_CHRG_INTV)) {
+		di->sm_linek = SIMULATE_CHRG_K;
+		DBG("<%s>. simulate mode..\n", __func__);
+	} else {
+		/* charge and discharge switch */
+		if ((di->sm_linek * di->current_avg <= 0) ||
+		    (di->sm_linek == TERM_CHRG_K) ||
+		    (di->sm_linek == FULL_CHRG_K) ||
+		    (di->sm_linek == SIMULATE_CHRG_K)) {
+			DBG("<%s>. linek mode, retinit sm linek..\n", __func__);
+			rk818_bat_calc_sm_linek(di);
+		}
+	}
+
+	old_cap = di->sm_remain_cap;
+	/*
+	 * when dsoc equal rsoc(not include full, term, simulate case),
+	 * sm_linek should change to -1000/1000 smoothly to avoid dsoc+1/-1
+	 * right away, so change it after flat seconds
+	 */
+	if ((di->dsoc == di->rsoc) && (abs(di->sm_linek) != 1000) &&
+	    (di->sm_linek != FULL_CHRG_K && di->sm_linek != TERM_CHRG_K &&
+	     di->sm_linek != SIMULATE_CHRG_K)) {
+		if (!di->flat_match_sec)
+			di->flat_match_sec = get_boot_sec();
+		tgt_sec = di->fcc * 3600 / 100 / DIV(abs(di->current_avg)) / 3;
+		if (base2sec(di->flat_match_sec) >= tgt_sec) {
+			di->flat_match_sec = 0;
+			di->sm_linek = (di->current_avg >= 0) ? 1000 : -1000;
+		}
+		DBG("<%s>. flat_sec=%ld, tgt_sec=%ld, sm_k=%d\n", __func__,
+		    base2sec(di->flat_match_sec), tgt_sec, di->sm_linek);
+	} else {
+		di->flat_match_sec = 0;
+	}
+
+	/* abs(k)=1000 or dsoc=100, stop calc */
+	if ((abs(di->sm_linek) == 1000) || (di->current_avg >= 0 &&
+	     di->chrg_status == CC_OR_CV && di->dsoc >= 100)) {
+		DBG("<%s>. sm_linek=%d\n", __func__, di->sm_linek);
+		if (abs(di->sm_linek) == 1000) {
+			di->dsoc = di->rsoc;
+			di->sm_linek = (di->sm_linek > 0) ? 1000 : -1000;
+			DBG("<%s>. dsoc == rsoc, sm_linek=%d\n",
+			    __func__, di->sm_linek);
+		}
+		di->sm_remain_cap = di->remain_cap;
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+		di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+		DBG("<%s>. sm_dischrg_dsoc=%d, sm_chrg_dsoc=%d\n",
+		    __func__, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+	} else {
+		delta_cap = di->remain_cap - di->sm_remain_cap;
+		if (delta_cap == 0) {
+			DBG("<%s>. delta_cap = 0\n", __func__);
+			return;
+		}
+		ydsoc = di->sm_linek * abs(delta_cap) * 100 / DIV(di->fcc);
+		if (ydsoc == 0) {
+			DBG("<%s>. ydsoc = 0\n", __func__);
+			return;
+		}
+		di->sm_remain_cap = di->remain_cap;
+
+		DBG("<%s>. k=%d, ydsoc=%d; cap:old=%d, new:%d; delta_cap=%d\n",
+		    __func__, di->sm_linek, ydsoc, old_cap,
+		    di->sm_remain_cap, delta_cap);
+
+		/* discharge mode */
+		if (ydsoc < 0) {
+			di->sm_dischrg_dsoc += ydsoc;
+			rk818_bat_calc_smooth_dischrg(di);
+		/* charge mode */
+		} else {
+			di->sm_chrg_dsoc += ydsoc;
+			rk818_bat_calc_smooth_chrg(di);
+		}
+
+		if (di->s2r) {
+			di->s2r = false;
+			rk818_bat_calc_sm_linek(di);
+		}
+	}
+}
+
+/*
+ * cccv and finish switch all the time will cause dsoc freeze,
+ * if so, do finish chrg, 100ma is less than min finish_ma.
+ */
+static bool rk818_bat_fake_finish_mode(struct rk818_battery *di)
+{
+	if ((di->rsoc == 100) && (rk818_bat_get_chrg_status(di) == CC_OR_CV) &&
+	    (abs(di->current_avg) <= 100))
+		return true;
+	else
+		return false;
+}
+
+static void rk818_bat_display_smooth(struct rk818_battery *di)
+{
+	/* discharge: reinit "zero & smooth" algorithm to avoid handling dsoc */
+	if (di->s2r && !di->sleep_chrg_online) {
+		DBG("s2r: discharge, reset algorithm...\n");
+		di->s2r = false;
+		rk818_bat_zero_algo_prepare(di);
+		rk818_bat_smooth_algo_prepare(di);
+		return;
+	}
+
+	if (di->work_mode == MODE_FINISH) {
+		DBG("step1: charge finish...\n");
+		rk818_bat_finish_algorithm(di);
+		if ((rk818_bat_get_chrg_status(di) != CHARGE_FINISH) &&
+		    !rk818_bat_fake_finish_mode(di)) {
+			if ((di->current_avg < 0) &&
+			    (di->voltage_avg < di->pdata->zero_algorithm_vol)) {
+				DBG("step1: change to zero mode...\n");
+				rk818_bat_zero_algo_prepare(di);
+				di->work_mode = MODE_ZERO;
+			} else {
+				DBG("step1: change to smooth mode...\n");
+				rk818_bat_smooth_algo_prepare(di);
+				di->work_mode = MODE_SMOOTH;
+			}
+		}
+	} else if (di->work_mode == MODE_ZERO) {
+		DBG("step2: zero algorithm...\n");
+		rk818_bat_zero_algorithm(di);
+		if ((di->voltage_avg >= di->pdata->zero_algorithm_vol + 50) ||
+		    (di->current_avg >= 0)) {
+			DBG("step2: change to smooth mode...\n");
+			rk818_bat_smooth_algo_prepare(di);
+			di->work_mode = MODE_SMOOTH;
+		} else if ((rk818_bat_get_chrg_status(di) == CHARGE_FINISH) ||
+			   rk818_bat_fake_finish_mode(di)) {
+			DBG("step2: change to finish mode...\n");
+			rk818_bat_finish_algo_prepare(di);
+			di->work_mode = MODE_FINISH;
+		}
+	} else {
+		DBG("step3: smooth algorithm...\n");
+		rk818_bat_smooth_algorithm(di);
+		if ((di->current_avg < 0) &&
+		    (di->voltage_avg < di->pdata->zero_algorithm_vol)) {
+			DBG("step3: change to zero mode...\n");
+			rk818_bat_zero_algo_prepare(di);
+			di->work_mode = MODE_ZERO;
+		} else if ((rk818_bat_get_chrg_status(di) == CHARGE_FINISH) ||
+			   rk818_bat_fake_finish_mode(di)) {
+			DBG("step3: change to finish mode...\n");
+			rk818_bat_finish_algo_prepare(di);
+			di->work_mode = MODE_FINISH;
+		}
+	}
+}
+
+static void rk818_bat_relax_vol_calib(struct rk818_battery *di)
+{
+	int soc, cap, vol;
+
+	vol = di->voltage_relax;
+	soc = rk818_bat_vol_to_ocvsoc(di, vol);
+	cap = rk818_bat_vol_to_ocvcap(di, vol);
+	rk818_bat_init_capacity(di, cap);
+	BAT_INFO("sleep ocv calib: rsoc=%d, cap=%d\n", soc, cap);
+}
+
+static void rk818_bat_relife_age_flag(struct rk818_battery *di)
+{
+	u8 ocv_soc, ocv_cap, soc_level;
+
+	if (di->voltage_relax <= 0)
+		return;
+
+	ocv_soc = rk818_bat_vol_to_ocvsoc(di, di->voltage_relax);
+	ocv_cap = rk818_bat_vol_to_ocvcap(di, di->voltage_relax);
+	DBG("<%s>. ocv_soc=%d, min=%lu, vol=%d\n", __func__,
+	    ocv_soc, di->sleep_dischrg_sec / 60, di->voltage_relax);
+
+	/* sleep enough time and ocv_soc enough low */
+	if (!di->age_allow_update && ocv_soc <= 10) {
+		di->age_voltage = di->voltage_relax;
+		di->age_ocv_cap = ocv_cap;
+		di->age_ocv_soc = ocv_soc;
+		di->age_adjust_cap = 0;
+
+		if (ocv_soc <= 1)
+			di->age_level = 100;
+		else if (ocv_soc < 5)
+			di->age_level = 90;
+		else
+			di->age_level = 80;
+
+		soc_level = rk818_bat_get_age_level(di);
+		if (soc_level > di->age_level) {
+			di->age_allow_update = false;
+		} else {
+			di->age_allow_update = true;
+			di->age_keep_sec = get_boot_sec();
+		}
+
+		BAT_INFO("resume: age_vol:%d, age_ocv_cap:%d, age_ocv_soc:%d, "
+			 "soc_level:%d, age_allow_update:%d, "
+			 "age_level:%d\n",
+			 di->age_voltage, di->age_ocv_cap, ocv_soc, soc_level,
+			 di->age_allow_update, di->age_level);
+	}
+}
+
+static int rk818_bat_sleep_dischrg(struct rk818_battery *di)
+{
+	bool ocv_soc_updated = false;
+	int tgt_dsoc, gap_soc, sleep_soc = 0;
+	int pwroff_vol = di->pdata->pwroff_vol;
+	unsigned long sleep_sec = di->sleep_dischrg_sec;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d, rv=%d, v=%d, sleep_min=%lu\n",
+	    __func__, di->dsoc, di->rsoc, di->voltage_relax,
+	    di->voltage_avg, sleep_sec / 60);
+
+	if (di->voltage_relax >= di->voltage_avg) {
+		rk818_bat_relax_vol_calib(di);
+		rk818_bat_restart_relax(di);
+		rk818_bat_relife_age_flag(di);
+		ocv_soc_updated = true;
+	}
+
+	/* handle dsoc */
+	if (di->dsoc <= di->rsoc) {
+		di->sleep_sum_cap = (SLP_CURR_MIN * sleep_sec / 3600);
+		sleep_soc = di->sleep_sum_cap * 100 / DIV(di->fcc);
+		tgt_dsoc = di->dsoc - sleep_soc;
+		if (sleep_soc > 0) {
+			BAT_INFO("calib0: rl=%d, dl=%d, intval=%d\n",
+				 di->rsoc, di->dsoc, sleep_soc);
+			if (di->dsoc < 5) {
+				di->dsoc--;
+			} else if ((tgt_dsoc < 5) && (di->dsoc >= 5)) {
+				if (di->dsoc == 5)
+					di->dsoc--;
+				else
+					di->dsoc = 5;
+			} else if (tgt_dsoc > 5) {
+				di->dsoc = tgt_dsoc;
+			}
+		}
+
+		DBG("%s: dsoc<=rsoc, sum_cap=%d==>sleep_soc=%d, tgt_dsoc=%d\n",
+		    __func__, di->sleep_sum_cap, sleep_soc, tgt_dsoc);
+	} else {
+		/* di->dsoc > di->rsoc */
+		di->sleep_sum_cap = (SLP_CURR_MAX * sleep_sec / 3600);
+		sleep_soc = di->sleep_sum_cap / DIV(di->fcc / 100);
+		gap_soc = di->dsoc - di->rsoc;
+
+		BAT_INFO("calib1: rsoc=%d, dsoc=%d, intval=%d\n",
+			 di->rsoc, di->dsoc, sleep_soc);
+		if (gap_soc > sleep_soc) {
+			if ((gap_soc - 5) > (sleep_soc * 2))
+				di->dsoc -= (sleep_soc * 2);
+			else
+				di->dsoc -= sleep_soc;
+		} else {
+			di->dsoc = di->rsoc;
+		}
+
+		DBG("%s: dsoc>rsoc, sum_cap=%d=>sleep_soc=%d, gap_soc=%d\n",
+		    __func__, di->sleep_sum_cap, sleep_soc, gap_soc);
+	}
+
+	if (di->voltage_avg <= pwroff_vol - 70) {
+		di->dsoc = 0;
+		rk_send_wakeup_key();
+		BAT_INFO("low power sleeping, shutdown... %d\n", di->dsoc);
+	}
+
+	if (ocv_soc_updated && sleep_soc && (di->rsoc - di->dsoc) < 5 &&
+	    di->dsoc < 40) {
+		di->dsoc--;
+		BAT_INFO("low power sleeping, reserved... %d\n", di->dsoc);
+	}
+
+	if (di->dsoc <= 0) {
+		di->dsoc = 0;
+		rk_send_wakeup_key();
+		BAT_INFO("sleep dsoc is %d...\n", di->dsoc);
+	}
+
+	DBG("<%s>. out: dsoc=%d, rsoc=%d, sum_cap=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sleep_sum_cap);
+
+	return sleep_soc;
+}
+
+static void rk818_bat_power_supply_changed(struct rk818_battery *di)
+{
+	u8 status, thermal;
+	static int old_soc = -1;
+
+	if (di->dsoc > 100)
+		di->dsoc = 100;
+	else if (di->dsoc < 0)
+		di->dsoc = 0;
+
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	status = rk818_bat_read(di, RK818_SUP_STS_REG);
+	status = (status & CHRG_STATUS_MSK) >> 4;
+	old_soc = di->dsoc;
+	di->last_dsoc = di->dsoc;
+	power_supply_changed(di->bat);
+	DBG("changed: dsoc=%d, rsoc=%d, v=%d, ov=%d c=%d, "
+		 "cap=%d, f=%d, st=%s, hotdie=%d\n",
+		 di->dsoc, di->rsoc, di->voltage_avg, di->voltage_ocv,
+		 di->current_avg, di->remain_cap, di->fcc, bat_status[status],
+		 !!(thermal & HOTDIE_STS));
+
+	DBG("dl=%d, rl=%d, v=%d, halt=%d, halt_n=%d, max=%d, "
+		 "init=%d, sw=%d, calib=%d, below0=%d, force=%d\n",
+		 di->dbg_pwr_dsoc, di->dbg_pwr_rsoc, di->dbg_pwr_vol,
+		 di->is_halt, di->halt_cnt, di->is_max_soc_offset,
+		 di->is_initialized, di->is_sw_reset, di->is_ocv_calib,
+		 di->dbg_cap_low0, di->is_force_calib);
+
+	/* system poweroff condition */
+	if (((di->remain_cap < 40) ||
+		(di->voltage_avg < di->pdata->pwroff_vol)) &&
+			(status == 0))
+		rk_send_power_key(1);
+}
+
+static u8 rk818_bat_check_reboot(struct rk818_battery *di)
+{
+	u8 cnt;
+
+	cnt = rk818_bat_read(di, RK818_REBOOT_CNT_REG);
+	cnt++;
+
+	if (cnt >= REBOOT_MAX_CNT) {
+		BAT_INFO("reboot: %d --> %d\n", di->dsoc, di->rsoc);
+		di->dsoc = di->rsoc;
+		if (di->dsoc > 100)
+			di->dsoc = 100;
+		else if (di->dsoc < 0)
+			di->dsoc = 0;
+		rk818_bat_save_dsoc(di, di->dsoc);
+		cnt = REBOOT_MAX_CNT;
+	}
+
+	rk818_bat_save_reboot_cnt(di, cnt);
+	DBG("reboot cnt: %d\n", cnt);
+
+	return cnt;
+}
+
+static void rk818_bat_rsoc_daemon(struct rk818_battery *di)
+{
+	int est_vol, remain_cap;
+	static unsigned long sec;
+
+	if ((di->remain_cap < 0) && (di->fb_blank != 0)) {
+		if (!sec)
+			sec = get_boot_sec();
+
+		DBG("sec=%ld, hold_sec=%ld\n", sec, base2sec(sec));
+		if (base2sec(sec) >= 60) {
+			sec = 0;
+			di->dbg_cap_low0++;
+			est_vol = di->voltage_avg -
+					(di->bat_res * di->current_avg) / 1000;
+			remain_cap = rk818_bat_vol_to_ocvcap(di, est_vol);
+			rk818_bat_init_capacity(di, remain_cap);
+			BAT_INFO("adjust cap below 0 --> %d, rsoc=%d\n",
+				 di->remain_cap, di->rsoc);
+		}
+	} else {
+		sec = 0;
+	}
+}
+
+static void rk818_bat_update_info(struct rk818_battery *di)
+{
+	int is_charging;
+
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->chrg_status = rk818_bat_get_chrg_status(di);
+	is_charging = rk818_bat_get_charge_state(di);
+	if (is_charging != di->is_charging) {
+		di->is_charging = is_charging;
+		if (is_charging)
+			di->charge_count++;
+	}
+	if (di->voltage_avg > di->voltage_max)
+		di->voltage_max = di->voltage_avg;
+	if (di->current_avg > di->current_max)
+		di->current_max = di->current_avg;
+
+	/* smooth charge */
+	if (di->remain_cap > di->fcc) {
+		di->sm_remain_cap -= (di->remain_cap - di->fcc);
+		DBG("<%s>. cap: remain=%d, sm_remain=%d\n",
+		    __func__, di->remain_cap, di->sm_remain_cap);
+		rk818_bat_init_coulomb_cap(di, di->fcc);
+	}
+
+	if (di->chrg_status != CHARGE_FINISH)
+		di->finish_base = get_boot_sec();
+
+	/*
+	 * we need update fcc in continuous charging state, if discharge state
+	 * keep at least 2 hour, we decide not to update fcc, so clear the
+	 * fcc update flag: age_allow_update.
+	 */
+	if (base2min(di->plug_out_base) > 120)
+		di->age_allow_update = false;
+
+	/* do adc calib: status must from cccv mode to finish mode */
+	if (di->chrg_status == CC_OR_CV) {
+		di->adc_allow_update = true;
+		di->adc_calib_cnt = 0;
+	}
+}
+
+static void rk818_bat_init_ts1_detect(struct rk818_battery *di)
+{
+	u8 buf;
+	u32 *ntc_table = di->pdata->ntc_table;
+
+	if (!di->pdata->ntc_size)
+		return;
+
+	/* select ua */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf &= ~TS1_CUR_MSK;
+	/* chose suitable UA for temperature detect */
+	if (ntc_table[0] < NTC_80UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_80UA;
+		di->pdata->ntc_uA = 80;
+		buf |= ADC_CUR_80UA;
+	} else if (ntc_table[0] < NTC_60UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_60UA;
+		di->pdata->ntc_uA = 60;
+		buf |= ADC_CUR_60UA;
+	} else if (ntc_table[0] < NTC_40UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_40UA;
+		di->pdata->ntc_uA = 40;
+		buf |= ADC_CUR_40UA;
+	} else {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_20UA;
+		di->pdata->ntc_uA = 20;
+		buf |= ADC_CUR_20UA;
+	}
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+
+	/* enable ADC_TS1_EN */
+	buf = rk818_bat_read(di, RK818_ADC_CTRL_REG);
+	buf |= ADC_TS1_EN;
+	rk818_bat_write(di, RK818_ADC_CTRL_REG, buf);
+}
+
+/*
+ * Due to hardware design issue, Vdelta = "(R_sample + R_other) * I_avg" will be
+ * included into TS1 adc value. We must subtract it to get correct adc value.
+ * The solution:
+ *
+ * (1) calculate Vdelta:
+ *
+ *   adc1 - Vdelta    ua1			  (adc2 * ua1) - (adc1 * ua2)
+ *   ------------- = -----  ==> equals: Vdelta = -----------------------------
+ *   adc2 - Vdelta    ua2				ua1 - ua2
+ *
+ *
+ * (2) calculate correct ADC value:
+ *
+ *     charging: ADC = adc1 - abs(Vdelta);
+ *  discharging: ADC = adc1 + abs(Vdelta);
+ */
+static int rk818_bat_get_ntc_res(struct rk818_battery *di)
+{
+	int adc1 = 0, adc2 = 0;
+	int ua1, ua2, v_delta, res, val;
+	u8 buf;
+
+	/* read sample ua1 */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	DBG("<%s>. read adc1, sample uA=%d\n",
+	    __func__, ((buf & 0x03) + 1) * 20);
+
+	/* read adc adc1 */
+	ua1 = di->pdata->ntc_uA;
+	adc1 |= rk818_bat_read(di, RK818_TS1_ADC_REGL) << 0;
+	adc1 |= rk818_bat_read(di, RK818_TS1_ADC_REGH) << 8;
+
+	/* chose reference UA for adc2 */
+	ua2 = (ua1 != 20) ? 20 : 40;
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf &= ~TS1_CUR_MSK;
+	buf |= ((ua2 - 20) / 20);
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+
+	/* read adc adc2 */
+	msleep(1000);
+
+	/* read sample ua2 */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	DBG("<%s>. read adc2, sample uA=%d\n",
+	    __func__, ((buf & 0x03) + 1) * 20);
+
+	adc2 |= rk818_bat_read(di, RK818_TS1_ADC_REGL) << 0;
+	adc2 |= rk818_bat_read(di, RK818_TS1_ADC_REGH) << 8;
+
+	DBG("<%s>. ua1=%d, ua2=%d, adc1=%d, adc2=%d\n",
+	    __func__, ua1, ua2, adc1, adc2);
+
+	/* calculate delta voltage */
+	if (adc2 != adc1)
+		v_delta = abs((adc2 * ua1 - adc1 * ua2) / (ua2 - ua1));
+	else
+		v_delta = 0;
+
+	/* considering current avg direction, calcuate real adc value */
+	val = (di->current_avg >= 0) ? (adc1 - v_delta) : (adc1 + v_delta);
+
+	DBG("<%s>. Iavg=%d, Vdelta=%d, Vadc=%d\n",
+	    __func__, di->current_avg, v_delta, val);
+
+	res = val * di->pdata->ntc_factor;
+
+	DBG("<%s>. val=%d, ntc_res=%d, ntc_factor=%d, Rdelta=%d\n",
+	    __func__, val, res, di->pdata->ntc_factor,
+	    v_delta * di->pdata->ntc_factor);
+
+	DBG("<%s>. t=[%d'C(%d) ~ %dC(%d)]\n", __func__,
+	    di->pdata->ntc_degree_from, di->pdata->ntc_table[0],
+	    di->pdata->ntc_degree_from + di->pdata->ntc_size - 1,
+	    di->pdata->ntc_table[di->pdata->ntc_size - 1]);
+
+	rk818_bat_init_ts1_detect(di);
+
+	return res;
+}
+
+static void rk818_bat_set_input_current(struct rk818_battery *di,
+					int input_current)
+{
+	u8 usb_ctrl;
+
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	usb_ctrl &= ~0x0f;
+	usb_ctrl |= (input_current);
+	rk818_bat_write(di, RK818_USB_CTRL_REG, usb_ctrl);
+}
+
+static BLOCKING_NOTIFIER_HEAD(rk818_bat_notifier_chain);
+
+int rk818_bat_temp_notifier_register(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&rk818_bat_notifier_chain, nb);
+}
+EXPORT_SYMBOL_GPL(rk818_bat_temp_notifier_register);
+
+int rk818_bat_temp_notifier_unregister(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&rk818_bat_notifier_chain, nb);
+}
+EXPORT_SYMBOL_GPL(rk818_bat_temp_notifier_unregister);
+
+static void rk818_bat_temp_notifier_callback(int temp)
+{
+	blocking_notifier_call_chain(&rk818_bat_notifier_chain, temp, NULL);
+}
+
+static void rk818_bat_update_temperature(struct rk818_battery *di)
+{
+	static int old_temp, first_time = 1;
+	u32 ntc_size, *ntc_table;
+	int i, res, temp;
+
+	ntc_table = di->pdata->ntc_table;
+	ntc_size = di->pdata->ntc_size;
+	di->temperature = VIRTUAL_TEMPERATURE;
+
+	if (ntc_size) {
+		res = rk818_bat_get_ntc_res(di);
+		if (res < ntc_table[ntc_size - 1]) {
+			di->temperature = di->pdata->ntc_degree_from +
+					  di->pdata->ntc_size - 1;
+			if (di->pdata->bat_mode != MODE_VIRTUAL)
+				rk818_bat_set_input_current(di, INPUT_CUR80MA);
+			BAT_INFO("bat ntc upper max degree: R=%d\n", res);
+		} else if (res > ntc_table[0]) {
+			di->temperature = di->pdata->ntc_degree_from;
+			if (di->pdata->bat_mode != MODE_VIRTUAL)
+				rk818_bat_set_input_current(di, INPUT_CUR80MA);
+			BAT_INFO("bat ntc lower min degree: R=%d\n", res);
+		} else {
+			for (i = 0; i < ntc_size; i++) {
+				if (res >= ntc_table[i])
+					break;
+			}
+
+			/* if first in, init old_temp */
+			temp = (i + di->pdata->ntc_degree_from) * 10;
+			if (first_time == 1) {
+				di->temperature = temp;
+				old_temp = temp;
+				first_time = 0;
+			}
+
+			/*
+			 * compare with old one, it's invalid when over 50
+			 * and we should use old data.
+			 */
+			if (abs(temp - old_temp) > 50)
+				temp = old_temp;
+			else
+				old_temp = temp;
+
+			di->temperature = temp;
+			DBG("<%s>. temperature = %d\n",
+			    __func__, di->temperature);
+			rk818_bat_temp_notifier_callback(di->temperature / 10);
+		}
+	}
+}
+
+static void rk818_bat_init_dsoc_algorithm(struct rk818_battery *di)
+{
+	u8 buf;
+	int16_t rest = 0;
+	unsigned long soc_sec;
+	const char *mode_name[] = { "MODE_ZERO", "MODE_FINISH",
+		"MODE_SMOOTH_CHRG", "MODE_SMOOTH_DISCHRG", "MODE_SMOOTH", };
+
+	/* get rest */
+	rest |= rk818_bat_read(di, RK818_CALC_REST_REGH) << 8;
+	rest |= rk818_bat_read(di, RK818_CALC_REST_REGL) << 0;
+
+	/* get mode */
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	di->algo_rest_mode = (buf & ALGO_REST_MODE_MSK) >> ALGO_REST_MODE_SHIFT;
+
+	if (rk818_bat_get_chrg_status(di) == CHARGE_FINISH) {
+		if (di->algo_rest_mode == MODE_FINISH) {
+			soc_sec = di->fcc * 3600 / 100 / FINISH_CHRG_CUR1;
+			if ((rest / DIV(soc_sec)) > 0) {
+				if (di->dsoc < 100) {
+					di->dsoc++;
+					di->algo_rest_val = rest % soc_sec;
+					BAT_INFO("algorithm rest(%d) dsoc "
+						 "inc: %d\n",
+						 rest, di->dsoc);
+				} else {
+					di->algo_rest_val = 0;
+				}
+			} else {
+				di->algo_rest_val = rest;
+			}
+		} else {
+			di->algo_rest_val = rest;
+		}
+	} else {
+		/* charge speed up */
+		if ((rest / 1000) > 0 && rk818_bat_chrg_online(di)) {
+			if (di->dsoc < di->rsoc) {
+				di->dsoc++;
+				di->algo_rest_val = rest % 1000;
+				BAT_INFO("algorithm rest(%d) dsoc inc: %d\n",
+					 rest, di->dsoc);
+			} else {
+				di->algo_rest_val = 0;
+			}
+		/* discharge speed up */
+		} else if (((rest / 1000) < 0) && !rk818_bat_chrg_online(di)) {
+			if (di->dsoc > di->rsoc) {
+				di->dsoc--;
+				di->algo_rest_val = rest % 1000;
+				BAT_INFO("algorithm rest(%d) dsoc sub: %d\n",
+					 rest, di->dsoc);
+			} else {
+				di->algo_rest_val = 0;
+			}
+		} else {
+			di->algo_rest_val = rest;
+		}
+	}
+
+	if (di->dsoc >= 100)
+		di->dsoc = 100;
+	else if (di->dsoc <= 0)
+		di->dsoc = 0;
+
+	/* init current mode */
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	if (rk818_bat_get_chrg_status(di) == CHARGE_FINISH) {
+		rk818_bat_finish_algo_prepare(di);
+		di->work_mode = MODE_FINISH;
+	} else {
+		rk818_bat_smooth_algo_prepare(di);
+		di->work_mode = MODE_SMOOTH;
+	}
+
+	DBG("<%s>. init: org_rest=%d, rest=%d, mode=%s; "
+	    "doc(x1000): zero=%d, chrg=%d, dischrg=%d, finish=%lu\n",
+	    __func__, rest, di->algo_rest_val, mode_name[di->algo_rest_mode],
+	    di->zero_dsoc, di->sm_chrg_dsoc, di->sm_dischrg_dsoc,
+	    di->finish_base);
+}
+
+static void rk818_bat_save_algo_rest(struct rk818_battery *di)
+{
+	u8 buf, mode;
+	int16_t algo_rest = 0;
+	int tmp_soc;
+	int zero_rest = 0, sm_chrg_rest = 0;
+	int sm_dischrg_rest = 0, finish_rest = 0;
+	const char *mode_name[] = { "MODE_ZERO", "MODE_FINISH",
+		"MODE_SMOOTH_CHRG", "MODE_SMOOTH_DISCHRG", "MODE_SMOOTH", };
+
+	/* zero dischrg */
+	tmp_soc = (di->zero_dsoc) / 1000;
+	if (tmp_soc == di->dsoc)
+		zero_rest = di->zero_dsoc - ((di->dsoc + 1) * 1000 -
+				MIN_ACCURACY);
+
+	/* sm chrg */
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		sm_chrg_rest = di->sm_chrg_dsoc - di->dsoc * 1000;
+
+	/* sm dischrg */
+	tmp_soc = (di->sm_dischrg_dsoc) / 1000;
+	if (tmp_soc == di->dsoc)
+		sm_dischrg_rest = di->sm_dischrg_dsoc - ((di->dsoc + 1) * 1000 -
+				MIN_ACCURACY);
+
+	/* last time is also finish chrg, then add last rest */
+	if (di->algo_rest_mode == MODE_FINISH && di->algo_rest_val)
+		finish_rest = base2sec(di->finish_base) + di->algo_rest_val;
+	else
+		finish_rest = base2sec(di->finish_base);
+
+	/* total calc */
+	if ((rk818_bat_chrg_online(di) && (di->dsoc > di->rsoc)) ||
+	    (!rk818_bat_chrg_online(di) && (di->dsoc < di->rsoc)) ||
+	    (di->dsoc == di->rsoc)) {
+		di->algo_rest_val = 0;
+		algo_rest = 0;
+		DBG("<%s>. step1..\n", __func__);
+	} else if (di->work_mode == MODE_FINISH) {
+		algo_rest = finish_rest;
+		DBG("<%s>. step2..\n", __func__);
+	} else if (di->algo_rest_mode == MODE_FINISH) {
+		algo_rest = zero_rest + sm_dischrg_rest + sm_chrg_rest;
+		DBG("<%s>. step3..\n", __func__);
+	} else {
+		if (rk818_bat_chrg_online(di) && (di->dsoc < di->rsoc))
+			algo_rest = sm_chrg_rest + di->algo_rest_val;
+		else if (!rk818_bat_chrg_online(di) && (di->dsoc > di->rsoc))
+			algo_rest = zero_rest + sm_dischrg_rest +
+				    di->algo_rest_val;
+		else
+			algo_rest = zero_rest + sm_dischrg_rest + sm_chrg_rest +
+				    di->algo_rest_val;
+		DBG("<%s>. step4..\n", __func__);
+	}
+
+	/* check mode */
+	if ((di->work_mode == MODE_FINISH) || (di->work_mode == MODE_ZERO)) {
+		mode = di->work_mode;
+	} else {/* MODE_SMOOTH */
+		if (di->sm_linek > 0)
+			mode = MODE_SMOOTH_CHRG;
+		else
+			mode = MODE_SMOOTH_DISCHRG;
+	}
+
+	/* save mode */
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	buf &= ~ALGO_REST_MODE_MSK;
+	buf |= (mode << ALGO_REST_MODE_SHIFT);
+	rk818_bat_write(di, RK818_MISC_MARK_REG, buf);
+
+	/* save rest */
+	buf = (algo_rest >> 8) & 0xff;
+	rk818_bat_write(di, RK818_CALC_REST_REGH, buf);
+	buf = (algo_rest >> 0) & 0xff;
+	rk818_bat_write(di, RK818_CALC_REST_REGL, buf);
+
+	DBG("<%s>. rest: algo=%d, mode=%s, last_rest=%d; zero=%d, "
+	    "chrg=%d, dischrg=%d, finish=%lu\n",
+	    __func__, algo_rest, mode_name[mode], di->algo_rest_val, zero_rest,
+	    sm_chrg_rest, sm_dischrg_rest, base2sec(di->finish_base));
+}
+
+static void rk818_bat_save_data(struct rk818_battery *di)
+{
+	rk818_bat_save_dsoc(di, di->dsoc);
+	rk818_bat_save_cap(di, di->remain_cap);
+	rk818_bat_save_algo_rest(di);
+}
+
+static void rk818_battery_work(struct work_struct *work)
+{
+	struct rk818_battery *di =
+		container_of(work, struct rk818_battery, bat_delay_work.work);
+
+	rk818_bat_update_info(di);
+	rk818_bat_wait_finish_sig(di);
+	rk818_bat_rsoc_daemon(di);
+	rk818_bat_update_temperature(di);
+	rk818_bat_display_smooth(di);
+	rk818_bat_power_supply_changed(di);
+	rk818_bat_save_data(di);
+	rk818_bat_debug_info(di);
+
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(di->monitor_ms));
+}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+static irqreturn_t rk818_vb_low_irq(int irq, void *bat)
+{
+	struct rk818_battery *di = (struct rk818_battery *)bat;
+
+	di->dsoc = 0;
+	rk_send_wakeup_key();
+	BAT_INFO("lower power yet, power off system! v=%d, c=%d, dsoc=%d\n",
+		 di->voltage_avg, di->current_avg, di->dsoc);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static void rk818_bat_init_sysfs(struct rk818_battery *di)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(rk818_bat_attr); i++) {
+		ret = sysfs_create_file(&di->dev->kobj,
+					&rk818_bat_attr[i].attr);
+		if (ret)
+			dev_err(di->dev, "create bat node(%s) error\n",
+				rk818_bat_attr[i].attr.name);
+	}
+}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+static int rk818_bat_init_irqs(struct rk818_battery *di)
+{
+	struct rk808 *rk818 = di->rk818;
+	struct platform_device *pdev = di->pdev;
+	int ret, vb_lo_irq;
+
+	vb_lo_irq = regmap_irq_get_virq(rk818->irq_data, RK818_IRQ_VB_LO);
+	if (vb_lo_irq < 0) {
+		dev_err(di->dev, "vb_lo_irq request failed!\n");
+		return vb_lo_irq;
+	}
+
+	ret = devm_request_threaded_irq(di->dev, vb_lo_irq, NULL,
+					rk818_vb_low_irq,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					"rk818_vb_low", di);
+	if (ret) {
+		dev_err(&pdev->dev, "vb_lo_irq request failed!\n");
+		return ret;
+	}
+	enable_irq_wake(vb_lo_irq);
+
+	return 0;
+}
+#endif
+
+static void rk818_bat_init_info(struct rk818_battery *di)
+{
+	di->design_cap = di->pdata->design_capacity;
+	di->qmax = di->pdata->design_qmax;
+	di->bat_res = di->pdata->bat_res;
+	di->monitor_ms = di->pdata->monitor_sec * TIMER_MS_COUNTS;
+	di->boot_base = POWER_ON_SEC_BASE;
+	di->res_div = (di->pdata->sample_res == SAMPLE_RES_20MR) ?
+		       SAMPLE_RES_DIV1 : SAMPLE_RES_DIV2;
+}
+
+static time_t rk818_get_rtc_sec(void)
+{
+	int err;
+	struct rtc_time tm;
+	struct timespec tv = { .tv_nsec = NSEC_PER_SEC >> 1, };
+	struct rtc_device *rtc = rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);
+	time_t sec;
+
+	err = rtc_read_time(rtc, &tm);
+	if (err) {
+		dev_err(rtc->dev.parent, "read hardware clk failed\n");
+		return 0;
+	}
+
+	err = rtc_valid_tm(&tm);
+	if (err) {
+		dev_err(rtc->dev.parent, "invalid date time\n");
+		return 0;
+	}
+
+	rtc_tm_to_time(&tm, &tv.tv_sec);
+	sec = tv.tv_sec;
+
+	return sec;
+}
+
+static int rk818_bat_rtc_sleep_sec(struct rk818_battery *di)
+{
+	int interval_sec;
+
+	interval_sec = rk818_get_rtc_sec() - di->rtc_base;
+
+	return (interval_sec > 0) ? interval_sec : 0;
+}
+
+static void rk818_bat_set_shtd_vol(struct rk818_battery *di)
+{
+	u8 val;
+
+	/* set vbat lowest 3.0v shutdown */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= ~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK);
+	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+
+	/* disable low irq */
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1,
+			   VB_LOW_INT_EN, VB_LOW_INT_EN);
+}
+
+static void rk818_bat_init_fg(struct rk818_battery *di)
+{
+	rk818_bat_enable_gauge(di);
+	rk818_bat_init_voltage_kb(di);
+	rk818_bat_init_coffset(di);
+	rk818_bat_set_relax_sample(di);
+	rk818_bat_set_ioffset_sample(di);
+	rk818_bat_set_ocv_sample(di);
+	rk818_bat_init_ts1_detect(di);
+	rk818_bat_init_rsoc(di);
+	rk818_bat_init_coulomb_cap(di, di->nac);
+	rk818_bat_init_age_algorithm(di);
+	rk818_bat_init_chrg_config(di);
+	rk818_bat_set_shtd_vol(di);
+	rk818_bat_init_zero_table(di);
+	rk818_bat_init_caltimer(di);
+	rk818_bat_init_dsoc_algorithm(di);
+
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->voltage_ocv = rk818_bat_get_ocv_voltage(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->dbg_pwr_dsoc = di->dsoc;
+	di->dbg_pwr_rsoc = di->rsoc;
+	di->dbg_pwr_vol = di->voltage_avg;
+
+	rk818_bat_dump_regs(di, 0x99, 0xee);
+	DBG("nac=%d cap=%d ov=%d v=%d rv=%d dl=%d rl=%d c=%d\n",
+	    di->nac, di->remain_cap, di->voltage_ocv, di->voltage_avg,
+	    di->voltage_relax, di->dsoc, di->rsoc, di->current_avg);
+}
+
+#ifdef CONFIG_OF
+static int rk818_bat_parse_dt(struct rk818_battery *di)
+{
+	u32 out_value;
+	int length, ret;
+	size_t size;
+	struct device_node *np = di->dev->of_node;
+	struct battery_platform_data *pdata;
+	struct device *dev = di->dev;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	di->pdata = pdata;
+	/* init default param */
+	pdata->bat_res = DEFAULT_BAT_RES;
+	pdata->monitor_sec = DEFAULT_MONITOR_SEC;
+	pdata->pwroff_vol = DEFAULT_PWROFF_VOL_THRESD;
+	pdata->sleep_exit_current = DEFAULT_SLP_EXIT_CUR;
+	pdata->sleep_enter_current = DEFAULT_SLP_ENTER_CUR;
+	pdata->bat_mode = MODE_BATTARY;
+	pdata->max_soc_offset = DEFAULT_MAX_SOC_OFFSET;
+	pdata->sample_res = DEFAULT_SAMPLE_RES;
+	pdata->energy_mode = DEFAULT_ENERGY_MODE;
+	pdata->fb_temp = DEFAULT_FB_TEMP;
+	pdata->zero_reserve_dsoc = DEFAULT_ZERO_RESERVE_DSOC;
+
+	/* parse necessary param */
+	if (!of_find_property(np, "ocv_table", &length)) {
+		dev_err(dev, "ocv_table not found!\n");
+		return -EINVAL;
+	}
+
+	pdata->ocv_size = length / sizeof(u32);
+	if (pdata->ocv_size <= 0) {
+		dev_err(dev, "invalid ocv table\n");
+		return -EINVAL;
+	}
+
+	size = sizeof(*pdata->ocv_table) * pdata->ocv_size;
+	pdata->ocv_table = devm_kzalloc(di->dev, size, GFP_KERNEL);
+	if (!pdata->ocv_table)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "ocv_table",
+					 pdata->ocv_table,
+					 pdata->ocv_size);
+	if (ret < 0)
+		return ret;
+
+	ret = of_property_read_u32(np, "design_capacity", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "design_capacity not found!\n");
+		return ret;
+	}
+	pdata->design_capacity = out_value;
+
+	ret = of_property_read_u32(np, "design_qmax", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "design_qmax not found!\n");
+		return ret;
+	}
+	pdata->design_qmax = out_value;
+	ret = of_property_read_u32(np, "max_chrg_voltage", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "max_chrg_voltage missing!\n");
+		return ret;
+	}
+	pdata->max_chrg_voltage = out_value;
+	if (out_value >= 4300)
+		pdata->zero_algorithm_vol = DEFAULT_ALGR_VOL_THRESD2;
+	else
+		pdata->zero_algorithm_vol = DEFAULT_ALGR_VOL_THRESD1;
+
+	ret = of_property_read_u32(np, "fb_temperature", &pdata->fb_temp);
+	if (ret < 0)
+		dev_err(dev, "fb_temperature missing!\n");
+
+	ret = of_property_read_u32(np, "sample_res", &pdata->sample_res);
+	if (ret < 0)
+		dev_err(dev, "sample_res missing!\n");
+
+	ret = of_property_read_u32(np, "energy_mode", &pdata->energy_mode);
+	if (ret < 0)
+		dev_err(dev, "energy_mode missing!\n");
+
+	ret = of_property_read_u32(np, "max_soc_offset",
+				   &pdata->max_soc_offset);
+	if (ret < 0)
+		dev_err(dev, "max_soc_offset missing!\n");
+
+	ret = of_property_read_u32(np, "monitor_sec", &pdata->monitor_sec);
+	if (ret < 0)
+		dev_err(dev, "monitor_sec missing!\n");
+
+	ret = of_property_read_u32(np, "zero_algorithm_vol",
+				   &pdata->zero_algorithm_vol);
+	if (ret < 0)
+		dev_err(dev, "zero_algorithm_vol missing!\n");
+
+	ret = of_property_read_u32(np, "zero_reserve_dsoc",
+				  &pdata->zero_reserve_dsoc);
+
+	ret = of_property_read_u32(np, "virtual_power", &pdata->bat_mode);
+	if (ret < 0)
+		dev_err(dev, "virtual_power missing!\n");
+
+	ret = of_property_read_u32(np, "bat_res", &pdata->bat_res);
+	if (ret < 0)
+		dev_err(dev, "bat_res missing!\n");
+
+	ret = of_property_read_u32(np, "sleep_enter_current",
+				   &pdata->sleep_enter_current);
+	if (ret < 0)
+		dev_err(dev, "sleep_enter_current missing!\n");
+
+	ret = of_property_read_u32(np, "sleep_exit_current",
+				   &pdata->sleep_exit_current);
+	if (ret < 0)
+		dev_err(dev, "sleep_exit_current missing!\n");
+
+	ret = of_property_read_u32(np, "power_off_thresd", &pdata->pwroff_vol);
+	if (ret < 0)
+		dev_err(dev, "power_off_thresd missing!\n");
+
+	if (!of_find_property(np, "ntc_table", &length)) {
+		pdata->ntc_size = 0;
+	} else {
+		/* get ntc degree base value */
+		ret = of_property_read_s32(np, "ntc_degree_from_v2",
+					   &pdata->ntc_degree_from);
+		if (ret) {
+			dev_err(dev, "invalid ntc_degree_from_v2\n");
+			return -EINVAL;
+		}
+
+		pdata->ntc_size = length / sizeof(u32);
+	}
+
+	if (pdata->ntc_size) {
+		size = sizeof(*pdata->ntc_table) * pdata->ntc_size;
+		pdata->ntc_table = devm_kzalloc(di->dev, size, GFP_KERNEL);
+		if (!pdata->ntc_table)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(np, "ntc_table",
+						 pdata->ntc_table,
+						 pdata->ntc_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	DBG("the battery dts info dump:\n"
+	    "bat_res:%d\n"
+	    "design_capacity:%d\n"
+	    "design_qmax :%d\n"
+	    "sleep_enter_current:%d\n"
+	    "sleep_exit_current:%d\n"
+	    "zero_algorithm_vol:%d\n"
+	    "zero_reserve_dsoc:%d\n"
+	    "monitor_sec:%d\n"
+	    "max_soc_offset:%d\n"
+	    "virtual_power:%d\n"
+	    "pwroff_vol:%d\n"
+	    "sample_res:%d\n"
+	    "ntc_size=%d\n"
+	    "ntc_degree_from_v2:%d\n"
+	    "ntc_degree_to:%d\n",
+	    pdata->bat_res, pdata->design_capacity, pdata->design_qmax,
+	    pdata->sleep_enter_current, pdata->sleep_exit_current,
+	    pdata->zero_algorithm_vol, pdata->zero_reserve_dsoc,
+	    pdata->monitor_sec,
+	    pdata->max_soc_offset, pdata->bat_mode, pdata->pwroff_vol,
+	    pdata->sample_res, pdata->ntc_size, pdata->ntc_degree_from,
+	    pdata->ntc_degree_from + pdata->ntc_size - 1
+	    );
+
+	return 0;
+}
+#else
+static int rk818_bat_parse_dt(struct rk818_battery *di)
+{
+	return -ENODEV;
+}
+#endif
+
+static const struct of_device_id rk818_battery_of_match[] = {
+	{.compatible = "rk818-battery",},
+	{ },
+};
+
+static int rk818_battery_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(rk818_battery_of_match, &pdev->dev);
+	struct rk818_battery *di;
+	struct rk808 *rk818 = dev_get_drvdata(pdev->dev.parent);
+	struct i2c_client *client = rk818->i2c;
+	int ret;
+
+	if (!of_id) {
+		dev_err(&pdev->dev, "Failed to find matching dt id\n");
+		return -ENODEV;
+	}
+
+	di = devm_kzalloc(&client->dev, sizeof(*di), GFP_KERNEL);
+	if (!di)
+		return -ENOMEM;
+
+	di->rk818 = rk818;
+	di->client = client;
+	di->pdev = pdev;
+	di->dev = &pdev->dev;
+	di->regmap = rk818->regmap;
+	platform_set_drvdata(pdev, di);
+
+	ret = rk818_bat_parse_dt(di);
+	if (ret < 0) {
+		dev_err(di->dev, "rk818 battery parse dt failed!\n");
+		return ret;
+	}
+
+	if (!is_rk818_bat_exist(di)) {
+		di->pdata->bat_mode = MODE_VIRTUAL;
+		dev_err(di->dev, "no battery, virtual power mode\n");
+	}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	ret = rk818_bat_init_irqs(di);
+	if (ret != 0) {
+		dev_err(di->dev, "rk818 bat init irqs failed!\n");
+		return ret;
+	}
+#endif
+	ret = rk818_bat_init_power_supply(di);
+	if (ret) {
+		dev_err(di->dev, "rk818 power supply register failed!\n");
+		return ret;
+	}
+
+	rk818_bat_init_info(di);
+	rk818_bat_init_fg(di);
+	rk818_bat_init_sysfs(di);
+	rk818_bat_register_fb_notify(di);
+	di->bat_monitor_wq = alloc_ordered_workqueue("%s",
+			WQ_MEM_RECLAIM | WQ_FREEZABLE, "rk818-bat-monitor-wq");
+	INIT_DELAYED_WORK(&di->bat_delay_work, rk818_battery_work);
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(TIMER_MS_COUNTS * 5));
+
+	BAT_INFO("driver version %s\n", DRIVER_VERSION);
+
+	return ret;
+}
+
+static int rk818_battery_suspend(struct platform_device *dev,
+				 pm_message_t state)
+{
+	struct rk818_battery *di = platform_get_drvdata(dev);
+	u8 val, st;
+
+	cancel_delayed_work_sync(&di->bat_delay_work);
+
+	di->s2r = false;
+	di->sleep_chrg_online = rk818_bat_chrg_online(di);
+	di->sleep_chrg_status = rk818_bat_get_chrg_status(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	di->rtc_base = rk818_get_rtc_sec();
+	rk818_bat_save_data(di);
+	st = (rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK) >> 4;
+
+	/* if not CHARGE_FINISH, reinit finish_base.
+	 * avoid sleep loop between suspend and resume
+	 */
+	if (di->sleep_chrg_status != CHARGE_FINISH)
+		di->finish_base = get_boot_sec();
+
+	/* avoid: enter suspend from MODE_ZERO: load from heavy to light */
+	if ((di->work_mode == MODE_ZERO) &&
+	    (di->sleep_chrg_online) && (di->current_avg >= 0)) {
+		DBG("suspend: MODE_ZERO exit...\n");
+		/* it need't do prepare for mode finish and smooth, it will
+		 * be done in display_smooth
+		 */
+		if (di->sleep_chrg_status == CHARGE_FINISH) {
+			di->work_mode = MODE_FINISH;
+			di->finish_base = get_boot_sec();
+		} else {
+			di->work_mode = MODE_SMOOTH;
+			rk818_bat_smooth_algo_prepare(di);
+		}
+	}
+
+	/* set vbat low than 3.4v to generate a wakeup irq */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= (~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK));
+	val |= (RK818_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1, VB_LOW_INT_EN, 0);
+
+	BAT_INFO("suspend: dl=%d rl=%d c=%d v=%d cap=%d at=%ld ch=%d st=%s\n",
+		 di->dsoc, di->rsoc, di->current_avg,
+		 rk818_bat_get_avg_voltage(di), rk818_bat_get_coulomb_cap(di),
+		 di->sleep_dischrg_sec, di->sleep_chrg_online, bat_status[st]);
+
+	return 0;
+}
+
+static int rk818_battery_resume(struct platform_device *dev)
+{
+	struct rk818_battery *di = platform_get_drvdata(dev);
+	int interval_sec, time_step = 0, pwroff_vol;
+	u8 val, st;
+
+	di->s2r = true;
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	interval_sec = rk818_bat_rtc_sleep_sec(di);
+	di->sleep_sum_sec += interval_sec;
+	pwroff_vol = di->pdata->pwroff_vol;
+	st = (rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK) >> 4;
+
+	if (!di->sleep_chrg_online) {
+		/* only add up discharge sleep seconds */
+		di->sleep_dischrg_sec += interval_sec;
+		if (di->voltage_avg <= pwroff_vol + 50)
+			time_step = DISCHRG_TIME_STEP1;
+		else
+			time_step = DISCHRG_TIME_STEP2;
+	}
+
+	BAT_INFO("resume: dl=%d rl=%d c=%d v=%d rv=%d "
+		 "cap=%d dt=%d at=%ld ch=%d st=%s\n",
+		 di->dsoc, di->rsoc, di->current_avg, di->voltage_avg,
+		 di->voltage_relax, rk818_bat_get_coulomb_cap(di), interval_sec,
+		 di->sleep_dischrg_sec, di->sleep_chrg_online, bat_status[st]);
+
+	/* sleep: enough time and discharge */
+	if ((di->sleep_dischrg_sec > time_step) && (!di->sleep_chrg_online)) {
+		if (rk818_bat_sleep_dischrg(di))
+			di->sleep_dischrg_sec = 0;
+	}
+
+	rk818_bat_save_data(di);
+
+	/* set vbat lowest 3.0v shutdown */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= ~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK);
+	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1,
+			   VB_LOW_INT_EN, VB_LOW_INT_EN);
+
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(1000));
+
+	return 0;
+}
+
+static void rk818_battery_shutdown(struct platform_device *dev)
+{
+	u8 cnt = 0;
+	struct rk818_battery *di = platform_get_drvdata(dev);
+
+	cancel_delayed_work_sync(&di->bat_delay_work);
+	cancel_delayed_work_sync(&di->calib_delay_work);
+	rk818_bat_unregister_fb_notify(di);
+	del_timer(&di->caltimer);
+	if (base2sec(di->boot_base) < REBOOT_PERIOD_SEC)
+		cnt = rk818_bat_check_reboot(di);
+	else
+		rk818_bat_save_reboot_cnt(di, 0);
+
+	BAT_INFO("shutdown: dl=%d rl=%d c=%d v=%d cap=%d f=%d ch=%d n=%d "
+		 "mode=%d rest=%d\n",
+		 di->dsoc, di->rsoc, di->current_avg, di->voltage_avg,
+		 di->remain_cap, di->fcc, rk818_bat_chrg_online(di), cnt,
+		 di->algo_rest_mode, di->algo_rest_val);
+}
+
+static struct platform_driver rk818_battery_driver = {
+	.probe = rk818_battery_probe,
+	.suspend = rk818_battery_suspend,
+	.resume = rk818_battery_resume,
+	.shutdown = rk818_battery_shutdown,
+	.driver = {
+		.name = "rk818-battery",
+		.of_match_table = rk818_battery_of_match,
+	},
+};
+
+static int __init battery_init(void)
+{
+	return platform_driver_register(&rk818_battery_driver);
+}
+fs_initcall_sync(battery_init);
+
+static void __exit battery_exit(void)
+{
+	platform_driver_unregister(&rk818_battery_driver);
+}
+module_exit(battery_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rk818-battery");
+MODULE_AUTHOR("chenjh<chenjh@rock-chips.com>");
diff --git a/drivers/power/supply/rk818_battery.h b/drivers/power/supply/rk818_battery.h
new file mode 100644
index 000000000000..66cbbe9dac4c
--- /dev/null
+++ b/drivers/power/supply/rk818_battery.h
@@ -0,0 +1,168 @@
+/*
+ * rk818_battery.h: fuel gauge driver structures
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * Author: chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef RK818_BATTERY
+#define RK818_BATTERY
+
+/* RK818_INT_STS_MSK_REG2 */
+#define PLUG_IN_MSK		BIT(0)
+#define PLUG_OUT_MSK		BIT(1)
+#define CHRG_CVTLMT_INT_MSK	BIT(6)
+
+/* RK818_TS_CTRL_REG */
+#define GG_EN			BIT(7)
+#define ADC_CUR_EN		BIT(6)
+#define ADC_TS1_EN		BIT(5)
+#define ADC_TS2_EN		BIT(4)
+#define TS1_CUR_MSK		0x03
+
+/* RK818_GGCON */
+#define OCV_SAMP_MIN_MSK	0x0c
+#define OCV_SAMP_8MIN		(0x00 << 2)
+
+#define ADC_CAL_MIN_MSK		0x30
+#define ADC_CAL_8MIN		(0x00 << 4)
+#define ADC_CUR_MODE		BIT(1)
+
+/* RK818_GGSTS */
+#define BAT_CON			BIT(4)
+#define RELAX_VOL1_UPD		BIT(3)
+#define RELAX_VOL2_UPD		BIT(2)
+#define RELAX_VOL12_UPD_MSK	(RELAX_VOL1_UPD | RELAX_VOL2_UPD)
+
+/* RK818_SUP_STS_REG */
+#define CHRG_STATUS_MSK		0x70
+#define BAT_EXS			BIT(7)
+#define CHARGE_OFF		(0x0 << 4)
+#define DEAD_CHARGE		(0x1 << 4)
+#define TRICKLE_CHARGE		(0x2 << 4)
+#define CC_OR_CV		(0x3 << 4)
+#define CHARGE_FINISH		(0x4 << 4)
+#define USB_OVER_VOL		(0x5 << 4)
+#define BAT_TMP_ERR		(0x6 << 4)
+#define TIMER_ERR		(0x7 << 4)
+#define USB_VLIMIT_EN		BIT(3)
+#define USB_CLIMIT_EN		BIT(2)
+#define USB_EXIST		BIT(1)
+#define USB_EFF			BIT(0)
+
+/* RK818_USB_CTRL_REG */
+#define CHRG_CT_EN		BIT(7)
+#define FINISH_CUR_MSK		0xc0
+#define TEMP_105C		(0x02 << 2)
+#define FINISH_100MA		(0x00 << 6)
+#define FINISH_150MA		(0x01 << 6)
+#define FINISH_200MA		(0x02 << 6)
+#define FINISH_250MA		(0x03 << 6)
+
+/* RK818_CHRG_CTRL_REG3 */
+#define CHRG_TERM_MODE_MSK	BIT(5)
+#define CHRG_TERM_ANA_SIGNAL	(0 << 5)
+#define CHRG_TERM_DIG_SIGNAL	BIT(5)
+#define CHRG_TIMER_CCCV_EN	BIT(2)
+#define CHRG_EN			BIT(7)
+
+/* RK818_VB_MON_REG */
+#define	RK818_VBAT_LOW_3V0      0x02
+#define	RK818_VBAT_LOW_3V4      0x06
+#define PLUG_IN_STS		BIT(6)
+
+/* RK818_THERMAL_REG */
+#define FB_TEMP_MSK		0x0c
+#define HOTDIE_STS		BIT(1)
+
+/* RK818_INT_STS_MSK_REG1 */
+#define VB_LOW_INT_EN		BIT(1)
+
+/* RK818_MISC_MARK_REG */
+#define FG_INIT			BIT(5)
+#define FG_RESET_LATE		BIT(4)
+#define FG_RESET_NOW		BIT(3)
+#define ALGO_REST_MODE_MSK	(0xc0)
+#define ALGO_REST_MODE_SHIFT	6
+
+/* bit shift */
+#define FB_TEMP_SHIFT		2
+
+/* parse ocv table param */
+#define TIMER_MS_COUNTS		1000
+#define MAX_PERCENTAGE		100
+#define MAX_INTERPOLATE		1000
+#define MAX_INT			0x7FFF
+
+#define DRIVER_VERSION		"7.1"
+
+struct battery_platform_data {
+	u32 *ocv_table;
+	u32 *zero_table;
+	u32 *ntc_table;
+	u32 ocv_size;
+	u32 max_chrg_voltage;
+	u32 ntc_size;
+	int ntc_degree_from;
+	u32 pwroff_vol;
+	u32 monitor_sec;
+	u32 zero_algorithm_vol;
+	u32 zero_reserve_dsoc;
+	u32 bat_res;
+	u32 design_capacity;
+	u32 design_qmax;
+	u32 sleep_enter_current;
+	u32 sleep_exit_current;
+	u32 max_soc_offset;
+	u32 sample_res;
+	u32 bat_mode;
+	u32 fb_temp;
+	u32 energy_mode;
+	u32 cccv_hour;
+	u32 ntc_uA;
+	u32 ntc_factor;
+};
+
+enum work_mode {
+	MODE_ZERO = 0,
+	MODE_FINISH,
+	MODE_SMOOTH_CHRG,
+	MODE_SMOOTH_DISCHRG,
+	MODE_SMOOTH,
+};
+
+enum bat_mode {
+	MODE_BATTARY = 0,
+	MODE_VIRTUAL,
+};
+
+static const u16 feedback_temp_array[] = {
+	85, 95, 105, 115
+};
+
+static const u16 chrg_vol_sel_array[] = {
+	4050, 4100, 4150, 4200, 4250, 4300, 4350
+};
+
+static const u16 chrg_cur_sel_array[] = {
+	1000, 1200, 1400, 1600, 1800, 2000, 2250, 2400, 2600, 2800, 3000
+};
+
+static const u16 chrg_cur_input_array[] = {
+	450, 80, 850, 1000, 1250, 1500, 1750, 2000, 2250, 2500, 2750, 3000
+};
+
+void kernel_power_off(void);
+int rk818_bat_temp_notifier_register(struct notifier_block *nb);
+int rk818_bat_temp_notifier_unregister(struct notifier_block *nb);
+
+#endif
diff --git a/drivers/power/supply/rk818_charger.c b/drivers/power/supply/rk818_charger.c
new file mode 100644
index 000000000000..3935fbea58e6
--- /dev/null
+++ b/drivers/power/supply/rk818_charger.c
@@ -0,0 +1,1992 @@
+/*
+ * rk818 charger driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/extcon.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/power/rk_usbbc.h>
+#include <linux/regmap.h>
+#include <linux/rk_keys.h>
+#include <linux/rtc.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include "rk818_battery.h"
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+#include <linux/amlogic/usbtype.h>
+#include <linux/platform_data/board_odroid.h>
+#endif
+
+static int dbg_enable = 0;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define CG_INFO(fmt, args...) pr_info("rk818-charger: "fmt, ##args)
+
+#define DEFAULT_CHRG_CURRENT	1400
+#define DEFAULT_INPUT_CURRENT	2000
+#define DEFAULT_CHRG_VOLTAGE	4200
+#define SAMPLE_RES_10MR		10
+#define SAMPLE_RES_20MR		20
+#define SAMPLE_RES_DIV1		1
+#define SAMPLE_RES_DIV2		2
+
+/* RK818_USB_CTRL_REG */
+#define INPUT_CUR450MA		(0x00)
+#define INPUT_CUR80MA		(0x01)
+#define INPUT_CUR850MA		(0x02)
+#define INPUT_CUR1500MA		(0x05)
+#define INPUT_CUR_MSK		(0x0f)
+/* RK818_CHRG_CTRL_REG3 */
+#define CHRG_FINISH_MODE_MSK	BIT(5)
+#define CHRG_FINISH_ANA_SIGNAL	(0)
+#define CHRG_FINISH_DIG_SIGNAL	BIT(5)
+/* RK818_SUP_STS_REG */
+#define BAT_EXS			BIT(7)
+#define USB_VLIMIT_EN		BIT(3)
+#define USB_CLIMIT_EN		BIT(2)
+/* RK818_CHRG_CTRL_REG1 */
+#define CHRG_EN			BIT(7)
+#define CHRG_CUR_MSK		(0x0f)
+/* RK818_INT_STS_MSK_REG2 */
+#define CHRG_CVTLMT_INT_MSK	BIT(6)
+#define PLUG_OUT_MSK		BIT(1)
+#define PLUG_IN_MSK		BIT(0)
+/* RK818_VB_MON_REG */
+#define PLUG_IN_STS		BIT(6)
+/* RK818_TS_CTRL_REG */
+#define GG_EN			BIT(7)
+#define TS2_FUN_ADC		BIT(5)
+/* RK818_ADC_CTRL_REG */
+#define ADC_TS2_EN		BIT(4)
+
+#define CG_DRIVER_VERSION		"2.0"
+
+#define DEFAULT_TS2_THRESHOLD_VOL      4350
+#define DEFAULT_TS2_VALID_VOL          1000
+#define DEFAULT_TS2_VOL_MULTI          0
+#define DEFAULT_TS2_CHECK_CNT          5
+
+enum charger_t {
+	USB_TYPE_UNKNOWN_CHARGER,
+	USB_TYPE_NONE_CHARGER,
+	USB_TYPE_USB_CHARGER,
+	USB_TYPE_AC_CHARGER,
+	USB_TYPE_CDP_CHARGER,
+	DC_TYPE_DC_CHARGER,
+	DC_TYPE_NONE_CHARGER,
+};
+
+enum {
+	OFFLINE = 0,
+	ONLINE
+};
+
+struct temp_chrg_table {
+	int temp_down;
+	int temp_up;
+	u32 chrg_current;
+	u8 set_chrg_current;
+};
+
+struct charger_platform_data {
+	u32 max_input_current;
+	u32 max_chrg_current;
+	u32 max_chrg_voltage;
+	u32 pwroff_vol;
+	u32 power_dc2otg;
+	u32 dc_det_level;
+	int dc_det_pin;
+	bool support_dc_det;
+	int virtual_power;
+	int sample_res;
+	int otg5v_suspend_enable;
+	bool extcon;
+	int ts2_vol_multi;
+	struct temp_chrg_table *tc_table;
+	u32 tc_count;
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	int chg_led_pin;
+	bool chg_led_on;
+#endif
+};
+
+struct rk818_charger {
+	struct platform_device *pdev;
+	struct device *dev;
+	struct rk808 *rk818;
+	struct regmap *regmap;
+	struct power_supply *ac_psy;
+	struct power_supply *usb_psy;
+	struct power_supply *bat_psy;
+	struct extcon_dev *cable_edev;
+	struct charger_platform_data *pdata;
+	struct workqueue_struct *usb_charger_wq;
+	struct workqueue_struct *dc_charger_wq;
+	struct workqueue_struct *finish_sig_wq;
+	struct workqueue_struct *ts2_wq;
+	struct delayed_work dc_work;
+	struct delayed_work usb_work;
+	struct delayed_work host_work;
+	struct delayed_work discnt_work;
+	struct delayed_work finish_sig_work;
+	struct delayed_work irq_work;
+	struct delayed_work ts2_vol_work;
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	struct workqueue_struct *led_wq;
+	struct delayed_work led_work;
+#endif
+	struct notifier_block bc_nb;
+	struct notifier_block cable_cg_nb;
+	struct notifier_block cable_host_nb;
+	struct notifier_block cable_discnt_nb;
+	struct notifier_block temp_nb;
+	unsigned int bc_event;
+	enum charger_t usb_charger;
+	enum charger_t dc_charger;
+	struct regulator *otg5v_rdev;
+	u8 ac_in;
+	u8 usb_in;
+	u8 otg_in;	/* OTG device attached status */
+	u8 otg_pmic5v;	/* OTG device power supply from PMIC */
+	u8 dc_in;
+	u8 prop_status;
+	u8 chrg_voltage;
+	u8 chrg_input;
+	u8 chrg_current;
+	u8 res_div;
+	u8 sleep_set_off_reg1;
+	u8 plugin_trigger;
+	u8 plugout_trigger;
+	int plugin_irq;
+	int plugout_irq;
+	int charger_changed;
+};
+
+static int rk818_reg_read(struct rk818_charger *cg, u8 reg)
+{
+	int ret, val;
+
+	ret = regmap_read(cg->regmap, reg, &val);
+	if (ret)
+		dev_err(cg->dev, "i2c read reg: 0x%2x failed\n", reg);
+
+	return val;
+}
+
+static int rk818_reg_write(struct rk818_charger *cg, u8 reg, u8 buf)
+{
+	int ret;
+
+	ret = regmap_write(cg->regmap, reg, buf);
+	if (ret)
+		dev_err(cg->dev, "i2c write reg: 0x%2x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_reg_set_bits(struct rk818_charger *cg, u8 reg, u8 mask, u8 buf)
+{
+	int ret;
+
+	ret = regmap_update_bits(cg->regmap, reg, mask, buf);
+	if (ret)
+		dev_err(cg->dev, "i2c set reg: 0x%2x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_reg_clear_bits(struct rk818_charger *cg, u8 reg, u8 mask)
+{
+	int ret;
+
+	ret = regmap_update_bits(cg->regmap, reg, mask, 0);
+	if (ret)
+		dev_err(cg->dev, "i2c clr reg: 0x%02x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_cg_online(struct rk818_charger *cg)
+{
+	return (cg->ac_in | cg->usb_in | cg->dc_in);
+}
+
+static int rk818_cg_get_dsoc(struct rk818_charger *cg)
+{
+	return rk818_reg_read(cg, RK818_SOC_REG);
+}
+
+static int rk818_cg_get_avg_current(struct rk818_charger *cg)
+{
+	int cur, val = 0;
+
+	val |= rk818_reg_read(cg, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_reg_read(cg, RK818_BAT_CUR_AVG_REGH) << 8;
+
+	if (val & 0x800)
+		val -= 4096;
+	cur = val * cg->res_div * 1506 / 1000;
+
+	return cur;
+}
+
+static int rk818_cg_get_ts2_voltage(struct rk818_charger *cg)
+{
+	u32 val = 0;
+	int voltage;
+
+	val |= rk818_reg_read(cg, RK818_TS2_ADC_REGL) << 0;
+	val |= rk818_reg_read(cg, RK818_TS2_ADC_REGH) << 8;
+
+	/* refer voltage 2.2V, 12bit adc accuracy */
+	voltage = val * 2200 * cg->pdata->ts2_vol_multi / 4095;
+
+	DBG("********* ts2 adc=%d, vol=%d\n", val, voltage);
+
+	return voltage;
+}
+
+static u64 get_boot_sec(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return ts.tv_sec;
+}
+
+static int rk818_cg_lowpwr_check(struct rk818_charger *cg)
+{
+	u8 buf;
+	static u64 time;
+	int current_avg, dsoc, fake_offline = 0;
+
+	buf = rk818_reg_read(cg, RK818_TS_CTRL_REG);
+	if (!(buf & GG_EN))
+		return fake_offline;
+
+	dsoc = rk818_cg_get_dsoc(cg);
+	current_avg = rk818_cg_get_avg_current(cg);
+	if ((current_avg < 0) && (dsoc == 0)) {
+		if (!time)
+			time = get_boot_sec();
+		if ((get_boot_sec() - time) >= 30) {
+			fake_offline = 1;
+			CG_INFO("low power....soc=%d, current=%d\n",
+				dsoc, current_avg);
+		}
+	} else {
+		time = 0;
+		fake_offline = 0;
+	}
+
+	DBG("<%s>. t=%lld, dsoc=%d, current=%d, fake_offline=%d\n",
+	    __func__, get_boot_sec() - time, dsoc, current_avg, fake_offline);
+
+	return fake_offline;
+}
+
+static int rk818_cg_get_bat_psy(struct device *dev, void *data)
+{
+	struct rk818_charger *cg = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_BATTERY) {
+		cg->bat_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void rk818_cg_get_psy(struct rk818_charger *cg)
+{
+	if (!cg->bat_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)cg,
+				      rk818_cg_get_bat_psy);
+}
+
+static int rk818_cg_get_bat_max_cur(struct rk818_charger *cg)
+{
+	union power_supply_propval val;
+	int ret;
+
+	rk818_cg_get_psy(cg);
+
+	if (!cg->bat_psy)
+		return cg->pdata->max_chrg_current;
+
+	ret = cg->bat_psy->desc->get_property(cg->bat_psy,
+					      POWER_SUPPLY_PROP_CURRENT_MAX,
+					      &val);
+	if (!ret && val.intval)
+		return val.intval;
+
+	return cg->pdata->max_chrg_current;
+}
+
+static int rk818_cg_get_bat_max_vol(struct rk818_charger *cg)
+{
+	union power_supply_propval val;
+	int ret;
+
+	rk818_cg_get_psy(cg);
+
+	if (!cg->bat_psy)
+		return cg->pdata->max_chrg_voltage;
+
+	ret = cg->bat_psy->desc->get_property(cg->bat_psy,
+					      POWER_SUPPLY_PROP_VOLTAGE_MAX,
+					      &val);
+	if (!ret && val.intval)
+		return val.intval;
+
+	return cg->pdata->max_chrg_voltage;
+}
+
+static enum power_supply_property rk818_ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+static enum power_supply_property rk818_usb_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+static int rk818_cg_ac_get_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    union power_supply_propval *val)
+{
+	struct rk818_charger *cg = power_supply_get_drvdata(psy);
+	int fake_offline = 0, ret = 0;
+
+	if (rk818_cg_online(cg))
+		fake_offline = rk818_cg_lowpwr_check(cg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (cg->pdata->virtual_power)
+			val->intval = 1;
+		else if (fake_offline)
+			val->intval = 0;
+		else
+			val->intval = (cg->ac_in | cg->dc_in);
+
+		DBG("report online: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		if (cg->pdata->virtual_power)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (fake_offline)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			val->intval = cg->prop_status;
+
+		DBG("report prop: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = rk818_cg_get_bat_max_vol(cg);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = rk818_cg_get_bat_max_cur(cg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rk818_cg_usb_get_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     union power_supply_propval *val)
+{
+	struct rk818_charger *cg = power_supply_get_drvdata(psy);
+	int fake_offline = 0, ret = 0;
+
+	if (rk818_cg_online(cg))
+		fake_offline = rk818_cg_lowpwr_check(cg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (cg->pdata->virtual_power)
+			val->intval = 1;
+		else if (fake_offline)
+			val->intval = 0;
+		else
+			val->intval = cg->usb_in;
+
+		DBG("report online: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		if (cg->pdata->virtual_power)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (fake_offline)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			val->intval = cg->prop_status;
+
+		DBG("report prop: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = rk818_cg_get_bat_max_vol(cg);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = rk818_cg_get_bat_max_cur(cg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct power_supply_desc rk818_ac_desc = {
+	.name		= "ac",
+	.type		= POWER_SUPPLY_TYPE_MAINS,
+	.properties	= rk818_ac_props,
+	.num_properties	= ARRAY_SIZE(rk818_ac_props),
+	.get_property	= rk818_cg_ac_get_property,
+};
+
+static const struct power_supply_desc rk818_usb_desc = {
+	.name		= "usb",
+	.type		= POWER_SUPPLY_TYPE_USB,
+	.properties	= rk818_usb_props,
+	.num_properties	= ARRAY_SIZE(rk818_usb_props),
+	.get_property	= rk818_cg_usb_get_property,
+};
+
+static int rk818_cg_init_power_supply(struct rk818_charger *cg)
+{
+	struct power_supply_config psy_cfg = { .drv_data = cg, };
+
+	cg->usb_psy = devm_power_supply_register(cg->dev, &rk818_usb_desc,
+						 &psy_cfg);
+	if (IS_ERR(cg->usb_psy)) {
+		dev_err(cg->dev, "register usb power supply fail\n");
+		return PTR_ERR(cg->usb_psy);
+	}
+
+	cg->ac_psy = devm_power_supply_register(cg->dev, &rk818_ac_desc,
+						&psy_cfg);
+	if (IS_ERR(cg->ac_psy)) {
+		dev_err(cg->dev, "register ac power supply fail\n");
+		return PTR_ERR(cg->ac_psy);
+	}
+
+	return 0;
+}
+
+static void rk818_cg_pr_info(struct rk818_charger *cg)
+{
+	u8 usb_ctrl, chrg_ctrl1;
+
+	usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+	chrg_ctrl1 = rk818_reg_read(cg, RK818_CHRG_CTRL_REG1);
+	CG_INFO("ac=%d usb=%d dc=%d otg=%d 5v=%d, v=%d chrg=%d input=%d virt=%d\n",
+		cg->ac_in, cg->usb_in, cg->dc_in, cg->otg_in, cg->otg_pmic5v,
+		chrg_vol_sel_array[(chrg_ctrl1 & 0x70) >> 4],
+		chrg_cur_sel_array[chrg_ctrl1 & 0x0f] * cg->res_div,
+		chrg_cur_input_array[usb_ctrl & 0x0f],
+		cg->pdata->virtual_power);
+}
+
+static bool is_battery_exist(struct rk818_charger *cg)
+{
+	return (rk818_reg_read(cg, RK818_SUP_STS_REG) & BAT_EXS) ? true : false;
+}
+
+static void rk818_cg_set_chrg_current(struct rk818_charger *cg,
+				      u8 chrg_current)
+{
+	u8 chrg_ctrl_reg1;
+
+	chrg_ctrl_reg1 = rk818_reg_read(cg, RK818_CHRG_CTRL_REG1);
+	chrg_ctrl_reg1 &= ~CHRG_CUR_MSK;
+	chrg_ctrl_reg1 |= (chrg_current);
+	rk818_reg_write(cg, RK818_CHRG_CTRL_REG1, chrg_ctrl_reg1);
+}
+
+static void rk818_cg_set_input_current(struct rk818_charger *cg,
+				       int input_current)
+{
+	u8 usb_ctrl;
+
+	if (cg->pdata->virtual_power) {
+		CG_INFO("warning: virtual power mode...\n");
+		input_current = cg->chrg_input;
+	}
+
+	usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+	usb_ctrl &= ~INPUT_CUR_MSK;
+	usb_ctrl |= (input_current);
+	rk818_reg_write(cg, RK818_USB_CTRL_REG, usb_ctrl);
+}
+
+static void rk818_cg_set_finish_sig(struct rk818_charger *cg, int mode)
+{
+	u8 buf;
+
+	buf = rk818_reg_read(cg, RK818_CHRG_CTRL_REG3);
+	buf &= ~CHRG_FINISH_MODE_MSK;
+	buf |= mode;
+	rk818_reg_write(cg, RK818_CHRG_CTRL_REG3, buf);
+}
+
+static void rk818_cg_finish_sig_work(struct work_struct *work)
+{
+	struct rk818_charger *cg;
+
+	cg = container_of(work, struct rk818_charger, finish_sig_work.work);
+	if (rk818_cg_online(cg))
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_DIG_SIGNAL);
+	else
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_ANA_SIGNAL);
+}
+
+static void rk818_cg_set_chrg_param(struct rk818_charger *cg,
+				    enum charger_t charger)
+{
+	u8 buf;
+
+	switch (charger) {
+	case USB_TYPE_NONE_CHARGER:
+		cg->usb_in = 0;
+		cg->ac_in = 0;
+		if (cg->dc_in == 0) {
+			cg->prop_status = POWER_SUPPLY_STATUS_DISCHARGING;
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case USB_TYPE_USB_CHARGER:
+		cg->usb_in = 1;
+		cg->ac_in = 0;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (cg->dc_in == 0) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case USB_TYPE_CDP_CHARGER:
+		cg->usb_in = 1;
+		cg->ac_in = 0;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (cg->dc_in == 0) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR1500MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case USB_TYPE_AC_CHARGER:
+		cg->ac_in = 1;
+		cg->usb_in = 0;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (charger == USB_TYPE_AC_CHARGER) {
+			if (cg->pdata->ts2_vol_multi) {
+				rk818_cg_set_chrg_current(cg, cg->chrg_current);
+				rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+				queue_delayed_work(cg->ts2_wq,
+						   &cg->ts2_vol_work,
+						   msecs_to_jiffies(0));
+			} else {
+				rk818_cg_set_chrg_current(cg, cg->chrg_current);
+				rk818_cg_set_input_current(cg, cg->chrg_input);
+			}
+		} else {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR1500MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case DC_TYPE_DC_CHARGER:
+		cg->dc_in = 1;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (cg->pdata->ts2_vol_multi) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+			queue_delayed_work(cg->ts2_wq,
+					   &cg->ts2_vol_work,
+					   msecs_to_jiffies(0));
+		} else {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, cg->chrg_input);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case DC_TYPE_NONE_CHARGER:
+		cg->dc_in = 0;
+		buf = rk818_reg_read(cg, RK818_VB_MON_REG);
+		if ((buf & PLUG_IN_STS) == 0) {
+			cg->ac_in = 0;
+			cg->usb_in = 0;
+			cg->prop_status = POWER_SUPPLY_STATUS_DISCHARGING;
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		} else if (cg->usb_in) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+			cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	default:
+		cg->prop_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	}
+
+	cg->charger_changed = 1;
+
+	if (rk818_cg_online(cg) && rk818_cg_get_dsoc(cg) == 100)
+		cg->prop_status = POWER_SUPPLY_STATUS_FULL;
+
+	if (cg->finish_sig_wq)
+		queue_delayed_work(cg->finish_sig_wq, &cg->finish_sig_work,
+				   msecs_to_jiffies(1000));
+}
+
+static void rk818_cg_set_otg_in(struct rk818_charger *cg, int online)
+{
+	cg->otg_in = online;
+}
+
+static void rk818_cg_set_otg_power(struct rk818_charger *cg, int state)
+{
+	int ret;
+
+	switch (state) {
+	case USB_OTG_POWER_ON:
+		if (cg->otg_pmic5v) {
+			CG_INFO("otg5v is on yet, ignore..\n");
+		} else {
+			if (IS_ERR(cg->otg5v_rdev)) {
+				CG_INFO("not get otg_switch regulator!\n");
+				return;
+			}
+
+			if (!regulator_is_enabled(cg->otg5v_rdev)) {
+				ret = regulator_enable(cg->otg5v_rdev);
+				if (ret) {
+					CG_INFO("enable otg5v failed:%d\n",
+						ret);
+					return;
+				}
+			}
+			cg->otg_pmic5v = 1;
+			disable_irq(cg->plugin_irq);
+			disable_irq(cg->plugout_irq);
+			CG_INFO("enable otg5v\n");
+		}
+		break;
+
+	case USB_OTG_POWER_OFF:
+		if (!cg->otg_pmic5v) {
+			CG_INFO("otg5v is off yet, ignore..\n");
+		} else {
+			if (IS_ERR(cg->otg5v_rdev)) {
+				CG_INFO("not get otg_switch regulator!\n");
+				return;
+			}
+
+			if (regulator_is_enabled(cg->otg5v_rdev)) {
+				ret = regulator_disable(cg->otg5v_rdev);
+				if (ret) {
+					CG_INFO("disable otg5v failed: %d\n",
+						ret);
+					return;
+				}
+			}
+			cg->otg_pmic5v = 0;
+			enable_irq(cg->plugin_irq);
+			enable_irq(cg->plugout_irq);
+			CG_INFO("disable otg5v\n");
+		}
+		break;
+	default:
+		dev_err(cg->dev, "error otg type\n");
+		break;
+	}
+}
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+static void rk818_cg_led_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, led_work.work);
+
+	/* battery status check */
+	if (rk818_cg_online(cg)) {
+		if (cg->prop_status == POWER_SUPPLY_STATUS_CHARGING)
+			gpio_set_value(cg->pdata->chg_led_pin,
+					!gpio_get_value(cg->pdata->chg_led_pin));
+		else
+			gpio_set_value(cg->pdata->chg_led_pin,
+					cg->pdata->chg_led_on);
+	}
+	else
+		gpio_set_value(cg->pdata->chg_led_pin,
+				!cg->pdata->chg_led_on);
+
+	queue_delayed_work(cg->led_wq, &cg->led_work,
+		msecs_to_jiffies(1000));
+}
+#endif
+
+static enum charger_t rk818_cg_get_dc_state(struct rk818_charger *cg)
+{
+	int level;
+
+	if (!gpio_is_valid(cg->pdata->dc_det_pin))
+		return DC_TYPE_NONE_CHARGER;
+
+	level = gpio_get_value(cg->pdata->dc_det_pin);
+
+	return (level == cg->pdata->dc_det_level) ?
+		DC_TYPE_DC_CHARGER : DC_TYPE_NONE_CHARGER;
+}
+
+static void rk818_cg_dc_det_worker(struct work_struct *work)
+{
+	enum charger_t charger;
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, dc_work.work);
+
+	charger = rk818_cg_get_dc_state(cg);
+	if (charger == DC_TYPE_DC_CHARGER) {
+		//CG_INFO("detect dc charger in..\n");
+		rk818_cg_set_chrg_param(cg, DC_TYPE_DC_CHARGER);
+		/* check otg supply */
+		if (cg->otg_in && cg->pdata->power_dc2otg) {
+			CG_INFO("otg power from dc adapter\n");
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+		}
+	} else {
+		//CG_INFO("detect dc charger out..\n");
+		rk818_cg_set_chrg_param(cg, DC_TYPE_NONE_CHARGER);
+		/* check otg supply, power on anyway */
+		if (cg->otg_in)
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_ON);
+	}
+
+	rk_send_wakeup_key();
+	//rk818_cg_pr_info(cg);
+}
+
+static u8 rk818_cg_decode_chrg_vol(struct rk818_charger *cg, u32 chrg_vol)
+{
+	u8 val = 0, index;
+
+	for (index = 0; index < ARRAY_SIZE(chrg_vol_sel_array); index++) {
+		if (chrg_vol < chrg_vol_sel_array[index])
+			break;
+		val = index << 4;
+	}
+
+	return val;
+}
+
+static u8 rk818_cg_decode_input_current(struct rk818_charger *cg,
+					u32 input_current)
+{
+	u8 val = 0, index;
+
+	for (index = 2; index < ARRAY_SIZE(chrg_cur_input_array); index++) {
+		if (input_current < 850 && input_current > 80) {
+			val = 0x0;	/* 450mA */
+			break;
+		} else if (input_current <= 80) {
+			val = 0x1;	/* 80mA */
+			break;
+		} else {
+			if (input_current < chrg_cur_input_array[index])
+				break;
+			val = index <<  0;
+		}
+	}
+
+	return val;
+}
+
+static u8 rk818_cg_decode_chrg_current(struct rk818_charger *cg,
+				       u32 chrg_current)
+{
+	u8 val = 0, index;
+
+	if (cg->pdata->sample_res == SAMPLE_RES_10MR) {
+		if (chrg_current > 2000)
+			chrg_current /= cg->res_div;
+		else
+			chrg_current = 1000;
+	}
+
+	for (index = 0; index < ARRAY_SIZE(chrg_cur_sel_array); index++) {
+		if (chrg_current < chrg_cur_sel_array[index])
+			break;
+		val = index << 0;
+	}
+
+	return val;
+}
+
+static void rk818_cg_init_config(struct rk818_charger *cg)
+{
+	u8 usb_ctrl, sup_sts, chrg_ctrl1;
+
+	cg->chrg_voltage = rk818_cg_decode_chrg_vol(cg,
+				cg->pdata->max_chrg_voltage);
+	cg->chrg_current = rk818_cg_decode_chrg_current(cg,
+				cg->pdata->max_chrg_current);
+	cg->chrg_input = rk818_cg_decode_input_current(cg,
+				cg->pdata->max_input_current);
+
+	sup_sts = rk818_reg_read(cg, RK818_SUP_STS_REG);
+	usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+
+	/* set charge current and voltage */
+	usb_ctrl &= ~INPUT_CUR_MSK;
+	usb_ctrl |= cg->chrg_input;
+	chrg_ctrl1 = (CHRG_EN | cg->chrg_voltage | cg->chrg_current);
+
+	/* disable voltage limit and enable input current limit */
+	sup_sts &= ~USB_VLIMIT_EN;
+	sup_sts |= USB_CLIMIT_EN;
+
+	rk818_reg_write(cg, RK818_SUP_STS_REG, sup_sts);
+	rk818_reg_write(cg, RK818_USB_CTRL_REG, usb_ctrl);
+	rk818_reg_write(cg, RK818_CHRG_CTRL_REG1, chrg_ctrl1);
+}
+
+static void rk818_ts2_vol_work(struct work_struct *work)
+{
+	struct rk818_charger *cg;
+	int ts2_vol, input_current, invalid_cnt = 0, confirm_cnt = 0;
+
+	cg = container_of(work, struct rk818_charger, ts2_vol_work.work);
+
+	input_current = INPUT_CUR80MA;
+	while (input_current < cg->chrg_input) {
+		msleep(100);
+		ts2_vol = rk818_cg_get_ts2_voltage(cg);
+
+		/* filter invalid voltage */
+		if (ts2_vol <= DEFAULT_TS2_VALID_VOL) {
+			invalid_cnt++;
+			DBG("%s: invalid ts2 voltage: %d\n, cnt=%d",
+			    __func__, ts2_vol, invalid_cnt);
+			if (invalid_cnt < DEFAULT_TS2_CHECK_CNT)
+				continue;
+
+			/* if fail, set max input current as default */
+			input_current = cg->chrg_input;
+			rk818_cg_set_input_current(cg, input_current);
+			break;
+		}
+
+		/* update input current */
+		if (ts2_vol >= DEFAULT_TS2_THRESHOLD_VOL) {
+			/* update input current */
+			input_current++;
+			rk818_cg_set_input_current(cg, input_current);
+			DBG("********* input=%d\n",
+			    chrg_cur_input_array[input_current & 0x0f]);
+		} else {
+			/* confirm lower threshold voltage */
+			confirm_cnt++;
+			if (confirm_cnt < DEFAULT_TS2_CHECK_CNT) {
+				DBG("%s: confirm ts2 voltage: %d\n, cnt=%d",
+				    __func__, ts2_vol, confirm_cnt);
+				continue;
+			}
+
+			/* trigger threshold, so roll back 1 step */
+			input_current--;
+			if (input_current == INPUT_CUR80MA ||
+			    input_current < 0)
+				input_current = INPUT_CUR450MA;
+			rk818_cg_set_input_current(cg, input_current);
+			break;
+		}
+	}
+
+	if (input_current != cg->chrg_input)
+		CG_INFO("adjust input current: %dma\n",
+			chrg_cur_input_array[input_current & 0x0f]);
+}
+
+static int rk818_cg_charger_evt_notifier(struct notifier_block *nb,
+					 unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, cable_cg_nb);
+
+	queue_delayed_work(cg->usb_charger_wq, &cg->usb_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static int rk818_cg_discnt_evt_notfier(struct notifier_block *nb,
+				       unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, cable_discnt_nb);
+
+	queue_delayed_work(cg->usb_charger_wq, &cg->discnt_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static int rk818_cg_host_evt_notifier(struct notifier_block *nb,
+				      unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, cable_host_nb);
+
+	queue_delayed_work(cg->usb_charger_wq, &cg->host_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static int rk818_cg_bc_evt_notifier(struct notifier_block *nb,
+				    unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, bc_nb);
+
+	cg->bc_event = event;
+	queue_delayed_work(cg->usb_charger_wq, &cg->usb_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static void rk818_cg_bc_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+					struct rk818_charger, usb_work.work);
+	const char *event_name[] = {"DISCNT", "USB", "AC", "CDP1.5A",
+				    "UNKNOWN", "OTG ON", "OTG OFF"};
+
+	switch (cg->bc_event) {
+	case USB_BC_TYPE_DISCNT:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_NONE_CHARGER);
+		break;
+	case USB_BC_TYPE_SDP:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_USB_CHARGER);
+		break;
+	case USB_BC_TYPE_DCP:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_AC_CHARGER);
+		break;
+	case USB_BC_TYPE_CDP:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_CDP_CHARGER);
+		break;
+	case USB_OTG_POWER_ON:
+		rk818_cg_set_otg_in(cg, ONLINE);
+		if (cg->pdata->power_dc2otg && cg->dc_in)
+			CG_INFO("otg power from dc adapter\n");
+		else
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_ON);
+		break;
+	case USB_OTG_POWER_OFF:
+		rk818_cg_set_otg_in(cg, OFFLINE);
+		rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+		break;
+	default:
+		break;
+	}
+
+	CG_INFO("receive bc notifier event: %s..\n", event_name[cg->bc_event]);
+
+	rk818_cg_pr_info(cg);
+}
+
+static void rk818_cg_irq_delay_work(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, irq_work.work);
+
+	if (cg->plugin_trigger) {
+		CG_INFO("pmic: plug in\n");
+		cg->plugin_trigger = 0;
+		rk_send_wakeup_key();
+		if (cg->pdata->extcon)
+			queue_delayed_work(cg->usb_charger_wq, &cg->usb_work,
+					   msecs_to_jiffies(10));
+	} else if (cg->plugout_trigger) {
+		CG_INFO("pmic: plug out\n");
+		cg->plugout_trigger = 0;
+		rk818_cg_set_chrg_param(cg, USB_TYPE_NONE_CHARGER);
+		rk818_cg_set_chrg_param(cg, DC_TYPE_NONE_CHARGER);
+		rk_send_wakeup_key();
+		rk818_cg_pr_info(cg);
+	} else {
+		CG_INFO("pmic: unknown irq\n");
+	}
+}
+
+static irqreturn_t rk818_plug_in_isr(int irq, void *cg)
+{
+	struct rk818_charger *icg;
+
+	icg = (struct rk818_charger *)cg;
+	icg->plugin_trigger = 1;
+	queue_delayed_work(icg->usb_charger_wq, &icg->irq_work,
+			   msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rk818_plug_out_isr(int irq, void *cg)
+{
+	struct rk818_charger *icg;
+
+	icg = (struct rk818_charger *)cg;
+	icg->plugout_trigger = 1;
+	queue_delayed_work(icg->usb_charger_wq, &icg->irq_work,
+			   msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rk818_dc_det_isr(int irq, void *charger)
+{
+	struct rk818_charger *cg = (struct rk818_charger *)charger;
+
+	if (gpio_get_value(cg->pdata->dc_det_pin))
+		irq_set_irq_type(irq, IRQF_TRIGGER_LOW);
+	else
+		irq_set_irq_type(irq, IRQF_TRIGGER_HIGH);
+
+	queue_delayed_work(cg->dc_charger_wq, &cg->dc_work,
+			   msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+static int rk818_cg_init_irqs(struct rk818_charger *cg)
+{
+	struct rk808 *rk818 = cg->rk818;
+	struct platform_device *pdev = cg->pdev;
+	int ret, plug_in_irq, plug_out_irq;
+
+	plug_in_irq = regmap_irq_get_virq(rk818->irq_data, RK818_IRQ_PLUG_IN);
+	if (plug_in_irq < 0) {
+		dev_err(cg->dev, "plug_in_irq request failed!\n");
+		return plug_in_irq;
+	}
+
+	plug_out_irq = regmap_irq_get_virq(rk818->irq_data, RK818_IRQ_PLUG_OUT);
+	if (plug_out_irq < 0) {
+		dev_err(cg->dev, "plug_out_irq request failed!\n");
+		return plug_out_irq;
+	}
+
+	ret = devm_request_threaded_irq(cg->dev, plug_in_irq, NULL,
+					rk818_plug_in_isr,
+					IRQF_TRIGGER_RISING,
+					"rk818_plug_in", cg);
+	if (ret) {
+		dev_err(&pdev->dev, "plug_in_irq request failed!\n");
+		return ret;
+	}
+
+	ret = devm_request_threaded_irq(cg->dev, plug_out_irq, NULL,
+					rk818_plug_out_isr,
+					IRQF_TRIGGER_FALLING,
+					"rk818_plug_out", cg);
+	if (ret) {
+		dev_err(&pdev->dev, "plug_out_irq request failed!\n");
+		return ret;
+	}
+
+	cg->plugin_irq = plug_in_irq;
+	cg->plugout_irq = plug_out_irq;
+
+	INIT_DELAYED_WORK(&cg->irq_work, rk818_cg_irq_delay_work);
+
+	return 0;
+}
+
+static int rk818_cg_init_dc(struct rk818_charger *cg)
+{
+	int ret, level;
+	unsigned long irq_flags;
+	unsigned int dc_det_irq;
+
+	cg->dc_charger_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-dc-wq");
+	INIT_DELAYED_WORK(&cg->dc_work, rk818_cg_dc_det_worker);
+	cg->dc_charger = DC_TYPE_NONE_CHARGER;
+
+	if (!cg->pdata->support_dc_det)
+		return 0;
+
+	ret = devm_gpio_request(cg->dev, cg->pdata->dc_det_pin, "rk818_dc_det");
+	if (ret < 0) {
+		dev_err(cg->dev, "failed to request gpio %d\n",
+			cg->pdata->dc_det_pin);
+		return ret;
+	}
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	gpiod_set_pull(gpio_to_desc(cg->pdata->dc_det_pin),
+			GPIOD_PULL_UP);
+#endif
+	ret = gpio_direction_input(cg->pdata->dc_det_pin);
+	if (ret) {
+		dev_err(cg->dev, "failed to set gpio input\n");
+		return ret;
+	}
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	if (cg->pdata->chg_led_pin) {
+		ret = devm_gpio_request(cg->dev,
+					cg->pdata->chg_led_pin,
+					"rk817_chg_led");
+		if (ret < 0)
+			dev_err(cg->dev, "failed to request gpio %d\n",
+				cg->pdata->chg_led_pin);
+		else
+			gpio_direction_output(cg->pdata->chg_led_pin,
+					     !cg->pdata->chg_led_on);
+	}
+
+	cg->led_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk817-led-wq");
+	INIT_DELAYED_WORK(&cg->led_work, rk818_cg_led_worker);
+
+	queue_delayed_work(cg->led_wq, &cg->led_work,
+		msecs_to_jiffies(500));
+#endif
+
+
+	level = gpio_get_value(cg->pdata->dc_det_pin);
+	if (level == cg->pdata->dc_det_level)
+		cg->dc_charger = DC_TYPE_DC_CHARGER;
+	else
+		cg->dc_charger = DC_TYPE_NONE_CHARGER;
+
+	if (level)
+		irq_flags = IRQF_TRIGGER_LOW;
+	else
+		irq_flags = IRQF_TRIGGER_HIGH;
+
+	dc_det_irq = gpio_to_irq(cg->pdata->dc_det_pin);
+	ret = devm_request_irq(cg->dev, dc_det_irq, rk818_dc_det_isr,
+			       irq_flags, "rk818_dc_det", cg);
+	if (ret != 0) {
+		dev_err(cg->dev, "rk818_dc_det_irq request failed!\n");
+		return ret;
+	}
+
+	enable_irq_wake(dc_det_irq);
+	return 0;
+}
+
+static void rk818_cg_discnt_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, discnt_work.work);
+
+	if (extcon_get_state(cg->cable_edev, EXTCON_USB) == 0) {
+		CG_INFO("receive type-c notifier event: DISCNT...\n");
+		rk818_cg_set_chrg_param(cg, USB_TYPE_NONE_CHARGER);
+		rk818_cg_pr_info(cg);
+	}
+}
+
+static void rk818_cg_host_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, host_work.work);
+	struct extcon_dev *edev = cg->cable_edev;
+
+	/* Determine charger type */
+	if (extcon_get_state(edev, EXTCON_USB_VBUS_EN) > 0) {
+		rk818_cg_set_otg_in(cg, ONLINE);
+		CG_INFO("receive type-c notifier event: OTG ON...\n");
+		if (cg->dc_in && cg->pdata->power_dc2otg)
+			CG_INFO("otg power from dc adapter\n");
+		else
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_ON);
+	} else if (extcon_get_state(edev, EXTCON_USB_VBUS_EN) == 0) {
+		CG_INFO("receive type-c notifier event: OTG OFF...\n");
+		rk818_cg_set_otg_in(cg, OFFLINE);
+		rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+	}
+
+	rk818_cg_pr_info(cg);
+}
+
+static void rk818_cg_charger_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+				struct rk818_charger, usb_work.work);
+	struct extcon_dev *edev = cg->cable_edev;
+	enum charger_t charger = USB_TYPE_UNKNOWN_CHARGER;
+	const char *event[] = {"UN", "NONE", "USB", "AC", "CDP1.5A"};
+
+	/* Determine charger type */
+	if (extcon_get_state(edev, EXTCON_CHG_USB_SDP) > 0)
+		charger = USB_TYPE_USB_CHARGER;
+	else if (extcon_get_state(edev, EXTCON_CHG_USB_DCP) > 0)
+		charger = USB_TYPE_AC_CHARGER;
+	else if (extcon_get_state(edev, EXTCON_CHG_USB_CDP) > 0)
+		charger = USB_TYPE_CDP_CHARGER;
+
+	if (charger != USB_TYPE_UNKNOWN_CHARGER) {
+		CG_INFO("receive type-c notifier event: %s...\n",
+			event[charger]);
+		cg->usb_charger = charger;
+		rk818_cg_set_chrg_param(cg, charger);
+		rk818_cg_pr_info(cg);
+	}
+}
+
+static long rk818_cg_init_usb(struct rk818_charger *cg)
+{
+	enum charger_t charger;
+	enum bc_port_type bc_type;
+	struct extcon_dev *edev;
+	struct device *dev = cg->dev;
+	int ret;
+
+	cg->usb_charger_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-usb-wq");
+	cg->usb_charger = USB_TYPE_NONE_CHARGER;
+
+	/* type-C */
+	if (cg->pdata->extcon) {
+		edev = extcon_get_edev_by_phandle(dev->parent, 0);
+		if (IS_ERR(edev)) {
+			if (PTR_ERR(edev) != -EPROBE_DEFER)
+				dev_err(dev, "Invalid or missing extcon\n");
+			return PTR_ERR(edev);
+		}
+
+		/* Register chargers  */
+		INIT_DELAYED_WORK(&cg->usb_work, rk818_cg_charger_evt_worker);
+		cg->cable_cg_nb.notifier_call = rk818_cg_charger_evt_notifier;
+		ret = extcon_register_notifier(edev, EXTCON_CHG_USB_SDP,
+					       &cg->cable_cg_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for SDP\n");
+			return ret;
+		}
+
+		ret = extcon_register_notifier(edev, EXTCON_CHG_USB_DCP,
+					       &cg->cable_cg_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for DCP\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			return ret;
+		}
+
+		ret = extcon_register_notifier(edev, EXTCON_CHG_USB_CDP,
+					       &cg->cable_cg_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for CDP\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_DCP,
+						   &cg->cable_cg_nb);
+			return ret;
+		}
+
+		/* Register host */
+		INIT_DELAYED_WORK(&cg->host_work, rk818_cg_host_evt_worker);
+		cg->cable_host_nb.notifier_call = rk818_cg_host_evt_notifier;
+		ret = extcon_register_notifier(edev, EXTCON_USB_VBUS_EN,
+					       &cg->cable_host_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for HOST\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_DCP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_CDP,
+						   &cg->cable_cg_nb);
+
+			return ret;
+		}
+
+		/* Register discnt usb */
+		INIT_DELAYED_WORK(&cg->discnt_work, rk818_cg_discnt_evt_worker);
+		cg->cable_discnt_nb.notifier_call = rk818_cg_discnt_evt_notfier;
+		ret = extcon_register_notifier(edev, EXTCON_USB,
+					       &cg->cable_discnt_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for HOST\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_DCP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_CDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_USB_VBUS_EN,
+						   &cg->cable_host_nb);
+			return ret;
+		}
+
+		cg->cable_edev = edev;
+
+		schedule_delayed_work(&cg->host_work, 0);
+		schedule_delayed_work(&cg->usb_work, 0);
+
+		CG_INFO("register typec extcon evt notifier\n");
+	} else {
+		INIT_DELAYED_WORK(&cg->usb_work, rk818_cg_bc_evt_worker);
+		cg->bc_nb.notifier_call = rk818_cg_bc_evt_notifier;
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+		bc_type = USB_BC_TYPE_DISCNT;
+		ret = dwc_otg_charger_detect_register_notifier(&cg->bc_nb);
+		if (ret) {
+			dev_err(dev, "failed to register notifier for bc\n");
+			return -EINVAL;
+		}
+#else
+		ret = rk_bc_detect_notifier_register(&cg->bc_nb, &bc_type);
+		if (ret) {
+			dev_err(dev, "failed to register notifier for bc\n");
+			return -EINVAL;
+		}
+#endif
+		switch (bc_type) {
+		case USB_BC_TYPE_DISCNT:
+			charger = USB_TYPE_NONE_CHARGER;
+			break;
+		case USB_BC_TYPE_SDP:
+		case USB_BC_TYPE_CDP:
+			charger = USB_TYPE_USB_CHARGER;
+			break;
+		case USB_BC_TYPE_DCP:
+			charger = USB_TYPE_AC_CHARGER;
+			break;
+		default:
+			charger = USB_TYPE_NONE_CHARGER;
+			break;
+		}
+
+		cg->usb_charger = charger;
+		CG_INFO("register bc evt notifier\n");
+	}
+
+	return 0;
+}
+
+static void rk818_cg_init_finish_sig(struct rk818_charger *cg)
+{
+	if (rk818_cg_online(cg))
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_DIG_SIGNAL);
+	else
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_ANA_SIGNAL);
+
+	cg->finish_sig_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-finish-sig-wq");
+	INIT_DELAYED_WORK(&cg->finish_sig_work, rk818_cg_finish_sig_work);
+}
+
+static void rk818_cg_init_ts2_detect(struct rk818_charger *cg)
+{
+	u8 buf;
+
+	cg->ts2_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-ts2-wq");
+	INIT_DELAYED_WORK(&cg->ts2_vol_work, rk818_ts2_vol_work);
+
+	if (!cg->pdata->ts2_vol_multi)
+		return;
+
+	/* TS2 adc mode */
+	buf = rk818_reg_read(cg, RK818_TS_CTRL_REG);
+	buf |= TS2_FUN_ADC;
+	rk818_reg_write(cg, RK818_TS_CTRL_REG, buf);
+
+	/* TS2 adc enable */
+	buf = rk818_reg_read(cg, RK818_ADC_CTRL_REG);
+	buf |= ADC_TS2_EN;
+	rk818_reg_write(cg, RK818_ADC_CTRL_REG, buf);
+
+	CG_INFO("enable ts2 voltage detect, multi=%d\n",
+		cg->pdata->ts2_vol_multi);
+}
+
+static void rk818_cg_init_charger_state(struct rk818_charger *cg)
+{
+	rk818_cg_init_config(cg);
+	rk818_cg_init_finish_sig(cg);
+	rk818_cg_set_chrg_param(cg, cg->dc_charger);
+	rk818_cg_set_chrg_param(cg, cg->usb_charger);
+
+	if (cg->otg_in && cg->dc_in && cg->pdata->power_dc2otg) {
+		CG_INFO("otg power from dc adapter\n");
+		rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+	}
+
+	CG_INFO("ac=%d, usb=%d, dc=%d, otg=%d, 5v=%d\n",
+		cg->ac_in, cg->usb_in, cg->dc_in, cg->otg_in, cg->otg_pmic5v);
+}
+
+static int rk818_cg_temperature_notifier_call(struct notifier_block *nb,
+					      unsigned long temp, void *data)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, temp_nb);
+	static int temp_triggered, config_index = -1;
+	int i, up_temp, down_temp, cfg_current;
+	int now_temp = temp;
+	u8 usb_ctrl, chrg_ctrl1;
+
+	DBG("%s: receive notify temperature = %d\n", __func__, now_temp);
+	for (i = 0; i < cg->pdata->tc_count; i++) {
+		up_temp = cg->pdata->tc_table[i].temp_up;
+		down_temp = cg->pdata->tc_table[i].temp_down;
+		cfg_current = cg->pdata->tc_table[i].chrg_current;
+
+		if (now_temp >= down_temp && now_temp <= up_temp) {
+			/* Temp range or charger are not update, return */
+			if (config_index == i && !cg->charger_changed)
+				return NOTIFY_DONE;
+
+			config_index = i;
+			cg->charger_changed = 0;
+			temp_triggered = 1;
+
+			if (cg->pdata->tc_table[i].set_chrg_current) {
+				rk818_cg_set_chrg_current(cg, cfg_current);
+				CG_INFO("temperature = %d'C[%d~%d'C], "
+					"chrg current = %d\n",
+					now_temp, down_temp, up_temp,
+					chrg_cur_sel_array[cfg_current] *
+					cg->res_div);
+			} else {
+				rk818_cg_set_input_current(cg, cfg_current);
+				CG_INFO("temperature = %d'C[%d~%d'C], "
+					"input current = %d\n",
+					now_temp, down_temp, up_temp,
+					chrg_cur_input_array[cfg_current]);
+			}
+			return NOTIFY_DONE;
+		}
+	}
+
+	/*
+	 * means: current temperature not covers above case, temperature rolls
+	 * back to normal range, so restore default value
+	 */
+	if (temp_triggered) {
+		temp_triggered = 0;
+		config_index = -1;
+		rk818_cg_set_chrg_current(cg, cg->chrg_current);
+		if (cg->ac_in || cg->dc_in)
+			rk818_cg_set_input_current(cg, cg->chrg_input);
+		else
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+		chrg_ctrl1 = rk818_reg_read(cg, RK818_CHRG_CTRL_REG1);
+		CG_INFO("roll back temp %d'C, current chrg = %d, input = %d\n",
+			now_temp,
+			chrg_cur_sel_array[(chrg_ctrl1 & 0x0f)] * cg->res_div,
+			chrg_cur_input_array[(usb_ctrl & 0x0f)]);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int parse_temperature_chrg_table(struct rk818_charger *cg,
+					struct device_node *np)
+{
+	int size, count;
+	int i, chrg_current;
+	const __be32 *list;
+
+	if (!of_find_property(np, "temperature_chrg_table_v2", &size))
+		return 0;
+
+	list = of_get_property(np, "temperature_chrg_table_v2", &size);
+	size /= sizeof(u32);
+	if (!size || (size % 3)) {
+		dev_err(cg->dev,
+			"invalid temperature_chrg_table: size=%d\n", size);
+		return -EINVAL;
+	}
+
+	count = size / 3;
+	cg->pdata->tc_count = count;
+	cg->pdata->tc_table = devm_kzalloc(cg->dev,
+					   count * sizeof(*cg->pdata->tc_table),
+					   GFP_KERNEL);
+	if (!cg->pdata->tc_table)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		/* temperature */
+		cg->pdata->tc_table[i].temp_down = be32_to_cpu(*list++);
+		cg->pdata->tc_table[i].temp_up = be32_to_cpu(*list++);
+
+		/*
+		 * because charge current lowest level is 1000mA:
+		 * higher than or equal 1000ma, select charge current;
+		 * lower than 1000ma, must select input current.
+		 */
+		chrg_current = be32_to_cpu(*list++);
+		if (chrg_current >= 1000) {
+			cg->pdata->tc_table[i].set_chrg_current = 1;
+			cg->pdata->tc_table[i].chrg_current =
+				rk818_cg_decode_chrg_current(cg, chrg_current);
+		} else {
+			cg->pdata->tc_table[i].chrg_current =
+				rk818_cg_decode_input_current(cg, chrg_current);
+		}
+
+		DBG("temp%d: [%d, %d], chrg_current=%d\n",
+		    i, cg->pdata->tc_table[i].temp_down,
+		    cg->pdata->tc_table[i].temp_up,
+		    cg->pdata->tc_table[i].chrg_current);
+	}
+
+	return 0;
+
+}
+
+static int rk818_cg_register_temp_notifier(struct rk818_charger *cg)
+{
+	int ret;
+
+	if (!cg->pdata->tc_count)
+		return 0;
+	cg->temp_nb.notifier_call = rk818_cg_temperature_notifier_call,
+	ret = rk818_bat_temp_notifier_register(&cg->temp_nb);
+	if (ret) {
+		dev_err(cg->dev,
+			"battery temperature notify register failed:%d\n", ret);
+		return ret;
+	}
+
+	CG_INFO("enable set charge current by temperature\n");
+
+	return 0;
+}
+
+static int rk818_cg_get_otg5v_regulator(struct rk818_charger *cg)
+{
+	int ret;
+
+	/* not necessary */
+	cg->otg5v_rdev = devm_regulator_get(cg->dev, "otg_switch");
+	if (IS_ERR(cg->otg5v_rdev)) {
+		ret = PTR_ERR(cg->otg5v_rdev);
+		dev_warn(cg->dev, "failed to get otg regulator: %d\n", ret);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int rk818_cg_parse_dt(struct rk818_charger *cg)
+{
+	struct device_node *np;
+	struct charger_platform_data *pdata;
+	enum of_gpio_flags flags;
+	struct device *dev = cg->dev;
+	int ret;
+
+	np = of_find_node_by_name(cg->pdev->dev.of_node, "battery");
+	if (!np) {
+		dev_err(dev, "battery node not found!\n");
+		return -ENODEV;
+	}
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	cg->pdata = pdata;
+	pdata->max_chrg_current = DEFAULT_CHRG_CURRENT;
+	pdata->max_input_current = DEFAULT_INPUT_CURRENT;
+	pdata->max_chrg_voltage = DEFAULT_CHRG_VOLTAGE;
+
+	pdata->extcon = device_property_read_bool(dev->parent, "extcon");
+
+	ret = of_property_read_u32(np, "max_chrg_current",
+				   &pdata->max_chrg_current);
+	if (ret < 0)
+		dev_err(dev, "max_chrg_current missing!\n");
+
+	ret = of_property_read_u32(np, "max_input_current",
+				   &pdata->max_input_current);
+	if (ret < 0)
+		dev_err(dev, "max_input_current missing!\n");
+
+	ret = of_property_read_u32(np, "max_chrg_voltage",
+				   &pdata->max_chrg_voltage);
+	if (ret < 0)
+		dev_err(dev, "max_chrg_voltage missing!\n");
+
+	ret = of_property_read_u32(np, "virtual_power", &pdata->virtual_power);
+	if (ret < 0)
+		dev_err(dev, "virtual_power missing!\n");
+
+	ret = of_property_read_u32(np, "power_dc2otg", &pdata->power_dc2otg);
+	if (ret < 0)
+		dev_err(dev, "power_dc2otg missing!\n");
+
+	ret = of_property_read_u32(np, "sample_res", &pdata->sample_res);
+	if (ret < 0) {
+		pdata->sample_res = SAMPLE_RES_20MR;
+		dev_err(dev, "sample_res missing!\n");
+	}
+
+	ret = of_property_read_u32(np, "otg5v_suspend_enable",
+				   &pdata->otg5v_suspend_enable);
+	if (ret < 0) {
+		pdata->otg5v_suspend_enable = 1;
+		dev_err(dev, "otg5v_suspend_enable missing!\n");
+	}
+
+	ret = of_property_read_u32(np, "ts2_vol_multi",
+				   &pdata->ts2_vol_multi);
+
+	if (!is_battery_exist(cg))
+		pdata->virtual_power = 1;
+
+	cg->res_div = (cg->pdata->sample_res == SAMPLE_RES_20MR) ?
+		       SAMPLE_RES_DIV1 : SAMPLE_RES_DIV2;
+
+	if (!of_find_property(np, "dc_det_gpio", &ret)) {
+		pdata->support_dc_det = false;
+		CG_INFO("not support dc\n");
+	} else {
+		pdata->support_dc_det = true;
+		pdata->dc_det_pin = of_get_named_gpio_flags(np, "dc_det_gpio",
+							    0, &flags);
+		if (gpio_is_valid(pdata->dc_det_pin)) {
+			CG_INFO("support dc\n");
+			pdata->dc_det_level = (flags & OF_GPIO_ACTIVE_LOW) ?
+					       0 : 1;
+		} else {
+			dev_err(dev, "invalid dc det gpio!\n");
+			return -EINVAL;
+		}
+	}
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	if (!of_find_property(np, "chg_led_gpio", &ret)) {
+		CG_INFO("not support charge led\n");
+		pdata->chg_led_pin = 0;
+	} else {
+		pdata->chg_led_pin = of_get_named_gpio_flags(np,
+						"chg_led_gpio",
+						0, &flags);
+		if (gpio_is_valid(pdata->chg_led_pin)) {
+			CG_INFO("support charge led\n");
+			pdata->chg_led_on =
+				(flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		}
+	}
+#endif
+
+
+	ret = parse_temperature_chrg_table(cg, np);
+	if (ret)
+		return ret;
+
+	CG_INFO("input_current:%d\n"
+	    "chrg_current:%d\n"
+	    "chrg_voltage:%d\n"
+	    "sample_res:%d\n"
+	    "extcon:%d\n"
+	    "ts2_vol_multi:%d\n"
+	    "virtual_power:%d\n"
+	    "power_dc2otg:%d\n",
+	    pdata->max_input_current, pdata->max_chrg_current,
+	    pdata->max_chrg_voltage, pdata->sample_res, pdata->extcon,
+	    pdata->ts2_vol_multi, pdata->virtual_power, pdata->power_dc2otg);
+
+	return 0;
+}
+#else
+static int rk818_cg_parse_dt(struct rk818_charger *cg)
+{
+	return -ENODEV;
+}
+#endif
+
+static int rk818_charger_probe(struct platform_device *pdev)
+{
+	struct rk808 *rk818 = dev_get_drvdata(pdev->dev.parent);
+	struct rk818_charger *cg;
+	int ret;
+
+	cg = devm_kzalloc(&pdev->dev, sizeof(*cg), GFP_KERNEL);
+	if (!cg)
+		return -ENOMEM;
+
+	cg->rk818 = rk818;
+	cg->pdev = pdev;
+	cg->dev = &pdev->dev;
+	cg->regmap = rk818->regmap;
+	platform_set_drvdata(pdev, cg);
+
+	ret = rk818_cg_parse_dt(cg);
+	if (ret < 0) {
+		dev_err(cg->dev, "parse dt failed!\n");
+		return ret;
+	}
+
+	rk818_cg_init_ts2_detect(cg);
+	rk818_cg_get_otg5v_regulator(cg);
+
+	ret = rk818_cg_init_dc(cg);
+	if (ret) {
+		dev_err(cg->dev, "init dc failed!\n");
+		return ret;
+	}
+
+	ret = rk818_cg_init_usb(cg);
+	if (ret) {
+		dev_err(cg->dev, "init usb failed!\n");
+		return ret;
+	}
+
+	ret = rk818_cg_init_power_supply(cg);
+	if (ret) {
+		dev_err(cg->dev, "init power supply fail!\n");
+		return ret;
+	}
+
+	rk818_cg_init_charger_state(cg);
+
+	ret = rk818_cg_register_temp_notifier(cg);
+	if (ret) {
+		dev_err(cg->dev, "register temp notify failed!\n");
+		goto notify_fail;
+	}
+
+	ret = rk818_cg_init_irqs(cg);
+	if (ret) {
+		dev_err(cg->dev, "init irqs failed!\n");
+		goto irq_fail;
+	}
+
+	CG_INFO("driver version: %s\n", CG_DRIVER_VERSION);
+
+	return 0;
+
+irq_fail:
+	rk818_bat_temp_notifier_unregister(&cg->temp_nb);
+
+notify_fail:
+	/* type-c only */
+	if (cg->pdata->extcon) {
+		cancel_delayed_work_sync(&cg->host_work);
+		cancel_delayed_work_sync(&cg->discnt_work);
+	}
+
+	cancel_delayed_work_sync(&cg->usb_work);
+	cancel_delayed_work_sync(&cg->dc_work);
+	cancel_delayed_work_sync(&cg->finish_sig_work);
+	cancel_delayed_work_sync(&cg->irq_work);
+	cancel_delayed_work_sync(&cg->ts2_vol_work);
+	destroy_workqueue(cg->ts2_wq);
+	destroy_workqueue(cg->usb_charger_wq);
+	destroy_workqueue(cg->dc_charger_wq);
+	destroy_workqueue(cg->finish_sig_wq);
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	cancel_delayed_work_sync(&cg->led_work);
+	destroy_workqueue(cg->led_wq);
+#endif
+
+	if (cg->pdata->extcon) {
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_SDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_DCP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_CDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB_VBUS_EN,
+					   &cg->cable_host_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB,
+					   &cg->cable_discnt_nb);
+	} else {
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+		dwc_otg_charger_detect_unregister_notifier(&cg->bc_nb);
+#else
+		rk_bc_detect_notifier_unregister(&cg->bc_nb);
+#endif
+	}
+
+	return ret;
+}
+
+static void rk818_charger_shutdown(struct platform_device *pdev)
+{
+	struct rk818_charger *cg = platform_get_drvdata(pdev);
+
+	/* type-c only */
+	if (cg->pdata->extcon) {
+		cancel_delayed_work_sync(&cg->host_work);
+		cancel_delayed_work_sync(&cg->discnt_work);
+	}
+
+	rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+	disable_irq(cg->plugin_irq);
+	disable_irq(cg->plugout_irq);
+
+	cancel_delayed_work_sync(&cg->usb_work);
+	cancel_delayed_work_sync(&cg->dc_work);
+	cancel_delayed_work_sync(&cg->finish_sig_work);
+	cancel_delayed_work_sync(&cg->irq_work);
+	cancel_delayed_work_sync(&cg->ts2_vol_work);
+	flush_workqueue(cg->ts2_wq);
+	flush_workqueue(cg->usb_charger_wq);
+	flush_workqueue(cg->dc_charger_wq);
+	flush_workqueue(cg->finish_sig_wq);
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	cancel_delayed_work_sync(&cg->led_work);
+	destroy_workqueue(cg->led_wq);
+#endif
+
+	if (cg->pdata->extcon) {
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_SDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_DCP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_CDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB_VBUS_EN,
+					   &cg->cable_host_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB,
+					   &cg->cable_discnt_nb);
+	} else {
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+		dwc_otg_charger_detect_unregister_notifier(&cg->bc_nb);
+#else
+		rk_bc_detect_notifier_unregister(&cg->bc_nb);
+#endif
+	}
+
+	rk818_bat_temp_notifier_unregister(&cg->temp_nb);
+
+	rk818_cg_set_finish_sig(cg, CHRG_FINISH_ANA_SIGNAL);
+
+	CG_INFO("shutdown: ac=%d usb=%d dc=%d otg=%d 5v=%d\n",
+		cg->ac_in, cg->usb_in, cg->dc_in, cg->otg_in, cg->otg_pmic5v);
+}
+
+static int rk818_charger_suspend(struct platform_device *pdev,
+				 pm_message_t state)
+{
+	struct rk818_charger *cg = platform_get_drvdata(pdev);
+
+	cg->sleep_set_off_reg1 = rk818_reg_read(cg, RK818_SLEEP_SET_OFF_REG1);
+
+	/* enable sleep boost5v and otg5v */
+	if (cg->pdata->otg5v_suspend_enable) {
+		if ((cg->otg_in && !cg->dc_in) ||
+		    (cg->otg_in && cg->dc_in && !cg->pdata->power_dc2otg)) {
+			rk818_reg_clear_bits(cg, RK818_SLEEP_SET_OFF_REG1,
+					     OTG_BOOST_SLP_OFF);
+			CG_INFO("suspend: otg 5v on\n");
+			return 0;
+		}
+	}
+
+	/* disable sleep otg5v */
+	rk818_reg_set_bits(cg, RK818_SLEEP_SET_OFF_REG1,
+			   OTG_SLP_SET_OFF, OTG_SLP_SET_OFF);
+	CG_INFO("suspend: otg 5v off\n");
+
+	return 0;
+}
+
+static int rk818_charger_resume(struct platform_device *pdev)
+{
+	struct rk818_charger *cg = platform_get_drvdata(pdev);
+
+	/* resume sleep boost5v and otg5v */
+	rk818_reg_set_bits(cg, RK818_SLEEP_SET_OFF_REG1,
+			   OTG_BOOST_SLP_OFF, cg->sleep_set_off_reg1);
+
+	return 0;
+}
+
+static struct platform_driver rk818_charger_driver = {
+	.probe = rk818_charger_probe,
+	.suspend = rk818_charger_suspend,
+	.resume = rk818_charger_resume,
+	.shutdown = rk818_charger_shutdown,
+	.driver = {
+		.name	= "rk818-charger",
+	},
+};
+
+static int __init charger_init(void)
+{
+	return platform_driver_register(&rk818_charger_driver);
+}
+module_init(charger_init);
+
+static void __exit charger_exit(void)
+{
+	platform_driver_unregister(&rk818_charger_driver);
+}
+module_exit(charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rk818-charger");
+MODULE_AUTHOR("chenjh<chenjh@rock-chips.com>");
diff --git a/drivers/regulator/rk808-regulator.c b/drivers/regulator/rk808-regulator.c
index 28646e4cf3ba..65178ff04252 100644
--- a/drivers/regulator/rk808-regulator.c
+++ b/drivers/regulator/rk808-regulator.c
@@ -31,11 +31,18 @@
 #include <linux/regulator/of_regulator.h>
 #include <linux/gpio/consumer.h>
 
+#define CONFIG_ARCH_MESON64_ODROID_COMMON
+
 /* Field Definitions */
 #define RK808_BUCK_VSEL_MASK	0x3f
 #define RK808_BUCK4_VSEL_MASK	0xf
 #define RK808_LDO_VSEL_MASK	0x1f
 
+#define RK816_DCDC_SLP_EN_REG_OFFSET	2
+#define RK816_SWITCH_SLP_EN_REG_OFFSET	1
+#define RK816_LDO1_4_SLP_EN_REG_OFFSET	1
+#define RK816_LDO5_6_SLP_EN_REG_OFFSET	2
+
 #define RK818_BUCK_VSEL_MASK		0x3f
 #define RK818_BUCK4_VSEL_MASK		0x1f
 #define RK818_LDO_VSEL_MASK		0x1f
@@ -62,8 +69,8 @@
 /* Offset from XXX_EN_REG to SLEEP_SET_OFF_XXX */
 #define RK808_SLP_SET_OFF_REG_OFFSET 2
 
-/* max steps for increase voltage of Buck1/2, equal 100mv*/
-#define MAX_STEPS_ONE_TIME 8
+/* max steps for increase voltage of Buck1/2, equal 25mv*/
+#define MAX_STEPS_ONE_TIME 2
 
 #define RK8XX_DESC(_id, _match, _supply, _min, _max, _step, _vreg,	\
 	_vmask, _ereg, _emask, _etime)					\
@@ -86,6 +93,76 @@
 		.ops		= &rk808_reg_ops,			\
 	}
 
+#define RK816_DESC(_id, _match, _supply, _min, _max, _step, _vreg,	\
+	_vmask, _ereg, _emask, _enval, _disval, _etime)		\
+	[_id] = {							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),	\
+		.owner		= THIS_MODULE,				\
+		.min_uV		= (_min) * 1000,			\
+		.uV_step	= (_step) * 1000,			\
+		.vsel_reg	= (_vreg),				\
+		.vsel_mask	= (_vmask),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.enable_time	= (_etime),				\
+		.ops		= &rk808_reg_ops,			\
+	}
+
+#define RK817_DESC(_id, _match, _supply, _min, _max, _step, _vreg,	\
+	_vmask, _ereg, _emask, _enval, _disval, _etime)		\
+	{							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),	\
+		.owner		= THIS_MODULE,				\
+		.min_uV		= (_min) * 1000,			\
+		.uV_step	= (_step) * 1000,			\
+		.vsel_reg	= (_vreg),				\
+		.vsel_mask	= (_vmask),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.enable_time	= (_etime),				\
+		.ops		= &rk817_reg_ops,			\
+	}
+
+#define RK817_BOOST_DESC(_id, _match, _supply, _min, _max, _step, _vreg,\
+	_vmask, _ereg, _emask, _enval, _disval, _etime, m_drop)		\
+	{							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),	\
+		.owner		= THIS_MODULE,				\
+		.min_uV		= (_min) * 1000,			\
+		.uV_step	= (_step) * 1000,			\
+		.vsel_reg	= (_vreg),				\
+		.vsel_mask	= (_vmask),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.enable_time	= (_etime),				\
+		.min_dropout_uV = (m_drop) * 1000,			\
+		.ops		= &rk817_boost_ops,			\
+	}
+
 #define RK8XX_DESC_SWITCH(_id, _match, _supply, _ereg, _emask)		\
 	[_id] = {							\
 		.name		= (_match),				\
@@ -100,6 +177,22 @@
 		.ops		= &rk808_switch_ops			\
 	}
 
+#define RK817_DESC_SWITCH(_id, _match, _supply, _ereg, _emask,\
+	_enval, _disval)		\
+	{							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.owner		= THIS_MODULE,				\
+		.ops		= &rk817_switch_ops			\
+	}
 
 struct rk808_regulator_data {
 	struct gpio_desc *dvs_gpio[2];
@@ -117,10 +210,76 @@ static const struct regulator_linear_range rk808_ldo3_voltage_ranges[] = {
 	REGULATOR_LINEAR_RANGE(2500000, 15, 15, 0),
 };
 
+static const struct regulator_linear_range rk816_buck_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(712500, 0, 59, 12500),	/* 0.7125v - 1.45v */
+	REGULATOR_LINEAR_RANGE(1800000, 60, 62, 200000),/* 1.8v - 2.2v */
+	REGULATOR_LINEAR_RANGE(2300000, 63, 63, 0),	/* 2.3v - 2.3v */
+};
+
+static const struct regulator_linear_range rk816_buck4_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(800000, 0, 26, 100000),	/* 0.8v - 3.4 */
+	REGULATOR_LINEAR_RANGE(3500000, 27, 31, 0),	/* 3.5v */
+};
+
+#define RK817_BUCK1_MIN0 500000
+#define RK817_BUCK1_MAX0 1500000
+
+#define RK817_BUCK1_MIN1 1600000
+#define RK817_BUCK1_MAX1 2400000
+
+#define RK817_BUCK3_MAX1 3400000
+
+#define RK817_BUCK1_STP0 12500
+#define RK817_BUCK1_STP1 100000
+
+#define RK817_BUCK1_SEL0 ((RK817_BUCK1_MAX0 - RK817_BUCK1_MIN0) /\
+						  RK817_BUCK1_STP0)
+#define RK817_BUCK1_SEL1 ((RK817_BUCK1_MAX1 - RK817_BUCK1_MIN1) /\
+						  RK817_BUCK1_STP1)
+
+#define RK817_BUCK3_SEL1 ((RK817_BUCK3_MAX1 - RK817_BUCK1_MIN1) /\
+						  RK817_BUCK1_STP1)
+
+#define RK817_BUCK1_SEL_CNT (RK817_BUCK1_SEL0 + RK817_BUCK1_SEL1 + 1)
+#define RK817_BUCK3_SEL_CNT (RK817_BUCK1_SEL0 + RK817_BUCK3_SEL1 + 1)
+
+static const struct regulator_linear_range rk817_buck1_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN0, 0,
+			       RK817_BUCK1_SEL0, RK817_BUCK1_STP0),
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN1, RK817_BUCK1_SEL0 + 1,
+			       RK817_BUCK1_SEL_CNT, RK817_BUCK1_STP1),
+};
+
+static const struct regulator_linear_range rk817_buck3_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN0, 0,
+			       RK817_BUCK1_SEL0, RK817_BUCK1_STP0),
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN1, RK817_BUCK1_SEL0 + 1,
+			       RK817_BUCK3_SEL_CNT, RK817_BUCK1_STP1),
+};
+
+#define RK809_BUCK5_SEL_CNT		(8)
+
+static const struct regulator_linear_range rk809_buck5_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1500000, 0, 0, 0),
+	REGULATOR_LINEAR_RANGE(1800000, 1, 3, 200000),
+	REGULATOR_LINEAR_RANGE(2800000, 4, 5, 200000),
+	REGULATOR_LINEAR_RANGE(3300000, 6, 7, 300000),
+};
+
+static unsigned int rk8xx_regulator_of_map_mode(unsigned int mode)
+{
+	if (mode == 1)
+		return REGULATOR_MODE_FAST;
+	if (mode == 2)
+		return REGULATOR_MODE_NORMAL;
+
+	return -EINVAL;
+}
+
 static int rk808_buck1_2_get_voltage_sel_regmap(struct regulator_dev *rdev)
 {
 	struct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);
-	int id = rdev->desc->id - RK808_ID_DCDC1;
+	int id = rdev_get_id(rdev);
 	struct gpio_desc *gpio = pdata->dvs_gpio[id];
 	unsigned int val;
 	int ret;
@@ -189,11 +348,63 @@ static int rk808_buck1_2_i2c_set_voltage_sel(struct regulator_dev *rdev,
 	return ret;
 }
 
+#ifdef CONFIG_CPU_RK312X
+extern void rkclk_cpuclk_div_setting(int div);
+#else
+static inline void rkclk_cpuclk_div_setting(int div) {}
+#endif
+
+static int rk816_regulator_set_voltage_sel_regmap(struct regulator_dev *rdev,
+						  unsigned int sel)
+{
+	int ret, real_sel, delay = 100;
+	int rk816_type;
+	int id = rdev_get_id(rdev);
+
+	regmap_read(rdev->regmap, RK816_CHIP_VER_REG, &rk816_type);
+	rk816_type &= RK816_CHIP_VERSION_MASK;
+	sel <<= ffs(rdev->desc->vsel_mask) - 1;
+
+	if ((rk816_type != RK816_TYPE_ES2) && (id == 0)) {
+		if (sel > 23)
+			rkclk_cpuclk_div_setting(4);
+		else
+			rkclk_cpuclk_div_setting(2);
+	}
+
+	do {
+		ret = regmap_update_bits(rdev->regmap,
+					 rdev->desc->vsel_reg,
+					 rdev->desc->vsel_mask, sel);
+		if (ret)
+			return ret;
+
+		if (rk816_type == RK816_TYPE_ES2) {
+			ret = regmap_update_bits(rdev->regmap,
+						 RK816_DCDC_EN_REG2,
+						 RK816_BUCK_DVS_CONFIRM,
+						 RK816_BUCK_DVS_CONFIRM);
+			if (ret)
+				return ret;
+		}
+
+		regmap_read(rdev->regmap,
+			    rdev->desc->vsel_reg, &real_sel);
+		real_sel &= rdev->desc->vsel_mask;
+		delay--;
+	} while ((sel != real_sel) && (delay > 0));
+
+	if ((rk816_type != RK816_TYPE_ES2) && (id == 0))
+		rkclk_cpuclk_div_setting(1);
+
+	return ret;
+}
+
 static int rk808_buck1_2_set_voltage_sel(struct regulator_dev *rdev,
 					 unsigned sel)
 {
 	struct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);
-	int id = rdev->desc->id - RK808_ID_DCDC1;
+	int id = rdev_get_id(rdev);
 	struct gpio_desc *gpio = pdata->dvs_gpio[id];
 	unsigned int reg = rdev->desc->vsel_reg;
 	unsigned old_sel;
@@ -228,11 +439,11 @@ static int rk808_buck1_2_set_voltage_sel(struct regulator_dev *rdev,
 }
 
 static int rk808_buck1_2_set_voltage_time_sel(struct regulator_dev *rdev,
-				       unsigned int old_selector,
-				       unsigned int new_selector)
+					      unsigned int old_selector,
+					      unsigned int new_selector)
 {
 	struct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);
-	int id = rdev->desc->id - RK808_ID_DCDC1;
+	int id = rdev_get_id(rdev);
 	struct gpio_desc *gpio = pdata->dvs_gpio[id];
 
 	/* if there is no dvs1/2 pin, we don't need wait extra time here. */
@@ -245,8 +456,7 @@ static int rk808_buck1_2_set_voltage_time_sel(struct regulator_dev *rdev,
 static int rk808_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
 {
 	unsigned int ramp_value = RK808_RAMP_RATE_10MV_PER_US;
-	unsigned int reg = rk808_buck_config_regs[rdev->desc->id -
-						  RK808_ID_DCDC1];
+	unsigned int reg = rk808_buck_config_regs[rdev_get_id(rdev)];
 
 	switch (ramp_delay) {
 	case 1 ... 2000:
@@ -269,6 +479,35 @@ static int rk808_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
 				  RK808_RAMP_RATE_MASK, ramp_value);
 }
 
+/*
+ * RK817 RK809
+ */
+static int rk817_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
+{
+	unsigned int ramp_value = RK817_RAMP_RATE_25MV_PER_US;
+	unsigned int reg = RK817_BUCK_CONFIG_REG(rdev_get_id(rdev));
+
+	switch (ramp_delay) {
+	case 0 ... 3000:
+		ramp_value = RK817_RAMP_RATE_3MV_PER_US;
+		break;
+	case 3001 ... 6300:
+		ramp_value = RK817_RAMP_RATE_6_3MV_PER_US;
+		break;
+	case 6301 ... 12500:
+		ramp_value = RK817_RAMP_RATE_12_5MV_PER_US;
+		break;
+	case 12501 ... 25000:
+		break;
+	default:
+		pr_warn("%s ramp_delay: %d not supported, setting 10000\n",
+			rdev->desc->name, ramp_delay);
+	}
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  RK817_RAMP_RATE_MASK, ramp_value);
+}
+
 static int rk808_set_suspend_voltage(struct regulator_dev *rdev, int uv)
 {
 	unsigned int reg;
@@ -284,6 +523,29 @@ static int rk808_set_suspend_voltage(struct regulator_dev *rdev, int uv)
 				  sel);
 }
 
+static int rk817_check_suspend_voltage(int id)
+{
+	if (id >= RK817_ID_DCDC1 && id <= RK817_ID_LDO9)
+		return 0;
+	return -1;
+}
+
+static int rk817_set_suspend_voltage(struct regulator_dev *rdev, int uv)
+{
+	unsigned int reg;
+	int id = rdev_get_id(rdev);
+	int sel = regulator_map_voltage_linear(rdev, uv, uv);
+	/* only ldo1~ldo9 */
+	if (sel < 0 || rk817_check_suspend_voltage(id))
+		return -EINVAL;
+
+	reg = rdev->desc->vsel_reg + RK808_SLP_REG_OFFSET;
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  rdev->desc->vsel_mask,
+				  sel);
+}
+
 static int rk808_set_suspend_voltage_range(struct regulator_dev *rdev, int uv)
 {
 	unsigned int reg;
@@ -299,9 +561,61 @@ static int rk808_set_suspend_voltage_range(struct regulator_dev *rdev, int uv)
 				  sel);
 }
 
+static int rk816_set_suspend_enable(struct regulator_dev *rdev)
+{
+	unsigned int reg, val;
+
+	if (rdev->desc->id <= RK816_ID_DCDC4) {
+		reg = rdev->desc->enable_reg +
+			RK816_DCDC_SLP_EN_REG_OFFSET;
+		val = 1 << rdev->desc->id;
+	} else if ((rdev->desc->id > RK816_ID_DCDC4) &&
+		   (rdev->desc->id <= RK816_ID_LDO4)) {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO1_4_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	} else {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO5_6_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	}
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  val,
+				  val);
+}
+
+static int rk816_set_suspend_disable(struct regulator_dev *rdev)
+{
+	unsigned int reg, val;
+
+	if (rdev->desc->id <= RK816_ID_DCDC4) {
+		reg = rdev->desc->enable_reg +
+			RK816_DCDC_SLP_EN_REG_OFFSET;
+		val = 1 << rdev->desc->id;
+	} else if ((rdev->desc->id > RK816_ID_DCDC4) &&
+		   (rdev->desc->id <= RK816_ID_LDO4)) {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO1_4_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	} else {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO5_6_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	}
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  val,
+				  0);
+}
+
 static int rk808_set_suspend_enable(struct regulator_dev *rdev)
 {
 	unsigned int reg;
+	struct rk808 *rk808 = dev_get_drvdata(rdev->dev.parent);
+
+	if (rk808->variant == RK816_ID)
+		return rk816_set_suspend_enable(rdev);
 
 	reg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;
 
@@ -313,6 +627,10 @@ static int rk808_set_suspend_enable(struct regulator_dev *rdev)
 static int rk808_set_suspend_disable(struct regulator_dev *rdev)
 {
 	unsigned int reg;
+	struct rk808 *rk808 = dev_get_drvdata(rdev->dev.parent);
+
+	if (rk808->variant == RK816_ID)
+		return rk816_set_suspend_disable(rdev);
 
 	reg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;
 
@@ -321,6 +639,119 @@ static int rk808_set_suspend_disable(struct regulator_dev *rdev)
 				  rdev->desc->enable_mask);
 }
 
+static int rk817_set_suspend_enable_ctrl(struct regulator_dev *rdev,
+					 unsigned int en)
+{
+	unsigned int reg;
+	int id = rdev_get_id(rdev);
+	unsigned int id_slp, msk, val;
+
+	if (id >= RK817_ID_DCDC1 && id <= RK817_ID_DCDC4)
+		id_slp = id;
+	else if (id >= RK817_ID_LDO1 && id <= RK817_ID_LDO8)
+		id_slp = 8 + (id - RK817_ID_LDO1);
+	else if (id >= RK817_ID_LDO9 && id <= RK809_ID_SW2)
+		id_slp = 4 + (id - RK817_ID_LDO9);
+	else
+		return -EINVAL;
+
+	reg = RK817_POWER_SLP_EN_REG(id_slp / 8);
+
+	msk = BIT(id_slp % 8);
+	if (en)
+		val = msk;
+	else
+		val = 0;
+
+	return regmap_update_bits(rdev->regmap, reg, msk, val);
+}
+
+static int rk817_set_suspend_enable(struct regulator_dev *rdev)
+{
+	return rk817_set_suspend_enable_ctrl(rdev, 1);
+}
+
+static int rk817_set_suspend_disable(struct regulator_dev *rdev)
+{
+	return rk817_set_suspend_enable_ctrl(rdev, 0);
+}
+
+static int rk8xx_set_suspend_mode(struct regulator_dev *rdev, unsigned int mode)
+{
+	unsigned int reg;
+
+	reg = rdev->desc->vsel_reg + RK808_SLP_REG_OFFSET;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return regmap_update_bits(rdev->regmap, reg,
+					  PWM_MODE_MSK, FPWM_MODE);
+	case REGULATOR_MODE_NORMAL:
+		return regmap_update_bits(rdev->regmap, reg,
+					  PWM_MODE_MSK, AUTO_PWM_MODE);
+	default:
+		pr_err("do not support this mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk8xx_set_mode(struct regulator_dev *rdev, unsigned int mode)
+{
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
+					  PWM_MODE_MSK, FPWM_MODE);
+	case REGULATOR_MODE_NORMAL:
+		return regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
+					  PWM_MODE_MSK, AUTO_PWM_MODE);
+	default:
+		pr_err("do not support this mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int rk8xx_get_mode(struct regulator_dev *rdev)
+{
+	unsigned int val;
+	int err;
+
+	err = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);
+	if (err)
+		return err;
+
+	if (val & FPWM_MODE)
+		return REGULATOR_MODE_FAST;
+	else
+		return REGULATOR_MODE_NORMAL;
+}
+
+static int rk8xx_is_enabled_wmsk_regmap(struct regulator_dev *rdev)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(rdev->regmap, rdev->desc->enable_reg, &val);
+	if (ret != 0)
+		return ret;
+
+	/* add write mask bit */
+	val |= (rdev->desc->enable_mask & 0xf0);
+	val &= rdev->desc->enable_mask;
+
+	if (rdev->desc->enable_is_inverted) {
+		if (rdev->desc->enable_val)
+			return val != rdev->desc->enable_val;
+		return (val == 0);
+	}
+	if (rdev->desc->enable_val)
+		return val == rdev->desc->enable_val;
+	return val != 0;
+}
+
 static struct regulator_ops rk808_buck1_2_ops = {
 	.list_voltage		= regulator_list_voltage_linear,
 	.map_voltage		= regulator_map_voltage_linear,
@@ -330,12 +761,65 @@ static struct regulator_ops rk808_buck1_2_ops = {
 	.enable			= regulator_enable_regmap,
 	.disable		= regulator_disable_regmap,
 	.is_enabled		= regulator_is_enabled_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
 	.set_ramp_delay		= rk808_set_ramp_delay,
 	.set_suspend_voltage	= rk808_set_suspend_voltage,
 	.set_suspend_enable	= rk808_set_suspend_enable,
 	.set_suspend_disable	= rk808_set_suspend_disable,
 };
 
+static struct regulator_ops rk8xx_buck_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+	.set_ramp_delay		= rk808_set_ramp_delay,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk808_set_suspend_enable,
+	.set_suspend_disable	= rk808_set_suspend_disable,
+};
+
+static struct regulator_ops rk817_buck_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+	.set_ramp_delay		= rk817_set_ramp_delay,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
+static struct regulator_ops rk809_buck5_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
 static struct regulator_ops rk808_reg_ops = {
 	.list_voltage		= regulator_list_voltage_linear,
 	.map_voltage		= regulator_map_voltage_linear,
@@ -343,12 +827,40 @@ static struct regulator_ops rk808_reg_ops = {
 	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
 	.enable			= regulator_enable_regmap,
 	.disable		= regulator_disable_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
 	.is_enabled		= regulator_is_enabled_regmap,
 	.set_suspend_voltage	= rk808_set_suspend_voltage,
 	.set_suspend_enable	= rk808_set_suspend_enable,
 	.set_suspend_disable	= rk808_set_suspend_disable,
 };
 
+static struct regulator_ops rk817_reg_ops = {
+	.list_voltage		= regulator_list_voltage_linear,
+	.map_voltage		= regulator_map_voltage_linear,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_voltage	= rk817_set_suspend_voltage,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
+static struct regulator_ops rk817_boost_ops = {
+	.list_voltage		= regulator_list_voltage_linear,
+	.map_voltage		= regulator_map_voltage_linear,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
 static struct regulator_ops rk808_reg_ops_ranges = {
 	.list_voltage		= regulator_list_voltage_linear_range,
 	.map_voltage		= regulator_map_voltage_linear_range,
@@ -356,6 +868,9 @@ static struct regulator_ops rk808_reg_ops_ranges = {
 	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
 	.enable			= regulator_enable_regmap,
 	.disable		= regulator_disable_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
 	.is_enabled		= regulator_is_enabled_regmap,
 	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
 	.set_suspend_enable	= rk808_set_suspend_enable,
@@ -368,6 +883,35 @@ static struct regulator_ops rk808_switch_ops = {
 	.is_enabled		= regulator_is_enabled_regmap,
 	.set_suspend_enable	= rk808_set_suspend_enable,
 	.set_suspend_disable	= rk808_set_suspend_disable,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+};
+
+static struct regulator_ops rk817_switch_ops = {
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
+static struct regulator_ops rk816_buck_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= rk816_regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+	.set_ramp_delay		= rk808_set_ramp_delay,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk808_set_suspend_enable,
+	.set_suspend_disable	= rk808_set_suspend_disable,
 };
 
 static const struct regulator_desc rk808_reg[] = {
@@ -464,6 +1008,106 @@ static const struct regulator_desc rk808_reg[] = {
 		RK808_DCDC_EN_REG, BIT(6)),
 };
 
+static const struct regulator_desc rk816_reg[] = {
+	{
+		.name = "DCDC_REG1",
+		.supply_name = "vcc1",
+		.of_match = of_match_ptr("DCDC_REG1"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK816_ID_DCDC1,
+		.ops = &rk816_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 64,
+		.linear_ranges = rk816_buck_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk816_buck_voltage_ranges),
+		.vsel_reg = RK816_BUCK1_ON_VSEL_REG,
+		.vsel_mask = RK818_BUCK_VSEL_MASK,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(4) | BIT(0),
+		.enable_val = BIT(4) | BIT(0),
+		.disable_val = BIT(4),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG2",
+		.supply_name = "vcc2",
+		.of_match = of_match_ptr("DCDC_REG2"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK816_ID_DCDC2,
+		.ops = &rk816_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 64,
+		.linear_ranges = rk816_buck_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk816_buck_voltage_ranges),
+		.vsel_reg = RK816_BUCK2_ON_VSEL_REG,
+		.vsel_mask = RK818_BUCK_VSEL_MASK,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(5) | BIT(1),
+		.enable_val = BIT(5) | BIT(1),
+		.disable_val = BIT(5),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG3",
+		.supply_name = "vcc3",
+		.of_match = of_match_ptr("DCDC_REG3"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK818_ID_DCDC3,
+		.ops = &rk808_switch_ops,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 1,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(6) | BIT(2),
+		.enable_val =  BIT(6) | BIT(2),
+		.disable_val = BIT(6),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG4",
+		.supply_name = "vcc4",
+		.of_match = of_match_ptr("DCDC_REG4"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK816_ID_DCDC4,
+		.ops = &rk8xx_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 32,
+		.linear_ranges = rk816_buck4_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk816_buck4_voltage_ranges),
+		.vsel_reg = RK816_BUCK4_ON_VSEL_REG,
+		.vsel_mask = RK818_BUCK4_VSEL_MASK,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(7) | BIT(3),
+		.enable_val = BIT(7) | BIT(3),
+		.disable_val = BIT(7),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	RK816_DESC(RK816_ID_LDO1, "LDO_REG1", "vcc5", 800, 3400, 100,
+		   RK816_LDO1_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(4) | BIT(0), BIT(4) | BIT(0),
+		   BIT(4), 400),
+	RK816_DESC(RK816_ID_LDO2, "LDO_REG2", "vcc5", 800, 3400, 100,
+		   RK816_LDO2_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(5) | BIT(1), BIT(5) | BIT(1),
+		   BIT(5), 400),
+	RK816_DESC(RK816_ID_LDO3, "LDO_REG3", "vcc5", 800, 3400, 100,
+		   RK816_LDO3_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(6) | BIT(2), BIT(6) | BIT(2),
+		   BIT(6), 400),
+	RK816_DESC(RK816_ID_LDO4, "LDO_REG4", "vcc6", 800, 3400, 100,
+		   RK816_LDO4_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(7) | BIT(3), BIT(7) | BIT(3),
+		   BIT(7), 400),
+	RK816_DESC(RK816_ID_LDO5, "LDO_REG5", "vcc6", 800, 3400, 100,
+		   RK816_LDO5_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG2, BIT(4) | BIT(0), BIT(4) | BIT(0),
+		   BIT(4), 400),
+	RK816_DESC(RK816_ID_LDO6, "LDO_REG6", "vcc6", 800, 3400, 100,
+		   RK816_LDO6_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG2, BIT(5) | BIT(1), BIT(5) | BIT(1),
+		   BIT(5), 400),
+};
+
 static const struct regulator_desc rk818_reg[] = {
 	{
 		.name = "DCDC_REG1",
@@ -566,10 +1210,283 @@ static const struct regulator_desc rk818_reg[] = {
 		RK818_DCDC_EN_REG, BIT(7)),
 };
 
+#define RK817_LDO_VSEL_MASK		0x7f
+#define RK817_BOOST_VSEL_MASK		0x7
+#define RK817_BUCK_VSEL_MASK		0x7f
+#define RK809_BUCK5_VSEL_MASK		0x7
+
+#define ENABLE_MASK(id)			(BIT(id) | BIT(4 + (id)))
+#define DISABLE_VAL(id)			(BIT(4 + (id)))
+
+static const struct regulator_desc rk817_reg[] = {
+	{
+		.name = "DCDC_REG1",
+		.supply_name = "vcc1",
+		.of_match = of_match_ptr("DCDC_REG1"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC1,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK1_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC1),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC1),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC1),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG2",
+		.supply_name = "vcc2",
+		.of_match = of_match_ptr("DCDC_REG2"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC2,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK2_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC2),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC2),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC2),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG3",
+		.supply_name = "vcc3",
+		.of_match = of_match_ptr("DCDC_REG3"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC3,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK3_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC3),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC3),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC3),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG4",
+		.supply_name = "vcc4",
+		.of_match = of_match_ptr("DCDC_REG4"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC4,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK3_SEL_CNT + 1,
+		.linear_ranges = rk817_buck3_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck3_voltage_ranges),
+		.vsel_reg = RK817_BUCK4_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC4),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC4),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC4),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	RK817_DESC(RK817_ID_LDO1, "LDO_REG1", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(0), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO2, "LDO_REG2", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(1), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO3, "LDO_REG3", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(2), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO4, "LDO_REG4", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(3), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO5, "LDO_REG5", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(4), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO6, "LDO_REG6", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(5), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO7, "LDO_REG7", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(6), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO8, "LDO_REG8", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(7), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO9, "LDO_REG9", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(8), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(3), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_BOOST_DESC(RK817_ID_BOOST, "BOOST", "vcc8", 4700, 5400, 100,
+			 RK817_BOOST_OTG_CFG, RK817_BOOST_VSEL_MASK,
+			 RK817_POWER_EN_REG(3), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400, 3500 - 5400),
+	RK817_DESC_SWITCH(RK817_ID_BOOST_OTG_SW, "OTG_SWITCH", "vcc9",
+			  RK817_POWER_EN_REG(3), ENABLE_MASK(2),
+			  ENABLE_MASK(2), DISABLE_VAL(2)),
+};
+
+static const struct regulator_desc rk809_reg[] = {
+	{
+		.name = "DCDC_REG1",
+		.supply_name = "vcc1",
+		.of_match = of_match_ptr("DCDC_REG1"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC1,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK1_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC1),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC1),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC1),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG2",
+		.supply_name = "vcc2",
+		.of_match = of_match_ptr("DCDC_REG2"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC2,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK2_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC2),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC2),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC2),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG3",
+		.supply_name = "vcc3",
+		.of_match = of_match_ptr("DCDC_REG3"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC3,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK3_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC3),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC3),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC3),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG4",
+		.supply_name = "vcc4",
+		.of_match = of_match_ptr("DCDC_REG4"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC4,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK3_SEL_CNT + 1,
+		.linear_ranges = rk817_buck3_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck3_voltage_ranges),
+		.vsel_reg = RK817_BUCK4_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC4),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC4),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC4),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	{
+		.name = "DCDC_REG5",
+		.supply_name = "vcc9",
+		.of_match = of_match_ptr("DCDC_REG5"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK809_ID_DCDC5,
+		.ops = &rk809_buck5_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK809_BUCK5_SEL_CNT,
+		.linear_ranges = rk809_buck5_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk809_buck5_voltage_ranges),
+		.vsel_reg = RK809_BUCK5_CONFIG(0),
+		.vsel_mask = RK809_BUCK5_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(3),
+		.enable_mask = ENABLE_MASK(1),
+		.enable_val = ENABLE_MASK(1),
+		.disable_val = DISABLE_VAL(1),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	RK817_DESC(RK817_ID_LDO1, "LDO_REG1", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(0), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO2, "LDO_REG2", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(1), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO3, "LDO_REG3", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(2), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO4, "LDO_REG4", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(3), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO5, "LDO_REG5", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(4), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO6, "LDO_REG6", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(5), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO7, "LDO_REG7", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(6), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO8, "LDO_REG8", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(7), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO9, "LDO_REG9", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(8), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(3), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC_SWITCH(RK809_ID_SW1, "SWITCH_REG1", "vcc9",
+			  RK817_POWER_EN_REG(3), ENABLE_MASK(2),
+			  ENABLE_MASK(2), DISABLE_VAL(2)),
+	RK817_DESC_SWITCH(RK809_ID_SW2, "SWITCH_REG2", "vcc8",
+			  RK817_POWER_EN_REG(3), ENABLE_MASK(3),
+			  ENABLE_MASK(3), DISABLE_VAL(3)),
+};
+
 static int rk808_regulator_dt_parse_pdata(struct device *dev,
-				   struct device *client_dev,
-				   struct regmap *map,
-				   struct rk808_regulator_data *pdata)
+					  struct device *client_dev,
+					  struct regmap *map,
+					  struct rk808_regulator_data *pdata)
 {
 	struct device_node *np;
 	int tmp, ret = 0, i;
@@ -589,7 +1506,7 @@ static int rk808_regulator_dt_parse_pdata(struct device *dev,
 		}
 
 		if (!pdata->dvs_gpio[i]) {
-			dev_info(dev, "there is no dvs%d gpio\n", i);
+			dev_warn(dev, "there is no dvs%d gpio\n", i);
 			continue;
 		}
 
@@ -630,10 +1547,22 @@ static int rk808_regulator_probe(struct platform_device *pdev)
 		regulators = rk808_reg;
 		nregulators = RK808_NUM_REGULATORS;
 		break;
+	case RK809_ID:
+		regulators = rk809_reg;
+		nregulators = RK809_NUM_REGULATORS;
+		break;
 	case RK818_ID:
 		regulators = rk818_reg;
 		nregulators = RK818_NUM_REGULATORS;
 		break;
+	case RK816_ID:
+		regulators = rk816_reg;
+		nregulators = RK816_NUM_REGULATORS;
+		break;
+	case RK817_ID:
+		regulators = rk817_reg;
+		nregulators = RK817_NUM_REGULATORS;
+		break;
 	default:
 		dev_err(&client->dev, "unsupported RK8XX ID %lu\n",
 			rk808->variant);
@@ -667,7 +1596,18 @@ static struct platform_driver rk808_regulator_driver = {
 
 module_platform_driver(rk808_regulator_driver);
 
-MODULE_DESCRIPTION("regulator driver for the RK808/RK818 series PMICs");
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+static struct platform_driver rk818_regulator_driver = {
+	.probe = rk808_regulator_probe,
+	.driver = {
+		.name = "rk818-regulator"
+	},
+};
+
+module_platform_driver(rk818_regulator_driver);
+#endif
+
+MODULE_DESCRIPTION("regulator driver for the RK808/RK816/RK818 series PMICs");
 MODULE_AUTHOR("Chris Zhong <zyw@rock-chips.com>");
 MODULE_AUTHOR("Zhang Qing <zhangqing@rock-chips.com>");
 MODULE_AUTHOR("Wadim Egorov <w.egorov@phytec.de>");
diff --git a/drivers/rtc/rtc-rk808.c b/drivers/rtc/rtc-rk808.c
index 35c9aada07c8..b84f0f210169 100644
--- a/drivers/rtc/rtc-rk808.c
+++ b/drivers/rtc/rtc-rk808.c
@@ -50,9 +50,18 @@
 #define NUM_TIME_REGS	(RK808_WEEKS_REG - RK808_SECONDS_REG + 1)
 #define NUM_ALARM_REGS	(RK808_ALARM_YEARS_REG - RK808_ALARM_SECONDS_REG + 1)
 
+struct rk_rtc_compat_reg {
+	unsigned int ctrl_reg;
+	unsigned int status_reg;
+	unsigned int alarm_seconds_reg;
+	unsigned int int_reg;
+	unsigned int seconds_reg;
+};
+
 struct rk808_rtc {
 	struct rk808 *rk808;
 	struct rtc_device *rtc;
+	struct rk_rtc_compat_reg *creg;
 	int irq;
 };
 
@@ -81,6 +90,7 @@ static void gregorian_to_rockchip(struct rtc_time *tm)
 {
 	time64_t extra_days = nov2dec_transitions(tm);
 	time64_t time = rtc_tm_to_time64(tm);
+
 	rtc_time64_to_tm(time - extra_days * 86400, tm);
 
 	/* Compensate if we went back over Nov 31st (will work up to 2381) */
@@ -101,7 +111,7 @@ static int rk808_rtc_readtime(struct device *dev, struct rtc_time *tm)
 	int ret;
 
 	/* Force an update of the shadowed registers right now */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_RTC_GET_TIME,
 				 BIT_RTC_CTRL_REG_RTC_GET_TIME);
 	if (ret) {
@@ -115,7 +125,7 @@ static int rk808_rtc_readtime(struct device *dev, struct rtc_time *tm)
 	 * 32khz. If we clear the GET_TIME bit here, the time of i2c transfer
 	 * certainly more than 31.25us: 16 * 2.5us at 400kHz bus frequency.
 	 */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_RTC_GET_TIME,
 				 0);
 	if (ret) {
@@ -123,7 +133,7 @@ static int rk808_rtc_readtime(struct device *dev, struct rtc_time *tm)
 		return ret;
 	}
 
-	ret = regmap_bulk_read(rk808->regmap, RK808_SECONDS_REG,
+	ret = regmap_bulk_read(rk808->regmap, rk808_rtc->creg->seconds_reg,
 			       rtc_data, NUM_TIME_REGS);
 	if (ret) {
 		dev_err(dev, "Failed to bulk read rtc_data: %d\n", ret);
@@ -166,7 +176,7 @@ static int rk808_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	rtc_data[6] = bin2bcd(tm->tm_wday);
 
 	/* Stop RTC while updating the RTC registers */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M);
 	if (ret) {
@@ -174,14 +184,14 @@ static int rk808_rtc_set_time(struct device *dev, struct rtc_time *tm)
 		return ret;
 	}
 
-	ret = regmap_bulk_write(rk808->regmap, RK808_SECONDS_REG,
+	ret = regmap_bulk_write(rk808->regmap, rk808_rtc->creg->seconds_reg,
 				rtc_data, NUM_TIME_REGS);
 	if (ret) {
 		dev_err(dev, "Failed to bull write rtc_data: %d\n", ret);
 		return ret;
 	}
 	/* Start RTC again */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M, 0);
 	if (ret) {
 		dev_err(dev, "Failed to update RTC control: %d\n", ret);
@@ -190,6 +200,7 @@ static int rk808_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	return 0;
 }
 
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
 /* Read alarm time and date in RTC */
 static int rk808_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
 {
@@ -199,8 +210,13 @@ static int rk808_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
 	uint32_t int_reg;
 	int ret;
 
-	ret = regmap_bulk_read(rk808->regmap, RK808_ALARM_SECONDS_REG,
+	ret = regmap_bulk_read(rk808->regmap,
+			       rk808_rtc->creg->alarm_seconds_reg,
 			       alrm_data, NUM_ALARM_REGS);
+	if (ret) {
+		dev_err(dev, "Failed to read RTC alarm date REG: %d\n", ret);
+		return ret;
+	}
 
 	alrm->time.tm_sec = bcd2bin(alrm_data[0] & SECONDS_REG_MSK);
 	alrm->time.tm_min = bcd2bin(alrm_data[1] & MINUTES_REG_MAK);
@@ -210,7 +226,7 @@ static int rk808_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
 	alrm->time.tm_year = (bcd2bin(alrm_data[5] & YEARS_REG_MSK)) + 100;
 	rockchip_to_gregorian(&alrm->time);
 
-	ret = regmap_read(rk808->regmap, RK808_RTC_INT_REG, &int_reg);
+	ret = regmap_read(rk808->regmap, rk808_rtc->creg->int_reg, &int_reg);
 	if (ret) {
 		dev_err(dev, "Failed to read RTC INT REG: %d\n", ret);
 		return ret;
@@ -231,7 +247,7 @@ static int rk808_rtc_stop_alarm(struct rk808_rtc *rk808_rtc)
 	struct rk808 *rk808 = rk808_rtc->rk808;
 	int ret;
 
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_INT_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->int_reg,
 				 BIT_RTC_INTERRUPTS_REG_IT_ALARM_M, 0);
 
 	return ret;
@@ -242,7 +258,7 @@ static int rk808_rtc_start_alarm(struct rk808_rtc *rk808_rtc)
 	struct rk808 *rk808 = rk808_rtc->rk808;
 	int ret;
 
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_INT_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->int_reg,
 				 BIT_RTC_INTERRUPTS_REG_IT_ALARM_M,
 				 BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
 
@@ -274,7 +290,8 @@ static int rk808_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
 	alrm_data[4] = bin2bcd(alrm->time.tm_mon + 1);
 	alrm_data[5] = bin2bcd(alrm->time.tm_year - 100);
 
-	ret = regmap_bulk_write(rk808->regmap, RK808_ALARM_SECONDS_REG,
+	ret = regmap_bulk_write(rk808->regmap,
+				rk808_rtc->creg->alarm_seconds_reg,
 				alrm_data, NUM_ALARM_REGS);
 	if (ret) {
 		dev_err(dev, "Failed to bulk write: %d\n", ret);
@@ -300,6 +317,7 @@ static int rk808_rtc_alarm_irq_enable(struct device *dev,
 
 	return rk808_rtc_stop_alarm(rk808_rtc);
 }
+#endif
 
 /*
  * We will just handle setting the frequency and make use the framework for
@@ -318,7 +336,7 @@ static irqreturn_t rk808_alarm_irq(int irq, void *data)
 	struct i2c_client *client = rk808->i2c;
 	int ret;
 
-	ret = regmap_write(rk808->regmap, RK808_RTC_STATUS_REG,
+	ret = regmap_write(rk808->regmap, rk808_rtc->creg->status_reg,
 			   RTC_STATUS_MASK);
 	if (ret) {
 		dev_err(&client->dev,
@@ -328,16 +346,18 @@ static irqreturn_t rk808_alarm_irq(int irq, void *data)
 
 	rtc_update_irq(rk808_rtc->rtc, 1, RTC_IRQF | RTC_AF);
 	dev_dbg(&client->dev,
-		 "%s:irq=%d\n", __func__, irq);
+		"%s:irq=%d\n", __func__, irq);
 	return IRQ_HANDLED;
 }
 
 static const struct rtc_class_ops rk808_rtc_ops = {
 	.read_time = rk808_rtc_readtime,
 	.set_time = rk808_rtc_set_time,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
 	.read_alarm = rk808_rtc_readalarm,
 	.set_alarm = rk808_rtc_setalarm,
 	.alarm_irq_enable = rk808_rtc_alarm_irq_enable,
+#endif
 };
 
 #ifdef CONFIG_PM_SLEEP
@@ -371,22 +391,65 @@ static int rk808_rtc_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(rk808_rtc_pm_ops,
 	rk808_rtc_suspend, rk808_rtc_resume);
 
+static struct rk_rtc_compat_reg rk808_creg = {
+	.ctrl_reg = RK808_RTC_CTRL_REG,
+	.status_reg = RK808_RTC_STATUS_REG,
+	.alarm_seconds_reg = RK808_ALARM_SECONDS_REG,
+	.int_reg = RK808_RTC_INT_REG,
+	.seconds_reg = RK808_SECONDS_REG,
+};
+
+static struct rk_rtc_compat_reg rk817_creg = {
+	.ctrl_reg = RK817_RTC_CTRL_REG,
+	.status_reg = RK817_RTC_STATUS_REG,
+	.alarm_seconds_reg = RK817_ALARM_SECONDS_REG,
+	.int_reg = RK817_RTC_INT_REG,
+	.seconds_reg = RK817_SECONDS_REG,
+};
+
 static int rk808_rtc_probe(struct platform_device *pdev)
 {
 	struct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);
 	struct rk808_rtc *rk808_rtc;
 	struct rtc_time tm;
+	struct device_node *np;
 	int ret;
 
+	switch (rk808->variant) {
+	case RK805_ID:
+	case RK808_ID:
+	case RK809_ID:
+	case RK816_ID:
+	case RK818_ID:
+	case RK817_ID:
+		np = of_get_child_by_name(pdev->dev.parent->of_node, "rtc");
+		if (np && !of_device_is_available(np)) {
+			dev_info(&pdev->dev, "device is disabled\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		break;
+	}
+
 	rk808_rtc = devm_kzalloc(&pdev->dev, sizeof(*rk808_rtc), GFP_KERNEL);
-	if (rk808_rtc == NULL)
+	if (!rk808_rtc)
 		return -ENOMEM;
 
+	switch (rk808->variant) {
+	case RK809_ID:
+	case RK817_ID:
+		rk808_rtc->creg = &rk817_creg;
+		break;
+	default:
+		rk808_rtc->creg = &rk808_creg;
+		break;
+	}
 	platform_set_drvdata(pdev, rk808_rtc);
 	rk808_rtc->rk808 = rk808;
 
 	/* start rtc running by default, and use shadowed timer. */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M |
 				 BIT_RTC_CTRL_REG_RTC_READSEL_M,
 				 BIT_RTC_CTRL_REG_RTC_READSEL_M);
@@ -396,7 +459,7 @@ static int rk808_rtc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = regmap_write(rk808->regmap, RK808_RTC_STATUS_REG,
+	ret = regmap_write(rk808->regmap, rk808_rtc->creg->status_reg,
 			   RTC_STATUS_MASK);
 	if (ret) {
 		dev_err(&pdev->dev,
diff --git a/include/linux/amlogic/media/vout/lcd/aml_bl.h b/include/linux/amlogic/media/vout/lcd/aml_bl.h
index 269031641c48..b156d4815b30 100644
--- a/include/linux/amlogic/media/vout/lcd/aml_bl.h
+++ b/include/linux/amlogic/media/vout/lcd/aml_bl.h
@@ -52,9 +52,6 @@ enum bl_chip_type_e {
 	BL_CHIP_TL1,
 	BL_CHIP_SM1,
 	BL_CHIP_TM2,
-	BL_CHIP_TM2B,
-	BL_CHIP_T5,
-	BL_CHIP_T5D,
 	BL_CHIP_MAX,
 };
 
@@ -134,7 +131,6 @@ struct bl_pwm_config_s {
 	unsigned int level_min;
 	unsigned int pwm_freq; /* pwm_vs: 1~4(vfreq), pwm: freq(unit: Hz) */
 	unsigned int pwm_duty; /* unit: % */
-	unsigned int pwm_duty_save; /* unit: %, for power on recovery */
 	unsigned int pwm_duty_max; /* unit: % */
 	unsigned int pwm_duty_min; /* unit: % */
 	unsigned int pwm_cnt; /* internal used for pwm control */
@@ -181,16 +177,12 @@ struct bl_config_s {
 /* backlight_properties: state */
 /* Flags used to signal drivers of state changes */
 /* Upper 4 bits in bl props are reserved for driver internal use */
-#define BL_STATE_GD_EN                BIT(4)
-#define BL_STATE_LCD_ON               BIT(3)
-#define BL_STATE_BL_INIT_ON           BIT(2)
-#define BL_STATE_BL_POWER_ON          BIT(1)
-#define BL_STATE_BL_ON                BIT(0)
+#define BL_STATE_LCD_ON               (1 << 3)
+#define BL_STATE_BL_POWER_ON          (1 << 1)
+#define BL_STATE_BL_ON                (1 << 0)
 struct aml_bl_drv_s {
 	unsigned int index;
 	unsigned int level;
-	unsigned int brightness_level;
-	unsigned int gd_level;
 	unsigned int state;
 	struct bl_data_s *data;
 	struct device             *dev;
@@ -199,7 +191,6 @@ struct aml_bl_drv_s {
 	struct workqueue_struct   *workqueue;
 	struct delayed_work       bl_delayed_work;
 	struct resource *res_ldim_vsync_irq;
-	struct resource *res_bl_vsync_irq;
 	/*struct resource *res_ldim_rdma_irq;*/
 };
 
diff --git a/include/linux/amlogic/media/vout/lcd/aml_lcd.h b/include/linux/amlogic/media/vout/lcd/aml_lcd.h
index 499382f2994b..ab655e5a8fbc 100644
--- a/include/linux/amlogic/media/vout/lcd/aml_lcd.h
+++ b/include/linux/amlogic/media/vout/lcd/aml_lcd.h
@@ -35,34 +35,18 @@
 /*******************************************/
 /*        LCD EXT CMD                      */
 /*******************************************/
-#define LCD_EXT_CMD_TYPE_CMD_DELAY     0x00
-#define LCD_EXT_CMD_TYPE_CMD2_DELAY    0x01  /* for i2c device 2nd addr */
-#define LCD_EXT_CMD_TYPE_CMD3_DELAY    0x02  /* for i2c device 3rd addr */
-#define LCD_EXT_CMD_TYPE_CMD4_DELAY    0x03  /* for i2c device 4th addr */
-#define LCD_EXT_CMD_TYPE_NONE          0x10
-#define LCD_EXT_CMD_TYPE_CMD_BIN2      0xa0  /* with reg offset and data_len*/
-#define LCD_EXT_CMD_TYPE_CMD2_BIN2     0xa1  /* for i2c device 2nd addr */
-#define LCD_EXT_CMD_TYPE_CMD3_BIN2     0xa2  /* for i2c device 3rd addr */
-#define LCD_EXT_CMD_TYPE_CMD4_BIN2     0xa3  /* for i2c device 4th addr */
-#define LCD_EXT_CMD_TYPE_CMD_BIN       0xb0
-#define LCD_EXT_CMD_TYPE_CMD2_BIN      0xb1  /* for i2c device 2nd addr */
-#define LCD_EXT_CMD_TYPE_CMD3_BIN      0xb2  /* for i2c device 3rd addr */
-#define LCD_EXT_CMD_TYPE_CMD4_BIN      0xb3  /* for i2c device 4th addr */
-#define LCD_EXT_CMD_TYPE_CMD           0xc0
-#define LCD_EXT_CMD_TYPE_CMD2          0xc1  /* for i2c device 2nd addr */
-#define LCD_EXT_CMD_TYPE_CMD3          0xc2  /* for i2c device 3rd addr */
-#define LCD_EXT_CMD_TYPE_CMD4          0xc3  /* for i2c device 4th addr */
-#define LCD_EXT_CMD_TYPE_CMD_BIN_DATA  0xd0 /* without auto fill reg addr 0x0 */
-#define LCD_EXT_CMD_TYPE_CMD2_BIN_DATA 0xd1 /* for i2c device 2nd addr */
-#define LCD_EXT_CMD_TYPE_CMD3_BIN_DATA 0xd2 /* for i2c device 3rd addr */
-#define LCD_EXT_CMD_TYPE_CMD4_BIN_DATA 0xd3 /* for i2c device 4th addr */
-#define LCD_EXT_CMD_TYPE_GPIO          0xf0
-#define LCD_EXT_CMD_TYPE_CHECK         0xfc
-#define LCD_EXT_CMD_TYPE_DELAY         0xfd
-#define LCD_EXT_CMD_TYPE_END           0xff
-
-#define LCD_EXT_CMD_SIZE_DYNAMIC       0xff
-#define LCD_EXT_DYNAMIC_SIZE_INDEX     1
+#define LCD_EXT_CMD_TYPE_CMD_DELAY    0x00
+#define LCD_EXT_CMD_TYPE_CMD2_DELAY   0x01  /* for i2c device 2nd addr */
+#define LCD_EXT_CMD_TYPE_NONE         0x10
+#define LCD_EXT_CMD_TYPE_CMD          0xc0
+#define LCD_EXT_CMD_TYPE_CMD2         0xc1  /* for i2c device 2nd addr */
+#define LCD_EXT_CMD_TYPE_GPIO         0xf0
+#define LCD_EXT_CMD_TYPE_CHECK        0xfc
+#define LCD_EXT_CMD_TYPE_DELAY        0xfd
+#define LCD_EXT_CMD_TYPE_END          0xff
+
+#define LCD_EXT_CMD_SIZE_DYNAMIC      0xff
+#define LCD_EXT_DYNAMIC_SIZE_INDEX    1
 
 
 #endif
diff --git a/include/linux/amlogic/media/vout/lcd/aml_ldim.h b/include/linux/amlogic/media/vout/lcd/aml_ldim.h
index ee59e9df0951..c066b0539e6e 100644
--- a/include/linux/amlogic/media/vout/lcd/aml_ldim.h
+++ b/include/linux/amlogic/media/vout/lcd/aml_ldim.h
@@ -34,26 +34,10 @@
 #define LD_DATA_MIN     10
 #define LD_DATA_MAX     0xfff
 
-/* **********************************
- * IOCTL define
- * **********************************
- */
 #define _VE_LDIM  'C'
-#define AML_LDIM_IOC_NR_GET_INFO	0x51
-#define AML_LDIM_IOC_NR_SET_INFO	0x52
-#define AML_LDIM_IOC_NR_GET_REMAP_INFO	0x53
-#define AML_LDIM_IOC_NR_SET_REMAP_INFO	0x54
 
-#define AML_LDIM_IOC_CMD_GET_INFO \
-	_IOR(_VE_LDIM, AML_LDIM_IOC_NR_GET_INFO, struct aml_ldim_info_s)
-#define AML_LDIM_IOC_CMD_SET_INFO \
-	_IOW(_VE_LDIM, AML_LDIM_IOC_NR_SET_INFO, struct aml_ldim_info_s)
-#define AML_LDIM_IOC_CMD_GET_REMAP_INFO \
-	_IOR(_VE_LDIM, AML_LDIM_IOC_NR_GET_REMAP_INFO, \
-	     struct aml_ldim_remap_info_s)
-#define AML_LDIM_IOC_CMD_SET_REMAP_INFO \
-	_IOW(_VE_LDIM, AML_LDIM_IOC_NR_SET_REMAP_INFO, \
-	     struct aml_ldim_remap_info_s)
+/* VPP.ldim IOCTL command list */
+#define LDIM_IOC_PARA  _IOW(_VE_LDIM, 0x50, struct ldim_param_s)
 
 enum ldim_dev_type_e {
 	LDIM_DEV_TYPE_NORMAL = 0,
@@ -62,88 +46,19 @@ enum ldim_dev_type_e {
 	LDIM_DEV_TYPE_MAX,
 };
 
-struct aml_ldim_info_s {
-	unsigned int func_en;
-	unsigned int remapping_en;
-	unsigned int alpha;
-	unsigned int LPF_method;
-	unsigned int lpf_gain;
-	unsigned int lpf_res;
-	unsigned int side_blk_diff_th;
-	unsigned int bbd_th;
-	unsigned int boost_gain;
-	unsigned int rgb_base;
-	unsigned int Ld_remap_bypass;
-	unsigned int LD_TF_STEP_TH;
-	unsigned int TF_BLK_FRESH_BL;
-	unsigned int TF_FRESH_BL;
-	unsigned int fw_LD_ThTF_l;
-	unsigned int fw_rgb_diff_th;
-	unsigned int fw_ld_thist;
-	unsigned int fw_ld_blest_acmode;
-	unsigned int bl_remap_curve[16];
-	unsigned int fw_ld_whist[16];
-};
-
-struct aml_ldim_remap_info_s {
-	unsigned int reg_LD_BackLit_Xtlk;
-	unsigned int reg_LD_BackLit_mode;
-	unsigned int reg_LD_Reflect_Hnum;
-	unsigned int reg_LD_Reflect_Vnum;
-	unsigned int reg_LD_BkLit_curmod;
-	unsigned int reg_LD_BkLUT_Intmod;
-	unsigned int reg_LD_BkLit_Intmod;
-	unsigned int reg_LD_BkLit_LPFmod;
-	unsigned int reg_LD_BkLit_Celnum;
-	unsigned int reg_LD_Reflect_Hdgr[20];
-	unsigned int reg_LD_Reflect_Vdgr[20];
-	unsigned int reg_LD_Reflect_Xdgr[4];
-	unsigned int reg_LD_Vgain;
-	unsigned int reg_LD_Hgain;
-	unsigned int reg_LD_Litgain;
-	unsigned int reg_LD_Litshft;
-	unsigned int reg_LD_BkLit_valid[32];
-	unsigned int reg_LD_LUT_VHk_pos[32];
-	unsigned int reg_LD_LUT_VHk_neg[32];
-	unsigned int reg_LD_LUT_HHk[32];
-	unsigned int reg_LD_LUT_VHo_pos[32];
-	unsigned int reg_LD_LUT_VHo_neg[32];
-	unsigned int reg_LD_LUT_VHo_LS;
-	unsigned int reg_LD_RGBmapping_demo;
-	unsigned int reg_LD_R_LUT_interp_mode;
-	unsigned int reg_LD_G_LUT_interp_mode;
-	unsigned int reg_LD_B_LUT_interp_mode;
-	unsigned int reg_LD_LUT_Hdg_LEXT;
-	unsigned int reg_LD_LUT_Vdg_LEXT;
-	unsigned int reg_LD_LUT_VHk_LEXT;
-	unsigned int Reg_LD_remap_LUT[16][32];
-};
-
 struct ldim_config_s {
 	unsigned short hsize;
 	unsigned short vsize;
-	unsigned char hist_row;
-	unsigned char hist_col;
+	unsigned char row;
+	unsigned char col;
 	unsigned char bl_mode;
-	unsigned char func_en;
-	unsigned char remap_en;
+	unsigned char bl_en;
 	unsigned char hvcnt_bypass;
-	unsigned char dev_index;
-	struct aml_ldim_info_s *ldim_info;
-	struct aml_ldim_remap_info_s *remap_info;
-};
-
-struct ldim_profile_s {
-	unsigned int ld_profile_mode;
-	unsigned int ld_lut_hdg[32];
-	unsigned int ld_lut_vdg[32];
-	unsigned int ld_lut_vhk[32];
 };
 
 #define LDIM_INIT_ON_MAX     300
 #define LDIM_INIT_OFF_MAX    20
 struct ldim_dev_config_s {
-	unsigned char index;
 	char name[20];
 	char pinmux_name[20];
 	unsigned char type;
@@ -155,11 +70,7 @@ struct ldim_dev_config_s {
 	int lamp_err_gpio;
 	unsigned char fault_check;
 	unsigned char write_check;
-	unsigned char device_count;
-	unsigned char pinmux_flag;
 
-	unsigned int blk_row;
-	unsigned int blk_col;
 	unsigned int dim_min;
 	unsigned int dim_max;
 
@@ -173,89 +84,29 @@ struct ldim_dev_config_s {
 	struct bl_pwm_config_s ldim_pwm_config;
 	struct bl_pwm_config_s analog_pwm_config;
 
-	unsigned short bl_zone_num;
+	unsigned short bl_regnum;
 	unsigned short bl_mapping[LD_BLKREGNUM];
 
-	struct ldim_profile_s *ld_profile;
-
 	void (*dim_range_update)(void);
-	int (*dev_reg_write)(unsigned int dev_id, unsigned char *buf,
-			     unsigned int len);
-	int (*dev_reg_read)(unsigned int dev_id, unsigned char *buf,
-			    unsigned int len);
-
-	struct pinctrl *pin;
-	struct device *dev;
-	struct class *dev_class;
-	struct spi_device *spi_dev;
-	struct spi_board_info *spi_info;
-};
-
-struct ldim_rmem_s {
-	void *wr_mem_vaddr1;
-	phys_addr_t wr_mem_paddr1;
-	void *wr_mem_vaddr2;
-	phys_addr_t wr_mem_paddr2;
-	void *rd_mem_vaddr1;
-	phys_addr_t rd_mem_paddr1;
-	void *rd_mem_vaddr2;
-	phys_addr_t rd_mem_paddr2;
-	unsigned int wr_mem_size;
-	unsigned int rd_mem_size;
+	int (*dev_reg_write)(unsigned char *buf, unsigned int len);
+	int (*dev_reg_read)(unsigned char *buf, unsigned int len);
 };
 
 /*******global API******/
-#define LDIM_STATE_POWER_ON             BIT(0)
-#define LDIM_STATE_FUNC_EN              BIT(1)
-#define LDIM_STATE_REMAP_EN             BIT(2)
-#define LDIM_STATE_REMAP_FORCE_UPDATE   BIT(3)
-#define LDIM_STATE_LD_EN                BIT(4)
-
 struct aml_ldim_driver_s {
 	unsigned char valid_flag;
+	unsigned char dev_index;
 	unsigned char static_pic_flag;
 	unsigned char vsync_change_flag;
+	unsigned char pinmux_flag;
 
-	unsigned char init_on_flag;
-	unsigned char func_en;
-	unsigned char remap_en;
-	unsigned char demo_en;
-	unsigned char func_bypass;  /* for lcd bist pattern */
-	unsigned char ld_sel;  /* for gd bypass */
-	unsigned char brightness_bypass;
-	unsigned char test_en;
-	unsigned char avg_update_en;
-	unsigned char matrix_update_en;
-	unsigned char remap_ram_flag;
-	unsigned char remap_ram_step;
-	unsigned char remap_mif_flag;
-	unsigned char remap_init_flag;
-	unsigned char remap_bypass_flag;
-	unsigned char alg_en;
-	unsigned char top_en;
-	unsigned char hist_en;
-	unsigned char load_db_en;
-	unsigned char db_print_flag;
-	unsigned char rdmif_flag;
-	unsigned char litstep_en;
-	unsigned int state;
-
-	unsigned int data_min;
-	unsigned int data_max;
-	unsigned int brightness_level;
-	unsigned int litgain;
-	unsigned int irq_cnt;
-
-	struct ldim_config_s *conf;
+	struct ldim_config_s *ldim_conf;
 	struct ldim_dev_config_s *ldev_conf;
-	struct ldim_rmem_s *rmem;
 	unsigned int *hist_matrix;
 	unsigned int *max_rgb;
-	unsigned short *test_matrix;
+	unsigned short *ldim_test_matrix;
 	unsigned short *local_ldim_matrix;
 	unsigned short *ldim_matrix_buf;
-	unsigned int *array_tmp;
-	struct ldim_fw_para_s *fw_para;
 	int (*init)(void);
 	int (*power_on)(void);
 	int (*power_off)(void);
@@ -268,7 +119,37 @@ struct aml_ldim_driver_s {
 	int (*device_bri_check)(void);
 	void (*config_print)(void);
 	void (*test_ctrl)(int flag);
-	void (*ld_sel_ctrl)(int flag);
+	struct pinctrl *pin;
+	struct device *dev;
+	struct spi_device *spi_dev;
+	struct spi_board_info *spi_info;
+};
+
+struct ldim_param_s {
+	/* beam model */
+	int rgb_base;
+	int boost_gain;
+	int lpf_res;
+	int fw_ld_th_sf; /* spatial filter threshold */
+	/* beam curve */
+	int ld_vgain;
+	int ld_hgain;
+	int ld_litgain;
+	int ld_lut_vdg_lext;
+	int ld_lut_hdg_lext;
+	int ld_lut_vhk_lext;
+	int ld_lut_hdg[32];
+	int ld_lut_vdg[32];
+	int ld_lut_vhk[32];
+	/* beam shape minor adjustment */
+	int ld_lut_vhk_pos[32];
+	int ld_lut_vhk_neg[32];
+	int ld_lut_hhk[32];
+	int ld_lut_vho_pos[32];
+	int ld_lut_vho_neg[32];
+	/* remapping */
+	int lit_idx_th;
+	int comp_gain;
 };
 
 extern struct aml_ldim_driver_s *aml_ldim_get_driver(void);
diff --git a/include/linux/amlogic/media/vout/lcd/lcd_extern.h b/include/linux/amlogic/media/vout/lcd/lcd_extern.h
index bd56be142ed1..1732a33d3d96 100644
--- a/include/linux/amlogic/media/vout/lcd/lcd_extern.h
+++ b/include/linux/amlogic/media/vout/lcd/lcd_extern.h
@@ -33,28 +33,21 @@ enum lcd_extern_type_e {
 #define LCD_EXTERN_GPIO_NUM_MAX       6
 #define LCD_EXTERN_INDEX_INVALID      0xff
 #define LCD_EXTERN_NAME_LEN_MAX       30
-struct lcd_ext_common_s {
-	unsigned char key_valid;
-	unsigned char i2c_bus;
-	unsigned char i2c_sck_gpio;
-	unsigned char i2c_sda_gpio;
-	struct pinctrl *pin;
-	unsigned char pinmux_valid;
-	unsigned char pinmux_gpio_off;
-	unsigned int pinmux_flag;
-};
-
 struct lcd_extern_config_s {
 	unsigned char index;
 	char name[LCD_EXTERN_NAME_LEN_MAX];
 	enum lcd_extern_type_e type;
 	unsigned char status;
+	unsigned char pinmux_valid;
+	unsigned char pinmux_gpio_off;
+	unsigned char key_valid;
 	unsigned char addr_sel; /* internal used */
 
 	unsigned char i2c_addr;
 	unsigned char i2c_addr2;
-	unsigned char i2c_addr3;
-	unsigned char i2c_addr4;
+	unsigned char i2c_bus;
+	unsigned char i2c_sck_gpio;
+	unsigned char i2c_sda_gpio;
 
 	unsigned char spi_gpio_cs;
 	unsigned char spi_gpio_clk;
@@ -69,7 +62,6 @@ struct lcd_extern_config_s {
 	unsigned int table_init_off_cnt;
 	unsigned char *table_init_on;
 	unsigned char *table_init_off;
-	struct lcd_ext_common_s *common_config;
 };
 
 /* global API */
@@ -79,6 +71,8 @@ struct aml_lcd_extern_driver_s {
 	int (*reg_write)(unsigned char *buf, unsigned int len);
 	int (*power_on)(void);
 	int (*power_off)(void);
+	struct pinctrl *pin;
+	unsigned int pinmux_flag;
 };
 
 #define LCD_EXT_I2C_DEV_MAX    10
@@ -88,6 +82,6 @@ struct aml_lcd_extern_i2c_dev_s {
 };
 
 extern struct aml_lcd_extern_driver_s *aml_lcd_extern_get_driver(int index);
-void lcd_extern_index_lut_add(int index);
+
 #endif
 
diff --git a/include/linux/amlogic/media/vout/lcd/lcd_notify.h b/include/linux/amlogic/media/vout/lcd/lcd_notify.h
index 69691e1f968f..adffaf0ed35b 100644
--- a/include/linux/amlogic/media/vout/lcd/lcd_notify.h
+++ b/include/linux/amlogic/media/vout/lcd/lcd_notify.h
@@ -60,6 +60,11 @@
 				LCD_EVENT_BL_OFF | LCD_EVENT_IF_OFF)
 #define LCD_EVENT_UNPREPARE         (LCD_EVENT_ENCL_OFF)
 
+/* lcd backlight index select */
+#define LCD_EVENT_BACKLIGHT_SEL     (1 << 8)
+/* lcd backlight pwm_vs vfreq change occurred */
+#define LCD_EVENT_BACKLIGHT_UPDATE  (1 << 9)
+
 #define LCD_EVENT_GAMMA_UPDATE      (1 << 10)
 #define LCD_EVENT_EXTERN_SEL        (1 << 11)
 
@@ -75,24 +80,9 @@
 #define LCD_VLOCK_PARAM_BIT_VALID   (1 << 0)
 #define LCD_EVENT_VLOCK_PARAM       (1 << 16)
 
-/* lcd backlight index select */
-#define LCD_EVENT_BACKLIGHT_SEL     BIT(24)
-/* lcd backlight pwm_vs vfreq change occurred */
-#define LCD_EVENT_BACKLIGHT_UPDATE  BIT(25)
-/* lcd backlight brightness update by global dimming */
-#define LCD_EVENT_BACKLIGHT_GD_DIM  BIT(26)
-/* lcd backlight brightness on/off by global dimming */
-#define LCD_EVENT_BACKLIGHT_GD_SEL  BIT(27)
-/* lcd backlight brightness on/off by local dimming */
-#define LCD_EVENT_BACKLIGHT_LD_SEL  BIT(28)
 
-/* blocking notify */
-int aml_lcd_notifier_register(struct notifier_block *nb);
-int aml_lcd_notifier_unregister(struct notifier_block *nb);
-int aml_lcd_notifier_call_chain(unsigned long event, void *v);
-/* atomic notify */
-int aml_lcd_atomic_notifier_register(struct notifier_block *nb);
-int aml_lcd_atomic_notifier_unregister(struct notifier_block *nb);
-int aml_lcd_atomic_notifier_call_chain(unsigned long event, void *v);
+extern int aml_lcd_notifier_register(struct notifier_block *nb);
+extern int aml_lcd_notifier_unregister(struct notifier_block *nb);
+extern int aml_lcd_notifier_call_chain(unsigned long event, void *v);
 
 #endif /* _INC_LCD_NOTIFY_H_ */
diff --git a/include/linux/amlogic/media/vout/lcd/lcd_tcon_data.h b/include/linux/amlogic/media/vout/lcd/lcd_tcon_data.h
deleted file mode 100644
index ed740c668901..000000000000
--- a/include/linux/amlogic/media/vout/lcd/lcd_tcon_data.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/* include/linux/amlogic/media/vout/lcd/lcd_tcon_data.h
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef _INC_AML_LCD_TCON_DATA_H
-#define _INC_AML_LCD_TCON_DATA_H
-
-/* for data block header flag */
-#define LCD_TCON_DATA_VALID_VAC      BIT(0)
-#define LCD_TCON_DATA_VALID_DEMURA   BIT(1)
-#define LCD_TCON_DATA_VALID_ACC      BIT(2)
-#define LCD_TCON_DATA_VALID_DITHER   BIT(3)
-#define LCD_TCON_DATA_VALID_OD       BIT(4)
-#define LCD_TCON_DATA_VALID_LOD      BIT(5)
-
-/* for tconless data format */
-/* for tconless data block type */
-#define LCD_TCON_DATA_BLOCK_TYPE_NONE           0x00
-#define LCD_TCON_DATA_BLOCK_TYPE_DEMURA_SET     0x01
-#define LCD_TCON_DATA_BLOCK_TYPE_DEMURA_LUT     0x02
-#define LCD_TCON_DATA_BLOCK_TYPE_ACC_LUT        0x03
-#define LCD_TCON_DATA_BLOCK_TYPE_DITHER_LUT     0x04
-#define LCD_TCON_DATA_BLOCK_TYPE_OD_LUT         0x05
-#define LCD_TCON_DATA_BLOCK_TYPE_LOD_LUT        0x06
-#define LCD_TCON_DATA_BLOCK_TYPE_VAC            0x11
-#define LCD_TCON_DATA_BLOCK_TYPE_EXT            0xe0 /* pmu */
-#define LCD_TCON_DATA_BLOCK_TYPE_MAX            0xff
-
-/* for tconless data block part type */
-#define LCD_TCON_DATA_PART_TYPE_WR_N            0xd0
-#define LCD_TCON_DATA_PART_TYPE_WR_DDR          0xdd
-#define LCD_TCON_DATA_PART_TYPE_WR_MASK         0xb0
-#define LCD_TCON_DATA_PART_TYPE_RD_MASK         0xab
-#define LCD_TCON_DATA_PART_TYPE_CHK_WR_MASK     0xcb
-#define LCD_TCON_DATA_PART_TYPE_CHK_EXIT        0xce
-#define LCD_TCON_DATA_PART_TYPE_PARAM           0xf0 /* only for tool */
-#define LCD_TCON_DATA_PART_TYPE_CONTROL         0xfc
-#define LCD_TCON_DATA_PART_TYPE_DELAY           0xfd
-
-#define LCD_TCON_DATA_PART_FLAG_TUNINTG_LUT     0x00
-#define LCD_TCON_DATA_PART_FLAG_FIXED_LUT       0x10
-#define LCD_TCON_DATA_PART_FLAG_TUNINTG_REG     0x01
-#define LCD_TCON_DATA_PART_FLAG_FIXED_REG       0x11
-#define LCD_TCON_DATA_PART_FLAG_TUNINTG_PARAM   0x0f
-#define LCD_TCON_DATA_PART_FLAG_FIXED_PARAM     0x1f
-
-#define LCD_TCON_DATA_BLOCK_HEADER_SIZE         64
-#define LCD_TCON_DATA_BLOCK_NAME_SIZE           36
-#define LCD_TCON_DATA_PART_NAME_SIZE            48
-#define LCD_TCON_INIT_BIN_NAME_SIZE             28
-#define LCD_TCON_INIT_BIN_VERSION_SIZE          8
-
-/* tcon data control defaine */
-#define LCD_TCON_DATA_CTRL_FLAG_MULTI           BIT(0)
-
-#define LCD_TCON_DATA_CTRL_DEFAULT              0x00
-#define LCD_TCON_DATA_CTRL_MULTI_VFREQ          0x01
-#define LCD_TCON_DATA_CTRL_MULTI_BL_LEVEL       0x11
-#define LCD_TCON_DATA_CTRL_MULTI_BL_PWM_DUTY    0x12
-
-struct lcd_tcon_init_block_header_s {
-	unsigned int crc32;
-	unsigned int reserved;
-	unsigned int block_size;
-	unsigned short header_size;
-	unsigned short reserved1;
-	unsigned short block_type;
-	unsigned short block_ctrl;
-	unsigned char reserved2[5];
-	unsigned char data_byte_width;
-	unsigned short chipid;
-	unsigned char name[LCD_TCON_INIT_BIN_NAME_SIZE];
-	char version[LCD_TCON_INIT_BIN_VERSION_SIZE];
-};
-
-struct lcd_tcon_data_block_header_s {
-	unsigned int crc32;
-	unsigned int raw_data_check;/* crc */
-	unsigned int block_size;
-	unsigned short header_size;
-	unsigned short ext_header_size;
-	unsigned short block_type;
-	unsigned short block_ctrl;
-	unsigned int block_flag;
-	unsigned short init_priority;
-	unsigned short chipid;
-	unsigned char name[LCD_TCON_DATA_BLOCK_NAME_SIZE];
-};
-
-struct lcd_tcon_data_block_ext_header_s {
-	unsigned short part_cnt;
-	unsigned char part_mapping_byte;
-	unsigned char reserved[13];
-};
-
-#define LCD_TCON_DATA_PART_CTRL_SIZE_PRE    (LCD_TCON_DATA_PART_NAME_SIZE + 12)
-struct lcd_tcon_data_part_ctrl_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned short ctrl_data_flag;
-	unsigned short ctrl_sub_type;
-	unsigned short data_byte_width;
-	unsigned short data_cnt;
-};
-
-#define LCD_TCON_DATA_PART_WR_N_SIZE_PRE    (LCD_TCON_DATA_PART_NAME_SIZE + 12)
-struct lcd_tcon_data_part_wr_n_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned char reg_addr_byte;
-	unsigned char reg_data_byte;
-	unsigned char reg_inc;
-	unsigned char reg_cnt;
-	unsigned int data_cnt;
-};
-
-#define LCD_TCON_DATA_PART_WR_DDR_SIZE_PRE  (LCD_TCON_DATA_PART_NAME_SIZE + 12)
-struct lcd_tcon_data_part_wr_ddr_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned short axi_buf_id;
-	unsigned short data_byte;
-	unsigned int data_cnt;
-};
-
-#define LCD_TCON_DATA_PART_WR_MASK_SIZE_PRE   (LCD_TCON_DATA_PART_NAME_SIZE + 6)
-struct lcd_tcon_data_part_wr_mask_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned char reg_addr_byte;
-	unsigned char reg_data_byte;
-};
-
-#define LCD_TCON_DATA_PART_RD_MASK_SIZE_PRE  (LCD_TCON_DATA_PART_NAME_SIZE + 6)
-struct lcd_tcon_data_part_rd_mask_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned char reg_addr_byte;
-	unsigned char reg_data_byte;
-};
-
-#define LCD_TCON_DATA_PART_CHK_WR_MASK_SIZE_PRE \
-	(LCD_TCON_DATA_PART_NAME_SIZE + 9)
-struct lcd_tcon_data_part_chk_wr_mask_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned char reg_chk_addr_byte;
-	unsigned char reg_chk_data_byte;
-	unsigned char reg_wr_addr_byte;
-	unsigned char reg_wr_data_byte;
-	unsigned char data_chk_cnt;
-};
-
-#define LCD_TCON_DATA_PART_CHK_EXIT_SIZE_PRE \
-	(LCD_TCON_DATA_PART_NAME_SIZE + 6)
-struct lcd_tcon_data_part_chk_exit_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned char reg_addr_byte;
-	unsigned char reg_data_byte;
-};
-
-#define LCD_TCON_DATA_PART_DELAY_SIZE    (LCD_TCON_DATA_PART_NAME_SIZE + 8)
-struct lcd_tcon_data_part_delay_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned int delay_us;
-};
-
-#define LCD_TCON_DATA_PART_PARAM_SIZE_PRE    (LCD_TCON_DATA_PART_NAME_SIZE + 8)
-struct lcd_tcon_data_part_param_s {
-	char name[LCD_TCON_DATA_PART_NAME_SIZE];
-	unsigned short part_id;
-	unsigned char tuning_flag;
-	unsigned char part_type;
-	unsigned int param_size;
-};
-
-union lcd_tcon_data_part_u {
-	struct lcd_tcon_data_part_ctrl_s *ctrl;
-	struct lcd_tcon_data_part_wr_n_s *wr_n;
-	struct lcd_tcon_data_part_wr_ddr_s *wr_ddr;
-	struct lcd_tcon_data_part_wr_mask_s *wr_mask;
-	struct lcd_tcon_data_part_rd_mask_s *rd_mask;
-	struct lcd_tcon_data_part_chk_wr_mask_s *chk_wr_mask;
-	struct lcd_tcon_data_part_chk_exit_s *chk_exit;
-	struct lcd_tcon_data_part_delay_s *delay;
-	struct lcd_tcon_data_part_param_s *param;
-};
-
-#define LCD_UKEY_TCON_SPI_BLOCK_SIZE_PRE          20
-struct lcd_tcon_spi_block_s {
-	unsigned short data_type;
-	unsigned short data_index; /* tcon_data_index, equal to init priority */
-	unsigned int data_flag;
-	unsigned int spi_offset;
-	unsigned int spi_size;
-	unsigned int param_cnt;
-
-	unsigned int data_raw_check; //crc...
-	unsigned int data_temp_size;
-	unsigned int data_new_size;
-
-	unsigned int *param;
-	unsigned char *raw_buf;
-	unsigned char *temp_buf;
-	unsigned char *new_buf;
-};
-
-struct lcd_tcon_spi_s {
-	unsigned short version;
-	unsigned int block_cnt;
-	unsigned int init_flag;
-	struct lcd_tcon_spi_block_s **spi_block;
-
-	unsigned char *ext_buf;
-	unsigned int ext_init_on_cnt;
-	unsigned int ext_init_off_cnt;
-
-	int (*data_read)(struct lcd_tcon_spi_block_s *spi_block);
-	int (*data_conv)(struct lcd_tcon_spi_block_s *spi_block);
-};
-
-struct lcd_tcon_spi_s *lcd_tcon_spi_get(void);
-
-unsigned int lcd_tcon_data_size_align(unsigned int size);
-unsigned char lcd_tcon_checksum(unsigned char *buf, unsigned int len);
-unsigned char lcd_tcon_lrc(unsigned char *buf, unsigned int len);
-
-#endif /* _INC_AML_LCD_TCON_DATA_H */
diff --git a/include/linux/amlogic/media/vout/lcd/lcd_unifykey.h b/include/linux/amlogic/media/vout/lcd/lcd_unifykey.h
index fc9f6cf7a25a..c27f57fe2be4 100644
--- a/include/linux/amlogic/media/vout/lcd/lcd_unifykey.h
+++ b/include/linux/amlogic/media/vout/lcd/lcd_unifykey.h
@@ -17,9 +17,8 @@
 
 #ifndef _INC_AML_LCD_UNIFYKEY_H__
 #define _INC_AML_LCD_UNIFYKEY_H__
-#include <linux/amlogic/media/vout/lcd/lcd_tcon_data.h>
 
-#define LCD_UNIFYKEY_WAIT_TIMEOUT      2000
+#define LCD_UNIFYKEY_WAIT_TIMEOUT      500
 #define LCD_UNIFYKEY_RETRY_INTERVAL    20   /* ms */
 
 /* declare external unifykey function */
@@ -255,7 +254,6 @@ extern int lcd_unifykey_header_check(unsigned char *buf,
 		struct aml_lcd_unifykey_header_s *header);
 extern int lcd_unifykey_get(char *key_name,
 		unsigned char *buf, int *len);
-int lcd_unifykey_get_tcon(char *key_name, unsigned char *buf, int *len);
 extern int lcd_unifykey_check_no_header(char *key_name);
 extern int lcd_unifykey_get_no_header(char *key_name,
 		unsigned char *buf, int *len);
diff --git a/include/linux/amlogic/media/vout/lcd/lcd_vout.h b/include/linux/amlogic/media/vout/lcd/lcd_vout.h
index 40ff3f187ff8..fb38bf5c4edc 100644
--- a/include/linux/amlogic/media/vout/lcd/lcd_vout.h
+++ b/include/linux/amlogic/media/vout/lcd/lcd_vout.h
@@ -23,7 +23,6 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/amlogic/media/vout/vout_notify.h>
 #include <linux/amlogic/iomap.h>
-#include <linux/amlogic/media/vout/lcd/lcd_tcon_data.h>
 
 extern void lcd_vlock_m_update(unsigned int vlock_m);
 extern void lcd_vlock_frac_update(unsigned int vlock_farc);
@@ -63,7 +62,6 @@ extern unsigned char lcd_debug_print_flag;
 
 /* ******** clk_ctrl ******** */
 #define CLK_CTRL_LEVEL              28 /* [30:28] */
-#define CLK_CTRL_FRAC_SHIFT         24 /* [24] */
 #define CLK_CTRL_FRAC               0  /* [18:0] */
 
 /* **********************************
@@ -96,8 +94,6 @@ enum lcd_chip_e {
 	LCD_CHIP_TL1,   /* 7 */
 	LCD_CHIP_SM1,	/* 8 */
 	LCD_CHIP_TM2,   /* 9 */
-	LCD_CHIP_T5,   /* 10 */
-	LCD_CHIP_T5D,   /* 11 */
 	LCD_CHIP_MAX,
 };
 
@@ -122,7 +118,6 @@ struct lcd_basic_s {
 	char model_name[MOD_LEN_MAX];
 	enum lcd_type_e lcd_type;
 	unsigned short lcd_bits;
-	unsigned char pinmux_flag;
 
 	unsigned short h_active;    /* Horizontal display area */
 	unsigned short v_active;    /* Vertical display area */
@@ -354,7 +349,7 @@ enum p2p_type_e {
 };
 
 struct p2p_config_s {
-	unsigned int p2p_type; /* bit[4:0] for type, bit[5] for vcm flag */
+	unsigned int p2p_type;
 	unsigned int lane_num;
 	unsigned int channel_sel0;
 	unsigned int channel_sel1;
@@ -385,7 +380,6 @@ enum lcd_power_type_e {
 	LCD_POWER_TYPE_EXTERN,
 	LCD_POWER_TYPE_WAIT_GPIO,
 	LCD_POWER_TYPE_CLK_SS,
-	LCD_POWER_TYPE_TCON_SPI_DATA_LOAD,
 	LCD_POWER_TYPE_MAX,
 };
 
@@ -438,16 +432,11 @@ struct lcd_power_ctrl_s {
 	int power_off_step_max; /* internal use for debug */
 };
 
-#define LCD_INIT_LEVEL_NORMAL         0
-#define LCD_INIT_LEVEL_PWR_OFF        1
-#define LCD_INIT_LEVEL_KERNEL_ON      2
-#define LCD_INIT_LEVEL_KERNEL_OFF     3
-
 struct lcd_boot_ctrl_s {
 	unsigned char lcd_type;	//bit[3:0]
 	unsigned char lcd_bits; //bit[7:4] bits:6 or 8
 	unsigned char advanced_flag;	//bit[15:8]
-	unsigned char lcd_init_level;	//bit[19:18]
+	unsigned char lcd_init_level;	//bit[19]
 	unsigned char debug_print_flag;	//bit[23:20]
 	unsigned char debug_test_pattern;	//bit[27:24]
 	unsigned char debug_para_source;//bit[29:28]
@@ -466,18 +455,17 @@ struct lcd_config_s {
 	struct lcd_optical_info_s optical_info;
 	struct lcd_control_config_s lcd_control;
 	struct lcd_power_ctrl_s *lcd_power;
+	struct lcd_boot_ctrl_s *lcd_boot_ctrl;
 	struct pinctrl *pin;
-	unsigned char change_flag;
 	unsigned char pinmux_flag;
+	unsigned char change_flag;
 	unsigned char retry_enable_flag;
 	unsigned char retry_enable_cnt;
-	unsigned char customer_pinmux;
 };
 
 struct lcd_duration_s {
 	unsigned int duration_num;
 	unsigned int duration_den;
-	unsigned int frac;
 };
 
 #define LCD_STATUS_IF_ON      (1 << 0)
@@ -485,13 +473,14 @@ struct lcd_duration_s {
 #define LCD_STATUS_VMODE_ACTIVE  (1 << 2)
 #define LCD_STATUS_ON         (LCD_STATUS_IF_ON | LCD_STATUS_ENCL_ON)
 
+#define LCD_MUTE_UPDATE       (1 << 4)
+#define LCD_TEST_UPDATE       (1 << 4)
+
 #define LCD_VIU_SEL_NONE      0
-#define EXTERN_MUL_MAX	      10
 struct aml_lcd_drv_s {
 	char version[20];
 	struct lcd_data_s *data;
 	unsigned char lcd_mode;
-	unsigned char lcd_pxp;
 	unsigned char lcd_status;
 	unsigned char lcd_key_valid;
 	unsigned char lcd_clk_path; /* 0=hpll, 1=gp0_pll */
@@ -504,17 +493,14 @@ struct aml_lcd_drv_s {
 	unsigned char lcd_mute_flag;
 	unsigned char viu_sel;
 	unsigned char vsync_none_timer_flag;
-	unsigned int extern_mul_index[EXTERN_MUL_MAX];
 
 	struct device *dev;
 	struct lcd_config_s *lcd_config;
 	struct vinfo_s *lcd_info;
 	struct class *lcd_debug_class;
-	struct lcd_boot_ctrl_s *boot_ctrl;
 
 	int fr_auto_policy;
 	int fr_mode;
-	int fr_duration;
 	struct lcd_duration_s std_duration;
 
 	int tcon_status;
@@ -531,7 +517,7 @@ struct aml_lcd_drv_s {
 	void (*power_ctrl)(int status);
 
 	struct workqueue_struct *workqueue;
-	struct work_struct lcd_probe_work;
+	struct delayed_work lcd_probe_delayed_work;
 	struct work_struct  lcd_resume_work;
 	struct resource *res_vsync_irq;
 	struct resource *res_vsync2_irq;
@@ -539,11 +525,11 @@ struct aml_lcd_drv_s {
 	struct resource *res_tcon_irq;
 
 	struct mutex power_mutex;
-	spinlock_t isr_lock; /* for mute and test isr */
 };
 
 extern struct aml_lcd_drv_s *aml_lcd_get_driver(void);
 
+
 /* **********************************
  * IOCTL define
  * **********************************
diff --git a/include/linux/amlogic/media/vout/lcd/ldim_alg.h b/include/linux/amlogic/media/vout/lcd/ldim_alg.h
index 95c39c38a5d5..8f98e87528df 100644
--- a/include/linux/amlogic/media/vout/lcd/ldim_alg.h
+++ b/include/linux/amlogic/media/vout/lcd/ldim_alg.h
@@ -32,9 +32,7 @@
 #define LD_BLKHMAX 32
 #define LD_BLKVMAX 32
 
-#define LD_BLKREGNUM   1536  /* maximum support 48*32*/
-#define LD_NUM_PROFILE 8  //16
-#define LD_NUM_PROFILE_TM2  16  //16
+#define LD_BLKREGNUM 384  /* maximum support 24*16*/
 
 struct LDReg_s {
 	int reg_LD_pic_RowMax;            /*u13*/
@@ -136,10 +134,10 @@ struct LDReg_s {
 	int reg_ldfw_sta_norm;
 	int reg_ldfw_sta_norm_rs;
 	int reg_ldfw_tf_enable;
-	int reg_LD_LUT_Hdg_TXLX[8][LD_LUT_LEN];
-	int reg_LD_LUT_Vdg_TXLX[8][LD_LUT_LEN];
-	int reg_LD_LUT_VHk_TXLX[8][LD_LUT_LEN];
-	int reg_LD_LUT_Id[LD_BLKREGNUM];
+	int reg_LD_LUT_Hdg_TXLX[8][32];
+	int reg_LD_LUT_Vdg_TXLX[8][32];
+	int reg_LD_LUT_VHk_TXLX[8][32];
+	int reg_LD_LUT_Id[16 * 24];
 	int reg_LD_LUT_Hdg_LEXT_TXLX[8];
 	int reg_LD_LUT_Vdg_LEXT_TXLX[8];
 	int reg_LD_LUT_VHk_LEXT_TXLX[8];
@@ -192,7 +190,7 @@ struct LDReg_s {
 	 */
 	int reg_LD_Reflect_Vdgr[20];
 	/*20*u6:  cells 1~20 for V Gains of different dist of Top/Bot;*/
-	int reg_LD_Reflect_Xdgr[6];     /*4*u6:*/
+	int reg_LD_Reflect_Xdgr[4];     /*4*u6:*/
 	int reg_LD_Vgain;               /*u12*/
 	int reg_LD_Hgain;               /*u12*/
 	int reg_LD_Litgain;             /*u12*/
@@ -214,13 +212,13 @@ struct LDReg_s {
 	/* VHk positive and negative side gain, normalized to 128
 	 *	as "1" 20150428
 	 */
-	int reg_LD_LUT_VHk_pos[LD_LUT_LEN];   /* u8*/
-	int reg_LD_LUT_VHk_neg[LD_LUT_LEN];   /* u8*/
-	int reg_LD_LUT_HHk[LD_LUT_LEN];
+	int reg_LD_LUT_VHk_pos[32];   /* u8*/
+	int reg_LD_LUT_VHk_neg[32];   /* u8*/
+	int reg_LD_LUT_HHk[32];
 	/* u8 side gain for LED direction hdist gain for different LED*/
 	/* VHo possitive and negative side offset, use with LS, (x<<LS)*/
-	int reg_LD_LUT_VHo_pos[LD_LUT_LEN];   /* s8*/
-	int reg_LD_LUT_VHo_neg[LD_LUT_LEN];   /* s8*/
+	int reg_LD_LUT_VHo_pos[32];   /* s8*/
+	int reg_LD_LUT_VHo_neg[32];   /* s8*/
 	int reg_LD_LUT_VHo_LS;/* u3:0~6,left shift bits of VH0_pos/neg*/
 	/* adding three cells for left boundary extend during
 	 *	Cubic interpolation
@@ -271,16 +269,24 @@ struct FW_DAT_s {
 	unsigned int *TF_BL_alpha;
 	unsigned int *last_YUVsum;
 	unsigned int *last_RGBsum;
-	unsigned int *last_sta1_maxrgb;
+	unsigned int *last_STA1_MaxRGB;
 	unsigned int *SF_BL_matrix;
 	unsigned int *TF_BL_matrix;
 	unsigned int *TF_BL_matrix_2;
 };
 
-struct fw_ctrl_config_s {
+struct ldim_fw_para_s {
+	/* header */
+	unsigned int para_ver;
+	unsigned int para_size;
+	char ver_str[20];
+	unsigned char ver_num;
+
+	unsigned char hist_col;
+	unsigned char hist_row;
+
 	unsigned int fw_LD_ThSF_l;
 	unsigned int fw_LD_ThTF_l;
-	unsigned int fw_ld_thist; /* pre-calc gain */
 	unsigned int boost_gain; /*norm 256 to 1,T960 finally use*/
 	unsigned int TF_alpha; /*256;*/
 	unsigned int lpf_gain;  /* [0~128~256], norm 128 as 1*/
@@ -313,62 +319,26 @@ struct fw_ctrl_config_s {
 	unsigned char bbd_detect_en;
 	unsigned char diff_blk_luma_en;
 
-	unsigned char Sf_bypass;
-	unsigned char Boost_light_bypass;
-	unsigned char Lpf_bypass;
-	unsigned char Ld_remap_bypass;
+	unsigned char Sf_bypass, Boost_light_bypass;
+	unsigned char Lpf_bypass, Ld_remap_bypass;
 	unsigned char black_frm;
-	unsigned char black_frm_en;
-	unsigned int black_frm_rgbmax_th;
-	unsigned int black_frm_cnt_th;
-
-	unsigned char white_area_remap_en;
-	unsigned int white_area;
-	unsigned int white_lvl;
-	unsigned int white_area_th_max;
-	unsigned int white_area_th_min;
-	unsigned int white_lvl_th_max;
-	unsigned int white_lvl_th_min;
-
-	unsigned int fw_ld_blest_acmode;
-	unsigned int min_bl_alpha;
-	unsigned int glb_blend_alpha;
-
-	unsigned int sc_method;
-	unsigned int sc_step;
-};
-
-struct ldim_fw_para_s {
-	/* header */
-	unsigned int para_ver;
-	unsigned int para_size;
-	unsigned int fw_ctrl_size;
-	char ver_str[20];
-	unsigned char ver_num;
-	unsigned char valid;
-
-	unsigned char hist_col;
-	unsigned char hist_row;
 
 	/* for debug print */
 	unsigned char fw_hist_print;/*20180525*/
 	unsigned int fw_print_frequent;/*20180606,print every 8 frame*/
 	unsigned int Dbprint_lv;
 
-	struct LDReg_s *nprm;
-	struct FW_DAT_s *fdat;
+	struct LDReg_s *nPRM;
+	struct FW_DAT_s *FDat;
 	unsigned int *bl_remap_curve; /* size: 16 */
-	unsigned int *fw_ld_whist;    /* size: 16 */
-
-	struct fw_ctrl_config_s *ctrl;
+	unsigned int *fw_LD_Whist;    /* size: 16 */
 
 	void (*fw_alg_frm)(struct ldim_fw_para_s *fw_para,
 		unsigned int *max_matrix, unsigned int *hist_matrix);
 	void (*fw_alg_para_print)(struct ldim_fw_para_s *fw_para);
 };
-
 /* if struct ldim_fw_para_s changed, FW_PARA_VER must be update */
-#define FW_PARA_VER    5
+#define FW_PARA_VER    1
 
 extern struct ldim_fw_para_s *aml_ldim_get_fw_para(void);
 
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 9116cb293c7d..0f1c150a1d9d 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -25,7 +25,8 @@
 #define CLK_SET_PARENT_GATE	BIT(1) /* must be gated across re-parent */
 #define CLK_SET_RATE_PARENT	BIT(2) /* propagate rate change up one level */
 #define CLK_IGNORE_UNUSED	BIT(3) /* do not gate even if unused */
-				/* unused */
+				/* unused for CE kernel, but added from HK */
+#define CLK_IS_ROOT               BIT(4) /* root clk, has no parent */
 #define CLK_IS_BASIC		BIT(5) /* Basic clk, can't do a to_clk_foo() */
 #define CLK_GET_RATE_NOCACHE	BIT(6) /* do not use the cached clk rate */
 #define CLK_SET_RATE_NO_REPARENT BIT(7) /* don't re-parent on rate change */
diff --git a/include/linux/extcon.h b/include/linux/extcon.h
index 291345187854..472d73f27d99 100644
--- a/include/linux/extcon.h
+++ b/include/linux/extcon.h
@@ -45,6 +45,7 @@
 /* USB external connector */
 #define EXTCON_USB		1
 #define EXTCON_USB_HOST		2
+#define EXTCON_USB_VBUS_EN	3
 
 /* Charging external connector */
 #define EXTCON_CHG_USB_SDP	5	/* Standard Downstream Port */
diff --git a/include/linux/mfd/rk808.h b/include/linux/mfd/rk808.h
index 6d435a3c06bc..b433c7359734 100644
--- a/include/linux/mfd/rk808.h
+++ b/include/linux/mfd/rk808.h
@@ -1,15 +1,11 @@
 /*
- * Register definitions for Rockchip's RK808/RK818 PMIC
+ * rk808.h for Rockchip RK808
  *
  * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
  *
  * Author: Chris Zhong <zyw@rock-chips.com>
  * Author: Zhang Qing <zhangqing@rock-chips.com>
  *
- * Copyright (C) 2016 PHYTEC Messtechnik GmbH
- *
- * Author: Wadim Egorov <w.egorov@phytec.de>
- *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
@@ -20,8 +16,8 @@
  * more details.
  */
 
-#ifndef __LINUX_REGULATOR_RK808_H
-#define __LINUX_REGULATOR_RK808_H
+#ifndef __LINUX_REGULATOR_rk808_H
+#define __LINUX_REGULATOR_rk808_H
 
 #include <linux/regulator/machine.h>
 #include <linux/regmap.h>
@@ -32,7 +28,7 @@
 
 #define RK808_DCDC1	0 /* (0+RK808_START) */
 #define RK808_LDO1	4 /* (4+RK808_START) */
-#define RK808_NUM_REGULATORS	14
+#define RK808_NUM_REGULATORS   14
 
 enum rk808_reg {
 	RK808_ID_DCDC1,
@@ -51,6 +47,49 @@ enum rk808_reg {
 	RK808_ID_SWITCH2,
 };
 
+enum rk816_reg {
+	RK816_ID_DCDC1,
+	RK816_ID_DCDC2,
+	RK816_ID_DCDC3,
+	RK816_ID_DCDC4,
+	RK816_ID_LDO1,
+	RK816_ID_LDO2,
+	RK816_ID_LDO3,
+	RK816_ID_LDO4,
+	RK816_ID_LDO5,
+	RK816_ID_LDO6,
+};
+
+enum rk818_reg {
+	RK818_ID_DCDC1,
+	RK818_ID_DCDC2,
+	RK818_ID_DCDC3,
+	RK818_ID_DCDC4,
+	RK818_ID_BOOST,
+	RK818_ID_LDO1,
+	RK818_ID_LDO2,
+	RK818_ID_LDO3,
+	RK818_ID_LDO4,
+	RK818_ID_LDO5,
+	RK818_ID_LDO6,
+	RK818_ID_LDO7,
+	RK818_ID_LDO8,
+	RK818_ID_LDO9,
+	RK818_ID_SWITCH,
+	RK818_ID_HDMI_SWITCH,
+	RK818_ID_OTG_SWITCH,
+};
+
+enum rk805_reg {
+	RK805_ID_DCDC1,
+	RK805_ID_DCDC2,
+	RK805_ID_DCDC3,
+	RK805_ID_DCDC4,
+	RK805_ID_LDO1,
+	RK805_ID_LDO2,
+	RK805_ID_LDO3,
+};
+
 #define RK808_SECONDS_REG	0x00
 #define RK808_MINUTES_REG	0x01
 #define RK808_HOURS_REG		0x02
@@ -121,31 +160,8 @@ enum rk808_reg {
 #define RK808_INT_STS_MSK_REG2	0x4f
 #define RK808_IO_POL_REG	0x50
 
-/* RK818 */
-#define RK818_DCDC1			0
-#define RK818_LDO1			4
-#define RK818_NUM_REGULATORS		17
-
-enum rk818_reg {
-	RK818_ID_DCDC1,
-	RK818_ID_DCDC2,
-	RK818_ID_DCDC3,
-	RK818_ID_DCDC4,
-	RK818_ID_BOOST,
-	RK818_ID_LDO1,
-	RK818_ID_LDO2,
-	RK818_ID_LDO3,
-	RK818_ID_LDO4,
-	RK818_ID_LDO5,
-	RK818_ID_LDO6,
-	RK818_ID_LDO7,
-	RK818_ID_LDO8,
-	RK818_ID_LDO9,
-	RK818_ID_SWITCH,
-	RK818_ID_HDMI_SWITCH,
-	RK818_ID_OTG_SWITCH,
-};
-
+#define RK818_VB_MON_REG		0x21
+#define RK818_THERMAL_REG		0x22
 #define RK818_DCDC_EN_REG		0x23
 #define RK818_LDO_EN_REG		0x24
 #define RK818_SLEEP_SET_OFF_REG1	0x25
@@ -184,29 +200,99 @@ enum rk818_reg {
 #define RK818_LDO7_SLP_VSEL_REG		0x48
 #define RK818_LDO8_ON_VSEL_REG		0x49
 #define RK818_LDO8_SLP_VSEL_REG		0x4a
-#define RK818_BOOST_LDO9_ON_VSEL_REG	0x54
-#define RK818_BOOST_LDO9_SLP_VSEL_REG	0x55
 #define RK818_DEVCTRL_REG		0x4b
 #define RK818_INT_STS_REG1		0X4c
-#define RK818_INT_STS_MSK_REG1		0x4d
-#define RK818_INT_STS_REG2		0x4e
-#define RK818_INT_STS_MSK_REG2		0x4f
-#define RK818_IO_POL_REG		0x50
+#define RK818_INT_STS_MSK_REG1		0X4d
+#define RK818_INT_STS_REG2		0X4e
+#define RK818_INT_STS_MSK_REG2		0X4f
+#define RK818_IO_POL_REG		0X50
+#define RK818_OTP_VDD_EN_REG		0x51
 #define RK818_H5V_EN_REG		0x52
 #define RK818_SLEEP_SET_OFF_REG3	0x53
 #define RK818_BOOST_LDO9_ON_VSEL_REG	0x54
 #define RK818_BOOST_LDO9_SLP_VSEL_REG	0x55
 #define RK818_BOOST_CTRL_REG		0x56
-#define RK818_DCDC_ILMAX		0x90
+#define RK818_DCDC_ILMAX_REG		0x90
+#define RK818_CHRG_COMP_REG		0x9a
+#define RK818_SUP_STS_REG		0xa0
 #define RK818_USB_CTRL_REG		0xa1
+#define RK818_CHRG_CTRL_REG1		0xa3
+#define RK818_CHRG_CTRL_REG2		0xa4
+#define RK818_CHRG_CTRL_REG3		0xa5
+#define RK818_BAT_CTRL_REG		0xa6
+#define RK818_BAT_HTS_TS1_REG		0xa8
+#define RK818_BAT_LTS_TS1_REG		0xa9
+#define RK818_BAT_HTS_TS2_REG		0xaa
+#define RK818_BAT_LTS_TS2_REG		0xab
+#define RK818_TS_CTRL_REG		0xac
+#define RK818_ADC_CTRL_REG		0xad
+#define RK818_ON_SOURCE_REG		0xae
+#define RK818_OFF_SOURCE_REG		0xaf
+#define RK818_GGCON_REG			0xb0
+#define RK818_GGSTS_REG			0xb1
+#define RK818_FRAME_SMP_INTERV_REG	0xb2
+#define RK818_AUTO_SLP_CUR_THR_REG	0xb3
+#define RK818_GASCNT_CAL_REG3		0xb4
+#define RK818_GASCNT_CAL_REG2		0xb5
+#define RK818_GASCNT_CAL_REG1		0xb6
+#define RK818_GASCNT_CAL_REG0		0xb7
+#define RK818_GASCNT3_REG		0xb8
+#define RK818_GASCNT2_REG		0xb9
+#define RK818_GASCNT1_REG		0xba
+#define RK818_GASCNT0_REG		0xbb
+#define RK818_BAT_CUR_AVG_REGH		0xbc
+#define RK818_BAT_CUR_AVG_REGL		0xbd
+#define RK818_TS1_ADC_REGH		0xbe
+#define RK818_TS1_ADC_REGL		0xbf
+#define RK818_TS2_ADC_REGH		0xc0
+#define RK818_TS2_ADC_REGL		0xc1
+#define RK818_BAT_OCV_REGH		0xc2
+#define RK818_BAT_OCV_REGL		0xc3
+#define RK818_BAT_VOL_REGH		0xc4
+#define RK818_BAT_VOL_REGL		0xc5
+#define RK818_RELAX_ENTRY_THRES_REGH	0xc6
+#define RK818_RELAX_ENTRY_THRES_REGL	0xc7
+#define RK818_RELAX_EXIT_THRES_REGH	0xc8
+#define RK818_RELAX_EXIT_THRES_REGL	0xc9
+#define RK818_RELAX_VOL1_REGH		0xca
+#define RK818_RELAX_VOL1_REGL		0xcb
+#define RK818_RELAX_VOL2_REGH		0xcc
+#define RK818_RELAX_VOL2_REGL		0xcd
+#define RK818_BAT_CUR_R_CALC_REGH	0xce
+#define RK818_BAT_CUR_R_CALC_REGL	0xcf
+#define RK818_BAT_VOL_R_CALC_REGH	0xd0
+#define RK818_BAT_VOL_R_CALC_REGL	0xd1
+#define RK818_CAL_OFFSET_REGH		0xd2
+#define RK818_CAL_OFFSET_REGL		0xd3
+#define RK818_NON_ACT_TIMER_CNT_REG	0xd4
+#define RK818_VCALIB0_REGH		0xd5
+#define RK818_VCALIB0_REGL		0xd6
+#define RK818_VCALIB1_REGH		0xd7
+#define RK818_VCALIB1_REGL		0xd8
+#define RK818_IOFFSET_REGH		0xdd
+#define RK818_IOFFSET_REGL		0xde
+#define RK818_SOC_REG			0xe0
+#define RK818_REMAIN_CAP_REG3		0xe1
+#define RK818_REMAIN_CAP_REG2		0xe2
+#define RK818_REMAIN_CAP_REG1		0xe3
+#define RK818_REMAIN_CAP_REG0		0xe4
+#define RK818_UPDAT_LEVE_REG		0xe5
+#define RK818_NEW_FCC_REG3		0xe6
+#define RK818_NEW_FCC_REG2		0xe7
+#define RK818_NEW_FCC_REG1		0xe8
+#define RK818_NEW_FCC_REG0		0xe9
+#define RK818_NON_ACT_TIMER_CNT_SAVE_REG 0xea
+#define RK818_OCV_VOL_VALID_REG		0xeb
+#define RK818_REBOOT_CNT_REG		0xec
+#define RK818_POFFSET_REG		0xed
+#define RK818_MISC_MARK_REG		0xee
+#define RK818_HALT_CNT_REG		0xef
+#define RK818_CALC_REST_REGH		0xf0
+#define RK818_CALC_REST_REGL		0xf1
+#define RK818_SAVE_DATA19		0xf2
+#define RK818_NUM_REGULATORS		17
 
-#define RK818_H5V_EN			BIT(0)
-#define RK818_REF_RDY_CTRL		BIT(1)
-#define RK818_USB_ILIM_SEL_MASK		0xf
-#define RK818_USB_ILMIN_2000MA		0x7
-#define RK818_USB_CHG_SD_VSEL_MASK	0x70
-
-/* RK808 IRQ Definitions */
+/* IRQ Definitions */
 #define RK808_IRQ_VOUT_LO	0
 #define RK808_IRQ_VB_LO		1
 #define RK808_IRQ_PWRON		2
@@ -228,43 +314,6 @@ enum rk818_reg {
 #define RK808_IRQ_PLUG_IN_INT_MSK	BIT(0)
 #define RK808_IRQ_PLUG_OUT_INT_MSK	BIT(1)
 
-/* RK818 IRQ Definitions */
-#define RK818_IRQ_VOUT_LO	0
-#define RK818_IRQ_VB_LO		1
-#define RK818_IRQ_PWRON		2
-#define RK818_IRQ_PWRON_LP	3
-#define RK818_IRQ_HOTDIE	4
-#define RK818_IRQ_RTC_ALARM	5
-#define RK818_IRQ_RTC_PERIOD	6
-#define RK818_IRQ_USB_OV	7
-#define RK818_IRQ_PLUG_IN	8
-#define RK818_IRQ_PLUG_OUT	9
-#define RK818_IRQ_CHG_OK	10
-#define RK818_IRQ_CHG_TE	11
-#define RK818_IRQ_CHG_TS1	12
-#define RK818_IRQ_TS2		13
-#define RK818_IRQ_CHG_CVTLIM	14
-#define RK818_IRQ_DISCHG_ILIM	15
-
-#define RK818_IRQ_VOUT_LO_MSK		BIT(0)
-#define RK818_IRQ_VB_LO_MSK		BIT(1)
-#define RK818_IRQ_PWRON_MSK		BIT(2)
-#define RK818_IRQ_PWRON_LP_MSK		BIT(3)
-#define RK818_IRQ_HOTDIE_MSK		BIT(4)
-#define RK818_IRQ_RTC_ALARM_MSK		BIT(5)
-#define RK818_IRQ_RTC_PERIOD_MSK	BIT(6)
-#define RK818_IRQ_USB_OV_MSK		BIT(7)
-#define RK818_IRQ_PLUG_IN_MSK		BIT(0)
-#define RK818_IRQ_PLUG_OUT_MSK		BIT(1)
-#define RK818_IRQ_CHG_OK_MSK		BIT(2)
-#define RK818_IRQ_CHG_TE_MSK		BIT(3)
-#define RK818_IRQ_CHG_TS1_MSK		BIT(4)
-#define RK818_IRQ_TS2_MSK		BIT(5)
-#define RK818_IRQ_CHG_CVTLIM_MSK	BIT(6)
-#define RK818_IRQ_DISCHG_ILIM_MSK	BIT(7)
-
-#define RK818_NUM_IRQ		16
-
 #define RK808_VBAT_LOW_2V8	0x00
 #define RK808_VBAT_LOW_2V9	0x01
 #define RK808_VBAT_LOW_3V0	0x02
@@ -290,12 +339,619 @@ enum rk818_reg {
 #define SWITCH2_EN	BIT(6)
 #define SWITCH1_EN	BIT(5)
 #define DEV_OFF_RST	BIT(3)
+#define DEV_OFF		BIT(0)
+#define RTC_STOP	BIT(0)
 
 #define VB_LO_ACT		BIT(4)
 #define VB_LO_SEL_3500MV	(7 << 0)
 
 #define VOUT_LO_INT	BIT(0)
 #define CLK32KOUT2_EN	BIT(0)
+#define CLK32KOUT2_FUNC		(0 << 1)
+#define CLK32KOUT2_FUNC_MASK	BIT(1)
+#define H5V_EN_MASK		BIT(0)
+#define H5V_EN_ENABLE		BIT(0)
+#define REF_RDY_CTRL_MASK	BIT(1)
+#define REF_RDY_CTRL_ENABLE	BIT(1)
+
+/*RK818_DCDC_EN_REG*/
+#define BUCK1_EN_MASK		BIT(0)
+#define BUCK2_EN_MASK		BIT(1)
+#define BUCK3_EN_MASK		BIT(2)
+#define BUCK4_EN_MASK		BIT(3)
+#define BOOST_EN_MASK		BIT(4)
+#define LDO9_EN_MASK		BIT(5)
+#define SWITCH_EN_MASK		BIT(6)
+#define OTG_EN_MASK		BIT(7)
+
+#define BUCK1_EN_ENABLE		BIT(0)
+#define BUCK2_EN_ENABLE		BIT(1)
+#define BUCK3_EN_ENABLE		BIT(2)
+#define BUCK4_EN_ENABLE		BIT(3)
+#define BOOST_EN_ENABLE		BIT(4)
+#define LDO9_EN_ENABLE		BIT(5)
+#define SWITCH_EN_ENABLE	BIT(6)
+#define OTG_EN_ENABLE		BIT(7)
+
+/* IRQ Definitions */
+#define RK818_IRQ_VOUT_LO	0
+#define RK818_IRQ_VB_LO		1
+#define RK818_IRQ_PWRON		2
+#define RK818_IRQ_PWRON_LP	3
+#define RK818_IRQ_HOTDIE	4
+#define RK818_IRQ_RTC_ALARM	5
+#define RK818_IRQ_RTC_PERIOD	6
+#define RK818_IRQ_USB_OV	7
+#define RK818_IRQ_PLUG_IN	8
+#define RK818_IRQ_PLUG_OUT	9
+#define RK818_IRQ_CHG_OK	10
+#define RK818_IRQ_CHG_TE	11
+#define RK818_IRQ_CHG_TS1	12
+#define RK818_IRQ_TS2		13
+#define RK818_IRQ_CHG_CVTLIM	14
+#define RK818_IRQ_DISCHG_ILIM	15
+
+#define BUCK1_SLP_SET_MASK	BIT(0)
+#define BUCK2_SLP_SET_MASK	BIT(1)
+#define BUCK3_SLP_SET_MASK	BIT(2)
+#define BUCK4_SLP_SET_MASK	BIT(3)
+#define BOOST_SLP_SET_MASK	BIT(4)
+#define LDO9_SLP_SET_MASK	BIT(5)
+#define SWITCH_SLP_SET_MASK	BIT(6)
+#define OTG_SLP_SET_MASK	BIT(7)
+
+#define BUCK1_SLP_SET_OFF	BIT(0)
+#define BUCK2_SLP_SET_OFF	BIT(1)
+#define BUCK3_SLP_SET_OFF	BIT(2)
+#define BUCK4_SLP_SET_OFF	BIT(3)
+#define BOOST_SLP_SET_OFF	BIT(4)
+#define LDO9_SLP_SET_OFF	BIT(5)
+#define SWITCH_SLP_SET_OFF	BIT(6)
+#define OTG_SLP_SET_OFF		BIT(7)
+#define OTG_BOOST_SLP_OFF	(BOOST_SLP_SET_OFF | OTG_SLP_SET_OFF)
+
+#define BUCK1_SLP_SET_ON	BIT(0)
+#define BUCK2_SLP_SET_ON	BIT(1)
+#define BUCK3_SLP_SET_ON	BIT(2)
+#define BUCK4_SLP_SET_ON	BIT(3)
+#define BOOST_SLP_SET_ON	BIT(4)
+#define LDO9_SLP_SET_ON		BIT(5)
+#define SWITCH_SLP_SET_ON	BIT(6)
+#define OTG_SLP_SET_ON		BIT(7)
+
+#define VOUT_LO_MASK		BIT(0)
+#define VB_LO_MASK		BIT(1)
+#define PWRON_MASK		BIT(2)
+#define PWRON_LP_MASK		BIT(3)
+#define HOTDIE_MASK		BIT(4)
+#define RTC_ALARM_MASK		BIT(5)
+#define RTC_PERIOD_MASK		BIT(6)
+#define USB_OV_MASK		BIT(7)
+
+#define VOUT_LO_DISABLE		BIT(0)
+#define VB_LO_DISABLE		BIT(1)
+#define PWRON_DISABLE		BIT(2)
+#define PWRON_LP_DISABLE	BIT(3)
+#define HOTDIE_DISABLE		BIT(4)
+#define RTC_ALARM_DISABLE	BIT(5)
+#define RTC_PERIOD_DISABLE	BIT(6)
+#define USB_OV_INT_DISABLE	BIT(7)
+
+#define VOUT_LO_ENABLE		(0 << 0)
+#define VB_LO_ENABLE		(0 << 1)
+#define PWRON_ENABLE		(0 << 2)
+#define PWRON_LP_ENABLE		(0 << 3)
+#define HOTDIE_ENABLE		(0 << 4)
+#define RTC_ALARM_ENABLE	(0 << 5)
+#define RTC_PERIOD_ENABLE	(0 << 6)
+#define USB_OV_INT_ENABLE	(0 << 7)
+
+#define PLUG_IN_MASK		BIT(0)
+#define PLUG_OUT_MASK		BIT(1)
+#define CHGOK_MASK		BIT(2)
+#define CHGTE_MASK		BIT(3)
+#define CHGTS1_MASK		BIT(4)
+#define TS2_MASK		BIT(5)
+#define CHG_CVTLIM_MASK		BIT(6)
+#define DISCHG_ILIM_MASK	BIT(7)
+
+#define PLUG_IN_DISABLE		BIT(0)
+#define PLUG_OUT_DISABLE	BIT(1)
+#define CHGOK_DISABLE		BIT(2)
+#define CHGTE_DISABLE		BIT(3)
+#define CHGTS1_DISABLE		BIT(4)
+#define TS2_DISABLE		BIT(5)
+#define CHG_CVTLIM_DISABLE	BIT(6)
+#define DISCHG_ILIM_DISABLE	BIT(7)
+
+#define PLUG_IN_ENABLE		BIT(0)
+#define PLUG_OUT_ENABLE		BIT(1)
+#define CHGOK_ENABLE		BIT(2)
+#define CHGTE_ENABLE		BIT(3)
+#define CHGTS1_ENABLE		BIT(4)
+#define TS2_ENABLE		BIT(5)
+#define CHG_CVTLIM_ENABLE	BIT(6)
+#define DISCHG_ILIM_ENABLE	BIT(7)
+
+/* IRQ Definitions */
+#define RK805_IRQ_VB_LOW		1
+#define RK805_IRQ_PWRON			2
+#define RK805_IRQ_PWRON_LP		3
+#define RK805_IRQ_HOTDIE		4
+#define RK805_IRQ_RTC_ALARM		5
+#define RK805_IRQ_RTC_PERIOD		6
+
+/*
+ * When PMIC irq occurs, regmap-irq.c will traverse all PMIC child
+ * interrupts from low index 0 to high index, we give fall interrupt
+ * high priority to be called earlier than rise, so that it can be
+ * override by late rise event. This can helps to solve key release
+ * glitch which make a wrongly fall event immediately after rise.
+ */
+#define RK805_IRQ_PWRON_FALL		0
+#define RK805_IRQ_PWRON_RISE		7
+
+#define RK805_IRQ_PWRON_RISE_MSK	BIT(0)
+#define RK805_IRQ_VB_LOW_MSK		BIT(1)
+#define RK805_IRQ_PWRON_MSK		BIT(2)
+#define RK805_IRQ_PWRON_LP_MSK		BIT(3)
+#define RK805_IRQ_HOTDIE_MSK		BIT(4)
+#define RK805_IRQ_RTC_ALARM_MSK		BIT(5)
+#define RK805_IRQ_RTC_PERIOD_MSK	BIT(6)
+#define RK805_IRQ_PWRON_FALL_MSK	BIT(7)
+
+#define RK805_PWR_RISE_INT_STATUS	BIT(0)
+#define RK805_VB_LOW_INT_STATUS		BIT(1)
+#define RK805_PWRON_INT_STATUS		BIT(2)
+#define RK805_PWRON_LP_INT_STATUS	BIT(3)
+#define RK805_HOTDIE_INT_STATUS		BIT(4)
+#define RK805_ALARM_INT_STATUS		BIT(5)
+#define RK805_PERIOD_INT_STATUS		BIT(6)
+#define RK805_PWR_FALL_INT_STATUS	BIT(7)
+
+/*INTERRUPT REGISTER*/
+#define RK805_INT_STS_REG		0x4C
+#define RK805_INT_STS_MSK_REG		0x4D
+#define RK805_GPIO_IO_POL_REG		0x50
+#define RK805_OUT_REG			0x52
+#define RK805_ON_SOURCE_REG		0xAE
+#define RK805_OFF_SOURCE_REG		0xAF
+
+/*POWER CHANNELS ENABLE REGISTER*/
+#define RK805_DCDC_EN_REG		0x23
+#define RK805_SLP_DCDC_EN_REG		0x25
+#define RK805_SLP_LDO_EN_REG		0x26
+#define RK805_LDO_EN_REG		0x27
+
+/*CONFIG REGISTER*/
+#define RK805_THERMAL_REG		0x22
+
+/*BUCK AND LDO CONFIG REGISTER*/
+#define RK805_BUCK_LDO_SLP_LP_EN_REG	0x2A
+#define RK805_BUCK1_CONFIG_REG		0x2E
+#define RK805_BUCK1_ON_VSEL_REG		0x2F
+#define RK805_BUCK1_SLP_VSEL_REG	0x30
+#define RK805_BUCK2_CONFIG_REG		0x32
+#define RK805_BUCK2_ON_VSEL_REG		0x33
+#define RK805_BUCK2_SLP_VSEL_REG	0x34
+#define RK805_BUCK3_CONFIG_REG		0x36
+#define RK805_BUCK4_CONFIG_REG		0x37
+#define RK805_BUCK4_ON_VSEL_REG		0x38
+#define RK805_BUCK4_SLP_VSEL_REG	0x39
+#define RK805_LDO1_ON_VSEL_REG		0x3B
+#define RK805_LDO1_SLP_VSEL_REG		0x3C
+#define RK805_LDO2_ON_VSEL_REG		0x3D
+#define RK805_LDO2_SLP_VSEL_REG		0x3E
+#define RK805_LDO3_ON_VSEL_REG		0x3F
+#define RK805_LDO3_SLP_VSEL_REG		0x40
+#define RK805_OUT_REG			0x52
+#define RK805_ON_SOURCE_REG		0xAE
+#define RK805_OFF_SOURCE_REG		0xAF
+#define RK805_DCDC_VRP_REG		0x92
+
+#define RK805_NUM_REGULATORS		7
+
+#define RK805_PWRON_FALL_RISE_INT_EN	0x0
+#define RK805_PWRON_FALL_RISE_INT_MSK	0x81
+
+/*VERSION REGISTER*/
+#define RK816_CHIP_NAME_REG			0x17
+#define RK816_CHIP_VER_REG			0x18
+#define RK816_OTP_VER_REG			0x19
+#define RK816_NUM_REGULATORS			10
+
+/*POWER ON/OFF REGISTER*/
+#define RK816_VB_MON_REG			0x21
+#define RK816_THERMAL_REG			0x22
+#define RK816_PWRON_LP_INT_TIME_REG		0x47
+#define RK816_PWRON_DB_REG			0x48
+#define RK816_DEV_CTRL_REG			0x4B
+#define RK816_ON_SOURCE_REG			0xAE
+#define RK816_OFF_SOURCE_REG			0xAF
+
+/*POWER CHANNELS ENABLE REGISTER*/
+#define RK816_DCDC_EN_REG1			0x23
+#define RK816_DCDC_EN_REG2			0x24
+#define RK816_SLP_DCDC_EN_REG			0x25
+#define RK816_SLP_LDO_EN_REG			0x26
+#define RK816_LDO_EN_REG1			0x27
+#define RK816_LDO_EN_REG2			0x28
+
+/*BUCK AND LDO CONFIG REGISTER*/
+#define RK816_BUCK1_CONFIG_REG			0x2E
+#define RK816_BUCK1_ON_VSEL_REG			0x2F
+#define RK816_BUCK1_SLP_VSEL_REG		0x30
+#define RK816_BUCK2_CONFIG_REG			0x32
+#define RK816_BUCK2_ON_VSEL_REG			0x33
+#define RK816_BUCK2_SLP_VSEL_REG		0x34
+#define RK816_BUCK3_CONFIG_REG			0x36
+#define RK816_BUCK4_CONFIG_REG			0x37
+#define RK816_BUCK4_ON_VSEL_REG			0x38
+#define RK816_BUCK4_SLP_VSEL_REG		0x39
+#define RK816_LDO1_ON_VSEL_REG			0x3B
+#define RK816_LDO1_SLP_VSEL_REG			0x3C
+#define RK816_LDO2_ON_VSEL_REG			0x3D
+#define RK816_LDO2_SLP_VSEL_REG			0x3E
+#define RK816_LDO3_ON_VSEL_REG			0x3F
+#define RK816_LDO3_SLP_VSEL_REG			0x40
+#define RK816_LDO4_ON_VSEL_REG			0x41
+#define RK816_LDO4_SLP_VSEL_REG			0x42
+#define RK816_LDO5_ON_VSEL_REG			0x43
+#define RK816_LDO5_SLP_VSEL_REG			0x44
+#define RK816_LDO6_ON_VSEL_REG			0x45
+#define RK816_LDO6_SLP_VSEL_REG			0x46
+
+/*CHARGER BOOST AND OTG REGISTER*/
+#define RK816_OTG_BUCK_LDO_CONFIG_REG           0x2A
+#define RK816_CHRG_CONFIG_REG                   0x2B
+#define RK816_BOOST_ON_VESL_REG                 0x54
+#define RK816_BOOST_SLP_VSEL_REG                0x55
+#define RK816_CHRG_BOOST_CONFIG_REG             0x9A
+#define RK816_SUP_STS_REG                       0xA0
+#define RK816_USB_CTRL_REG                      0xA1
+#define RK816_CHRG_CTRL_REG1                    0xA3
+#define RK816_CHRG_CTRL_REG2                    0xA4
+#define RK816_CHRG_CTRL_REG3                    0xA5
+#define RK816_BAT_CTRL_REG                      0xA6
+#define RK816_BAT_HTS_TS_REG                    0xA8
+#define RK816_BAT_LTS_TS_REG                    0xA9
+
+#define RK816_TS_CTRL_REG			0xAC
+#define RK816_ADC_CTRL_REG			0xAD
+#define RK816_GGCON_REG				0xB0
+#define RK816_GGSTS_REG				0xB1
+#define RK816_ZERO_CUR_ADC_REGH			0xB2
+#define RK816_ZERO_CUR_ADC_REGL			0xB3
+#define RK816_GASCNT_CAL_REG3			0xB4
+#define RK816_GASCNT_CAL_REG2			0xB5
+#define RK816_GASCNT_CAL_REG1			0xB6
+#define RK816_GASCNT_CAL_REG0			0xB7
+#define RK816_GASCNT_REG3			0xB8
+#define RK816_GASCNT_REG2			0xB9
+#define RK816_GASCNT_REG1			0xBA
+#define RK816_GASCNT_REG0			0xBB
+#define RK816_BAT_CUR_AVG_REGH			0xBC
+#define RK816_BAT_CUR_AVG_REGL			0xBD
+#define RK816_TS_ADC_REGH			0xBE
+#define RK816_TS_ADC_REGL			0xBF
+#define RK816_USB_ADC_REGH			0xC0
+#define RK816_USB_ADC_REGL			0xC1
+#define RK816_BAT_OCV_REGH			0xC2
+#define RK816_BAT_OCV_REGL			0xC3
+#define RK816_BAT_VOL_REGH			0xC4
+#define RK816_BAT_VOL_REGL			0xC5
+#define RK816_RELAX_ENTRY_THRES_REGH		0xC6
+#define RK816_RELAX_ENTRY_THRES_REGL		0xC7
+#define RK816_RELAX_EXIT_THRES_REGH		0xC8
+#define RK816_RELAX_EXIT_THRES_REGL		0xC9
+#define RK816_RELAX_VOL1_REGH			0xCA
+#define RK816_RELAX_VOL1_REGL			0xCB
+#define RK816_RELAX_VOL2_REGH			0xCC
+#define RK816_RELAX_VOL2_REGL			0xCD
+#define RK816_RELAX_CUR1_REGH			0xCE
+#define RK816_RELAX_CUR1_REGL			0xCF
+#define RK816_RELAX_CUR2_REGH			0xD0
+#define RK816_RELAX_CUR2_REGL			0xD1
+#define RK816_CAL_OFFSET_REGH			0xD2
+#define RK816_CAL_OFFSET_REGL			0xD3
+#define RK816_NON_ACT_TIMER_CNT_REG		0xD4
+#define RK816_VCALIB0_REGH			0xD5
+#define RK816_VCALIB0_REGL			0xD6
+#define RK816_VCALIB1_REGH			0xD7
+#define RK816_VCALIB1_REGL			0xD8
+#define RK816_FCC_GASCNT_REG3			0xD9
+#define RK816_FCC_GASCNT_REG2			0xDA
+#define RK816_FCC_GASCNT_REG1			0xDB
+#define RK816_FCC_GASCNT_REG0			0xDC
+#define RK816_IOFFSET_REGH			0xDD
+#define RK816_IOFFSET_REGL			0xDE
+#define RK816_SLEEP_CON_SAMP_CUR_REG		0xDF
+
+/*DATA REGISTER*/
+#define RK816_SOC_REG				0xE0
+#define	RK816_REMAIN_CAP_REG3			0xE1
+#define	RK816_REMAIN_CAP_REG2			0xE2
+#define	RK816_REMAIN_CAP_REG1			0xE3
+#define	RK816_REMAIN_CAP_REG0			0xE4
+#define	RK816_UPDATE_LEVE_REG			0xE5
+#define	RK816_NEW_FCC_REG3			0xE6
+#define	RK816_NEW_FCC_REG2			0xE7
+#define	RK816_NEW_FCC_REG1			0xE8
+#define	RK816_NEW_FCC_REG0			0xE9
+#define RK816_NON_ACT_TIMER_CNT_REG_SAVE	0xEA
+#define RK816_OCV_VOL_VALID_REG			0xEB
+#define RK816_REBOOT_CNT_REG			0xEC
+#define RK816_PCB_IOFFSET_REG			0xED
+#define RK816_MISC_MARK_REG			0xEE
+#define RK816_HALT_CNT_REG			0xEF
+#define RK816_CALC_REST_REGH			0xF0
+#define RK816_CALC_REST_REGL			0xF1
+#define DATA18_REG				0xF2
+
+/*INTERRUPT REGISTER*/
+#define RK816_INT_STS_REG1			0x49
+#define RK816_INT_STS_MSK_REG1			0x4A
+#define RK816_INT_STS_REG2			0x4C
+#define RK816_INT_STS_MSK_REG2			0x4D
+#define RK816_INT_STS_REG3			0x4E
+#define RK816_INT_STS_MSK_REG3			0x4F
+#define RK816_GPIO_IO_POL_REG			0x50
+
+#define RK816_DATA18_REG			0xF2
+
+/* IRQ Definitions */
+#define RK816_IRQ_PWRON_FALL			0
+#define RK816_IRQ_PWRON_RISE			1
+#define RK816_IRQ_VB_LOW			2
+#define RK816_IRQ_PWRON				3
+#define RK816_IRQ_PWRON_LP			4
+#define RK816_IRQ_HOTDIE			5
+#define RK816_IRQ_RTC_ALARM			6
+#define RK816_IRQ_RTC_PERIOD			7
+#define RK816_IRQ_USB_OV			8
+#define RK816_IRQ_PLUG_IN			9
+#define RK816_IRQ_PLUG_OUT			10
+#define RK816_IRQ_CHG_OK			11
+#define RK816_IRQ_CHG_TE			12
+#define RK816_IRQ_CHG_TS			13
+#define RK816_IRQ_CHG_CVTLIM			14
+#define RK816_IRQ_DISCHG_ILIM			15
+
+#define RK816_IRQ_PWRON_FALL_MSK		BIT(5)
+#define RK816_IRQ_PWRON_RISE_MSK		BIT(6)
+#define RK816_IRQ_VB_LOW_MSK			BIT(1)
+#define RK816_IRQ_PWRON_MSK			BIT(2)
+#define RK816_IRQ_PWRON_LP_MSK			BIT(3)
+#define RK816_IRQ_HOTDIE_MSK			BIT(4)
+#define RK816_IRQ_RTC_ALARM_MSK			BIT(5)
+#define RK816_IRQ_RTC_PERIOD_MSK		BIT(6)
+#define RK816_IRQ_USB_OV_MSK			BIT(7)
+#define RK816_IRQ_PLUG_IN_MSK			BIT(0)
+#define RK816_IRQ_PLUG_OUT_MSK			BIT(1)
+#define RK816_IRQ_CHG_OK_MSK			BIT(2)
+#define RK816_IRQ_CHG_TE_MSK			BIT(3)
+#define RK816_IRQ_CHG_TS_MSK			BIT(4)
+#define RK816_IRQ_CHG_CVTLIM_MSK		BIT(6)
+#define RK816_IRQ_DISCHG_ILIM_MSK		BIT(7)
+
+#define RK816_VBAT_LOW_2V8			0x00
+#define RK816_VBAT_LOW_2V9			0x01
+#define RK816_VBAT_LOW_3V0			0x02
+#define RK816_VBAT_LOW_3V1			0x03
+#define RK816_VBAT_LOW_3V2			0x04
+#define RK816_VBAT_LOW_3V3			0x05
+#define RK816_VBAT_LOW_3V4			0x06
+#define RK816_VBAT_LOW_3V5			0x07
+#define RK816_PWR_FALL_INT_STATUS		(0x1 << 5)
+#define RK816_PWR_RISE_INT_STATUS		(0x1 << 6)
+#define RK816_ALARM_INT_STATUS			(0x1 << 5)
+#define EN_VBAT_LOW_IRQ				(0x1 << 4)
+#define VBAT_LOW_ACT_MASK			(0x1 << 4)
+#define RTC_TIMER_ALARM_INT_MSK			(0x3 << 2)
+#define RTC_TIMER_ALARM_INT_DIS			(0x0 << 2)
+#define RTC_PERIOD_ALARM_INT_MSK		(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_ST			(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_DIS		(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_EN			(0x9f)
+#define REG_WRITE_MSK				0xff
+#define BUCK4_MAX_ILIMIT			0x2c
+#define BUCK_RATE_MSK				(0x3 << 3)
+#define BUCK_RATE_12_5MV_US			(0x2 << 3)
+#define ALL_INT_FLAGS_ST			0xff
+#define PLUGIN_OUT_INT_EN			0xfc
+#define RK816_PWRON_FALL_RISE_INT_EN		0x9f
+#define BUCK1_2_IMAX_MAX			(0x3 << 6)
+#define BUCK3_4_IMAX_MAX			(0x3 << 3)
+#define BOOST_DISABLE				((0x1 << 5) | (0x0 << 1))
+#define BUCK4_VRP_3PERCENT			0xc0
+#define RK816_BUCK_DVS_CONFIRM			(0x1 << 7)
+#define RK816_TYPE_ES2				0x05
+#define RK816_CHIP_VERSION_MASK			0x0f
+
+#define TEMP105C			0x08
+#define TEMP115C			0x0c
+#define TEMP_HOTDIE_MSK			0x0c
+#define SLP_SD_MSK			(0x3 << 2)
+#define SHUTDOWN_FUN			(0x2 << 2)
+#define SLEEP_FUN			(0x1 << 2)
+#define RK8XX_ID_MSK			0xfff0
+#define PWM_MODE_MSK			BIT(7)
+#define FPWM_MODE			BIT(7)
+#define AUTO_PWM_MODE			0
+#define REGS_WMSK			0xf0
+
+enum rk817_reg_id {
+	RK817_ID_DCDC1 = 0,
+	RK817_ID_DCDC2,
+	RK817_ID_DCDC3,
+	RK817_ID_DCDC4,
+	RK817_ID_LDO1,
+	RK817_ID_LDO2,
+	RK817_ID_LDO3,
+	RK817_ID_LDO4,
+	RK817_ID_LDO5,
+	RK817_ID_LDO6,
+	RK817_ID_LDO7,
+	RK817_ID_LDO8,
+	RK817_ID_LDO9,
+	RK817_ID_BOOST,
+	RK817_ID_BOOST_OTG_SW,
+	RK817_NUM_REGULATORS
+};
+
+enum rk809_reg_id {
+	RK809_ID_DCDC5 = RK817_ID_BOOST,
+	RK809_ID_SW1,
+	RK809_ID_SW2,
+	RK809_NUM_REGULATORS
+};
+
+#define RK817_SECONDS_REG		0x00
+#define RK817_MINUTES_REG		0x01
+#define RK817_HOURS_REG			0x02
+#define RK817_DAYS_REG			0x03
+#define RK817_MONTHS_REG		0x04
+#define RK817_YEARS_REG			0x05
+#define RK817_WEEKS_REG			0x06
+#define RK817_ALARM_SECONDS_REG		0x07
+#define RK817_ALARM_MINUTES_REG		0x08
+#define RK817_ALARM_HOURS_REG		0x09
+#define RK817_ALARM_DAYS_REG		0x0a
+#define RK817_ALARM_MONTHS_REG		0x0b
+#define RK817_ALARM_YEARS_REG		0x0c
+#define RK817_RTC_CTRL_REG		0xd
+#define RK817_RTC_STATUS_REG		0xe
+#define RK817_RTC_INT_REG		0xf
+#define RK817_RTC_COMP_LSB_REG		0x10
+#define RK817_RTC_COMP_MSB_REG		0x11
+
+#define RK817_POWER_EN_SAVE0		0x99
+#define RK817_POWER_EN_SAVE1		0xa4
+
+#define RK817_POWER_EN_REG(i)		(0xb1 + (i))
+#define RK817_POWER_SLP_EN_REG(i)	(0xb5 + (i))
+
+#define RK817_POWER_CONFIG		(0xb9)
+
+#define RK817_BUCK_CONFIG_REG(i)	(0xba + (i) * 3)
+
+#define RK817_BUCK1_ON_VSEL_REG		0xBB
+#define RK817_BUCK1_SLP_VSEL_REG	0xBC
+
+#define RK817_BUCK2_CONFIG_REG		0xBD
+#define RK817_BUCK2_ON_VSEL_REG		0xBE
+#define RK817_BUCK2_SLP_VSEL_REG	0xBF
+
+#define RK817_BUCK3_CONFIG_REG		0xC0
+#define RK817_BUCK3_ON_VSEL_REG		0xC1
+#define RK817_BUCK3_SLP_VSEL_REG	0xC2
+
+#define RK817_BUCK4_CONFIG_REG		0xC3
+#define RK817_BUCK4_ON_VSEL_REG		0xC4
+#define RK817_BUCK4_SLP_VSEL_REG	0xC5
+
+#define RK817_LDO_ON_VSEL_REG(idx)	(0xcc + (idx) * 2)
+#define RK817_BOOST_OTG_CFG		(0xde)
+
+#define RK817_ID_MSB			0xed
+#define RK817_ID_LSB			0xee
+
+#define RK817_SYS_STS			0xf0
+#define RK817_SYS_CFG(i)		(0xf1 + (i))
+
+#define RK817_ON_SOURCE_REG		0xf5
+#define RK817_OFF_SOURCE_REG		0xf6
+
+/* INTERRUPT REGISTER */
+#define RK817_INT_STS_REG0		0xf8
+#define RK817_INT_STS_MSK_REG0		0xf9
+#define RK817_INT_STS_REG1		0xfa
+#define RK817_INT_STS_MSK_REG1		0xfb
+#define RK817_INT_STS_REG2		0xfc
+#define RK817_INT_STS_MSK_REG2		0xfd
+#define RK817_GPIO_INT_CFG		0xfe
+
+/* IRQ Definitions */
+#define RK817_IRQ_PWRON_FALL		0
+#define RK817_IRQ_PWRON_RISE		1
+#define RK817_IRQ_PWRON			2
+#define RK817_IRQ_PWMON_LP		3
+#define RK817_IRQ_HOTDIE		4
+#define RK817_IRQ_RTC_ALARM		5
+#define RK817_IRQ_RTC_PERIOD		6
+#define RK817_IRQ_VB_LO			7
+#define RK817_IRQ_PLUG_IN		(8 + 0)
+#define RK817_IRQ_PLUG_OUT		(8 + 1)
+#define RK817_IRQ_CHRG_TERM		(8 + 2)
+#define RK817_IRQ_CHRG_TIME		(8 + 3)
+#define RK817_IRQ_CHRG_TS		(8 + 4)
+#define RK817_IRQ_USB_OV		(8 + 5)
+#define RK817_IRQ_CHRG_IN_CLMP		(8 + 6)
+#define RK817_IRQ_BAT_DIS_ILIM		(8 + 7)
+#define RK817_IRQ_GATE_GPIO		(16 + 0)
+#define RK817_IRQ_TS_GPIO		(16 + 1)
+#define RK817_IRQ_CODEC_PD		(16 + 2)
+#define RK817_IRQ_CODEC_PO		(16 + 3)
+#define RK817_IRQ_CLASSD_MUTE_DONE	(16 + 4)
+#define RK817_IRQ_CLASSD_OCP		(16 + 5)
+#define RK817_IRQ_BAT_OVP		(16 + 6)
+#define RK817_IRQ_CHRG_BAT_HI		(16 + 7)
+#define RK817_IRQ_END			(RK817_IRQ_CHRG_BAT_HI + 1)
+
+/*
+ * rtc_ctrl 0xd
+ * same as 808, except bit4
+ */
+#define RK817_RTC_CTRL_RSV4		BIT(4)
+
+/* power config 0xb9 */
+#define RK817_BUCK3_FB_RES_MSK		BIT(6)
+#define RK817_BUCK3_FB_RES_INTER	BIT(6)
+#define RK817_BUCK3_FB_RES_EXT		0
+
+/* buck config 0xba */
+#define RK817_RAMP_RATE_OFFSET		6
+#define RK817_RAMP_RATE_MASK		(0x3 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_3MV_PER_US	(0x0 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_6_3MV_PER_US	(0x1 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_12_5MV_PER_US	(0x2 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_25MV_PER_US	(0x3 << RK817_RAMP_RATE_OFFSET)
+
+/* sys_cfg1 0xf2 */
+#define RK817_HOTDIE_TEMP_MSK		(0x3 << 4)
+#define RK817_HOTDIE_85			(0x0 << 4)
+#define RK817_HOTDIE_95			(0x1 << 4)
+#define RK817_HOTDIE_105		(0x2 << 4)
+#define RK817_HOTDIE_115		(0x3 << 4)
+
+#define RK817_TSD_TEMP_MSK		BIT(6)
+#define RK817_TSD_140			0
+#define RK817_TSD_160			BIT(6)
+
+#define RK817_CLK32KOUT2_EN		BIT(7)
+
+/* sys_cfg3 0xf4 */
+#define RK817_SLPPIN_FUNC_MSK		(0x3 << 3)
+#define SLPPIN_NULL_FUN			(0x0 << 3)
+#define SLPPIN_SLP_FUN			(0x1 << 3)
+#define SLPPIN_DN_FUN			(0x2 << 3)
+#define SLPPIN_RST_FUN			(0x3 << 3)
+
+#define RK817_RST_FUNC_MSK		(0x3 << 6)
+#define RK817_RST_FUNC_SFT		(6)
+#define RK817_RST_FUNC_CNT		(3)
+#define RK817_RST_FUNC_DEV		(0) /* reset the dev */
+#define RK817_RST_FUNC_REG		(0x1 << 6) /* reset the reg only */
+
+#define RK817_SLPPOL_MSK		BIT(5)
+#define RK817_SLPPOL_H			BIT(5)
+#define RK817_SLPPOL_L			(0)
+
+/* gpio&int 0xfe */
+#define RK817_INT_POL_MSK		BIT(1)
+#define RK817_INT_POL_H			BIT(1)
+#define RK817_INT_POL_L			0
+#define RK809_BUCK5_CONFIG(i)		(RK817_BOOST_OTG_CFG + (i) * 1)
 
 enum {
 	BUCK_ILMIN_50MA,
@@ -319,17 +975,29 @@ enum {
 	BOOST_ILMIN_250MA,
 };
 
-enum {
-	RK808_ID = 0x0000,
-	RK818_ID = 0x8181,
+struct rk808_pin_info {
+	struct pinctrl *p;
+	struct pinctrl_state *reset;
+	struct pinctrl_state *power_off;
+	struct pinctrl_state *sleep;
 };
 
 struct rk808 {
-	struct i2c_client		*i2c;
-	struct regmap_irq_chip_data	*irq_data;
-	struct regmap			*regmap;
-	long				variant;
-	const struct regmap_config	*regmap_cfg;
-	const struct regmap_irq_chip	*regmap_irq_chip;
+	struct i2c_client *i2c;
+	struct regmap_irq_chip_data *irq_data;
+	struct regmap_irq_chip_data *battery_irq_data;
+	struct regmap *regmap;
+	long variant;
+	struct rk808_pin_info *pins;
 };
-#endif /* __LINUX_REGULATOR_RK808_H */
+
+enum {
+	RK805_ID = 0x8050,
+	RK808_ID = 0x0000,
+	RK809_ID = 0x8090,
+	RK816_ID = 0x8160,
+	RK817_ID = 0x8170,
+	RK818_ID = 0x8180,
+};
+
+#endif /* __LINUX_REGULATOR_rk808_H */
diff --git a/include/linux/platform_data/emuelec.h b/include/linux/platform_data/emuelec.h
new file mode 100644
index 000000000000..c1a7edfae293
--- /dev/null
+++ b/include/linux/platform_data/emuelec.h
@@ -0,0 +1,19 @@
+#ifndef __EMUELEC_BOARD_H
+#define __EMUELEC_BOARD_H
+
+// #include <linux/types.h>
+
+// #define EMUELEC_BOARD_GENERIC   0x00000000U
+// #define EMUELEC_BOARD_OGU       0x00000001U
+
+extern bool emuelec_is_ogu;
+
+// extern u32 emuelec_board_model;
+
+// bool __emuelec_board_is(u32 board);
+
+// #define emuelec_board_is_generic()  __emuelec_board_is(EMUELEC_BOARD_GENERIC)
+// #define emuelec_board_is_ogu()  __emuelec_board_is(EMUELEC_BOARD_OGU)
+
+
+#endif
\ No newline at end of file
diff --git a/include/linux/power/rk_usbbc.h b/include/linux/power/rk_usbbc.h
new file mode 100755
index 000000000000..45f7128b3a69
--- /dev/null
+++ b/include/linux/power/rk_usbbc.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK_USBBC_H
+#define __RK_USBBC_H
+
+/* USB Charger Types */
+enum bc_port_type{
+	USB_BC_TYPE_DISCNT = 0,
+	USB_BC_TYPE_SDP,
+	USB_BC_TYPE_DCP,
+	USB_BC_TYPE_CDP,
+	USB_BC_TYPE_UNKNOW,
+	USB_OTG_POWER_ON,
+	USB_OTG_POWER_OFF,
+	USB_BC_TYPE_MAX,
+};
+
+/***********************************
+ * USB Port Type
+ * 0 : Disconnect
+ * 1 : SDP - pc
+ * 2 : DCP - charger
+ * 3 : CDP - pc with big currect charge
+ ************************************/
+#ifdef CONFIG_DWC_OTG_310
+extern int dwc_otg_check_dpdm(bool wait);
+extern int rk_bc_detect_notifier_register(struct notifier_block *nb,
+					  enum bc_port_type *type);
+extern int rk_bc_detect_notifier_unregister(struct notifier_block *nb);
+#else
+static inline int dwc_otg_check_dpdm(bool wait) { return USB_BC_TYPE_DISCNT; }
+
+static inline int rk_bc_detect_notifier_register(struct notifier_block *nb,
+						 enum bc_port_type *type)
+{
+	return -EINVAL;
+}
+
+static inline int rk_bc_detect_notifier_unregister(struct notifier_block *nb)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/include/linux/rk_keys.h b/include/linux/rk_keys.h
new file mode 100755
index 000000000000..b839fe281756
--- /dev/null
+++ b/include/linux/rk_keys.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _RK_KEYS_H
+#define _RK_KEYS_H
+
+#ifdef CONFIG_INPUT_RK8XX_PWRKEY
+void rk_send_power_key(int state);
+void rk_send_wakeup_key(void);
+#else
+static inline void rk_send_power_key(int state) { }
+static inline void rk_send_wakeup_key(void) { }
+#endif
+
+#endif
diff --git a/lib/radix-tree.c b/lib/radix-tree.c
index 8e6d552c40dd..0a84035c6f17 100644
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@ -45,6 +45,7 @@ static unsigned long height_to_maxnodes[RADIX_TREE_MAX_PATH + 1] __read_mostly;
  * Radix tree node cache.
  */
 static struct kmem_cache *radix_tree_node_cachep;
+EXPORT_SYMBOL_GPL(radix_tree_node_cachep);
 
 /*
  * The radix tree is variable-height, so an insert operation not only has
@@ -329,6 +330,7 @@ static void radix_tree_node_rcu_free(struct rcu_head *head)
 
 	kmem_cache_free(radix_tree_node_cachep, node);
 }
+EXPORT_SYMBOL_GPL(radix_tree_node_rcu_free);
 
 static inline void
 radix_tree_node_free(struct radix_tree_node *node)
diff --git a/mm/cma.c b/mm/cma.c
index 1a9416a07efa..6256de96b7ff 100644
--- a/mm/cma.c
+++ b/mm/cma.c
@@ -646,6 +646,7 @@ struct page *cma_alloc(struct cma *cma, size_t count, unsigned int align)
 	pr_debug("%s(): returned %p\n", __func__, page);
 	return page;
 }
+EXPORT_SYMBOL(cma_alloc);
 
 /**
  * cma_release() - release allocated pages
@@ -685,3 +686,4 @@ bool cma_release(struct cma *cma, const struct page *pages, unsigned int count)
 	return true;
 }
 
+EXPORT_SYMBOL(cma_release);
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 89a19097435d..8e13205a222f 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -104,6 +104,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_PCM5102A
 	select SND_SOC_PCM512x_I2C if I2C
 	select SND_SOC_PCM512x_SPI if SPI_MASTER
+	select SND_SOC_RK817 if I2C
 	select SND_SOC_RT286 if I2C
 	select SND_SOC_RT298 if I2C
 	select SND_SOC_RT5514 if I2C
@@ -645,6 +646,11 @@ config SND_SOC_PCM512x_SPI
 	select SND_SOC_PCM512x
 	select REGMAP_SPI
 
+config SND_SOC_RK817
+	tristate "Rockchip RK817 CODEC"
+	depends on MFD_RK808
+	select REGMAP_I2C
+    
 config SND_SOC_RL6231
 	tristate
 	default y if SND_SOC_RT5514=y
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 0f32a08b5d85..26d365880b24 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -102,6 +102,7 @@ snd-soc-pcm5102a-objs := pcm5102a.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
+snd-soc-rk817-objs := rk817_codec.o
 snd-soc-rl6231-objs := rl6231.o
 snd-soc-rl6347a-objs := rl6347a.o
 snd-soc-rt286-objs := rt286.o
@@ -327,6 +328,7 @@ obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
+obj-$(CONFIG_SND_SOC_RK817)	+= snd-soc-rk817.o
 obj-$(CONFIG_SND_SOC_RL6231)	+= snd-soc-rl6231.o
 obj-$(CONFIG_SND_SOC_RL6347A)	+= snd-soc-rl6347a.o
 obj-$(CONFIG_SND_SOC_RT286)	+= snd-soc-rt286.o
diff --git a/sound/soc/codecs/rk817_codec.c b/sound/soc/codecs/rk817_codec.c
new file mode 100755
index 000000000000..f2b11eb79b0b
--- /dev/null
+++ b/sound/soc/codecs/rk817_codec.c
@@ -0,0 +1,1291 @@
+/*
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <sound/core.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include "rk817_codec.h"
+
+static int dbg_enable;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+/* For route */
+#define RK817_CODEC_PLAYBACK	1
+#define RK817_CODEC_CAPTURE	2
+#define RK817_CODEC_INCALL	4
+#define RK817_CODEC_ALL	(RK817_CODEC_PLAYBACK |\
+	RK817_CODEC_CAPTURE | RK817_CODEC_INCALL)
+
+/*
+ * DDAC L/R volume setting
+ * 0db~-95db,0.375db/step,for example:
+ * 0: 0dB
+ * 0x0a: -3.75dB
+ * 0x7d: -46dB
+ * 0xff: -95dB
+ */
+#define OUT_VOLUME	(0x03)
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#define RK817_DAC_VOLUME \
+	SOC_DOUBLE_R("Playback Volume", RK817_CODEC_DDAC_VOLL, RK817_CODEC_DDAC_VOLR, 0, 0xff, 1)
+static const DECLARE_TLV_DB_MINMAX(rk817_vol_tlv, -9500, -675);
+#endif
+
+/*
+ * DADC L/R volume setting
+ * 0db~-95db,0.375db/step,for example:
+ * 0: 0dB
+ * 0x0a: -3.75dB
+ * 0x7d: -46dB
+ * 0xff: -95dB
+ */
+#define CAPTURE_VOLUME	(0x0)
+
+#define CODEC_SET_SPK 1
+#define CODEC_SET_HP 2
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#define RK817_ADC_VOLUME \
+	SOC_DOUBLE_R("Record Volume", RK817_CODEC_DADC_VOLL, RK817_CODEC_DADC_VOLR, 0, 0xFF, 1)
+#endif
+
+
+struct rk817_codec_priv {
+	struct snd_soc_codec *codec;
+	struct regmap *regmap;
+	struct rk808 *rk817;
+	struct clk *mclk;
+
+	unsigned int stereo_sysclk;
+	unsigned int rate;
+
+	unsigned int spk_volume;
+	unsigned int hp_volume;
+	unsigned int capture_volume;
+
+	bool mic_in_differential;
+	bool pdmdata_out_enable;
+	bool use_ext_amplifier;
+	bool adc_for_loopback;
+
+	long int playback_path;
+	long int capture_path;
+
+	struct gpio_desc *spk_ctl_gpio;
+	struct gpio_desc *hp_ctl_gpio;
+	int spk_mute_delay;
+	int hp_mute_delay;
+};
+
+static const struct reg_default rk817_reg_defaults[] = {
+	{ RK817_CODEC_DTOP_VUCTL, 0x003 },
+	{ RK817_CODEC_DTOP_VUCTIME, 0x00 },
+	{ RK817_CODEC_DTOP_LPT_SRST, 0x00 },
+	{ RK817_CODEC_DTOP_DIGEN_CLKE, 0x00 },
+	{ RK817_CODEC_AREF_RTCFG0, 0x00 },
+	{ RK817_CODEC_AREF_RTCFG1, 0x06 },
+	{ RK817_CODEC_AADC_CFG0, 0xc8 },
+	{ RK817_CODEC_AADC_CFG1, 0x00 },
+	{ RK817_CODEC_DADC_VOLL, 0x00 },
+	{ RK817_CODEC_DADC_VOLR, 0x00 },
+	{ RK817_CODEC_DADC_SR_ACL0, 0x00 },
+	{ RK817_CODEC_DADC_ALC1, 0x00 },
+	{ RK817_CODEC_DADC_ALC2, 0x00 },
+	{ RK817_CODEC_DADC_NG, 0x00 },
+	{ RK817_CODEC_DADC_HPF, 0x00 },
+	{ RK817_CODEC_DADC_RVOLL, 0xff },
+	{ RK817_CODEC_DADC_RVOLR, 0xff },
+	{ RK817_CODEC_AMIC_CFG0, 0x70 },
+	{ RK817_CODEC_AMIC_CFG1, 0x00 },
+	{ RK817_CODEC_DMIC_PGA_GAIN, 0x66 },
+	{ RK817_CODEC_DMIC_LMT1, 0x00 },
+	{ RK817_CODEC_DMIC_LMT2, 0x00 },
+	{ RK817_CODEC_DMIC_NG1, 0x00 },
+	{ RK817_CODEC_DMIC_NG2, 0x00 },
+	{ RK817_CODEC_ADAC_CFG0, 0x00 },
+	{ RK817_CODEC_ADAC_CFG1, 0x07 },
+	{ RK817_CODEC_DDAC_POPD_DACST, 0x82 },
+	{ RK817_CODEC_DDAC_VOLL, 0x00 },
+	{ RK817_CODEC_DDAC_VOLR, 0x00 },
+	{ RK817_CODEC_DDAC_SR_LMT0, 0x00 },
+	{ RK817_CODEC_DDAC_LMT1, 0x00 },
+	{ RK817_CODEC_DDAC_LMT2, 0x00 },
+	{ RK817_CODEC_DDAC_MUTE_MIXCTL, 0xa0 },
+	{ RK817_CODEC_DDAC_RVOLL, 0xff },
+	{ RK817_CODEC_DDAC_RVOLR, 0xff },
+	{ RK817_CODEC_AHP_ANTI0, 0x00 },
+	{ RK817_CODEC_AHP_ANTI1, 0x00 },
+	{ RK817_CODEC_AHP_CFG0, 0xe0 },
+	{ RK817_CODEC_AHP_CFG1, 0x1f },
+	{ RK817_CODEC_AHP_CP, 0x09 },
+	{ RK817_CODEC_ACLASSD_CFG1, 0x69 },
+	{ RK817_CODEC_ACLASSD_CFG2, 0x44 },
+	{ RK817_CODEC_APLL_CFG0, 0x04 },
+	{ RK817_CODEC_APLL_CFG1, 0x00 },
+	{ RK817_CODEC_APLL_CFG2, 0x30 },
+	{ RK817_CODEC_APLL_CFG3, 0x19 },
+	{ RK817_CODEC_APLL_CFG4, 0x65 },
+	{ RK817_CODEC_APLL_CFG5, 0x01 },
+	{ RK817_CODEC_DI2S_CKM, 0x01 },
+	{ RK817_CODEC_DI2S_RSD, 0x00 },
+	{ RK817_CODEC_DI2S_RXCR1, 0x00 },
+	{ RK817_CODEC_DI2S_RXCR2, 0x17 },
+	{ RK817_CODEC_DI2S_RXCMD_TSD, 0x00 },
+	{ RK817_CODEC_DI2S_TXCR1, 0x00 },
+	{ RK817_CODEC_DI2S_TXCR2, 0x17 },
+	{ RK817_CODEC_DI2S_TXCR3_TXCMD, 0x00 },
+};
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+static const struct snd_kcontrol_new rk817_dac_controls[] = {
+	SOC_DOUBLE_R_RANGE_TLV("Playback Volume", RK817_CODEC_DDAC_VOLL,
+		RK817_CODEC_DDAC_VOLR, 0, 0x12, 0xff, 1, rk817_vol_tlv),
+	RK817_ADC_VOLUME
+};
+#endif
+
+static bool rk817_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case RK817_CODEC_DTOP_LPT_SRST:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rk817_codec_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case RK817_CODEC_DTOP_VUCTL:
+	case RK817_CODEC_DTOP_VUCTIME:
+	case RK817_CODEC_DTOP_LPT_SRST:
+	case RK817_CODEC_DTOP_DIGEN_CLKE:
+	case RK817_CODEC_AREF_RTCFG0:
+	case RK817_CODEC_AREF_RTCFG1:
+	case RK817_CODEC_AADC_CFG0:
+	case RK817_CODEC_AADC_CFG1:
+	case RK817_CODEC_DADC_VOLL:
+	case RK817_CODEC_DADC_VOLR:
+	case RK817_CODEC_DADC_SR_ACL0:
+	case RK817_CODEC_DADC_ALC1:
+	case RK817_CODEC_DADC_ALC2:
+	case RK817_CODEC_DADC_NG:
+	case RK817_CODEC_DADC_HPF:
+	case RK817_CODEC_DADC_RVOLL:
+	case RK817_CODEC_DADC_RVOLR:
+	case RK817_CODEC_AMIC_CFG0:
+	case RK817_CODEC_AMIC_CFG1:
+	case RK817_CODEC_DMIC_PGA_GAIN:
+	case RK817_CODEC_DMIC_LMT1:
+	case RK817_CODEC_DMIC_LMT2:
+	case RK817_CODEC_DMIC_NG1:
+	case RK817_CODEC_DMIC_NG2:
+	case RK817_CODEC_ADAC_CFG0:
+	case RK817_CODEC_ADAC_CFG1:
+	case RK817_CODEC_DDAC_POPD_DACST:
+	case RK817_CODEC_DDAC_VOLL:
+	case RK817_CODEC_DDAC_VOLR:
+	case RK817_CODEC_DDAC_SR_LMT0:
+	case RK817_CODEC_DDAC_LMT1:
+	case RK817_CODEC_DDAC_LMT2:
+	case RK817_CODEC_DDAC_MUTE_MIXCTL:
+	case RK817_CODEC_DDAC_RVOLL:
+	case RK817_CODEC_DDAC_RVOLR:
+	case RK817_CODEC_AHP_ANTI0:
+	case RK817_CODEC_AHP_ANTI1:
+	case RK817_CODEC_AHP_CFG0:
+	case RK817_CODEC_AHP_CFG1:
+	case RK817_CODEC_AHP_CP:
+	case RK817_CODEC_ACLASSD_CFG1:
+	case RK817_CODEC_ACLASSD_CFG2:
+	case RK817_CODEC_APLL_CFG0:
+	case RK817_CODEC_APLL_CFG1:
+	case RK817_CODEC_APLL_CFG2:
+	case RK817_CODEC_APLL_CFG3:
+	case RK817_CODEC_APLL_CFG4:
+	case RK817_CODEC_APLL_CFG5:
+	case RK817_CODEC_DI2S_CKM:
+	case RK817_CODEC_DI2S_RSD:
+	case RK817_CODEC_DI2S_RXCR1:
+	case RK817_CODEC_DI2S_RXCR2:
+	case RK817_CODEC_DI2S_RXCMD_TSD:
+	case RK817_CODEC_DI2S_TXCR1:
+	case RK817_CODEC_DI2S_TXCR2:
+	case RK817_CODEC_DI2S_TXCR3_TXCMD:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int rk817_codec_ctl_gpio(struct rk817_codec_priv *rk817,
+				int gpio, int level)
+{
+	if ((gpio & CODEC_SET_SPK) &&
+	    rk817->spk_ctl_gpio) {
+		gpiod_set_value(rk817->spk_ctl_gpio, level);
+		DBG("%s set spk clt %d\n", __func__, level);
+		msleep(rk817->spk_mute_delay);
+	}
+
+	if ((gpio & CODEC_SET_HP) &&
+	    rk817->hp_ctl_gpio) {
+		gpiod_set_value(rk817->hp_ctl_gpio, level);
+		DBG("%s set hp clt %d\n", __func__, level);
+		msleep(rk817->hp_mute_delay);
+	}
+
+	return 0;
+}
+
+static int rk817_reset(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, RK817_CODEC_DTOP_LPT_SRST, 0x40);
+	snd_soc_write(codec, RK817_CODEC_DDAC_POPD_DACST, 0x02);
+	snd_soc_write(codec, RK817_CODEC_DTOP_DIGEN_CLKE, 0x0f);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG0, 0x04);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG1, 0x58);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG2, 0x2d);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG3, 0x0c);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG4, 0xa5);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG5, 0x00);
+	snd_soc_write(codec, RK817_CODEC_DTOP_DIGEN_CLKE, 0x00);
+
+	return 0;
+}
+
+static struct rk817_reg_val_typ playback_power_up_list[] = {
+	{RK817_CODEC_AREF_RTCFG1, 0x40},
+	{RK817_CODEC_DDAC_POPD_DACST, 0x02},
+	{RK817_CODEC_DDAC_SR_LMT0, 0x02},
+	/* {RK817_CODEC_DTOP_DIGEN_CLKE, 0x0f}, */
+	/* APLL */
+	{RK817_CODEC_APLL_CFG0, 0x04},
+	{RK817_CODEC_APLL_CFG1, 0x58},
+	{RK817_CODEC_APLL_CFG2, 0x2d},
+	{RK817_CODEC_APLL_CFG3, 0x0c},
+	{RK817_CODEC_APLL_CFG4, 0xa5},
+	{RK817_CODEC_APLL_CFG5, 0x00},
+
+	{RK817_CODEC_DI2S_RXCMD_TSD, 0x00},
+	{RK817_CODEC_DI2S_RSD, 0x00},
+	/* {RK817_CODEC_DI2S_CKM, 0x00}, */
+	{RK817_CODEC_DI2S_RXCR1, 0x00},
+	{RK817_CODEC_DI2S_RXCMD_TSD, 0x20},
+	{RK817_CODEC_DTOP_VUCTIME, 0xf4},
+	{RK817_CODEC_DDAC_MUTE_MIXCTL, 0x00},
+
+	{RK817_CODEC_DDAC_VOLL, 0x0a},
+	{RK817_CODEC_DDAC_VOLR, 0x0a},
+};
+
+#define RK817_CODEC_PLAYBACK_POWER_UP_LIST_LEN \
+	ARRAY_SIZE(playback_power_up_list)
+
+static struct rk817_reg_val_typ playback_power_down_list[] = {
+	{RK817_CODEC_DDAC_MUTE_MIXCTL, 0x01},
+	{RK817_CODEC_ADAC_CFG1, 0x0f},
+	/* HP */
+	{RK817_CODEC_AHP_CFG0, 0xe0},
+	{RK817_CODEC_AHP_CP, 0x09},
+	/* SPK */
+	{RK817_CODEC_ACLASSD_CFG1, 0x69},
+};
+
+#define RK817_CODEC_PLAYBACK_POWER_DOWN_LIST_LEN \
+	ARRAY_SIZE(playback_power_down_list)
+
+static struct rk817_reg_val_typ capture_power_up_list[] = {
+	{RK817_CODEC_AREF_RTCFG1, 0x40},
+	{RK817_CODEC_DDAC_SR_LMT0, 0x02},
+	{RK817_CODEC_DADC_SR_ACL0, 0x02},
+	/* {RK817_CODEC_DTOP_DIGEN_CLKE, 0xff}, */
+	{RK817_CODEC_APLL_CFG0, 0x04},
+	{RK817_CODEC_APLL_CFG1, 0x58},
+	{RK817_CODEC_APLL_CFG2, 0x2d},
+	{RK817_CODEC_APLL_CFG3, 0x0c},
+	{RK817_CODEC_APLL_CFG4, 0xa5},
+	{RK817_CODEC_APLL_CFG5, 0x00},
+
+	/*{RK817_CODEC_DI2S_RXCMD_TSD, 0x00},*/
+	{RK817_CODEC_DI2S_RSD, 0x00},
+	/* {RK817_CODEC_DI2S_CKM, 0x00}, */
+	{RK817_CODEC_DI2S_RXCR1, 0x00},
+	{RK817_CODEC_DI2S_RXCMD_TSD, 0x20},
+	{RK817_CODEC_DTOP_VUCTIME, 0xf4},
+
+	{RK817_CODEC_DDAC_MUTE_MIXCTL, 0x00},
+	{RK817_CODEC_AADC_CFG0, 0x08},
+	{RK817_CODEC_AMIC_CFG0, 0x0f},
+	{RK817_CODEC_DI2S_TXCR3_TXCMD, 0x88},
+	{RK817_CODEC_DDAC_POPD_DACST, 0x02},
+	/* 0x29: -18db to 27db */
+	{RK817_CODEC_DMIC_PGA_GAIN, 0x99},
+};
+
+#define RK817_CODEC_CAPTURE_POWER_UP_LIST_LEN \
+	ARRAY_SIZE(capture_power_up_list)
+
+static struct rk817_reg_val_typ capture_power_down_list[] = {
+	{RK817_CODEC_AADC_CFG0, 0xc8},
+	{RK817_CODEC_AMIC_CFG0, 0x70},
+};
+
+#define RK817_CODEC_CAPTURE_POWER_DOWN_LIST_LEN \
+	ARRAY_SIZE(capture_power_down_list)
+
+static int rk817_codec_power_up(struct snd_soc_codec *codec, int type)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	int i;
+
+	DBG("%s : power up %s %s %s\n", __func__,
+	    type & RK817_CODEC_PLAYBACK ? "playback" : "",
+	    type & RK817_CODEC_CAPTURE ? "capture" : "",
+	    type & RK817_CODEC_INCALL ? "incall" : "");
+
+	if (type & RK817_CODEC_PLAYBACK) {
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    DAC_DIG_CLK_MASK, DAC_DIG_CLK_EN);
+		for (i = 0; i < RK817_CODEC_PLAYBACK_POWER_UP_LIST_LEN; i++) {
+			snd_soc_write(codec, playback_power_up_list[i].reg,
+				      playback_power_up_list[i].value);
+		}
+	}
+
+	if (type & RK817_CODEC_CAPTURE) {
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    ADC_DIG_CLK_MASK, ADC_DIG_CLK_EN);
+		for (i = 0; i < RK817_CODEC_CAPTURE_POWER_UP_LIST_LEN; i++) {
+			snd_soc_write(codec, capture_power_up_list[i].reg,
+				      capture_power_up_list[i].value);
+		}
+
+		if (rk817->mic_in_differential)
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+					    MIC_DIFF_MASK, MIC_DIFF_EN);
+		else
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+					    MIC_DIFF_MASK, MIC_DIFF_DIS);
+
+		if (rk817->pdmdata_out_enable)
+			snd_soc_update_bits(codec, RK817_CODEC_DI2S_CKM,
+					    PDM_EN_MASK, PDM_EN_ENABLE);
+
+		snd_soc_write(codec, RK817_CODEC_DADC_VOLL,
+			      rk817->capture_volume);
+		snd_soc_write(codec, RK817_CODEC_DADC_VOLR,
+			      rk817->capture_volume);
+	}
+
+	return 0;
+}
+
+static int rk817_codec_power_down(struct snd_soc_codec *codec, int type)
+{
+	int i;
+
+	DBG("%s : power down %s %s %s\n", __func__,
+	    type & RK817_CODEC_PLAYBACK ? "playback" : "",
+	    type & RK817_CODEC_CAPTURE ? "capture" : "",
+	    type & RK817_CODEC_INCALL ? "incall" : "");
+
+	/* mute output for pop noise */
+	if ((type & RK817_CODEC_PLAYBACK) ||
+	    (type & RK817_CODEC_INCALL)) {
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_ENABLE);
+	}
+
+	if (type & RK817_CODEC_CAPTURE) {
+		for (i = 0; i < RK817_CODEC_CAPTURE_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, capture_power_down_list[i].reg,
+				      capture_power_down_list[i].value);
+		}
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    ADC_DIG_CLK_MASK, ADC_DIG_CLK_DIS);
+	}
+
+	if (type & RK817_CODEC_PLAYBACK) {
+		for (i = 0; i < RK817_CODEC_PLAYBACK_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, playback_power_down_list[i].reg,
+				      playback_power_down_list[i].value);
+		}
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    DAC_DIG_CLK_MASK, DAC_DIG_CLK_DIS);
+	}
+
+	if (type == RK817_CODEC_ALL) {
+		for (i = 0; i < RK817_CODEC_PLAYBACK_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, playback_power_down_list[i].reg,
+				      playback_power_down_list[i].value);
+		}
+		for (i = 0; i < RK817_CODEC_CAPTURE_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, capture_power_down_list[i].reg,
+				      capture_power_down_list[i].value);
+		}
+		snd_soc_write(codec, RK817_CODEC_DTOP_DIGEN_CLKE, 0x00);
+		snd_soc_write(codec, RK817_CODEC_APLL_CFG5, 0x01);
+		snd_soc_write(codec, RK817_CODEC_AREF_RTCFG1, 0x06);
+	}
+
+	return 0;
+}
+
+/* For tiny alsa playback/capture/voice call path */
+static const char * const rk817_playback_path_mode[] = {
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	"OFF", "RCV", "SPK", "HP", "HP_NO_MIC", "BT", "SPK_HP", /* 0-6 */
+	"RING_SPK", "RING_HP", "RING_HP_NO_MIC", "RING_SPK_HP"}; /* 7-10 */
+#else
+	"OFF", "SPK", "HP", "SPK_HP"};
+#endif
+
+static const char * const rk817_capture_path_mode[] = {
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	"MIC OFF", "Main Mic", "Hands Free Mic", "BT Sco Mic"};
+
+static const char * const rk817_call_path_mode[] = {
+	"OFF", "RCV", "SPK", "HP", "HP_NO_MIC", "BT"}; /* 0-5 */
+
+static const char * const rk817_modem_input_mode[] = {"OFF", "ON"};
+#else
+	"MIC OFF", "Main Mic"};
+#endif
+
+static SOC_ENUM_SINGLE_DECL(rk817_playback_path_type,
+	0, 0, rk817_playback_path_mode);
+
+static SOC_ENUM_SINGLE_DECL(rk817_capture_path_type,
+	0, 0, rk817_capture_path_mode);
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+static SOC_ENUM_SINGLE_DECL(rk817_call_path_type,
+	0, 0, rk817_call_path_mode);
+
+static SOC_ENUM_SINGLE_DECL(rk817_modem_input_type,
+	0, 0, rk817_modem_input_mode);
+#endif
+
+static int rk817_playback_path_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s : playback_path %ld\n", __func__, rk817->playback_path);
+
+	ucontrol->value.integer.value[0] = rk817->playback_path;
+
+	return 0;
+}
+
+static int rk817_playback_path_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	long int pre_path;
+
+	if (rk817->playback_path == ucontrol->value.integer.value[0]) {
+		DBG("%s : playback_path is not changed!\n",
+		    __func__);
+		return 0;
+	}
+
+	pre_path = rk817->playback_path;
+	rk817->playback_path = ucontrol->value.integer.value[0];
+
+	DBG("%s : set playback_path %ld, pre_path %ld\n",
+	    __func__, rk817->playback_path, pre_path);
+
+	if (rk817->playback_path != OFF)
+		clk_prepare_enable(rk817->mclk);
+	else
+		clk_disable_unprepare(rk817->mclk);
+
+	switch (rk817->playback_path) {
+	case OFF:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		if (pre_path != OFF && (pre_path != HP_PATH &&
+			pre_path != HP_NO_MIC && pre_path != RING_HP &&
+			pre_path != RING_HP_NO_MIC)) {
+			rk817_codec_power_down(codec, RK817_CODEC_PLAYBACK);
+			if (rk817->capture_path == 0)
+				rk817_codec_power_down(codec, RK817_CODEC_ALL);
+		}
+		break;
+	case RCV:
+	case SPK_PATH:
+	case RING_SPK:
+#else
+		if (pre_path != OFF && (pre_path != HP_PATH)) {
+			rk817_codec_power_down(codec, RK817_CODEC_PLAYBACK);
+			if (rk817->capture_path == 0)
+				rk817_codec_power_down(codec, RK817_CODEC_ALL);
+		}
+		break;
+	case SPK_PATH:
+#endif
+		if (pre_path == OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_PLAYBACK);
+		if (!rk817->use_ext_amplifier) {
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+				      PWD_DACBIAS_ON | PWD_DACD_ON |
+				      PWD_DACL_ON | PWD_DACR_ON);
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		} else {
+			/* HP_CP_EN , CP 2.3V */
+			snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+			/* power on HP two stage opamp ,HP amplitude 0db */
+			snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+					  PWD_DACBIAS_ON | PWD_DACD_DOWN |
+					  PWD_DACL_ON | PWD_DACR_ON);
+			snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+						DACMT_ENABLE, DACMT_DISABLE);
+		}
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLL, rk817->spk_volume);
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLR, rk817->spk_volume);
+		break;
+	case HP_PATH:
+	case HP_NO_MIC:
+	case RING_HP:
+	case RING_HP_NO_MIC:
+#else
+		break;
+	case HP_PATH:
+#endif
+		if (pre_path == OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_PLAYBACK);
+		/* HP_CP_EN , CP 2.3V */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_DOWN |
+			      PWD_DACL_ON | PWD_DACR_ON);
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_DISABLE);
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLL, rk817->hp_volume);
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLR, rk817->hp_volume);
+		break;
+	case BT:
+		break;
+	case SPK_HP:
+	case RING_SPK_HP:
+#else
+		break;
+	case SPK_HP:
+#endif
+		if (pre_path == OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_PLAYBACK);
+
+		/* HP_CP_EN , CP 2.3V  */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_ON |
+			      PWD_DACL_ON | PWD_DACR_ON);
+
+		if (!rk817->use_ext_amplifier) {
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLL, rk817->hp_volume);
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLR, rk817->hp_volume);
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk817_capture_path_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s : capture_path %ld\n", __func__,
+	    rk817->capture_path);
+
+	ucontrol->value.integer.value[0] = rk817->capture_path;
+
+	return 0;
+}
+
+static int rk817_capture_path_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	long int pre_path;
+
+	if (rk817->capture_path == ucontrol->value.integer.value[0]) {
+		DBG("%s : capture_path is not changed!\n",
+		    __func__);
+		return 0;
+	}
+
+	pre_path = rk817->capture_path;
+	rk817->capture_path = ucontrol->value.integer.value[0];
+
+	DBG("%s : set capture_path %ld, pre_path %ld\n", __func__,
+	    rk817->capture_path, pre_path);
+
+	if (rk817->capture_path != MIC_OFF)
+		clk_prepare_enable(rk817->mclk);
+	else
+		clk_disable_unprepare(rk817->mclk);
+
+	switch (rk817->capture_path) {
+	case MIC_OFF:
+		if (pre_path != MIC_OFF)
+			rk817_codec_power_down(codec, RK817_CODEC_CAPTURE);
+		break;
+	case MAIN_MIC:
+		if (pre_path == MIC_OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_CAPTURE);
+
+		if (rk817->adc_for_loopback) {
+			/* don't need to gain when adc use for loopback */
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0, 0xf, 0x0);
+			snd_soc_write(codec, RK817_CODEC_DMIC_PGA_GAIN, 0x66);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0x00);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLR, 0x00);
+			break;
+		}
+		if (!rk817->mic_in_differential) {
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0xff);
+			snd_soc_update_bits(codec, RK817_CODEC_AADC_CFG0,
+					    ADC_L_PWD_MASK, ADC_L_PWD_EN);
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+					    PWD_PGA_L_MASK, PWD_PGA_L_EN);
+		}
+		break;
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	case HANDS_FREE_MIC:
+		if (pre_path == MIC_OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_CAPTURE);
+
+		if (rk817->adc_for_loopback) {
+			/* don't need to gain when adc use for loopback */
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0, 0xf, 0x0);
+			snd_soc_write(codec, RK817_CODEC_DMIC_PGA_GAIN, 0x66);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0x00);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLR, 0x00);
+			break;
+		}
+		if (!rk817->mic_in_differential) {
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0xff);
+			snd_soc_update_bits(codec, RK817_CODEC_AADC_CFG0,
+	 				    ADC_L_PWD_MASK, ADC_L_PWD_EN);
+	 		snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+	 				    PWD_PGA_L_MASK, PWD_PGA_L_EN);
+	 	}
+	 	break;
+	case BT_SCO_MIC:
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct snd_kcontrol_new rk817_snd_path_controls[] = {
+	SOC_ENUM_EXT("Playback Path", rk817_playback_path_type,
+		     rk817_playback_path_get, rk817_playback_path_put),
+
+	SOC_ENUM_EXT("Capture MIC Path", rk817_capture_path_type,
+		     rk817_capture_path_get, rk817_capture_path_put),
+};
+
+static int rk817_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	rk817->stereo_sysclk = freq;
+
+	DBG("%s : MCLK = %dHz\n", __func__, rk817->stereo_sysclk);
+
+	return 0;
+}
+
+static int rk817_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			     unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned int i2s_mst = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		i2s_mst |= RK817_I2S_MODE_SLV;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2s_mst |= RK817_I2S_MODE_MST;
+		break;
+	default:
+		dev_err(codec->dev, "%s : set master mask failed!\n",
+			__func__);
+		return -EINVAL;
+	}
+	DBG("%s : i2s %s mode\n", __func__,
+	    i2s_mst ? "master" : "slave");
+
+	snd_soc_update_bits(codec, RK817_CODEC_DI2S_CKM,
+			    RK817_I2S_MODE_MASK, i2s_mst);
+
+	return 0;
+}
+
+static int rk817_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	unsigned int rate = params_rate(params);
+
+	DBG("%s : MCLK = %dHz, sample rate = %dHz\n",
+	    __func__, rk817->stereo_sysclk, rate);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		snd_soc_write(codec, RK817_CODEC_DI2S_RXCR2, VDW_RX_16BITS);
+		snd_soc_write(codec, RK817_CODEC_DI2S_TXCR2, VDW_TX_16BITS);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		snd_soc_write(codec, RK817_CODEC_DI2S_RXCR2, VDW_RX_24BITS);
+		snd_soc_write(codec, RK817_CODEC_DI2S_TXCR2, VDW_TX_24BITS);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk817_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s %d\n", __func__, mute);
+	if (mute)
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_ENABLE);
+	else
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_DISABLE);
+
+	if (mute) {
+		rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
+		rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 0);
+	} else {
+		switch (rk817->playback_path) {
+		case SPK_PATH:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		case RING_SPK:
+#endif
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 0);
+			break;
+		case HP_PATH:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		case HP_NO_MIC:
+		case RING_HP:
+		case RING_HP_NO_MIC:
+#endif
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 1);
+			break;
+		case SPK_HP:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		case RING_SPK_HP:
+#endif
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 1);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+#define RK817_PLAYBACK_RATES (SNDRV_PCM_RATE_8000 |\
+			      SNDRV_PCM_RATE_16000 |	\
+			      SNDRV_PCM_RATE_32000 |	\
+			      SNDRV_PCM_RATE_44100 |	\
+			      SNDRV_PCM_RATE_48000 |	\
+			      SNDRV_PCM_RATE_96000)
+
+#define RK817_CAPTURE_RATES (SNDRV_PCM_RATE_8000 |\
+			      SNDRV_PCM_RATE_16000 |	\
+			      SNDRV_PCM_RATE_32000 |	\
+			      SNDRV_PCM_RATE_44100 |	\
+			      SNDRV_PCM_RATE_48000 |	\
+			      SNDRV_PCM_RATE_96000)
+
+#define RK817_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
+			SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE |\
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_ops rk817_dai_ops = {
+	.hw_params	= rk817_hw_params,
+	.set_fmt	= rk817_set_dai_fmt,
+	.set_sysclk	= rk817_set_dai_sysclk,
+	.digital_mute	= rk817_digital_mute,
+};
+
+static struct snd_soc_dai_driver rk817_dai[] = {
+	{
+		.name = "rk817-hifi",
+		.id = RK817_HIFI,
+		.playback = {
+			.stream_name = "HiFi Playback",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = RK817_PLAYBACK_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.capture = {
+			.stream_name = "HiFi Capture",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = RK817_CAPTURE_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.ops = &rk817_dai_ops,
+	},
+	{
+		.name = "rk817-voice",
+		.id = RK817_VOICE,
+		.playback = {
+			.stream_name = "Voice Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = RK817_PLAYBACK_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Voice Capture",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = RK817_CAPTURE_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.ops = &rk817_dai_ops,
+	},
+
+};
+
+static int rk817_suspend(struct snd_soc_codec *codec)
+{
+	rk817_codec_power_down(codec, RK817_CODEC_ALL);
+	return 0;
+}
+
+static int rk817_resume(struct snd_soc_codec *codec)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	rk817_codec_power_up(codec, RK817_CODEC_ALL);
+
+	DBG("[%s] playback path %ld, spk %d, hp %d\n", __func__,
+		rk817->playback_path,
+		rk817->spk_volume, rk817->hp_volume);
+
+	switch (rk817->playback_path) {
+	case OFF:
+		break;
+	case SPK_PATH:
+		if (!rk817->use_ext_amplifier) {
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+				      PWD_DACBIAS_ON | PWD_DACD_ON |
+				      PWD_DACL_ON | PWD_DACR_ON);
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		} else {
+			/* HP_CP_EN , CP 2.3V */
+			snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+			/* power on HP two stage opamp ,HP amplitude 0db */
+			snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+					  PWD_DACBIAS_ON | PWD_DACD_DOWN |
+					  PWD_DACL_ON | PWD_DACR_ON);
+			snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+						DACMT_ENABLE, DACMT_DISABLE);
+		}
+		break;
+	case HP_PATH:
+		/* HP_CP_EN , CP 2.3V */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_DOWN |
+			      PWD_DACL_ON | PWD_DACR_ON);
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_DISABLE);
+		break;
+	case SPK_HP:
+		/* HP_CP_EN , CP 2.3V  */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_ON |
+			      PWD_DACL_ON | PWD_DACR_ON);
+
+		if (!rk817->use_ext_amplifier) {
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk817_probe(struct snd_soc_codec *codec)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s\n", __func__);
+
+	if (!rk817) {
+		dev_err(codec->dev, "%s : rk817 priv is NULL!\n",
+			__func__);
+		return -EINVAL;
+	}
+	rk817->codec = codec;
+	rk817->playback_path = OFF;
+	rk817->capture_path = MIC_OFF;
+
+	rk817_reset(codec);
+
+	snd_soc_add_codec_controls(codec, rk817_snd_path_controls,
+				   ARRAY_SIZE(rk817_snd_path_controls));
+	return 0;
+}
+
+/* power down chip */
+static int rk817_remove(struct snd_soc_codec *codec)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s\n", __func__);
+
+	if (!rk817) {
+		dev_err(codec->dev, "%s : rk817 is NULL\n", __func__);
+		return 0;
+	}
+
+	rk817_codec_power_down(codec, RK817_CODEC_ALL);
+	mdelay(10);
+
+	return 0;
+}
+
+static struct regmap *rk817_get_regmap(struct device *dev)
+{
+	struct rk817_codec_priv *rk817 = dev_get_drvdata(dev);
+
+	return rk817->regmap;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_rk817 = {
+	.probe = rk817_probe,
+	.remove = rk817_remove,
+	.get_regmap = rk817_get_regmap,
+	.suspend = rk817_suspend,
+	.resume = rk817_resume,
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	.component_driver = {
+		.controls = rk817_dac_controls,
+		.num_controls = ARRAY_SIZE(rk817_dac_controls),
+	}
+#endif
+};
+
+static int rk817_codec_parse_dt_property(struct device *dev,
+					 struct rk817_codec_priv *rk817)
+{
+	struct device_node *node = dev->parent->of_node;
+	int ret;
+
+	DBG("%s()\n", __func__);
+
+	if (!node) {
+		dev_err(dev, "%s() dev->parent->of_node is NULL\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	node = of_get_child_by_name(dev->parent->of_node, "codec");
+	if (!node) {
+		dev_err(dev, "%s() Can not get child: codec\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	rk817->hp_ctl_gpio = devm_gpiod_get_optional(dev, "hp-ctl",
+						  GPIOD_OUT_LOW);
+	if (!IS_ERR_OR_NULL(rk817->hp_ctl_gpio)) {
+		DBG("%s : hp-ctl-gpio %d\n", __func__,
+		    desc_to_gpio(rk817->hp_ctl_gpio));
+	}
+
+	rk817->spk_ctl_gpio = devm_gpiod_get_optional(dev, "spk-ctl",
+						  GPIOD_OUT_LOW);
+	if (!IS_ERR_OR_NULL(rk817->spk_ctl_gpio)) {
+		DBG("%s : spk-ctl-gpio %d\n", __func__,
+		    desc_to_gpio(rk817->spk_ctl_gpio));
+	}
+
+	ret = of_property_read_u32(node, "spk-mute-delay-ms",
+				   &rk817->spk_mute_delay);
+	if (ret < 0) {
+		DBG("%s() Can not read property spk-mute-delay-ms\n",
+			__func__);
+		rk817->spk_mute_delay = 0;
+	}
+
+	ret = of_property_read_u32(node, "hp-mute-delay-ms",
+				   &rk817->hp_mute_delay);
+	if (ret < 0) {
+		DBG("%s() Can not read property hp-mute-delay-ms\n",
+		    __func__);
+		rk817->hp_mute_delay = 0;
+	}
+	DBG("spk mute delay %dms --- hp mute delay %dms\n",
+	    rk817->spk_mute_delay, rk817->hp_mute_delay);
+
+	ret = of_property_read_u32(node, "spk-volume", &rk817->spk_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property spk-volume\n", __func__);
+		rk817->spk_volume = OUT_VOLUME;
+	}
+	if (rk817->spk_volume < 3)
+		rk817->spk_volume = 3;
+
+	ret = of_property_read_u32(node, "hp-volume",
+				   &rk817->hp_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property hp-volume\n",
+		    __func__);
+		rk817->hp_volume = OUT_VOLUME;
+	}
+	if (rk817->hp_volume < 3)
+		rk817->hp_volume = 3;
+
+	ret = of_property_read_u32(node, "capture-volume",
+				   &rk817->capture_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property capture-volume\n",
+		    __func__);
+		rk817->capture_volume = CAPTURE_VOLUME;
+	}
+
+	rk817->mic_in_differential =
+			of_property_read_bool(node, "mic-in-differential");
+
+	rk817->pdmdata_out_enable =
+			of_property_read_bool(node, "pdmdata-out-enable");
+
+	rk817->use_ext_amplifier =
+			of_property_read_bool(node, "use-ext-amplifier");
+
+	rk817->adc_for_loopback =
+			of_property_read_bool(node, "adc-for-loopback");
+
+	return 0;
+}
+
+static const struct regmap_config rk817_codec_regmap_config = {
+	.name = "rk817-codec",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.reg_stride = 1,
+	.max_register = 0x4f,
+	.cache_type = REGCACHE_NONE,
+	.volatile_reg = rk817_volatile_register,
+	.writeable_reg = rk817_codec_register,
+	.readable_reg = rk817_codec_register,
+	.reg_defaults = rk817_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rk817_reg_defaults),
+};
+
+static int rk817_platform_probe(struct platform_device *pdev)
+{
+	struct rk808 *rk817 = dev_get_drvdata(pdev->dev.parent);
+	struct rk817_codec_priv *rk817_codec_data;
+	int ret;
+
+	DBG("%s\n", __func__);
+
+	if (!rk817) {
+		dev_err(&pdev->dev, "%s : rk817 is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	rk817_codec_data = devm_kzalloc(&pdev->dev,
+					sizeof(struct rk817_codec_priv),
+					GFP_KERNEL);
+	if (!rk817_codec_data)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, rk817_codec_data);
+
+	ret = rk817_codec_parse_dt_property(&pdev->dev, rk817_codec_data);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "%s() parse device tree property error %d\n",
+			__func__, ret);
+		goto err_;
+	}
+
+	rk817_codec_data->regmap = devm_regmap_init_i2c(rk817->i2c,
+					    &rk817_codec_regmap_config);
+	if (IS_ERR(rk817_codec_data->regmap)) {
+		ret = PTR_ERR(rk817_codec_data->regmap);
+		dev_err(&pdev->dev, "failed to allocate register map: %d\n",
+			ret);
+		goto err_;
+	}
+
+	rk817_codec_data->mclk = devm_clk_get(&pdev->dev, "mclk");
+	if (IS_ERR(rk817_codec_data->mclk)) {
+		dev_err(&pdev->dev, "Unable to get mclk\n");
+		ret = -ENXIO;
+		goto err_;
+	}
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_rk817,
+				     rk817_dai, ARRAY_SIZE(rk817_dai));
+	if (ret < 0) {
+		dev_err(&pdev->dev, "%s() register codec error %d\n",
+			__func__, ret);
+		goto err_;
+	}
+
+	return 0;
+err_:
+
+	return ret;
+}
+
+static int rk817_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+
+	return 0;
+}
+
+static void rk817_platform_shutdown(struct platform_device *pdev)
+{
+	struct rk817_codec_priv *rk817 = dev_get_drvdata(&pdev->dev);
+
+	DBG("%s\n", __func__);
+
+	rk817_codec_power_down(rk817->codec, RK817_CODEC_ALL);
+
+}
+
+static const struct of_device_id rk817_codec_dt_ids[] = {
+	{ .compatible = "rockchip,rk817-codec" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk817_codec_dt_ids);
+
+static struct platform_driver rk817_codec_driver = {
+	.driver = {
+		   .name = "rk817-codec",
+		   .of_match_table = rk817_codec_dt_ids,
+		   },
+	.probe = rk817_platform_probe,
+	.remove = rk817_platform_remove,
+	.shutdown = rk817_platform_shutdown,
+};
+
+module_platform_driver(rk817_codec_driver);
+
+MODULE_DESCRIPTION("ASoC RK817 codec driver");
+MODULE_AUTHOR("binyuan <kevan.lan@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/rk817_codec.h b/sound/soc/codecs/rk817_codec.h
new file mode 100755
index 000000000000..c1079dba45cb
--- /dev/null
+++ b/sound/soc/codecs/rk817_codec.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __RK817_CODEC_H__
+#define __RK817_CODEC_H__
+
+/* codec register */
+#define RK817_CODEC_BASE		0x0000
+
+#define RK817_CODEC_DTOP_VUCTL		(RK817_CODEC_BASE + 0x12)
+#define RK817_CODEC_DTOP_VUCTIME	(RK817_CODEC_BASE + 0x13)
+#define RK817_CODEC_DTOP_LPT_SRST	(RK817_CODEC_BASE + 0x14)
+#define RK817_CODEC_DTOP_DIGEN_CLKE	(RK817_CODEC_BASE + 0x15)
+#define RK817_CODEC_AREF_RTCFG0		(RK817_CODEC_BASE + 0x16)
+#define RK817_CODEC_AREF_RTCFG1		(RK817_CODEC_BASE + 0x17)
+#define RK817_CODEC_AADC_CFG0		(RK817_CODEC_BASE + 0x18)
+#define RK817_CODEC_AADC_CFG1		(RK817_CODEC_BASE + 0x19)
+#define RK817_CODEC_DADC_VOLL		(RK817_CODEC_BASE + 0x1a)
+#define RK817_CODEC_DADC_VOLR		(RK817_CODEC_BASE + 0x1b)
+#define RK817_CODEC_DADC_SR_ACL0	(RK817_CODEC_BASE + 0x1e)
+#define RK817_CODEC_DADC_ALC1		(RK817_CODEC_BASE + 0x1f)
+#define RK817_CODEC_DADC_ALC2		(RK817_CODEC_BASE + 0x20)
+#define RK817_CODEC_DADC_NG		(RK817_CODEC_BASE + 0x21)
+#define RK817_CODEC_DADC_HPF		(RK817_CODEC_BASE + 0x22)
+#define RK817_CODEC_DADC_RVOLL		(RK817_CODEC_BASE + 0x23)
+#define RK817_CODEC_DADC_RVOLR		(RK817_CODEC_BASE + 0x24)
+#define RK817_CODEC_AMIC_CFG0		(RK817_CODEC_BASE + 0x27)
+#define RK817_CODEC_AMIC_CFG1		(RK817_CODEC_BASE + 0x28)
+#define RK817_CODEC_DMIC_PGA_GAIN	(RK817_CODEC_BASE + 0x29)
+#define RK817_CODEC_DMIC_LMT1		(RK817_CODEC_BASE + 0x2a)
+#define RK817_CODEC_DMIC_LMT2		(RK817_CODEC_BASE + 0x2b)
+#define RK817_CODEC_DMIC_NG1		(RK817_CODEC_BASE + 0x2c)
+#define RK817_CODEC_DMIC_NG2		(RK817_CODEC_BASE + 0x2d)
+#define RK817_CODEC_ADAC_CFG0		(RK817_CODEC_BASE + 0x2e)
+#define RK817_CODEC_ADAC_CFG1		(RK817_CODEC_BASE + 0x2f)
+#define RK817_CODEC_DDAC_POPD_DACST	(RK817_CODEC_BASE + 0x30)
+#define RK817_CODEC_DDAC_VOLL		(RK817_CODEC_BASE + 0x31)
+#define RK817_CODEC_DDAC_VOLR		(RK817_CODEC_BASE + 0x32)
+#define RK817_CODEC_DDAC_SR_LMT0	(RK817_CODEC_BASE + 0x35)
+#define RK817_CODEC_DDAC_LMT1		(RK817_CODEC_BASE + 0x36)
+#define RK817_CODEC_DDAC_LMT2		(RK817_CODEC_BASE + 0x37)
+#define RK817_CODEC_DDAC_MUTE_MIXCTL	(RK817_CODEC_BASE + 0x38)
+#define RK817_CODEC_DDAC_RVOLL		(RK817_CODEC_BASE + 0x39)
+#define RK817_CODEC_DDAC_RVOLR		(RK817_CODEC_BASE + 0x3a)
+#define RK817_CODEC_AHP_ANTI0		(RK817_CODEC_BASE + 0x3b)
+#define RK817_CODEC_AHP_ANTI1		(RK817_CODEC_BASE + 0x3c)
+#define RK817_CODEC_AHP_CFG0		(RK817_CODEC_BASE + 0x3d)
+#define RK817_CODEC_AHP_CFG1		(RK817_CODEC_BASE + 0x3e)
+#define RK817_CODEC_AHP_CP		(RK817_CODEC_BASE + 0x3f)
+#define RK817_CODEC_ACLASSD_CFG1	(RK817_CODEC_BASE + 0x40)
+#define RK817_CODEC_ACLASSD_CFG2	(RK817_CODEC_BASE + 0x41)
+#define RK817_CODEC_APLL_CFG0		(RK817_CODEC_BASE + 0x42)
+#define RK817_CODEC_APLL_CFG1		(RK817_CODEC_BASE + 0x43)
+#define RK817_CODEC_APLL_CFG2		(RK817_CODEC_BASE + 0x44)
+#define RK817_CODEC_APLL_CFG3		(RK817_CODEC_BASE + 0x45)
+#define RK817_CODEC_APLL_CFG4		(RK817_CODEC_BASE + 0x46)
+#define RK817_CODEC_APLL_CFG5		(RK817_CODEC_BASE + 0x47)
+#define RK817_CODEC_DI2S_CKM		(RK817_CODEC_BASE + 0x48)
+#define RK817_CODEC_DI2S_RSD		(RK817_CODEC_BASE + 0x49)
+#define RK817_CODEC_DI2S_RXCR1		(RK817_CODEC_BASE + 0x4a)
+#define RK817_CODEC_DI2S_RXCR2		(RK817_CODEC_BASE + 0x4b)
+#define RK817_CODEC_DI2S_RXCMD_TSD	(RK817_CODEC_BASE + 0x4c)
+#define RK817_CODEC_DI2S_TXCR1		(RK817_CODEC_BASE + 0x4d)
+#define RK817_CODEC_DI2S_TXCR2		(RK817_CODEC_BASE + 0x4e)
+#define RK817_CODEC_DI2S_TXCR3_TXCMD	(RK817_CODEC_BASE + 0x4f)
+
+/* RK817_CODEC_DTOP_DIGEN_CLKE */
+#define ADC_DIG_CLK_MASK		(0xf << 4)
+#define ADC_DIG_CLK_SFT			4
+#define ADC_DIG_CLK_DIS			(0x0 << 4)
+#define ADC_DIG_CLK_EN			(0xf << 4)
+
+#define DAC_DIG_CLK_MASK		(0xf << 0)
+#define DAC_DIG_CLK_SFT			0
+#define DAC_DIG_CLK_DIS			(0x0 << 0)
+#define DAC_DIG_CLK_EN			(0xf << 0)
+
+/* RK817_CODEC_APLL_CFG5 */
+#define PLL_PW_DOWN			(0x01 << 0)
+#define PLL_PW_UP			(0x00 << 0)
+
+/* RK817_CODEC_DI2S_CKM */
+#define PDM_EN_MASK			(0x1 << 3)
+#define PDM_EN_SFT			3
+#define PDM_EN_DISABLE			(0x0 << 3)
+#define PDM_EN_ENABLE			(0x1 << 3)
+
+#define SCK_EN_ENABLE			(0x1 << 2)
+#define SCK_EN_DISABLE			(0x0 << 2)
+
+#define RK817_I2S_MODE_MASK		(0x1 << 0)
+#define RK817_I2S_MODE_SFT		0
+#define RK817_I2S_MODE_MST		(0x1 << 0)
+#define RK817_I2S_MODE_SLV		(0x0 << 0)
+
+/* RK817_CODEC_DDAC_MUTE_MIXCTL */
+#define DACMT_ENABLE			(0x1 << 0)
+#define DACMT_DISABLE			(0x0 << 0)
+
+/* RK817_CODEC_DI2S_RXCR2 */
+#define VDW_RX_24BITS			(0x17)
+#define VDW_RX_16BITS			(0x0f)
+/* RK817_CODEC_DI2S_TXCR2 */
+#define VDW_TX_24BITS			(0x17)
+#define VDW_TX_16BITS			(0x0f)
+
+/* RK817_CODEC_AHP_CFG1 */
+#define HP_ANTIPOP_ENABLE		(0x1 << 4)
+#define HP_ANTIPOP_DISABLE		(0x0 << 4)
+
+/* RK817_CODEC_ADAC_CFG1 */
+#define PWD_DACBIAS_MASK		(0x1 << 3)
+#define PWD_DACBIAS_SFT			3
+#define PWD_DACBIAS_DOWN		(0x1 << 3)
+#define PWD_DACBIAS_ON			(0x0 << 3)
+
+#define PWD_DACD_MASK			(0x1 << 2)
+#define PWD_DACD_SFT			2
+#define PWD_DACD_DOWN			(0x1 << 2)
+#define PWD_DACD_ON			(0x0 << 2)
+
+#define PWD_DACL_MASK			(0x1 << 1)
+#define PWD_DACL_SFT			1
+#define PWD_DACL_DOWN			(0x1 << 1)
+#define PWD_DACL_ON			(0x0 << 1)
+
+#define PWD_DACR_MASK			(0x1 << 0)
+#define PWD_DACR_SFT			0
+#define PWD_DACR_DOWN			(0x1 << 0)
+#define PWD_DACR_ON			(0x0 << 0)
+
+/* RK817_CODEC_AADC_CFG0 */
+#define ADC_L_PWD_MASK			(0x1 << 7)
+#define ADC_L_PWD_SFT			7
+#define ADC_L_PWD_DIS			(0x0 << 7)
+#define ADC_L_PWD_EN			(0x1 << 7)
+
+#define ADC_R_PWD_MASK			(0x1 << 6)
+#define ADC_R_PWD_SFT			6
+#define ADC_R_PWD_DIS			(0x0 << 6)
+#define ADC_R_PWD_EN			(0x1 << 6)
+
+/* RK817_CODEC_AMIC_CFG0 */
+#define MIC_DIFF_MASK			(0x1 << 7)
+#define MIC_DIFF_SFT			7
+#define MIC_DIFF_DIS			(0x0 << 7)
+#define MIC_DIFF_EN			(0x1 << 7)
+
+#define PWD_PGA_L_MASK			(0x1 << 5)
+#define PWD_PGA_L_SFT			5
+#define PWD_PGA_L_DIS			(0x0 << 5)
+#define PWD_PGA_L_EN			(0x1 << 5)
+
+#define PWD_PGA_R_MASK			(0x1 << 4)
+#define PWD_PGA_R_SFT			4
+#define PWD_PGA_R_DIS			(0x0 << 4)
+#define PWD_PGA_R_EN			(0x1 << 4)
+
+enum {
+	RK817_HIFI,
+	RK817_VOICE,
+};
+
+enum {
+	RK817_MONO = 1,
+	RK817_STEREO,
+};
+
+enum {
+	OFF,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	RCV,
+#endif
+	SPK_PATH,
+	HP_PATH,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	HP_NO_MIC,
+	BT,
+#endif
+	SPK_HP,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	RING_SPK,
+	RING_HP,
+	RING_HP_NO_MIC,
+	RING_SPK_HP,
+#endif
+};
+
+enum {
+	MIC_OFF,
+	MAIN_MIC,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	HANDS_FREE_MIC,
+	BT_SCO_MIC,
+#endif
+};
+
+struct rk817_reg_val_typ {
+	unsigned int reg;
+	unsigned int value;
+};
+
+struct rk817_init_bit_typ {
+	unsigned int reg;
+	unsigned int power_bit;
+	unsigned int init_bit;
+};
+
+#endif /* __RK817_CODEC_H__ */
-- 
2.38.0

