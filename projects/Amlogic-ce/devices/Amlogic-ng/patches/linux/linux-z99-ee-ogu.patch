From f17e130bfdbd60dfbf4763971cd41c9e56b3a474 Mon Sep 17 00:00:00 2001
From: 7Ji <pugokushin@gmail.com>
Date: Mon, 10 Oct 2022 13:50:17 +0800
Subject: [PATCH] OGU: introduce

---
 arch/arm64/boot/dts/amlogic/Makefile          |    1 +
 .../amlogic/g12b_s922x_odroid_go_ultra.dts    | 1124 +++++
 .../boot/dts/amlogic/meson64_gou_joypad.dtsi  |  218 +
 .../boot/dts/amlogic/meson64_gou_panel.dtsi   |  214 +
 .../boot/dts/amlogic/meson64_gou_pmic.dtsi    |  474 +++
 arch/arm64/kernel/setup.c                     |    9 +-
 drivers/amlogic/media/osd/osd_fb.c            |  103 +-
 .../media/vout/lcd/lcd_extern/mipi_ST7701.c   |  106 +-
 .../media/vout/vout_serve/vout_serve.c        |   11 +
 drivers/amlogic/mmc/aml_sd_emmc.c             |   26 +-
 drivers/base/dma-contiguous.c                 |    1 +
 drivers/clk/clk-rk808.c                       |   96 +-
 drivers/input/joystick/Kconfig                |    6 +
 drivers/input/joystick/Makefile               |    1 +
 drivers/input/joystick/odroid-gou-joypad.c    |  949 +++++
 drivers/input/misc/Kconfig                    |    6 +
 drivers/input/misc/Makefile                   |    1 +
 drivers/input/misc/rk8xx-pwrkey.c             |  173 +
 drivers/mfd/rk808.c                           | 1529 ++++++-
 drivers/pinctrl/Kconfig                       |    9 +
 drivers/pinctrl/Makefile                      |    1 +
 drivers/pinctrl/pinctrl-rk805.c               |  689 ++++
 drivers/power/supply/Kconfig                  |   16 +
 drivers/power/supply/Makefile                 |    2 +
 drivers/power/supply/rk818_battery.c          | 3623 +++++++++++++++++
 drivers/power/supply/rk818_battery.h          |  168 +
 drivers/power/supply/rk818_charger.c          | 1992 +++++++++
 drivers/regulator/rk808-regulator.c           |  968 ++++-
 drivers/rtc/rtc-rk808.c                       |   95 +-
 include/linux/clk-provider.h                  |    3 +-
 include/linux/extcon.h                        |    1 +
 include/linux/mfd/rk808.h                     |  856 +++-
 include/linux/platform_data/emuelec.h         |   19 +
 include/linux/power/rk_usbbc.h                |   44 +
 include/linux/rk_keys.h                       |   19 +
 lib/radix-tree.c                              |    2 +
 mm/cma.c                                      |    2 +
 sound/soc/codecs/Kconfig                      |    6 +
 sound/soc/codecs/Makefile                     |    2 +
 sound/soc/codecs/rk817_codec.c                | 1291 ++++++
 sound/soc/codecs/rk817_codec.h                |  220 +
 41 files changed, 14790 insertions(+), 286 deletions(-)
 create mode 100644 arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts
 create mode 100755 arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
 create mode 100755 arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
 create mode 100755 arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
 create mode 100755 drivers/input/joystick/odroid-gou-joypad.c
 create mode 100755 drivers/input/misc/rk8xx-pwrkey.c
 create mode 100755 drivers/pinctrl/pinctrl-rk805.c
 create mode 100644 drivers/power/supply/rk818_battery.c
 create mode 100644 drivers/power/supply/rk818_battery.h
 create mode 100644 drivers/power/supply/rk818_charger.c
 create mode 100644 include/linux/platform_data/emuelec.h
 create mode 100755 include/linux/power/rk_usbbc.h
 create mode 100755 include/linux/rk_keys.h
 create mode 100755 sound/soc/codecs/rk817_codec.c
 create mode 100755 sound/soc/codecs/rk817_codec.h

diff --git a/arch/arm64/boot/dts/amlogic/Makefile b/arch/arm64/boot/dts/amlogic/Makefile
index 3de9711b12b7..fa5a5e6fb0d4 100644
--- a/arch/arm64/boot/dts/amlogic/Makefile
+++ b/arch/arm64/boot/dts/amlogic/Makefile
@@ -22,6 +22,7 @@ dtb-$(CONFIG_ARM64) += g12b_s922x_minix_u22xj_max_rev_a.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_n2.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_n2plus.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_n2plus_rev_c.dtb
+dtb-$(CONFIG_ARM64) += g12b_s922x_odroid_go_ultra.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_ugoos_am6_2g.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_ugoos_am6_4g.dtb
 dtb-$(CONFIG_ARM64) += g12b_s922x_ugoos_am6_rev_a_2g.dtb
diff --git a/arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts b/arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts
new file mode 100644
index 000000000000..39abc18e89eb
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/g12b_s922x_odroid_go_ultra.dts
@@ -0,0 +1,1124 @@
+// All g12b devices should base on either coreelec_g12b.dtsi or coreelec_g12b_a.dtsi
+#include "coreelec_g12b.dtsi"
+// OGU specific: Power Management Integrated Controller
+#include "meson64_gou_pmic.dtsi"
+// OGU specific: LCD panel
+#include "meson64_gou_panel.dtsi"
+// OGU specific: GPIO Joypad
+#include "meson64_gou_joypad.dtsi"
+
+/ {
+    model = "Hardkernel ODROID-GOU";
+    coreelec-dt-id = "g12b_s922x_odroid_go_ultra"; // Yeah we will still use coreelec-dt-id, never re-invent the wheel huh?
+    amlogic-dt-id = "g12b_ogu";
+
+    // /delete-node/ memory@00000000; // Different from N2, we use that, since it's already 2G
+	/delete-node/ bt-dev; // No BT or Wi-Fi included
+	/delete-node/ wifi;
+	/delete-node/ wifi_pwm_conf;
+	/delete-node/ adc_keypad;
+	/delete-node/ unifykey;
+	// /delete-node/ rtc;
+    /delete-node/ videosync;
+    /delete-node/ dummy_venc;
+    /delete-node/ video_composer;
+    /delete-node/ meson_uvm;
+    /delete-node/ vcodec_dec;
+    /delete-node/ jpegenc;
+    /delete-node/ gpioleds;
+    /delete-node/ cvbsout;
+    /delete-node/ linux,picdec;
+    /delete-node/ picdec;
+    /delete-node/ multi-di;
+
+    vout {
+        /delete-property/ fr_policy;
+    };
+
+    vout2 { // This is not a label, so it can't be simply disabled at the end
+        /delete-property/ fr_policy;
+        status = "disabled";
+    };
+
+    gpiomem {
+		compatible = "amlogic, gpiomem";
+		reg = <0x0 0xff634000 0x0 0x1000>,	/* GPIO banks */
+			<0x0 0xff800000 0x0 0x1000>;	/* GPIO_AO bank */
+		status = "okay";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+        // /delete-node/ linux,ion-fb;
+        // /delete-node/ linux,vdin1_cma;
+        // /delete-node/ linux,galcore;
+        // /delete-node/ linux,isp_cma;
+        // /delete-node/ linux,adapt_cma;
+        // /delete-node/ linux,vdin0_cma;
+
+		/* global autoconfigured region for contiguous allocations */
+		ramoops@0x07400000 {
+			compatible = "ramoops";
+			reg = <0x0 0x07400000 0x0 0x00100000>;
+			record-size = <0x8000>;
+			console-size = <0x8000>;
+			ftrace-size = <0x40000>;
+            /delete-property/ pmsg-size;
+		};
+
+		secmon_reserved:linux,secmon {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x400000>;
+			alignment = <0x0 0x400000>;
+			alloc-ranges = <0x0 0x05000000 0x0 0x400000>;
+			clear-map;
+		};
+
+		secos_reserved:linux,secos {
+			status = "disable";
+			compatible = "amlogic, aml_secos_memory";
+			reg = <0x0 0x05300000 0x0 0x2000000>;
+			no-map;
+		};
+		logo_reserved:linux,meson-fb {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x800000>;
+			alignment = <0x0 0x400000>;
+			alloc-ranges = <0x0 0x3d800000 0x0 0x800000>;
+		};
+		ion_cma_reserved:linux,ion-dev {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x400000>;
+		};
+
+		/*di CMA pool */
+		di_cma_reserved:linux,di_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			/* buffer_size = 3621952(yuv422 8bit)
+			 *  | 4736064(yuv422 10bit)
+			 *  | 4074560(yuv422 10bit full pack mode)
+			 * 10x3621952=34.6M(0x23) support 8bit
+			 * 10x4736064=45.2M(0x2e) support 12bit
+			 * 10x4074560=40M(0x28) support 10bit
+			 */
+			size = <0x0 0x02800000>;
+			alignment = <0x0 0x400000>;
+		};
+		/*  POST PROCESS MANAGER */
+		ppmgr_reserved:linux,ppmgr {
+			compatible = "shared-dma-pool";
+			size = <0x0 0x0>;
+		};
+
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			/* ion_codec_mm max can alloc size 80M*/
+			size = <0x0 0x13400000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+			clear-map;
+		};
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x0>;
+			alignment = <0x0 0x100000>;
+			//no-map;
+		};
+	};
+
+	codec_mm {
+		compatible = "amlogic, codec, mm";
+		memory-region = <&codec_mm_cma &codec_mm_reserved>;
+		dev_name = "codec_mm";
+		status = "okay";
+	};
+
+	ppmgr {
+		compatible = "amlogic, ppmgr";
+		memory-region = <&ppmgr_reserved>;
+		dev_name = "ppmgr";
+		status = "okay";
+	};
+
+	deinterlace {
+		compatible = "amlogic, deinterlace";
+		status = "okay";
+		/* 0:use reserved; 1:use cma; 2:use cma as reserved */
+		flag_cma = <1>;
+		memory-region = <&di_cma_reserved>;
+		interrupts = <0 46 1
+				0 40 1>;
+		interrupt-names = "pre_irq", "post_irq";
+        clocks = <&clkc CLKID_VPU_CLKB_TMP_COMP>,
+			<&clkc CLKID_VPU_CLKB_COMP>;
+		clock-names = "vpu_clkb_tmp_composite",
+			"vpu_clkb_composite";
+		clock-range = <334 667>;
+		/* buffer-size = <3621952>;(yuv422 8bit) */
+		buffer-size = <4074560>;/*yuv422 fullpack*/
+		/* reserve-iomap = "true"; */
+		/* if enable nr10bit, set nr10bit-support to 1 */
+		post-wr-support = <1>;
+		nr10bit-support = <1>;
+		nrds-enable = <1>;
+		pps-enable = <1>;
+	};
+
+	ionvideo {
+		compatible = "amlogic, ionvideo";
+		dev_name = "ionvideo";
+		status = "okay";
+	};
+
+	efuse: efuse{
+		compatible = "amlogic, efuse";
+		read_cmd = <0x82000030>;
+		write_cmd = <0x82000031>;
+		get_max_cmd = <0x82000033>;
+		key = <&efusekey>;
+		clocks = <&clkc CLKID_EFUSE>;
+		clock-names = "efuse_clk";
+		status = "okay";
+	};
+
+	efusekey:efusekey{
+		keynum = <1>;
+		key0 = <&key_0>;
+        /delete-property/ key1;
+        /delete-property/ key2;
+        /delete-property/ key3;
+        /delete-node/ key_1;
+        /delete-node/ key_2;
+        /delete-node/ key_3;
+
+		key_0: key_0 {
+			keyname = "uuid";
+			offset = <0>;
+			size = <32>;
+		};
+	};//End efusekey
+
+	amlvecm {
+		compatible = "amlogic, vecm";
+		dev_name = "aml_vecm";
+		status = "okay";
+		gamma_en = <0>;/*1:enabel ;0:disable*/
+		wb_en = <0>;/*1:enabel ;0:disable*/
+		cm_en = <0>;/*1:enabel ;0:disable*/
+	};
+	amdolby_vision {
+		compatible = "amlogic, dolby_vision_g12a";
+		dev_name = "aml_amdolby_vision_driver";
+		status = "okay";
+		tv_mode = <0>;/*1:enabel ;0:disable*/
+	};
+
+	/* Audio Related start */
+	dummy_codec:dummy{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_dummy_codec";
+		status = "okay";
+	};
+	amlogic_codec:t9015{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml_codec_T9015";
+		reg = <0x0 0xFF632000 0x0 0x2000>;
+		is_auge_used = <1>; /* meson or auge chipset used */
+		tdmout_index = <1>;
+		status = "okay";
+	};
+	audio_effect:eqdrc{
+		/*eq_enable = <1>;*/
+		/*drc_enable = <1>;*/
+		/*
+		 * 0:tdmout_a
+		 * 1:tdmout_b
+		 * 2:tdmout_c
+		 * 3:spdifout
+		 * 4:spdifout_b
+		 */
+		eqdrc_module = <1>;
+		/* max 0xf, each bit for one lane, usually one lane */
+		lane_mask = <0x1>;
+		/* max 0xff, each bit for one channel */
+		channel_mask = <0x3>;
+	};
+	auge_sound {
+
+		compatible = "amlogic, g12a-sound-card";
+		aml-audio-card,name = "AML-AUGESOUND";
+		aml-audio-card,effect = <&audio_effect>;
+		aml-audio-card,hp-det-gpio = <&gpio_ao GPIOAO_9 GPIO_ACTIVE_LOW>;
+
+        /delete-property/ avout_mute-gpios;
+        /delete-node/ aml-audio-card,dai-link@1;
+        /delete-node/ aml-audio-card,dai-link@2;
+        /delete-node/ aml-audio-card,dai-link@3;
+		aml-audio-card,dai-link@0 {
+			format = "i2s";
+			mclk-fs = <256>;
+			bitclock-master = <&aml_tdmb>;
+			frame-master = <&aml_tdmb>;
+			continuous-clock;
+            /delete-property/ bitclock-master;
+			/delete-property/ frame-master;
+
+			cpu {
+				sound-dai = <&aml_tdmb>;
+				dai-tdm-slot-tx-mask = <1 1>;
+				dai-tdm-slot-rx-mask = <1 1>;
+				dai-tdm-slot-num = <2>;
+				dai-tdm-slot-width = <32>;
+				system-clock-frequency = <12288000>;
+			};
+			codec {
+				sound-dai = <&rk817_codec>;
+			};
+		};
+	};
+	audiolocker: locker {
+		compatible = "amlogic, audiolocker";
+		clocks = <&clkaudio CLKID_AUDIO_LOCKER_OUT
+				&clkaudio CLKID_AUDIO_LOCKER_IN
+				&clkaudio CLKID_AUDIO_MCLK_D
+				&clkaudio CLKID_AUDIO_MCLK_E
+				&clkc CLKID_MPLL1
+				&clkc CLKID_MPLL2>;
+		clock-names = "lock_out", "lock_in", "out_src",
+					"in_src", "out_calc", "in_ref";
+		interrupts = <GIC_SPI 1 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "irq";
+		frequency = <49000000>; /* pll */
+		dividor = <49>; /* locker's parent */
+		status = "okay";
+	};
+	/* Audio Related end */
+
+	cpu_opp_table0: cpu_opp_table0 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp00 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <730000>;
+		};
+		opp01 {
+			opp-hz = /bits/ 64 <667000000>;
+			opp-microvolt = <730000>;
+		};
+		opp02 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <760000>;
+		};
+		opp03 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <780000>;
+		};
+		opp04 {
+			opp-hz = /bits/ 64 <1398000000>;
+			opp-microvolt = <810000>;
+		};
+		opp05 {
+			opp-hz = /bits/ 64 <1512000000>;
+			opp-microvolt = <860000>;
+		};
+		opp06 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <900000>;
+		};
+		opp07 {
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <960000>;
+		};
+		opp08 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <1020000>;
+		};
+		opp09 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <1030000>;
+		};
+		opp10 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <1040000>;
+		};
+	};
+
+	cpu_opp_table1: cpu_opp_table1 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp00 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <730000>;
+		};
+		opp01 {
+			opp-hz = /bits/ 64 <667000000>;
+			opp-microvolt = <730000>;
+		};
+		opp02 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <730000>;
+		};
+		opp03 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <750000>;
+		};
+		opp04 {
+			opp-hz = /bits/ 64 <1398000000>;
+			opp-microvolt = <770000>;
+		};
+		opp05 {
+			opp-hz = /bits/ 64 <1512000000>;
+			opp-microvolt = <770000>;
+		};
+		opp06 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <780000>;
+		};
+		opp07 {
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <790000>;
+		};
+		opp08 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <830000>;
+		};
+		opp09 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <860000>;
+		};
+		opp10 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <910000>;
+		};
+		opp11 {
+			opp-hz = /bits/ 64 <2100000000>;
+			opp-microvolt = <960000>;
+		};
+		opp12 {
+			opp-hz = /bits/ 64 <2208000000>;
+			opp-microvolt = <1030000>;
+		};
+		opp13 {
+			opp-hz = /bits/ 64 <2304000000>;
+			opp-microvolt = <1030000>;
+		};
+		opp14 {
+			opp-hz = /bits/ 64 <2400000000>;
+			opp-microvolt = <1040000>;
+		};
+	};
+
+	cpufreq-meson {
+		compatible = "amlogic, cpufreq-meson";
+		status = "okay";
+	};
+
+	gpio_keypad {
+		compatible = "amlogic, gpio_keypad";
+		status = "disabled";
+		scan_period = <20>;
+		key_num = <1>;
+		key_name = "power";
+		key_code = <116>;
+		/delete-property/ key-gpios;
+		/delete-property/ detect_mode;
+		/delete-property/ reg;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		status = "okay";
+		sys_led {
+			label="sys_led";
+			gpios=<&gpio_ao GPIOAO_11 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+    soc {
+        ion_dev {
+            memory-region = <&ion_cma_reserved>;
+        };
+    };
+
+    remote:rc@0xff808040 {
+        compatible = "amlogic, aml_remote";
+        dev_name = "meson-remote";
+        reg = <0x0 0xff808040 0x00 0x44>,
+        <0x0 0xff808000 0x00 0x20>;
+        status = "okay";
+        protocol = <0x01>;
+        interrupts = <0 196 1>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&remote_pins>;
+        map = <&custom_maps>;
+        max_frame_time = <200>;
+    };
+
+    custom_maps:custom_maps {
+        mapnum = <3>;
+        map0 = <&map_0>;
+        map1 = <&map_1>;
+        map2 = <&map_2>;
+        map_0: map_0{
+            mapname = "amlogic-remote-1";
+            customcode = <0xfb04>;
+            release_delay = <80>;
+            size = <50>;
+            keymap = <((((0x47) & 0xFFFF)<<16) | ((11) & 0xFFFF))
+                ((((0x13) & 0xFFFF)<<16) | ((2) & 0xFFFF))
+                ((((0x10) & 0xFFFF)<<16) | ((3) & 0xFFFF))
+                ((((0x11) & 0xFFFF)<<16) | ((4) & 0xFFFF))
+                ((((0x0F) & 0xFFFF)<<16) | ((5) & 0xFFFF))
+                ((((0x0C) & 0xFFFF)<<16) | ((6) & 0xFFFF))
+                ((((0x0D) & 0xFFFF)<<16) | ((7) & 0xFFFF))
+                ((((0x0B) & 0xFFFF)<<16) | ((8) & 0xFFFF))
+                ((((0x08) & 0xFFFF)<<16) | ((9) & 0xFFFF))
+                ((((0x09) & 0xFFFF)<<16) | ((10) & 0xFFFF))
+                ((((0x5C) & 0xFFFF)<<16) | ((97) & 0xFFFF))
+                ((((0x51) & 0xFFFF)<<16) | ((61) & 0xFFFF))
+                ((((0x50) & 0xFFFF)<<16) | ((62) & 0xFFFF))
+                ((((0x40) & 0xFFFF)<<16) | ((63) & 0xFFFF))
+                ((((0x4d) & 0xFFFF)<<16) | ((64) & 0xFFFF))
+                ((((0x43) & 0xFFFF)<<16) | ((65) & 0xFFFF))
+                ((((0x17) & 0xFFFF)<<16) | ((66) & 0xFFFF))
+                ((((0x00) & 0xFFFF)<<16) | ((67) & 0xFFFF))
+                ((((0x01) & 0xFFFF)<<16) | ((68) & 0xFFFF))
+                ((((0x16) & 0xFFFF)<<16) | ((87) & 0xFFFF))
+                ((((0x49) & 0xFFFF)<<16) | ((14) & 0xFFFF))
+                ((((0x06) & 0xFFFF)<<16) | ((130) & 0xFFFF))
+                ((((0x14) & 0xFFFF)<<16) | ((131) & 0xFFFF))
+                ((((0x44) & 0xFFFF)<<16) | ((103) & 0xFFFF))
+                ((((0x1D) & 0xFFFF)<<16) | ((108) & 0xFFFF))
+                ((((0x1C) & 0xFFFF)<<16) | ((105) & 0xFFFF))
+                ((((0x48) & 0xFFFF)<<16) | ((106) & 0xFFFF))
+                ((((0x53) & 0xFFFF)<<16) | ((125) & 0xFFFF))
+                ((((0x45) & 0xFFFF)<<16) | ((104) & 0xFFFF))
+                ((((0x19) & 0xFFFF)<<16) | ((109) & 0xFFFF))
+                ((((0x52) & 0xFFFF)<<16) | ((119) & 0xFFFF))
+                ((((0x05) & 0xFFFF)<<16) | ((122) & 0xFFFF))
+                ((((0x59) & 0xFFFF)<<16) | ((123) & 0xFFFF))
+                ((((0x1b) & 0xFFFF)<<16) | ((120) & 0xFFFF))
+                ((((0x04) & 0xFFFF)<<16) | ((121) & 0xFFFF))
+                ((((0x1A) & 0xFFFF)<<16) | ((116) & 0xFFFF))
+                ((((0x0A) & 0xFFFF)<<16) | ((15) & 0xFFFF))
+                ((((0x0e) & 0xFFFF)<<16) | ((113) & 0xFFFF))
+                ((((0x1F) & 0xFFFF)<<16) | ((102) & 0xFFFF))
+                ((((0x1e) & 0xFFFF)<<16) | ((132) & 0xFFFF))
+                ((((0x07) & 0xFFFF)<<16) | ((133) & 0xFFFF))
+                ((((0x12) & 0xFFFF)<<16) | ((134) & 0xFFFF))
+                ((((0x54) & 0xFFFF)<<16) | ((135) & 0xFFFF))
+                ((((0x02) & 0xFFFF)<<16) | ((136) & 0xFFFF))
+                ((((0x4f) & 0xFFFF)<<16) | ((30) & 0xFFFF))
+                ((((0x42) & 0xFFFF)<<16) | ((48) & 0xFFFF))
+                ((((0x5d) & 0xFFFF)<<16) | ((46) & 0xFFFF))
+                ((((0x4c) & 0xFFFF)<<16) | ((32) & 0xFFFF))
+                ((((0x58) & 0xFFFF)<<16) | ((137) & 0xFFFF))
+                ((((0x55) & 0xFFFF)<<16) | ((140) & 0xFFFF))>;
+        };
+        map_1: map_1{
+            mapname = "amlogic-remote-2";
+            customcode = <0xfe01>;
+            release_delay = <80>;
+            size = <53>;
+            keymap = <((((0x01) & 0xFFFF)<<16) | ((2) & 0xFFFF))
+                ((((0x02) & 0xFFFF)<<16) | ((3) & 0xFFFF))
+                ((((0x03) & 0xFFFF)<<16) | ((4) & 0xFFFF))
+                ((((0x04) & 0xFFFF)<<16) | ((5) & 0xFFFF))
+                ((((0x05) & 0xFFFF)<<16) | ((6) & 0xFFFF))
+                ((((0x06) & 0xFFFF)<<16) | ((7) & 0xFFFF))
+                ((((0x07) & 0xFFFF)<<16) | ((8) & 0xFFFF))
+                ((((0x08) & 0xFFFF)<<16) | ((9) & 0xFFFF))
+                ((((0x09) & 0xFFFF)<<16) | ((10) & 0xFFFF))
+                ((((0x0a) & 0xFFFF)<<16) | ((11) & 0xFFFF))
+                ((((0x1F) & 0xFFFF)<<16) | ((0x1d2) & 0xFFFF))
+                ((((0x15) & 0xFFFF)<<16) | ((139) & 0xFFFF))
+                ((((0x16) & 0xFFFF)<<16) | ((15) & 0xFFFF))
+                ((((0x0c) & 0xFFFF)<<16) | ((0x192) & 0xFFFF))
+                ((((0x0d) & 0xFFFF)<<16) | ((0x193) & 0xFFFF))
+                ((((0x0e) & 0xFFFF)<<16) | ((115) & 0xFFFF))
+                ((((0x0f) & 0xFFFF)<<16) | ((114) & 0xFFFF))
+                ((((0x11) & 0xFFFF)<<16) | ((102) & 0xFFFF))
+                ((((0x1c) & 0xFFFF)<<16) | ((106) & 0xFFFF))
+                ((((0x1b) & 0xFFFF)<<16) | ((105) & 0xFFFF))
+                ((((0x19) & 0xFFFF)<<16) | ((103) & 0xFFFF))
+                ((((0x1a) & 0xFFFF)<<16) | ((108) & 0xFFFF))
+                ((((0x1d) & 0xFFFF)<<16) | ((28) & 0xFFFF))
+                ((((0x17) & 0xFFFF)<<16) | ((113) & 0xFFFF))
+                ((((0x49) & 0xFFFF)<<16) | ((219) & 0xFFFF))
+                ((((0x43) & 0xFFFF)<<16) | ((158) & 0xFFFF))
+                ((((0x12) & 0xFFFF)<<16) | ((0x1d5) & 0xFFFF))
+                ((((0x14) & 0xFFFF)<<16) | ((0x1d6) & 0xFFFF))
+                ((((0x18) & 0xFFFF)<<16) | ((0x1d7) & 0xFFFF))
+                ((((0x59) & 0xFFFF)<<16) | ((0x166) & 0xFFFF))
+                ((((0x5a) & 0xFFFF)<<16) | ((166) & 0xFFFF))
+                ((((0x10) & 0xFFFF)<<16) | ((116) & 0xFFFF))
+                ((((0x42) & 0xFFFF)<<16) | ((165) & 0xFFFF))
+                ((((0x44) & 0xFFFF)<<16) | ((163) & 0xFFFF))
+                ((((0x1e) & 0xFFFF)<<16) | ((168) & 0xFFFF))
+                ((((0x4b) & 0xFFFF)<<16) | ((208) & 0xFFFF))
+                ((((0x58) & 0xFFFF)<<16) | ((164) & 0xFFFF))
+                ((((0x46) & 0xFFFF)<<16) | ((130) & 0xFFFF))
+                ((((0x40) & 0xFFFF)<<16) | ((131) & 0xFFFF))
+                ((((0x38) & 0xFFFF)<<16) | ((70) & 0xFFFF))
+                ((((0x57) & 0xFFFF)<<16) | ((0x1d0) & 0xFFFF))
+                ((((0x5b) & 0xFFFF)<<16) | ((0x1d1) & 0xFFFF))
+                ((((0x54) & 0xFFFF)<<16) | ((0x18e) & 0xFFFF))
+                ((((0x4c) & 0xFFFF)<<16) | ((0x18f) & 0xFFFF))
+                ((((0x4e) & 0xFFFF)<<16) | ((0x190) & 0xFFFF))
+                ((((0x55) & 0xFFFF)<<16) | ((0x191) & 0xFFFF))
+                ((((0x53) & 0xFFFF)<<16) | ((237) & 0xFFFF))
+                ((((0x52) & 0xFFFF)<<16) | ((238) & 0xFFFF))
+                ((((0x39) & 0xFFFF)<<16) | ((212) & 0xFFFF))
+                ((((0x41) & 0xFFFF)<<16) | ((213) & 0xFFFF))
+                ((((0x0b) & 0xFFFF)<<16) | ((214) & 0xFFFF))
+                ((((0x00) & 0xFFFF)<<16) | ((216) & 0xFFFF))
+                ((((0x13) & 0xFFFF)<<16) | ((217) & 0xFFFF))>;
+        };
+        map_2: map_2{
+            mapname = "amlogic-remote-3";
+            customcode = <0xbd02>;
+            release_delay = <80>;
+            size = <17>;
+            keymap = <((((0xca) & 0xFFFF)<<16) | ((103) & 0xFFFF))
+            ((((0xd2) & 0xFFFF)<<16) | ((108) & 0xFFFF))
+            ((((0x99) & 0xFFFF)<<16) | ((105) & 0xFFFF))
+            ((((0xc1) & 0xFFFF)<<16) | ((106) & 0xFFFF))
+            ((((0xce) & 0xFFFF)<<16) | ((97) & 0xFFFF))
+            ((((0x45) & 0xFFFF)<<16) | ((116) & 0xFFFF))
+            ((((0xc5) & 0xFFFF)<<16) | ((133) & 0xFFFF))
+            ((((0x80) & 0xFFFF)<<16) | ((113) & 0xFFFF))
+            ((((0xd0) & 0xFFFF)<<16) | ((15) & 0xFFFF))
+            ((((0xd6) & 0xFFFF)<<16) | ((125) & 0xFFFF))
+            ((((0x95) & 0xFFFF)<<16) | ((102) & 0xFFFF))
+            ((((0xdd) & 0xFFFF)<<16) | ((104) & 0xFFFF))
+            ((((0x8c) & 0xFFFF)<<16) | ((109) & 0xFFFF))
+            ((((0x89) & 0xFFFF)<<16) | ((131) & 0xFFFF))
+            ((((0x9c) & 0xFFFF)<<16) | ((130) & 0xFFFF))
+            ((((0x9a) & 0xFFFF)<<16) | ((120) & 0xFFFF))
+            ((((0xcd) & 0xFFFF)<<16) | ((121) & 0xFFFF))>;
+        };
+    };
+
+    galcore {
+        status = "disabled";
+        /delete-property/ memory-region;
+    };
+
+    nand: nfc@0 {
+        compatible = "amlogic, aml_mtd_nand";
+        dev_name = "mtdnand";
+        status = "disabled";
+        reg = <0x0 0xFFE07800 0x0 0x200>;
+        interrupts = <0 34 1>;
+        pinctrl-names = "nand_rb_mod","nand_norb_mod", "nand_cs_only";
+        pinctrl-0 = <&all_nand_pins>;
+        pinctrl-1 = <&all_nand_pins>;
+        pinctrl-2 = <&nand_cs_pins>;
+        clock-names = "core", "clkin";
+        device_id = <0>;
+        bl_mode = <1>;
+        fip_copies = <4>;
+        fip_size = <0x200000>;
+        nand_clk_ctrl = <0xFFE07000>;
+    };
+
+    ddr_bandwidth {
+        /delete-property/ sec_base;
+    };
+}; /* end of / */
+
+&meson_fb {
+	status = "okay";
+	display_size_default = <1920 1080 1920 2160 32>;
+	mem_size = <0x00800000 0x4b80000 0x100000 0x100000 0x800000>;
+	logo_addr = "0x3d800000";
+	mem_alloc = <1>;
+	pxp_mode = <0>; /** 0:normal mode 1:pxp mode */
+};
+
+&pwm_ab {
+	status = "okay";
+};
+
+&pwm_AO_cd {
+	status = "okay";
+};
+
+&audiobus {
+	/* tdmb to internal DAC output*/
+    /delete-node/ loopback@0;
+    /delete-node/ i2s2hdmi;
+	aml_tdmb: tdmb {
+		compatible = "amlogic, g12a-snd-tdmb";
+		#sound-dai-cells = <0>;
+		dai-tdm-lane-slot-mask-in = <0 1 0 0>;
+		dai-tdm-lane-slot-mask-out = <1 0 0 0>;
+		dai-tdm-clk-sel = <1>;
+		clocks = <&clkaudio CLKID_AUDIO_MCLK_B
+				&clkc CLKID_MPLL0>;
+		clock-names = "mclk", "clk_srcpll";
+		pinctrl-names = "tdm_pins";
+		pinctrl-0 = <&tdmb_mclk &tdmout_b &tdmin_b>;
+		mclk_pad = <0>;  /* 0: mclk_0; 1: mclk_1 */
+		i2s2hdmi = <0>;
+
+        /delete-property/ samesource_sel;
+	};
+	aml_spdif: spdif {
+		compatible = "amlogic, g12a-snd-spdif-a";
+		#sound-dai-cells = <0>;
+		clocks = <&clkc CLKID_MPLL0
+				&clkc CLKID_FCLK_DIV4
+				&clkaudio CLKID_AUDIO_SPDIFIN
+				&clkaudio CLKID_AUDIO_SPDIFOUT
+				&clkaudio CLKID_AUDIO_SPDIFIN_CTRL
+				&clkaudio CLKID_AUDIO_SPDIFOUT_CTRL>;
+		clock-names = "sysclk", "fixed_clk", "gate_spdifin",
+				"gate_spdifout", "clk_spdifin", "clk_spdifout";
+		interrupts =
+				<GIC_SPI 151 IRQ_TYPE_EDGE_RISING>;
+
+		interrupt-names = "irq_spdifin";
+		status = "disabled";
+
+        /delete-property/ pinctrl-names;
+	};
+	aml_spdif_b: spdif_b {
+		compatible = "amlogic, g12a-snd-spdif-b";
+		#sound-dai-cells = <0>;
+		clocks = <&clkc CLKID_MPLL0 /*CLKID_HIFI_PLL*/
+				&clkaudio CLKID_AUDIO_SPDIFOUTB
+				&clkaudio CLKID_AUDIO_SPDIFOUTB_CTRL>;
+		clock-names = "sysclk",
+				"gate_spdifout", "clk_spdifout";
+		status = "disabled";
+	};
+	aml_loopback: loopback {
+		compatible = "amlogic, snd-loopback";
+		/*
+		 * 0: out rate = in data rate;
+		 * 1: out rate = loopback data rate;
+		 */
+		lb_mode = <0>;
+
+		/* datain src
+		 * 0: tdmin_a;
+		 * 1: tdmin_b;
+		 * 2: tdmin_c;
+		 * 3: spdifin;
+		 * 4: pdmin;
+		 */
+		datain_src = <4>;
+		datain_chnum = <8>;
+		datain_chmask = <0x3f>;
+
+		/* tdmin_lb src
+		 * 0: tdmoutA
+		 * 1: tdmoutB
+		 * 2: tdmoutC
+		 * 3: PAD_tdminA
+		 * 4: PAD_tdminB
+		 * 5: PAD_tdminC
+		 */
+		datalb_src = <2>;
+		datalb_chnum = <8>;
+		datalb_chmask = <0x3>;
+
+		status = "disabled";
+	};
+
+	audioresample: resample {
+		compatible = "amlogic, g12a-resample";
+		clocks = <&clkc CLKID_MPLL3
+				&clkaudio CLKID_AUDIO_MCLK_F
+				&clkaudio CLKID_AUDIO_RESAMPLE_CTRL>;
+		clock-names = "resample_pll", "resample_src", "resample_clk";
+		/*same with toddr_src
+		 *	TDMIN_A, 0
+		 *	TDMIN_B, 1
+		 *	TDMIN_C, 2
+		 *	SPDIFIN, 3
+		 *	PDMIN,  4
+		 *	NONE,
+		 *	TDMIN_LB, 6
+		 *	LOOPBACK, 7
+		 */
+		resample_module = <4>;
+		status = "disabled";
+	};
+	aml_pwrdet: pwrdet {
+		compatible = "amlogic, g12a-power-detect";
+
+		interrupts = <GIC_SPI 155 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "pwrdet_irq";
+
+		/* pwrdet source sel
+		 * 7: loopback;
+		 * 6: tdmin_lb;
+		 * 5: reserved;
+		 * 4: pdmin;
+		 * 3: spdifin;
+		 * 2: tdmin_c;
+		 * 1: tdmin_b;
+		 * 0: tdmin_a;
+		 */
+		pwrdet_src = <4>;
+
+		hi_th = <0x70000>;
+		lo_th = <0x16000>;
+
+		status = "disabled";
+	};
+}; /* end of audiobus */
+
+&pinctrl_periphs {
+	tdmb_mclk: tdmb_mclk {
+		mux { /* GPIOA_0 */
+			groups = "mclk0_a";
+			function = "mclk0";
+			drive-strength = <2>;
+		};
+	};
+	tdmout_b: tdmout_b {
+		mux { /* GPIOA_1, GPIOA_2, GPIOA_3 */
+			groups = "tdmb_sclk",
+				"tdmb_fs",
+				"tdmb_dout0";
+			function = "tdmb_out";
+			drive-strength = <2>;
+		};
+	};
+	tdmin_b:tdmin_b {
+		mux { /* GPIOA_4 */
+			groups = "tdmb_din1";
+			function = "tdmb_in";
+			drive-strength = <2>;
+		};
+	};
+
+	bl_pwm_off_pins:bl_pwm_off_pin {
+		mux {
+			pins = "GPIOH_5";
+			function = "gpio_periphs";
+			output-high;
+		};
+	};
+
+	clk12_24_z_pins:clk12_24_z_pins {
+		mux {
+			groups = "clk12_24_z";
+			function = "clk12_24_ee";
+			drive-strength = <3>;
+		};
+	};
+
+    spifc_all_pins: spifc_all_pins {
+        mux {
+            groups = "nor_d",
+                "nor_q",
+                "nor_c";
+            function = "nor";
+            input-enable;
+            bias-pull-up;
+        };
+    };
+}; /* end of pinctrl_periphs */
+
+&a_uart_pins {
+    mux {
+        groups = "uart_tx_a",
+            "uart_rx_a",
+            "uart_rts_a";
+    };
+    mux1 {
+        groups = "uart_cts_a";
+        function = "uart_a";
+        bias-pull-down;
+    };
+};
+
+&audio_data {
+	status = "okay";
+};
+
+&sd_emmc_c {
+	status = "okay";
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vddio_ao1v8>;
+	emmc {
+        // /delete-property/ save_para;
+		// /delete-property/ compute_cmd_delay;
+		// /delete-property/ compute_coef;
+		caps = "MMC_CAP_8_BIT_DATA",
+			 "MMC_CAP_MMC_HIGHSPEED",
+			 "MMC_CAP_SD_HIGHSPEED",
+			 "MMC_CAP_NONREMOVABLE",
+			 "MMC_CAP_HW_RESET",
+			 "MMC_CAP_ERASE",
+			 "MMC_CAP_CMD23";
+		caps2 = "MMC_CAP2_HS200_1_8V_SDR",
+			"MMC_CAP2_BROKEN_VOLTAGE";
+		f_min = <400000>;
+		f_max = <200000000>;
+		hw_reset = <&gpio BOOT_12 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&sd_emmc_b {
+	status = "okay";
+	// sd-uhs-sdr25;
+	// sd-uhs-sdr50;
+	// sd-uhs-sdr104;
+	// max-frequency = <200000000>;
+	// vmmc-supply = <&vcc_sd>;
+	// vqmmc-supply = <&vddio_c>;
+	// sd {
+	// 	caps = "MMC_CAP_4_BIT_DATA",
+	// 		 "MMC_CAP_MMC_HIGHSPEED",
+	// 		 "MMC_CAP_SD_HIGHSPEED",
+	// 		 "MMC_CAP_UHS_SDR25",
+	// 		 "MMC_CAP_UHS_SDR50",
+	// 		 "MMC_CAP_UHS_SDR104",
+	// 		 "MMC_CAP_ERASE",
+	// 		 "MMC_CAP_CMD23";
+	// 	f_min = <400000>;
+	// 	f_max = <200000000>;
+    //     jtag_pin = <&gpio 42 0>;
+	// };
+};
+
+&sd_emmc_a {
+    status = "disabled";
+    sdio {
+        /delete-property/ caps;
+        /delete-property/ f_min;
+        /delete-property/ f_max;
+    };
+};
+
+&gpu {
+    min_clk = <4>;
+};
+
+&dvfs285_cfg {
+   threshold = <100 190>;
+};
+
+&dvfs500_cfg {
+   threshold = <180 220>;
+};
+
+&dvfs666_cfg {
+   threshold = <210 236>;
+};
+
+&dvfs850_cfg {
+   threshold = <230 255>;
+};
+
+&ethmac {
+    status = "disabled";
+    /delete-property/ mc_val;
+    /delete-property/ internal_phy;
+	/delete-property/ pinctrl-names;
+	/delete-property/ pinctrl-0;
+};
+
+&external_eth_pins {
+    mux {
+        groups = "eth_mdio",
+        "eth_mdc",
+        "eth_rgmii_rx_clk",
+        "eth_rx_dv",
+        "eth_rxd0",
+        "eth_rxd1",
+        "eth_rxd2_rgmii",
+        "eth_rxd3_rgmii",
+        "eth_rgmii_tx_clk",
+        "eth_txen",
+        "eth_txd0",
+        "eth_txd1",
+        "eth_txd2_rgmii",
+        "eth_txd3_rgmii";
+    };
+};
+
+&pinctrl_aobus {
+    /delete-node/ spdifout;
+    /delete-node/ spdifout_a_mute;
+};
+
+&aml_spdif {
+    /delete-property/ pinctrl-0;
+    /delete-property/ pinctrl-1;
+};
+
+&usb2_phy_v2 {
+	status = "okay";
+	portnum = <2>;
+};
+
+&dwc3 {
+	status = "okay";
+};
+
+&dwc2_a {
+	status = "okay";
+	/** 0: normal, 1: otg+dwc3 host only, 2: otg+dwc3 device only*/
+	controller-type = <3>;
+};
+
+&pcie_A {
+	reset-gpio = <&gpio GPIOX_7 GPIO_ACTIVE_HIGH>;
+	status = "disabled";
+    clock-names = "pcie_refpll",
+                "pcie",
+                "pcie_phy";
+};
+
+&usb3_phy_v2 {
+	status = "okay";
+	portnum = <1>;
+	otg = <1>;
+    /delete-property/ gpio-vbus-power;
+    /delete-property/ gpios;
+};
+
+&saradc {
+	status = "okay";
+};
+
+&i2c0 {
+	/delete-property/ pinctrl-names;
+	/delete-property/ pinctrl-0;
+	/delete-property/ clock-frequency;
+};
+
+&i2c2 {
+	/delete-property/ pinctrl-names;
+	/delete-property/ pinctrl-0;
+	/delete-property/ clock-frequency;
+};
+
+&isp {
+	status = "disabled";
+    temper-buf-size = <24>;
+    /delete-property/ temper-line-offset;
+	/delete-property/ temper-frame-num;
+	/delete-property/ temper-frame-size;
+	/delete-property/ memory-region;
+};
+
+&adapter {
+	status = "disabled";
+    mem_alloc = <48>;
+    /delete-property/ memory-region;
+};
+
+&amhdmitx {
+	status = "disabled";
+    interrupts = <0 57 1>;
+    interrupt-names = "hdmitx_hpd";
+};
+
+&aocec {
+	status = "disabled";
+    compatible = "amlogic, aocec-g12a";
+    ee_cec;
+    arc_port_mask = <0x02>;
+    /delete-property/ output;
+};
+
+&cbus {
+    spifc: spifc@14000 {
+        status = "disabled";
+        compatible = "amlogic,aml-spi-nor";
+        reg = <0x0 0x14000 0x0 0x80>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&spifc_all_pins>;
+        clocks = <&clkc 11>;
+        clock-names = "core";
+   };
+};
+
+&uart_A {
+    status = "disabled";
+};
+
+&vdin0 {
+    /delete-property/ cma_size;
+    /delete-property/ tv_bit_mode;
+};
+
+&vdin1 {
+    /delete-property/ memory-region;
+    /delete-property/ tv_bit_mode;
+};
+
+&meson_cooldev {
+    cooling_devices {
+        cpufreq_cool_cluster0 {
+            gpu_pp = <2>;
+        };
+        cpufreq_cool_cluster1 {
+            gpu_pp = <2>;
+        };
+        cpucore_cool_cluster {
+            dyn_coeff = <0>;
+            gpu_pp = <2>;
+        };
+        gpufreq_cool {
+            cluster_id = <0>;
+        };
+        gpucore_cool {
+            dyn_coeff = <0>;
+            cluster_id = <0>;
+            gpu_pp = <2>;
+        };
+    };
+};
+
+&pswitch_on {
+    temperature = <65000>;
+};
+
+&phot {
+    temperature = <95000>;
+};
+
+&soc_thermal {
+    cooling-maps {
+        /delete-node/ cpucore_cooling_map0;
+        cpufreq_cooling_map0 {
+            cooling-device = <&cpufreq_cool0 0 10>;
+        };
+        cpufreq_cooling_map1 {
+            cooling-device = <&cpufreq_cool1 0 9>;
+        };
+        cpucore_cooling_map {
+            trip = <&pcontrol>;
+            cooling-device = <&cpucore_cool 0 5>;
+            contribution = <1024>;
+        };
+        gpufreq_cooling_map {
+            cooling-device = <&gpufreq_cool0 0 4>;
+        };
+        gpucore_cooling_map {
+            cooling-device = <&gpucore_cool0 0 2>;
+        };
+    };
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi b/arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
new file mode 100755
index 000000000000..cd5c528a181e
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
@@ -0,0 +1,218 @@
+/*
+ * arch/arm64/boot/dts/amlogic/meson64_gou_joypad.dtsi
+ *
+ * Copyright (C) 2021 Hardkernel Co,. Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/{
+	gpio_keys: gou-gpio-keys {
+		compatible = "gpio-keys-polled";
+		poll-interval = <200>;
+		autorepeat;
+
+		button@0 {
+			label = "GPIO BTN-VOLUP";
+			linux,code = <KEY_VOLUMEUP>;
+                        gpios = <&gpio GPIOX_8 GPIO_ACTIVE_LOW>;
+		};
+		button@1 {
+			label = "GPIO BTN-VOLDN";
+			linux,code = <KEY_VOLUMEDOWN>;
+                        gpios = <&gpio GPIOX_9 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	joypad: gou_joypad {
+                compatible = "odroidgou-joypad";
+		status = "okay";
+
+                joypad-name = "GO-Ultra Gamepad";
+                joypad-product = <0x1000>;
+                joypad-revision = <0x0100>;
+
+                /*
+                  - odroidgou-joypad sysfs list -
+		   * for poll device interval(ms)
+		   /sys/devices/platform/gou_joypad/poll_interval [rw]
+		   ex) echo 20 > poll_interval
+                   * for button-adc-fuzz
+		   /sys/devices/platform/gou_joypad/adc_fuzz [r]
+                   * for button-adc-flat
+		   /sys/devices/platform/gou_joypad/adc_flat [r]
+
+		   * for report control(1:enable, 0:disable)
+		   /sys/devices/platform/gou_joypad/enable [rw]
+		   * for adc calibration value setup(current adcs value -> cal value)
+		   /sys/devices/platform/gou_joypad/adc_cal [rw]
+		   ex) echo 0 > adc_cal
+                */
+
+		/* gpio pincontrol setup */
+                /* pinctrl-names = "default"; */
+                /* pinctrl-0 = <&key_all_pins>; */
+
+		/* Analog mux define */
+		io-channels = <&saradc SARADC_CH0>,
+			      <&saradc SARADC_CH1>,
+			      <&saradc SARADC_CH2>,
+			      <&saradc SARADC_CH3>;
+		io-channel-names = "key-RY", "key-RX", "key-LY", "key-LX";
+
+		/* adc calculate scale */
+		button-adc-scale = <4>;
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <64>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+		  Analog Stick data tuning value(precent)
+		  p = positive direction, n = negative direction
+		  report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <350>;
+		abs_x-n-tuning = <350>;
+
+		abs_y-p-tuning = <350>;
+		abs_y-n-tuning = <350>;
+
+		abs_rx-p-tuning = <350>;
+		abs_rx-n-tuning = <350>;
+
+		abs_ry-p-tuning = <350>;
+		abs_ry-n-tuning = <350>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+
+		/*    *** ODROID-GOU Switch layoout ***
+		|------------------------------------------------|
+		| sw15  sw20        sw10   sw9        sw19  sw16 |
+		|------------------------------------------------|
+		|      sw18                            sw17      |
+		|              |-------------------|             |
+		|     sw1      |                   |      sw8    |
+		|  sw3   sw4   |                   |   sw7   sw5 |
+		|     sw2      |    LCD Display    |      sw6    |
+		|              |                   |             |
+		|    Analog    |                   |    Analog   |
+		|              |-------------------|             |
+		|  sw11 sw12              |   |       sw13 sw14  |
+		|-------------------------|uSD|------------------| */
+                /*  joypad driver is poll-device driver.
+                    poll-device is does not support wakeup-source.
+		*/
+                sw1 {
+                        gpios = <&gpio GPIOX_0 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-UP";
+                        linux,code = <BTN_DPAD_UP>; // 0x220
+                };
+                sw2 {
+                        gpios = <&gpio GPIOX_1 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-DOWN";
+                        linux,code = <BTN_DPAD_DOWN>; // 0x221
+                };
+                sw3 {
+                        gpios = <&gpio GPIOX_2 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-LEFT";
+                        linux,code = <BTN_DPAD_LEFT>; // 0x222
+                };
+                sw4 {
+                        gpios = <&gpio GPIOX_3 GPIO_ACTIVE_LOW>;
+                        label = "GPIO DPAD-RIGHT";
+                        linux,code = <BTN_DPAD_RIGHT>; // 0x223
+                };
+                sw5 {
+                        gpios = <&gpio GPIOX_4 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-A";
+                        linux,code = <BTN_EAST>; // 0x131
+                };
+                sw6 {
+                        gpios = <&gpio GPIOX_5 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-B";
+                        linux,code = <BTN_SOUTH>; // 0x130
+                };
+                sw7 {
+                        gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-Y";
+                        linux,code = <BTN_WEST>; // 0x134
+                };
+                sw8 {
+                        gpios = <&gpio GPIOX_7 GPIO_ACTIVE_LOW>;
+                        label = "GPIO BTN-X";
+                        linux,code = <BTN_NORTH>; // 0x133
+                };
+                sw11 {
+                        gpios = <&gpio GPIOX_10 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F2";
+                        linux,code = <BTN_TRIGGER_HAPPY2>; // 0x2c2
+                };
+                sw12 {
+                        gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F3";
+                        linux,code = <BTN_TRIGGER_HAPPY3>; // 0x2c3
+                };
+                sw13 {
+                        gpios = <&gpio GPIOX_12 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F4";
+                        linux,code = <BTN_TRIGGER_HAPPY4>; // 0x2c4
+                };
+                sw14 {
+                        gpios = <&gpio GPIOX_13 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F5";
+                        linux,code = <BTN_TRIGGER_HAPPY5>; // 0x13c
+                };
+                sw15 {
+                        gpios = <&gpio GPIOX_14 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT";
+                        linux,code = <BTN_TL>; // 0x02
+                };
+                sw16 {
+                        gpios = <&gpio GPIOX_15 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT";
+                        linux,code = <BTN_TR>; // 0x05
+                };
+                sw17 {
+                        gpios = <&gpio GPIOX_16 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F6";
+                        linux,code = <BTN_TRIGGER_HAPPY6>;
+                };
+                sw18 {
+                        gpios = <&gpio GPIOX_17 GPIO_ACTIVE_LOW>;
+                        label = "GPIO F1";
+                        linux,code = <BTN_TRIGGER_HAPPY1>;
+                };
+                sw19 {
+                        gpios = <&gpio GPIOX_18 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-RIGHT2";
+                        linux,code = <BTN_TR2>;
+                };
+                sw20 {
+                        gpios = <&gpio GPIOX_19 GPIO_ACTIVE_LOW>;
+                        label = "GPIO TOP-LEFT2";
+                        linux,code = <BTN_TL2>;
+                };
+        };
+};
diff --git a/arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi b/arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
new file mode 100755
index 000000000000..5ddb0eeab886
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
@@ -0,0 +1,214 @@
+/*
+ * arch/arm64/boot/dts/amlogic/meson64_gou_panel.dtsi
+ *
+ * Copyright (C) 2021 Hardkernel Co,. Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/ {
+	lcd{
+		compatible = "amlogic, lcd-g12b";
+		mode = "tablet";
+		status = "okay";
+		key_valid = <0>;
+		clocks = <&clkc CLKID_MIPI_DSI_HOST
+			&clkc CLKID_MIPI_DSI_PHY
+			&clkc CLKID_DSI_MEAS_COMP
+			&clkc CLKID_VCLK2_ENCL
+			&clkc CLKID_VCLK2_VENCL
+			&clkc CLKID_GP0_PLL>;
+		clock-names = "dsi_host_gate",
+			"dsi_phy_gate",
+			"dsi_meas",
+			"encl_top_gate",
+			"encl_int_gate",
+			"gp0_pll";
+		reg = <0x0 0xffd07000 0x0 0x400    /* dsi_host */
+			0x0 0xff644000 0x0 0x200>; /* dsi_phy */
+		interrupts = <0 3 1
+			0 56 1>;
+		interrupt-names = "vsync","vsync2";
+		pinctrl_version = <2>; /* for uboot */
+		clk_path = <1>; /* default gp0 pll */
+
+		/* power type:
+		 *    (0=cpu_gpio, 1=pmu_gpio, 2=signal,3=extern, 0xff=ending)
+		 * power index:
+		 *    (point gpios_index, or extern_index,0xff=invalid)
+		 * power value:(0=output low, 1=output high, 2=input)
+		 * power delay:(unit in ms)
+		 */
+		lcd_cpu-gpios = <&gpio GPIOH_4 GPIO_ACTIVE_HIGH>;
+		lcd_cpu_gpio_names = "GPIOH_4";
+
+		lcd_0{
+			model_name = "kd50t048a";
+				/*interface(ttl,lvds,mipi)*/
+			interface = "mipi";
+			basic_setting = <
+				480 854 /*h_active, v_active*/
+				542 884 /*h_period=hfp+hbp+hsync-len, v_period=vfp+vbp+vsync-len*/
+				8 /*lcd_bits*/
+				7 14>; /*screen_widht, screen_height*/
+			lcd_timing = <
+				12 12 0 /*hs_width(hsync-len),hs_bp,hs_pol*/
+				4 8 0>; /*vs_width(vsync-len),vs_bp,vs_pol*/
+			clk_attr = <0 /*fr_adj_type(0=clock,1=htotal,2=vtotal)*/
+				0 /*clk_ss_level*/
+				1 /*clk_auto_generate*/
+				28747680>; /*pixel_clk(unit in Hz) h_period*v_period*60 */
+			mipi_attr = <2 /*lane_num*/
+				400 /*bit_rate_max(MHz)*/
+				0 /*factor(*100, default 0 for auto)*/
+				1 /*operation_mode_init(0=video, 1=command)*/
+				0 /*operation_mode_display(0=video, 1=command)*/
+				2 /*
+				   *video_mode_type
+				   *(0=sync_pulse,1=sync_event,2=burst)
+				   */
+				1 /*clk_always_hs(0=disable,1=enable)*/
+				0>; /*phy_switch(0=auto,1=standard,2=slow)*/
+				/* dsi_init: data_type, num, data... */
+			dsi_init_on = <0xff 0>; /* ending flag */
+			dsi_init_off = <0xff 0>; /* ending flag */
+				/* extern_init: 0xff for invalid */
+			extern_init = <0>;
+				/* power step: type,index,value,delay(ms) */
+			power_on_step = <0 0 1 1
+					0 0 0 1
+					0 0 1 120
+					3 0 0 0
+					0xff 0 0 0>;
+			power_off_step = <3 0 0 50
+					0 0 0 100
+					0xff 0 0 0>;
+		};
+	};
+
+	lcd_extern{
+		compatible = "amlogic, lcd_extern";
+		status = "okay";
+		i2c_bus = "i2c_bus_0";
+		key_valid = <0>;
+
+		extern_0{
+			index = <0>;
+			extern_name = "mipi_ST7701";/*ST7701*/
+			status = "okay";
+			type = <2>; /* 0=i2c, 1=spi, 2=mipi */
+			cmd_size = <0xff>;
+			init_on = <
+				0x13  1 0x11
+				0xfd  1 120	/* delay (ms) */
+
+				0x29  6 0xFF 0x77 0x01 0x00 0x00 0x10
+				0x29  3 0xC0 0xE9 0x03
+				0x29  3 0xC1 0x11 0x02
+				0x29  3 0xC2 0x31 0x08
+				0x23  2 0xCC 0x10
+				0x29 17 0xB0 0x00 0x0D 0x14 0x0D 0x10 0x05 0x02 0x08
+				        0x08 0x1E 0x05 0x13 0x11 0xA3 0x29 0x18
+				0x29 17 0xB1 0x00 0x0C 0x14 0x0C 0x10 0x05 0x03 0x08
+				        0x07 0x20 0x05 0x13 0x11 0xA4 0x29 0x18
+				0x29  6 0xFF 0x77 0x01 0x00 0x00 0x11
+				0x23  2 0xB0 0x6C
+				0x23  2 0xB1 0x43
+				0x23  2 0xB2 0x07
+				0x23  2 0xB3 0x80
+				0x23  2 0xB5 0x47
+				0x23  2 0xB7 0x85
+				0x23  2 0xB8 0x20
+				0x23  2 0xB9 0x10
+				0x23  2 0xC1 0x78
+				0x23  2 0xC3 0x78
+				0x23  2 0xD0 0x88
+				0xfd  1 250 /* delay (ms) */
+
+				0x29  4 0xE0 0x00 0x00 0x02
+				0x29 12 0xE1 0x08 0x00 0x0A 0x00 0x07 0x00 0x09 0x00
+					0x00 0x33 0x33
+				0x29 15 0xE2 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
+					0x00 0x00 0x00 0x00 0x00 0x00
+				0x29  5 0xE3 0x00 0x00 0x33 0x33
+				0x29  3 0xE4 0x44 0x44
+				0x29 17 0xE5 0x0E 0x60 0xA0 0xA0 0x10 0x60 0xA0 0xA0
+				        0x0A 0x60 0xA0 0xA0 0x0C 0x60 0xA0 0xA0
+				0x29  5 0xE6 0x00 0x00 0x33 0x33
+				0x29  3 0xE7 0x44 0x44
+				0x29 17 0xE8 0x0D 0x60 0xA0 0xA0 0x0F 0x60 0xA0 0xA0
+				        0x09 0x60 0xA0 0xA0 0x0B 0x60 0xA0 0xA0
+				0x29  8 0xEB 0x02 0x01 0xE4 0xE4 0x44 0x00 0x40
+				0x29  3 0xEC 0x02 0x01
+				0x29 17 0xED 0xAB 0x89 0x76 0x54 0x01 0xFF 0xFF 0xFF
+				        0xFF 0xFF 0xFF 0x10 0x45 0x67 0x98 0xBA
+				0x29  6 0xFF 0x77 0x01 0x00 0x00 0x00
+				0x23  2 0x3A 0x70
+				0x23  2 0x53 0xEC
+				0x23  2 0x55 0xB3
+				0x23  2 0x5E 0xFF
+				0x13  1 0x29
+				0xfd  1 50	/* delay (ms) */
+				0xff  0>; /*ending*/
+			init_off = <
+				0x05 1 0x28 /* display off */
+				0xfd 1 10   /* delay 10ms */
+				0x05 1 0x10 /* sleep in */
+				0xfd 1 150  /* delay 150ms */
+				0xff 0>;    /*ending*/
+		};
+	};
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm_ef MESON_PWM_1 40000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <200>;
+	};
+};/* end of panel */
+
+&pwm_ef {
+	status = "okay";
+	pinctrl-names = "pwm_pins";
+	pinctrl-0 = <&pwm_f_pins2>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi b/arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
new file mode 100755
index 000000000000..a244975e5f95
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
@@ -0,0 +1,474 @@
+/*
+ * arch/arm64/boot/dts/amlogic/meson64_gou_pmic.dtsi
+ *
+ * Copyright (C) 2021 Hardkernel Co,. Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/{
+	vcc_sys_817: sys_3v8_817 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys_817";
+		regulator-always-on;
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+	};
+	vcc_sys_818: sys_3v8_818 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys_818";
+		regulator-always-on;
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+	};
+	codec_clk: codec-clk {
+		compatible = "fixed-clock";
+		clock-frequency = <12288000>;
+		clock-output-names = "codec_clk";
+		#clock-cells = <0>;
+	};
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&ao_i2c_master_pins1>;
+	clock-frequency = <400000>;
+
+	rk818: pmic@1c {
+		compatible = "rockchip,rk818";
+		reg = <0x1c>;
+		status = "okay";
+		gpio-irq = <&gpio_ao GPIOAO_7 GPIO_ACTIVE_LOW>;
+		rockchip,system-power-controller;
+		//wakeup-source;
+		clock-output-names = "rk818-clkout1", "wifibt_32kin";
+		#clock-cells = <1>;
+
+		vcc1-supply = <&vcc_sys_818>;
+		vcc2-supply = <&vcc_sys_818>;
+		vcc3-supply = <&vcc_sys_818>;
+		vcc4-supply = <&vcc_sys_818>;
+		vcc6-supply = <&vcc_sys_818>;
+		vcc7-supply = <&vcc_2v3>;
+		vcc8-supply = <&vcc_2v3>;
+		vcc9-supply = <&vddao_3v3>;
+
+		regulators {
+			vddcpu_a: DCDC_REG1 {
+				regulator-name = "vdd_cpu_a";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1450000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+
+			vdd_ee: DCDC_REG2 {
+				regulator-name = "vdd_ee";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+
+			vddq_1v1: DCDC_REG3 {
+				regulator-name = "vcc_ddr";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vddao_3v3: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vddao_3v3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vdd_ldo1: LDO_REG1 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO1";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_ldo2: LDO_REG2 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO2";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_ldo3: LDO_REG3 {
+				regulator-boot-off;
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <1000000>;
+				regulator-name = "rk818_LDO3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_ldo4: LDO_REG4 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO4";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vddio_ao1v8: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vddio_ao1v8";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			LDO_REG6 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO6";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <2500000>;
+				};
+			};
+
+			vddq_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_18";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdd_ldo8: LDO_REG8 {
+				regulator-boot-off;
+				regulator-name = "rk818_LDO8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vddio_c: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vddio_c";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_sd: SWITCH_REG {
+				regulator-name = "vcc_sd";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			boost_otg: DCDC_BOOST {
+				regulator-name = "boost_otg";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			rk818_otg_switch: OTG_SWITCH {
+				regulator-name = "rk818_otg_switch";
+			};
+		};
+		battery {
+			compatible = "rk818-battery";
+			ocv_table = <
+				3470 3599 3671 3701 3728 3746 3762
+				3772 3781 3792 3816 3836 3866 3910
+				3942 3971 4002 4050 4088 4132 4200>;
+			design_capacity = <4000>;
+			design_qmax = <4100>;
+			bat_res = <180>;
+			max_input_current = <2000>;
+			max_chrg_current = <1500>;
+			max_chrg_voltage = <4250>;
+			sleep_enter_current = <300>;
+			sleep_exit_current = <300>;
+			power_off_thresd = <3450>;
+			zero_algorithm_vol = <3700>;
+			fb_temperature = <105>;
+			sample_res = <10>;
+			max_soc_offset = <60>;
+			energy_mode = <0>;
+			monitor_sec = <5>;
+			virtual_power = <0>;
+			power_dc2otg = <0>;
+			otg_switch-supply = <&rk818_otg_switch>;
+			otg5v_suspend_enable = <0>;
+			dc_det_gpio = <&gpio_ao GPIOAO_8 GPIO_ACTIVE_LOW>;
+			chg_led_gpio = <&gpio_ao GPIOAO_6 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c3_master_pins2>;
+	clock-frequency = <400000>;
+
+	rk817: pmic@20 {
+		compatible = "rockchip,rk817";
+		reg = <0x20>;
+		status = "okay";
+		gpio-irq = <&gpio_ao GPIOAO_5 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "pmic-sleep",
+				"pmic-power-off", "pmic-reset";
+		pinctrl-0 = <&rk817_slppin_null>;
+		pinctrl-1 = <&rk817_slppin_slp>;
+		pinctrl-2 = <&rk817_slppin_pwrdn>;
+		pinctrl-3 = <&rk817_slppin_rst>;
+
+		//rockchip,system-power-controller;
+		wakeup-source;
+		/* #clock-cells = <1>; */
+		/* clock-output-names = "rk808-clkout1", "rk808-clkout2"; */
+		fb-inner-reg-idxs = <2>;
+
+		/* 1: rst regs (default in codes), 0: rst the pmic */
+		pmic-reset-func = <0>;
+
+		vcc1-supply = <&vcc_sys_817>;
+		vcc2-supply = <&vcc_sys_817>;
+		vcc3-supply = <&vcc_sys_817>;
+		vcc4-supply = <&vcc_sys_817>;
+		vcc5-supply = <&vcc_sys_817>;
+		vcc6-supply = <&vcc_sys_817>;
+		vcc7-supply = <&vcc_sys_817>;
+		vcc8-supply = <&vcc_sys_817>;
+		vcc9-supply = <&rk817_boost>;
+
+		pinctrl_rk8xx: pinctrl_rk8xx {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk817_ts_gpio1: rk817_ts_gpio1 {
+				pins = "gpio_ts";
+				function = "pin_fun1";
+				/* output-low; */
+				/* input-enable; */
+			};
+
+			rk817_gt_gpio2: rk817_gt_gpio2 {
+				pins = "gpio_gt";
+				function = "pin_fun1";
+			};
+
+			rk817_pin_ts: rk817_pin_ts {
+				pins = "gpio_ts";
+				function = "pin_fun0";
+			};
+
+			rk817_pin_gt: rk817_pin_gt {
+				pins = "gpio_gt";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_null: rk817_slppin_null {
+				pins = "gpio_slp";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_slp: rk817_slppin_slp {
+				pins = "gpio_slp";
+				function = "pin_fun1";
+			};
+
+			rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+				pins = "gpio_slp";
+				function = "pin_fun2";
+			};
+
+			rk817_slppin_rst: rk817_slppin_rst {
+				pins = "gpio_slp";
+				function = "pin_fun3";
+			};
+		};
+
+		regulators {
+			/* Not Used */
+			DCDC_REG1 {
+				regulator-boot-off;
+				regulator-name = "rk817_BUCK1";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vddcpu_b: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1450000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_cpu_b";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1000000>;
+				};
+			};
+			vcc_2v3: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_2v3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+			DCDC_REG4 {
+				regulator-boot-off;
+				regulator-name = "rk817_BUCK4";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG1 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO1";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG2 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO2";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG3 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vdd_codec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vdd_codec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG5 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO5";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG6 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO6";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG7 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO7";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			vcc_lcd: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcc_lcd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			LDO_REG9 {
+				regulator-boot-off;
+				regulator-name = "rk817_LDO9";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			rk817_boost: BOOST {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5400000>;
+				regulator-name = "boost";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+			OTG_SWITCH {
+				regulator-name = "rk817_otg_switch";
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+
+		rk817_codec: codec {
+			#sound-dai-cells = <0>;
+			compatible = "rockchip,rk817-codec";
+			clocks = <&codec_clk>;
+			clock-names = "mclk";
+			hp-volume = <20>;
+			spk-volume = <3>;
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index 5b15911709aa..e41f68ad0832 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -69,6 +69,8 @@ phys_addr_t __fdt_pointer __initdata;
 const char *machine_name;
 EXPORT_SYMBOL(machine_name);
 
+bool emuelec_is_ogu = false;
+
 /*
  * Standard memory resources
  */
@@ -198,8 +200,13 @@ static void __init setup_machine_fdt(phys_addr_t dt_phys)
 	}
 	
 	name_dtid = of_flat_dt_get_coreelec_dt_id();
-	if (name_dtid)
+	if (name_dtid) {
 		pr_info("CoreELEC dt-id: %s\n", name_dtid);
+        if (!strcmp(name_dtid, "g12b_s922x_odroid_go_ultra")) {
+            emuelec_is_ogu = true;
+            pr_info("EmuELEC OGU: Warning, OGU on CE kernel is still under heavy development, prepare for major breaks :) - 7Ji");
+        }
+    }
 
 	name = of_flat_dt_get_machine_name();
 	if (!name)
diff --git a/drivers/amlogic/media/osd/osd_fb.c b/drivers/amlogic/media/osd/osd_fb.c
index 192948b9c0b9..e0028b30e46e 100644
--- a/drivers/amlogic/media/osd/osd_fb.c
+++ b/drivers/amlogic/media/osd/osd_fb.c
@@ -56,6 +56,8 @@
 #ifdef CONFIG_AMLOGIC_VPU
 #include <linux/amlogic/media/vpu/vpu.h>
 #endif
+#include <linux/platform_data/emuelec.h>
+#define CONFIG_ARCH_MESON64_ODROID_COMMON
 /* Local Headers */
 #include "osd.h"
 #include "osd_fb.h"
@@ -388,6 +390,35 @@ struct ion_handle *fb_ion_handle[OSD_COUNT][OSD_MAX_BUF_NUM];
 
 static int osd_cursor(struct fb_info *fbi, struct fb_cursor *var);
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+extern int  soft_cursor(struct fb_info *info, struct fb_cursor *cursor);
+
+static int osd_set_fb_var(int index, const struct vinfo_s *vinfo)
+{
+	if ((vinfo->width < 0) || (vinfo->height < 0)) {
+		pr_err("invalid vinfo\n");
+		return 1;
+	}
+
+	fb_def_var[index].xres = vinfo->width;
+	fb_def_var[index].yres = vinfo->height;
+	fb_def_var[index].xres_virtual = vinfo->width;
+	fb_def_var[index].yres_virtual = vinfo->height * 2;
+	fb_def_var[index].bits_per_pixel = 32;
+
+	return 0;
+}
+
+static void osd_set_fb_parameters(int index, const struct vinfo_s *vinfo)
+{
+	osd_set_free_scale_enable_hw(index, 0);
+	osd_set_free_scale_mode_hw(index, 1);
+	osd_set_free_scale_axis_hw(index, 0, 0, vinfo->width, vinfo->height);
+	osd_set_window_axis_hw(index, 0, 0, vinfo->width, vinfo->height);
+	osd_enable_hw(index, 1);
+}
+#endif /*CONFIG_ARCH_MESON64_ODROID_COMMON*/
+
 phys_addr_t get_fb_rmem_paddr(int index)
 {
 	if (index < 0 || index > 1)
@@ -1913,12 +1944,48 @@ static int osd_release(struct fb_info *info, int arg)
 	return err;
 }
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+extern void control_hdmiphy(bool on);
+
+static bool monitor_onoff_action;
+
+static int __init osd_setup_monitor_onoff(char *str)
+{
+	if (!strcmp(str, "true") || !strcmp(str, "1"))
+		monitor_onoff_action = true;
+	else
+		monitor_onoff_action = false;
+
+	return 0;
+}
+__setup("monitor_onoff=", osd_setup_monitor_onoff);
+#endif
+
 int osd_blank(int blank_mode, struct fb_info *info)
 {
 	osd_enable_hw(info->node, (blank_mode != 0) ? 0 : 1);
 	return 0;
 }
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	if (!monitor_onoff_action)
+		return 0;
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		control_hdmiphy(true);
+		break;
+	case FB_BLANK_POWERDOWN:
+		control_hdmiphy(false);
+		break;
+	case FB_BLANK_NORMAL:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_VSYNC_SUSPEND:
+	default:
+		break;
+	}
+#endif
+
 static int osd_pan_display(struct fb_var_screeninfo *var,
 			   struct fb_info *fbi)
 {
@@ -4597,7 +4664,36 @@ static int osd_probe(struct platform_device *pdev)
 					&var_screeninfo[0], 5);
 			if (ret)
 				osd_log_info("not found display_size_default\n");
-			else {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+			else if  (emuelec_is_ogu) {
+                if (osd_set_fb_var(index, vinfo)) {
+					/* no available vinfo, set default */
+					fb_def_var[index].xres =
+						var_screeninfo[0];
+					fb_def_var[index].yres =
+						var_screeninfo[1];
+					fb_def_var[index].xres_virtual =
+						var_screeninfo[2];
+					fb_def_var[index].yres_virtual =
+						var_screeninfo[3];
+					fb_def_var[index].bits_per_pixel =
+						var_screeninfo[4];
+				}
+				pr_info("fb def : %d %d %d %d %d\n",
+					fb_def_var[index].xres,
+					fb_def_var[index].yres,
+					fb_def_var[index].xres_virtual,
+					fb_def_var[index].yres_virtual,
+					fb_def_var[index].bits_per_pixel);
+				pr_info("init fbdev bpp is:%d\n",
+					fb_def_var[index].bits_per_pixel);
+
+				if (fb_def_var[index].bits_per_pixel > 32)
+					fb_def_var[index].bits_per_pixel = 32;
+            } else {
+#else
+            else {
+#endif
 				fb_def_var[index].xres = var_screeninfo[0];
 				fb_def_var[index].yres = var_screeninfo[1];
 				fb_def_var[index].xres_virtual =
@@ -4657,6 +4753,11 @@ static int osd_probe(struct platform_device *pdev)
 			for (i = 0; i < ARRAY_SIZE(osd_attrs_viu2); i++)
 			ret = device_create_file(fbi->dev, &osd_attrs_viu2[i]);
 		}
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+		if (index == DEV_OSD0)
+			osd_set_fb_parameters(DEV_OSD0, vinfo);
+#endif
 	}
 #ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
 	early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING;
diff --git a/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c b/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c
index 15e0d7989ba8..a1c62d6f23f3 100644
--- a/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c
+++ b/drivers/amlogic/media/vout/lcd/lcd_extern/mipi_ST7701.c
@@ -25,7 +25,9 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/of_fdt.h>
 #include <linux/amlogic/media/vout/lcd/lcd_extern.h>
+#include <linux/platform_data/emuelec.h>
 #include "lcd_extern.h"
 
 #define LCD_EXTERN_NAME			"mipi_ST7701"
@@ -34,7 +36,61 @@
  * format:  data_type, num, data....
  * special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
  */
-static unsigned char mipi_init_on_table[] = {
+static unsigned char mipi_init_on_table_ogu[] = {
+	0x13, 1, 0x01,
+	0xfd, 1, 5,	/* delay (ms) */
+	0x13, 1, 0x11,
+	0xfd, 1, 250,	/* delay (ms) */
+
+	0x29, 6, 0xFF, 0x77, 0x01, 0x00, 0x00, 0x10,
+	0x29, 3, 0xC0, 0xE9, 0x03,
+	0x29, 3, 0xC1, 0x11, 0x02,
+	0x29, 3, 0xC2, 0x31, 0x08,
+	0x23, 2, 0xCC, 0x10,
+	0x29,17, 0xB0, 0x00, 0x0D, 0x14, 0x0D, 0x10, 0x05, 0x02, 0x08,
+	         0x08, 0x1E, 0x05, 0x13, 0x11, 0xA3, 0x29, 0x18,
+	0x29,17, 0xB1, 0x00, 0x0C, 0x14, 0x0C, 0x10, 0x05, 0x03, 0x08,
+	         0x07, 0x20, 0x05, 0x13, 0x11, 0xA4, 0x29, 0x18,
+	0x29, 6, 0xFF, 0x77, 0x01, 0x00, 0x00, 0x11,
+	0x23, 2, 0xB0, 0x6C,
+	0x23, 2, 0xB1, 0x43,
+	0x23, 2, 0xB2, 0x07,
+	0x23, 2, 0xB3, 0x80,
+	0x23, 2, 0xB5, 0x47,
+	0x23, 2, 0xB7, 0x85,
+	0x23, 2, 0xB8, 0x20,
+	0x23, 2, 0xB9, 0x10,
+	0x23, 2, 0xC1, 0x78,
+	0x23, 2, 0xC3, 0x78,
+	0x23, 2, 0xD0, 0x88,
+	0xfd, 1, 250,	/* delay (ms) */
+
+	0x29, 4, 0xE0, 0x00, 0x00, 0x02,
+	0x29,12, 0xE1, 0x08, 0x00, 0x0A, 0x00, 0x07, 0x00, 0x09, 0x00, 0x00, 0x33, 0x33,
+	0x29,15, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x29, 5, 0xE3, 0x00, 0x00, 0x33, 0x33,
+	0x29, 3, 0xE4, 0x44, 0x44,
+	0x29,17, 0xE5, 0x0E, 0x60, 0xA0, 0xA0, 0x10, 0x60, 0xA0, 0xA0,
+	         0x0A, 0x60, 0xA0, 0xA0, 0x0C, 0x60, 0xA0, 0xA0,
+	0x29, 5, 0xE6, 0x00, 0x00, 0x33, 0x33,
+	0x29, 3, 0xE7, 0x44, 0x44,
+	0x29,17, 0xE8, 0x0D, 0x60, 0xA0, 0xA0, 0x0F, 0x60, 0xA0, 0xA0,
+	         0x09, 0x60, 0xA0, 0xA0, 0x0B, 0x60, 0xA0, 0xA0,
+	0x29, 8, 0xEB, 0x02, 0x01, 0xE4, 0xE4, 0x44, 0x00, 0x40,
+	0x29, 3, 0xEC, 0x02, 0x01,
+	0x29,17, 0xED, 0xAB, 0x89, 0x76, 0x54, 0x01, 0xFF, 0xFF, 0xFF,
+	         0xFF, 0xFF, 0xFF, 0x10, 0x45, 0x67, 0x98, 0xBA,
+	0x29, 6, 0xFF, 0x77, 0x01, 0x00, 0x00, 0x00,
+	0x23, 2, 0x3A, 0x70,
+	0x23, 2, 0x53, 0xEC,
+	0x23, 2, 0x55, 0xB3,
+	0x23, 2, 0x5E, 0xFF,
+	0x13, 1, 0x29,
+	0xfd, 1, 50,	/* delay (ms) */
+	0xff, 0,   	/* ending flag */
+};
+
+static unsigned char mipi_init_on_table_generic[] = {
 	0x13, 1, 0x11,
 	//0x13, 1, 0x21,
 	//0x23, 2, 0x36, 0x00,
@@ -98,7 +154,15 @@ static unsigned char mipi_init_on_table[] = {
 	0xff, 0xff,   /* ending flag */
 };
 
-static unsigned char mipi_init_off_table[] = {
+static unsigned char mipi_init_off_table_ogu[] = {
+	0x05, 1, 0x28,	/* display off */
+	0xfd, 1, 10,	/* delay 10ms */
+	0x05, 1, 0x10,	/* sleep in */
+	0xfd, 1, 150,	/* delay 150ms */
+	0xff, 0,   	/* ending flag */
+};
+
+static unsigned char mipi_init_off_table_generic[] = {
 	0x05, 1, 0x28, /* display off */
 	0xff, 10,      /* delay 10ms */
 	0x05, 1, 0x10, /* sleep in */
@@ -114,10 +178,20 @@ static int lcd_extern_driver_update(struct aml_lcd_extern_driver_s *ext_drv)
 	}
 
 	ext_drv->config->cmd_size = LCD_EXT_CMD_SIZE_DYNAMIC;
-	ext_drv->config->table_init_on  = &mipi_init_on_table[0];
-	ext_drv->config->table_init_on_cnt  = sizeof(mipi_init_on_table);
-	ext_drv->config->table_init_off = &mipi_init_off_table[0];
-	ext_drv->config->table_init_off_cnt  = sizeof(mipi_init_off_table);
+
+    if (emuelec_is_ogu) {
+        EXTPR("OGU ST7001 update\n");
+        ext_drv->config->table_init_on  = &mipi_init_on_table_ogu[0];
+        ext_drv->config->table_init_on_cnt  = sizeof(mipi_init_on_table_ogu);
+        ext_drv->config->table_init_off = &mipi_init_off_table_ogu[0];
+        ext_drv->config->table_init_off_cnt  = sizeof(mipi_init_off_table_ogu);
+    } else {
+        EXTPR("Generic ST7001 update\n");
+        ext_drv->config->table_init_on  = &mipi_init_on_table_generic[0];
+        ext_drv->config->table_init_on_cnt  = sizeof(mipi_init_on_table_generic);
+        ext_drv->config->table_init_off = &mipi_init_off_table_generic[0];
+        ext_drv->config->table_init_off_cnt  = sizeof(mipi_init_off_table_generic);
+    }
 
 	return 0;
 }
@@ -125,8 +199,24 @@ static int lcd_extern_driver_update(struct aml_lcd_extern_driver_s *ext_drv)
 int aml_lcd_extern_mipi_st7701_probe(struct aml_lcd_extern_driver_s *ext_drv)
 {
 	int ret = 0;
-
-	ret = lcd_extern_driver_update(ext_drv);
+    // char const *const ce_id = of_flat_dt_get_coreelec_dt_id();
+    // int ogu = 0;
+    // if (ce_id) {
+    //     if (!strcmp(ce_id, "g12b_s922x_odroid_go_ultra")) {
+    //         EXTPR("Device is OGU, running its specific init\n");
+    //         ogu = 1;
+    //     }
+    // } else {
+    //     EXTPR("Failed to get CE_ID to determine whether it's OGU or not\n");
+    // }
+    // if (of_property_read_string(of_root, "coreelec-dt-id", &model_name)) {
+    //     if (lcd_debug_print_flag) {
+	// 	    EXTPR("%s: %d\n", __func__, ret);
+    //     }
+    // } else if (!strcmp(model_name, "Hardkernel ODROID-GOU")) {
+    //     ogu = true;
+    // }
+    ret = lcd_extern_driver_update(ext_drv);
 
 	if (lcd_debug_print_flag)
 		EXTPR("%s: %d\n", __func__, ret);
diff --git a/drivers/amlogic/media/vout/vout_serve/vout_serve.c b/drivers/amlogic/media/vout/vout_serve/vout_serve.c
index 6e0f122578c0..f354f9f58f87 100644
--- a/drivers/amlogic/media/vout/vout_serve/vout_serve.c
+++ b/drivers/amlogic/media/vout/vout_serve/vout_serve.c
@@ -62,7 +62,11 @@ static int early_resume_flag;
 #define VMODE_NAME_LEN_MAX    64
 static struct class *vout_class;
 static DEFINE_MUTEX(vout_serve_mutex);
+#ifdef CONFIG_AMLOGIC_LCD
+static char vout_mode_uboot[VMODE_NAME_LEN_MAX] = "panel";
+#else
 static char vout_mode_uboot[VMODE_NAME_LEN_MAX] = "null";
+#endif
 static char vout_mode[VMODE_NAME_LEN_MAX] __nosavedata;
 static char local_name[VMODE_NAME_LEN_MAX] = {0};
 static u32 vout_init_vmode = VMODE_INIT_NULL;
@@ -310,12 +314,19 @@ static int set_vout_init_mode(void)
 
 	vout_init_vmode = validate_vmode(local_name, frac);
 	if (vout_init_vmode >= VMODE_MAX) {
+#ifdef CONFIG_AMLOGIC_LCD
+        VOUTERR("no matched vout_init mode %s, force to panel\n",
+			vout_mode_uboot);
+        snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", "panel");
+        vout_init_vmode = validate_vmode("panel", frac);
+#else
 		VOUTERR("no matched vout_init mode %s, force to invalid\n",
 			vout_mode_uboot);
 		nulldisp_index = 1;
 		vout_init_vmode = nulldisp_vinfo[nulldisp_index].mode;
 		snprintf(local_name, VMODE_NAME_LEN_MAX, "%s",
 			 nulldisp_vinfo[nulldisp_index].name);
+#endif
 	} else { /* recover vout_mode_uboot */
 		snprintf(local_name, VMODE_NAME_LEN_MAX, "%s", vout_mode_uboot);
 	}
diff --git a/drivers/amlogic/mmc/aml_sd_emmc.c b/drivers/amlogic/mmc/aml_sd_emmc.c
index 3fa135f65320..c69c3c2bdfbe 100644
--- a/drivers/amlogic/mmc/aml_sd_emmc.c
+++ b/drivers/amlogic/mmc/aml_sd_emmc.c
@@ -42,6 +42,7 @@
 #include <linux/mmc/emmc_partitions.h>
 #include <linux/amlogic/amlsd.h>
 #include <linux/amlogic/aml_sd_emmc_v3.h>
+#include <linux/platform_data/emuelec.h>
 
 struct mmc_host *sdio_host;
 
@@ -2967,7 +2968,25 @@ static int meson_mmc_get_cd(struct mmc_host *mmc)
 
 int aml_signal_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)
 {
-	return aml_sd_voltage_switch(mmc, ios->signal_voltage);
+    if (emuelec_is_ogu) {
+        pr_info("Voltage switch: OGU logic\n");
+        struct amlsd_platform *pdata = mmc_priv(mmc);
+        int ret = 0;
+
+        if (pdata->vol_switch) {
+            ret = aml_sd_voltage_switch(mmc, ios->signal_voltage);
+            if (ret)
+                dev_warn(mmc_dev(mmc), "Voltage switch failed\n");
+        } else {
+            ret = mmc_regulator_set_vqmmc(mmc, ios);
+            if (ret)
+                dev_warn(mmc_dev(mmc), "Regulator switch failed\n");
+        }
+        return ret;
+    } else {
+        pr_info("Voltage switch: Generic logic\n");
+        return aml_sd_voltage_switch(mmc, ios->signal_voltage);
+    }
 }
 
 /* Check if the card is pulling dat[0:3] low */
@@ -3333,7 +3352,10 @@ static int meson_mmc_probe(struct platform_device *pdev)
 			writel(boot_poll_en, host->pinmux_base
 					+ (host->data->ds_pin_poll_en << 2));
 		}
-
+        if (emuelec_is_ogu) {
+            pr_info("MMC probe: OGU logic, try to get supply from regulator\n");
+            ret = mmc_regulator_get_supply(mmc);
+        }
 		if (aml_card_type_mmc(pdata)
 				&& (host->ctrl_ver < 3))
 			/**set emmc tx_phase regs here base on dts**/
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
index e0c09f3cb88c..a772a714df23 100644
--- a/drivers/base/dma-contiguous.c
+++ b/drivers/base/dma-contiguous.c
@@ -35,6 +35,7 @@
 #endif
 
 struct cma *dma_contiguous_default_area;
+EXPORT_SYMBOL_GPL(dma_contiguous_default_area);
 
 /*
  * Default global CMA area size can be defined in kernel's .config.
diff --git a/drivers/clk/clk-rk808.c b/drivers/clk/clk-rk808.c
index 6461f2820a5b..73c508eddcd1 100644
--- a/drivers/clk/clk-rk808.c
+++ b/drivers/clk/clk-rk808.c
@@ -22,8 +22,11 @@
 #include <linux/mfd/rk808.h>
 #include <linux/i2c.h>
 
+#define RK808_NR_OUTPUT 2
+
 struct rk808_clkout {
 	struct rk808 *rk808;
+	struct clk_onecell_data clk_data;
 	struct clk_hw		clkout1_hw;
 	struct clk_hw		clkout2_hw;
 };
@@ -82,18 +85,65 @@ static const struct clk_ops rk808_clkout2_ops = {
 	.recalc_rate = rk808_clkout_recalc_rate,
 };
 
-static struct clk_hw *
-of_clk_rk808_get(struct of_phandle_args *clkspec, void *data)
+static int rk817_clkout2_enable(struct clk_hw *hw, bool enable)
+{
+	struct rk808_clkout *rk808_clkout = container_of(hw,
+							 struct rk808_clkout,
+							 clkout2_hw);
+	struct rk808 *rk808 = rk808_clkout->rk808;
+
+	return regmap_update_bits(rk808->regmap, RK817_SYS_CFG(1),
+				  RK817_CLK32KOUT2_EN,
+				  enable ? RK817_CLK32KOUT2_EN : 0);
+}
+
+static int rk817_clkout2_prepare(struct clk_hw *hw)
 {
-	struct rk808_clkout *rk808_clkout = data;
-	unsigned int idx = clkspec->args[0];
+	return rk817_clkout2_enable(hw, true);
+}
+
+static void rk817_clkout2_unprepare(struct clk_hw *hw)
+{
+	rk817_clkout2_enable(hw, false);
+}
+
+static int rk817_clkout2_is_prepared(struct clk_hw *hw)
+{
+	struct rk808_clkout *rk808_clkout = container_of(hw,
+							 struct rk808_clkout,
+							 clkout2_hw);
+	struct rk808 *rk808 = rk808_clkout->rk808;
+	unsigned int val;
+
+	int ret = regmap_read(rk808->regmap, RK817_SYS_CFG(1), &val);
 
-	if (idx >= 2) {
-		pr_err("%s: invalid index %u\n", __func__, idx);
-		return ERR_PTR(-EINVAL);
+	if (ret < 0)
+		return ret;
+
+	return (val & RK817_CLK32KOUT2_EN) ? 1 : 0;
+}
+
+static const struct clk_ops rk817_clkout2_ops = {
+	.prepare = rk817_clkout2_prepare,
+	.unprepare = rk817_clkout2_unprepare,
+	.is_prepared = rk817_clkout2_is_prepared,
+	.recalc_rate = rk808_clkout_recalc_rate,
+};
+
+static const struct clk_ops *rkpmic_get_ops(long variant)
+{
+	switch (variant) {
+	case RK809_ID:
+	case RK817_ID:
+		return &rk817_clkout2_ops;
+	case RK805_ID:
+	case RK808_ID:
+	case RK816_ID:
+	case RK818_ID:
+		return &rk808_clkout2_ops;
 	}
 
-	return idx ? &rk808_clkout->clkout2_hw : &rk808_clkout->clkout1_hw;
+	return &rk808_clkout2_ops;
 }
 
 static int rk808_clkout_probe(struct platform_device *pdev)
@@ -102,8 +152,8 @@ static int rk808_clkout_probe(struct platform_device *pdev)
 	struct i2c_client *client = rk808->i2c;
 	struct device_node *node = client->dev.of_node;
 	struct clk_init_data init = {};
+	struct clk **clk_table;
 	struct rk808_clkout *rk808_clkout;
-	int ret;
 
 	rk808_clkout = devm_kzalloc(&client->dev,
 				    sizeof(*rk808_clkout), GFP_KERNEL);
@@ -112,6 +162,12 @@ static int rk808_clkout_probe(struct platform_device *pdev)
 
 	rk808_clkout->rk808 = rk808;
 
+	clk_table = devm_kcalloc(&client->dev, RK808_NR_OUTPUT,
+				 sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_table)
+		return -ENOMEM;
+
+	init.flags = CLK_IS_ROOT;
 	init.parent_names = NULL;
 	init.num_parents = 0;
 	init.name = "rk808-clkout1";
@@ -122,23 +178,29 @@ static int rk808_clkout_probe(struct platform_device *pdev)
 	of_property_read_string_index(node, "clock-output-names",
 				      0, &init.name);
 
-	ret = devm_clk_hw_register(&client->dev, &rk808_clkout->clkout1_hw);
-	if (ret)
-		return ret;
+	clk_table[0] = devm_clk_register(&client->dev,
+					 &rk808_clkout->clkout1_hw);
+	if (IS_ERR(clk_table[0]))
+		return PTR_ERR(clk_table[0]);
 
 	init.name = "rk808-clkout2";
-	init.ops = &rk808_clkout2_ops;
+	init.ops = rkpmic_get_ops(rk808->variant);
 	rk808_clkout->clkout2_hw.init = &init;
 
 	/* optional override of the clockname */
 	of_property_read_string_index(node, "clock-output-names",
 				      1, &init.name);
 
-	ret = devm_clk_hw_register(&client->dev, &rk808_clkout->clkout2_hw);
-	if (ret)
-		return ret;
+	clk_table[1] = devm_clk_register(&client->dev,
+					 &rk808_clkout->clkout2_hw);
+	if (IS_ERR(clk_table[1]))
+		return PTR_ERR(clk_table[1]);
+
+	rk808_clkout->clk_data.clks = clk_table;
+	rk808_clkout->clk_data.clk_num = RK808_NR_OUTPUT;
 
-	return of_clk_add_hw_provider(node, of_clk_rk808_get, rk808_clkout);
+	return of_clk_add_provider(node, of_clk_src_onecell_get,
+				   &rk808_clkout->clk_data);
 }
 
 static int rk808_clkout_remove(struct platform_device *pdev)
diff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
index 4215b5382092..9cde5cb6744e 100644
--- a/drivers/input/joystick/Kconfig
+++ b/drivers/input/joystick/Kconfig
@@ -330,4 +330,10 @@ config JOYSTICK_MAPLE
 	  To compile this as a module choose M here: the module will be called
 	  maplecontrol.
 
+config JOYSTICK_ODROID_GOU
+	tristate "ODROID-Go-Ultra joypad driver"
+	# depends on ARCH_MESON64_ODROID_COMMON
+	help
+	  Made for ODROID-GO-Ultra.
+
 endif
diff --git a/drivers/input/joystick/Makefile b/drivers/input/joystick/Makefile
index 92dc0de9dfed..9a1130db591b 100644
--- a/drivers/input/joystick/Makefile
+++ b/drivers/input/joystick/Makefile
@@ -32,4 +32,5 @@ obj-$(CONFIG_JOYSTICK_WARRIOR)		+= warrior.o
 obj-$(CONFIG_JOYSTICK_XPAD)		+= xpad.o
 obj-$(CONFIG_JOYSTICK_ZHENHUA)		+= zhenhua.o
 obj-$(CONFIG_JOYSTICK_WALKERA0701)	+= walkera0701.o
+obj-$(CONFIG_JOYSTICK_ODROID_GOU)	+= odroid-gou-joypad.o
 
diff --git a/drivers/input/joystick/odroid-gou-joypad.c b/drivers/input/joystick/odroid-gou-joypad.c
new file mode 100755
index 000000000000..0124a1074847
--- /dev/null
+++ b/drivers/input/joystick/odroid-gou-joypad.c
@@ -0,0 +1,949 @@
+/*
+ * SARADC joystick & GPIO Button driver for Linux(Hardkernel ODROIDGO-Seriese)
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+/*----------------------------------------------------------------------------*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/types.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <dt-bindings/iio/adc/amlogic-saradc.h>
+
+/*----------------------------------------------------------------------------*/
+#define DRV_NAME "odroidgo_joypad"
+
+/*----------------------------------------------------------------------------*/
+#define	ADC_MAX_VOLTAGE		1800
+#define	ADC_DATA_TUNING(x, p)	((x * p) / 100)
+#define	ADC_TUNING_DEFAULT	180
+
+/*----------------------------------------------------------------------------*/
+/*
+	+--------------+--------+---------+
+	|  iio_channel | SELECT |  EVENT  |
+	+--------------+--------+---------+
+	|    ADC_AIN0  |  R-Y   | ABS_RY  |
+	+--------------+--------+---------+
+	|    ADC_AIN1  |  R-X   | ABS_RX  |
+	+--------------+--------+---------+
+	|    ADC_AIN2  |  L-Y   |  ABS_Y  |
+	+--------------+--------+---------+
+	|    ADC_AIN3  |  L-X   |  ABS_X  |
+	+--------------+--------+---------+
+*/
+/*----------------------------------------------------------------------------*/
+struct bt_adc {
+	/* report value (mV) */
+	int value;
+	/* report type */
+	int report_type;
+	/* input device init value (mV) */
+	int max, min;
+	/* calibrated adc value */
+	int cal;
+	/*  adc scale value */
+	int scale;
+	/* invert report */
+	bool invert;
+	/* adc channel */
+	int channel;
+	/* adc data tuning value([percent), p = positive, n = negative */
+	int tuning_p, tuning_n;
+};
+
+struct bt_gpio {
+	/* GPIO Request label */
+	const char *label;
+	/* GPIO Number */
+	int num;
+	/* report type */
+	int report_type;
+	/* report linux code */
+	int linux_code;
+	/* prev button value */
+	bool old_value;
+	/* button press level */
+	bool active_level;
+};
+
+struct joypad {
+	struct device *dev;
+	struct input_polled_dev	*poll_dev;
+	int poll_interval;
+
+	/* report enable/disable */
+	bool enable;
+
+	/* analog mux & joystick control */
+	struct iio_channel *adc_ch[SARADC_CH_NUM];
+
+	/* adc input channel count */
+	int chan_count;
+	/* analog button */
+	struct bt_adc *adcs;
+
+	/* report interval (ms) */
+	int bt_gpio_count;
+	struct bt_gpio *gpios;
+
+	/* button auto repeat */
+	int auto_repeat;
+
+	/* report threshold (mV) */
+	int bt_adc_fuzz, bt_adc_flat;
+	/* adc read value scale */
+	int bt_adc_scale;
+	/* joystick deadzone control */
+	int bt_adc_deadzone;
+
+	struct mutex lock;
+
+	/* adc debug channel */
+	int debug_ch;
+};
+
+/*----------------------------------------------------------------------------*/
+//
+// set to the value in the boot.ini file. (if exist)
+//
+/*----------------------------------------------------------------------------*/
+static unsigned int g_button_adc_fuzz = 0;
+static unsigned int g_button_adc_flat = 0;
+static unsigned int g_button_adc_scale = 0;
+static unsigned int g_button_adc_deadzone = 0;
+
+static int button_adc_fuzz(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_fuzz = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-fuzz=", button_adc_fuzz);
+
+static int button_adc_flat(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_flat = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-flat=", button_adc_flat);
+
+static int button_adc_scale(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_scale = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-scale=", button_adc_scale);
+
+static int button_adc_deadzone(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	g_button_adc_deadzone = simple_strtoul(str, NULL, 10);
+	return 0;
+}
+__setup("button-adc-deadzone=", button_adc_deadzone);
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_read(struct joypad *joypad, struct bt_adc *adc)
+{
+	int value;
+
+	if (iio_read_channel_processed(joypad->adc_ch[adc->channel], &value) < 0)
+		return 0;
+
+	value *= adc->scale;
+
+	return (adc->invert ? (adc->max - value) : value);
+}
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/odroidgo_joypad/poll_interval [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_poll_interval(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->poll_interval = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_poll_interval(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->poll_interval);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(poll_interval, S_IWUSR | S_IRUGO,
+		   joypad_show_poll_interval,
+		   joypad_store_poll_interval);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/adc_fuzz [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_fuzz(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_fuzz);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_fuzz, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_fuzz,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/adc_flat [r]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_flat(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->bt_adc_flat);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_flat, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_flat,
+		   NULL);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/enable [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_enable(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	mutex_lock(&joypad->lock);
+	joypad->enable = simple_strtoul(buf, NULL, 10);
+	mutex_unlock(&joypad->lock);
+
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_enable(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", joypad->enable);
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
+		   joypad_show_enable,
+		   joypad_store_enable);
+
+/*----------------------------------------------------------------------------*/
+/*
+ * ATTRIBUTES:
+ *
+ * /sys/devices/platform/oodroidgo_joypad/adc_cal [rw]
+ */
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_store_adc_cal(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	bool calibration;
+
+	calibration = simple_strtoul(buf, NULL, 10);
+
+	if (calibration) {
+		int nbtn;
+
+		mutex_lock(&joypad->lock);
+		for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+			struct bt_adc *adc = &joypad->adcs[nbtn];
+
+			adc->value = joypad_adc_read(joypad, adc);
+			if (!adc->value) {
+				dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+					__func__, nbtn);
+				continue;
+			}
+			adc->cal = adc->value;
+		}
+		mutex_unlock(&joypad->lock);
+	}
+	return count;
+}
+
+/*----------------------------------------------------------------------------*/
+static ssize_t joypad_show_adc_cal(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev  = to_platform_device(dev);
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	int nbtn;
+	ssize_t pos;
+
+	for (nbtn = 0, pos = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		pos += sprintf(&buf[pos], "adc[%d]->cal = %d\n",
+				nbtn, adc->cal);
+	}
+	pos += sprintf(&buf[pos], "adc scale = %d\n", joypad->bt_adc_scale);
+	return pos;
+}
+
+/*----------------------------------------------------------------------------*/
+static DEVICE_ATTR(adc_cal, S_IWUSR | S_IRUGO,
+		   joypad_show_adc_cal,
+		   joypad_store_adc_cal);
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static struct attribute *joypad_attrs[] = {
+	&dev_attr_poll_interval.attr,
+	&dev_attr_adc_fuzz.attr,
+	&dev_attr_adc_flat.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_adc_cal.attr,
+	NULL,
+};
+
+static struct attribute_group joypad_attr_group = {
+	.attrs = joypad_attrs,
+};
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+static void joypad_gpio_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn, value;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+
+		if (gpio_get_value_cansleep(gpio->num) < 0) {
+			dev_err(joypad->dev, "failed to get gpio state\n");
+			continue;
+		}
+		value = gpio_get_value(gpio->num);
+		if (value != gpio->old_value) {
+			input_event(poll_dev->input,
+				gpio->report_type,
+				gpio->linux_code,
+				(value == gpio->active_level) ? 1 : 0);
+			gpio->old_value = value;
+		}
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_adc_check(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->value = adc->value - adc->cal;
+
+		/* Joystick Deadzone check */
+		if (joypad->bt_adc_deadzone) {
+			if (abs(adc->value) < joypad->bt_adc_deadzone)
+				adc->value = 0;
+		}
+
+		/* adc data tuning */
+		if (adc->tuning_n && adc->value < 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_n);
+		if (adc->tuning_p && adc->value > 0)
+			adc->value = ADC_DATA_TUNING(adc->value, adc->tuning_p);
+
+		adc->value = adc->value > adc->max ? adc->max : adc->value;
+		adc->value = adc->value < adc->min ? adc->min : adc->value;
+
+		input_report_abs(poll_dev->input,
+			adc->report_type,
+			adc->invert ? adc->value * (-1) : adc->value);
+	}
+	input_sync(poll_dev->input);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_poll(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	if (joypad->enable) {
+		joypad_adc_check(poll_dev);
+		joypad_gpio_check(poll_dev);
+	}
+	if (poll_dev->poll_interval != joypad->poll_interval) {
+		mutex_lock(&joypad->lock);
+		poll_dev->poll_interval = joypad->poll_interval;
+		mutex_unlock(&joypad->lock);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_open(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+	int nbtn;
+
+	for (nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		gpio->old_value = gpio->active_level ? 0 : 1;
+	}
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->value = joypad_adc_read(joypad, adc);
+		if (!adc->value) {
+			dev_err(joypad->dev, "%s : saradc channels[%d]!\n",
+				__func__, nbtn);
+			continue;
+		}
+		adc->cal = adc->value;
+		dev_info(joypad->dev, "%s : adc[%d] adc->cal = %d\n",
+			__func__, nbtn, adc->cal);
+	}
+	/* buttons status sync */
+	joypad_adc_check(poll_dev);
+	joypad_gpio_check(poll_dev);
+
+	/* button report enable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = true;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : opened\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_close(struct input_polled_dev *poll_dev)
+{
+	struct joypad *joypad = poll_dev->private;
+
+	/* button report disable */
+	mutex_lock(&joypad->lock);
+	joypad->enable = false;
+	mutex_unlock(&joypad->lock);
+
+	dev_info(joypad->dev, "%s : closed\n", __func__);
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_iochannel_setup(struct device *dev, struct joypad *joypad)
+{
+	enum iio_chan_type type;
+	unsigned char cnt;
+	const char *uname;
+	int ret;
+
+	for (cnt = 0; cnt < joypad->chan_count; cnt++) {
+
+		ret = of_property_read_string_index(dev->of_node,
+				"io-channel-names", cnt, &uname);
+		if (ret < 0) {
+			dev_err(dev, "invalid channel name index[%d]\n", cnt);
+			return -EINVAL;
+		}
+
+		joypad->adc_ch[cnt] = devm_iio_channel_get(dev,
+				uname);
+		if (IS_ERR(joypad->adc_ch[cnt])) {
+			dev_err(dev, "iio channel get error\n");
+			return -EINVAL;
+		}
+		if (!joypad->adc_ch[cnt]->indio_dev)
+			return -ENXIO;
+	
+		if (iio_get_channel_type(joypad->adc_ch[cnt], &type))
+			return -EINVAL;
+	
+		if (type != IIO_VOLTAGE) {
+			dev_err(dev, "Incompatible channel type %d\n", type);
+			return -EINVAL;
+		}
+	}
+	return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_adc_setup(struct device *dev, struct joypad *joypad)
+{
+	int nbtn;
+
+	/* adc button struct init */
+	joypad->adcs = devm_kzalloc(dev, joypad->chan_count *
+				sizeof(struct bt_adc), GFP_KERNEL);
+	if (!joypad->adcs) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	for (nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+
+		adc->scale = joypad->bt_adc_scale;
+		
+		adc->max = (ADC_MAX_VOLTAGE / 2);
+		adc->min = (ADC_MAX_VOLTAGE / 2) * (-1);
+		if (adc->scale) {
+			adc->max *= adc->scale;
+			adc->min *= adc->scale;
+		}
+		adc->channel = nbtn;
+		adc->invert = false;
+
+		switch (nbtn) {
+			case 0:
+				adc->report_type = ABS_RY;
+				if (device_property_read_u32(dev,
+					"abs_ry-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_ry-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 1:
+				adc->report_type = ABS_RX;
+				if (device_property_read_u32(dev,
+					"abs_rx-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_rx-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 2:
+				adc->report_type = ABS_Y;
+				if (device_property_read_u32(dev,
+					"abs_y-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_y-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			case 3:
+				adc->report_type = ABS_X;
+				if (device_property_read_u32(dev,
+					"abs_x-p-tuning",
+					&adc->tuning_p))
+					adc->tuning_p = ADC_TUNING_DEFAULT;
+				if (device_property_read_u32(dev,
+					"abs_x-n-tuning",
+					&adc->tuning_n))
+					adc->tuning_n = ADC_TUNING_DEFAULT;
+				break;
+			default :
+				dev_err(dev, "%s io channel count(%d) error!",
+					__func__, nbtn);
+				return -EINVAL;
+		}
+	}
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_gpio_setup(struct device *dev, struct joypad *joypad)
+{
+	struct device_node *node, *pp;
+	int nbtn;
+
+	node = dev->of_node;
+	if (!node)
+		return -ENODEV;
+
+	joypad->gpios = devm_kzalloc(dev, joypad->bt_gpio_count *
+				sizeof(struct bt_gpio), GFP_KERNEL);
+
+	if (!joypad->gpios) {
+		dev_err(dev, "%s devm_kzmalloc error!", __func__);
+		return -ENOMEM;
+	}
+
+	nbtn = 0;
+	for_each_child_of_node(node, pp) {
+		enum of_gpio_flags flags;
+		struct bt_gpio *gpio = &joypad->gpios[nbtn++];
+		int error;
+
+		gpio->num = of_get_gpio_flags(pp, 0, &flags);
+		if (gpio->num < 0) {
+			error = gpio->num;
+			dev_err(dev, "Failed to get gpio flags, error: %d\n",
+				error);
+			return error;
+		}
+
+		/* gpio active level(key press level) */
+		gpio->active_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		gpio->label = of_get_property(pp, "label", NULL);
+
+		if (gpio_is_valid(gpio->num)) {
+			error = devm_gpio_request_one(dev, gpio->num,
+						      GPIOF_IN, gpio->label);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to request GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+			error = gpiod_set_pull(gpio_to_desc(gpio->num),
+				GPIOD_PULL_UP);
+			if (error < 0) {
+				dev_err(dev,
+					"Failed to set pull-up GPIO %d, error %d\n",
+					gpio->num, error);
+				return error;
+			}
+		}
+		if (of_property_read_u32(pp, "linux,code", &gpio->linux_code)) {
+			dev_err(dev, "Button without keycode: 0x%x\n",
+				gpio->num);
+			return -EINVAL;
+		}
+		if (of_property_read_u32(pp, "linux,input-type",
+				&gpio->report_type))
+			gpio->report_type = EV_KEY;
+	}
+	if (nbtn == 0)
+		return -EINVAL;
+
+	return	0;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_input_setup(struct device *dev, struct joypad *joypad)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	int nbtn, error;
+	u32 joypad_revision = 0;
+	u32 joypad_product = 0;
+
+	poll_dev = devm_input_allocate_polled_device(dev);
+	if (!poll_dev) {
+		dev_err(dev, "no memory for polled device\n");
+		return -ENOMEM;
+	}
+
+	poll_dev->private	= joypad;
+	poll_dev->poll		= joypad_poll;
+	poll_dev->poll_interval	= joypad->poll_interval;
+	poll_dev->open		= joypad_open;
+	poll_dev->close		= joypad_close;
+
+	input = poll_dev->input;
+
+	input->name = DRV_NAME;
+	input->phys = DRV_NAME"/input0";
+
+	device_property_read_u32(dev, "joypad-revision", &joypad_revision);
+	device_property_read_u32(dev, "joypad-product", &joypad_product);
+	input->id.bustype = BUS_HOST;
+	input->id.vendor  = 0x484B;
+	input->id.product = (u16)joypad_product;
+	input->id.version = (u16)joypad_revision;
+
+	/* IIO ADC key setup (0 mv ~ 1800 mv) * adc->scale */
+	__set_bit(EV_ABS, input->evbit);
+	for(nbtn = 0; nbtn < joypad->chan_count; nbtn++) {
+		struct bt_adc *adc = &joypad->adcs[nbtn];
+		input_set_abs_params(input, adc->report_type,
+				adc->min, adc->max,
+				joypad->bt_adc_fuzz,
+				joypad->bt_adc_flat);
+		dev_info(dev,
+			"%s : SCALE = %d, ABS min = %d, max = %d,"
+			" fuzz = %d, flat = %d, deadzone = %d\n",
+			__func__, adc->scale, adc->min, adc->max,
+			joypad->bt_adc_fuzz, joypad->bt_adc_flat,
+			joypad->bt_adc_deadzone);
+		dev_info(dev,
+			"%s : adc tuning_p = %d, adc_tuning_n = %d\n\n",
+			__func__, adc->tuning_p, adc->tuning_n);
+	}
+
+	/* GPIO key setup */
+	__set_bit(EV_KEY, input->evbit);
+	for(nbtn = 0; nbtn < joypad->bt_gpio_count; nbtn++) {
+		struct bt_gpio *gpio = &joypad->gpios[nbtn];
+		input_set_capability(input, gpio->report_type,
+				gpio->linux_code);
+	}
+
+	if (joypad->auto_repeat)
+		__set_bit(EV_REP, input->evbit);
+
+	error = input_register_polled_device(poll_dev);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+	joypad->dev = dev;
+	joypad->poll_dev = poll_dev;
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------*/
+static void joypad_setup_value_check(struct device *dev, struct joypad *joypad)
+{
+	/*
+		fuzz: specifies fuzz value that is used to filter noise from
+			the event stream.
+	*/
+	if (g_button_adc_fuzz)
+		joypad->bt_adc_fuzz = g_button_adc_fuzz;
+	else
+		device_property_read_u32(dev, "button-adc-fuzz",
+					&joypad->bt_adc_fuzz);
+	/*
+		flat: values that are within this value will be discarded by
+			joydev interface and reported as 0 instead.
+	*/
+	if (g_button_adc_flat)
+		joypad->bt_adc_flat = g_button_adc_flat;
+	else
+		device_property_read_u32(dev, "button-adc-flat",
+					&joypad->bt_adc_flat);
+
+	/* Joystick report value control */
+	if (g_button_adc_scale)
+		joypad->bt_adc_scale = g_button_adc_scale;
+	else
+		device_property_read_u32(dev, "button-adc-scale",
+					&joypad->bt_adc_scale);
+
+	/* Joystick deadzone value control */
+	if (g_button_adc_deadzone)
+		joypad->bt_adc_deadzone = g_button_adc_deadzone;
+	else
+		device_property_read_u32(dev, "button-adc-deadzone",
+					&joypad->bt_adc_deadzone);
+
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_dt_parse(struct device *dev, struct joypad *joypad)
+{
+	int error = 0;
+
+	/* initialize value check from boot.ini */
+	joypad_setup_value_check(dev, joypad);
+
+	joypad->chan_count = of_property_count_strings(dev->of_node,
+		"io-channel-names");
+
+	device_property_read_u32(dev, "poll-interval",
+				&joypad->poll_interval);
+
+	joypad->auto_repeat = device_property_present(dev, "autorepeat");
+
+	joypad->bt_gpio_count = device_get_child_node_count(dev);
+
+	if ((joypad->chan_count == 0) || (joypad->bt_gpio_count == 0)) {
+		dev_err(dev, "adc key = %d, gpio key = %d error!",
+			joypad->chan_count, joypad->bt_gpio_count);
+		return -EINVAL;
+	}
+
+	error = joypad_adc_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_iochannel_setup(dev, joypad);
+	if (error)
+		return error;
+
+	error = joypad_gpio_setup(dev, joypad);
+	if (error)
+		return error;
+
+	dev_info(dev, "%s : adc key cnt = %d, gpio key cnt = %d\n",
+			__func__, joypad->chan_count, joypad->bt_gpio_count);
+
+	return error;
+}
+
+/*----------------------------------------------------------------------------*/
+static int joypad_probe(struct platform_device *pdev)
+{
+	struct joypad *joypad;
+	struct device *dev = &pdev->dev;
+	int error;
+
+	joypad = devm_kzalloc(dev, sizeof(struct joypad), GFP_KERNEL);
+	if (!joypad) {
+		dev_err(dev, "joypad devm_kzmalloc error!");
+		return -ENOMEM;
+	}
+
+	/* device tree data parse */
+	error = joypad_dt_parse(dev, joypad);
+	if (error) {
+		dev_err(dev, "dt parse error!(err = %d)\n", error);
+		return error;
+	}
+
+	mutex_init(&joypad->lock);
+	platform_set_drvdata(pdev, joypad);
+
+	error = sysfs_create_group(&pdev->dev.kobj, &joypad_attr_group);
+	if (error) {
+		dev_err(dev, "create sysfs group fail, error: %d\n",
+			error);
+		return error;
+	}
+
+	/* poll input device setup */
+	error = joypad_input_setup(dev, joypad);
+	if (error) {
+		dev_err(dev, "input setup failed!(err = %d)\n", error);
+		return error;
+	}
+	dev_info(dev, "%s : probe success\n", __func__);
+	return 0;
+}
+
+static void joypad_shutdown(struct platform_device *pdev)
+{
+	struct joypad *joypad = platform_get_drvdata(pdev);
+	input_unregister_polled_device(joypad->poll_dev);
+}
+/*----------------------------------------------------------------------------*/
+static const struct of_device_id joypad_of_match[] = {
+	{ .compatible = "odroidgou-joypad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, joypad_of_match);
+
+/*----------------------------------------------------------------------------*/
+static struct platform_driver joypad_driver = {
+	.probe = joypad_probe,
+	.shutdown = joypad_shutdown,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(joypad_of_match),
+	},
+};
+
+/*----------------------------------------------------------------------------*/
+static int __init joypad_init(void)
+{
+	return platform_driver_register(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+static void __exit joypad_exit(void)
+{
+	platform_driver_unregister(&joypad_driver);
+}
+
+/*----------------------------------------------------------------------------*/
+late_initcall(joypad_init);
+module_exit(joypad_exit);
+
+/*----------------------------------------------------------------------------*/
+MODULE_AUTHOR("Hardkernel Co.,LTD");
+MODULE_DESCRIPTION("Keypad driver(ADC&GPIO) for ODROIDGO-Advance");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+
+/*----------------------------------------------------------------------------*/
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index ea1b5e441a96..d6d2e5f28825 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -464,6 +464,12 @@ config INPUT_RETU_PWRBUTTON
 	  To compile this driver as a module, choose M here. The module will
 	  be called retu-pwrbutton.
 
+config INPUT_RK8XX_PWRKEY
+	tristate "Rockchip RK8XX pwrkey driver"
+	depends on MFD_RK808
+	help
+	  Select this option to enable the pwrkey module of Rockchip RK8XX PMIC.
+
 config INPUT_TPS65218_PWRBUTTON
 	tristate "TPS65218 Power button driver"
 	depends on (MFD_TPS65217 || MFD_TPS65218)
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 13bf7dbba627..8734359ee5c7 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -63,6 +63,7 @@ obj-$(CONFIG_INPUT_PWM_BEEPER)		+= pwm-beeper.o
 obj-$(CONFIG_INPUT_RB532_BUTTON)	+= rb532_button.o
 obj-$(CONFIG_INPUT_REGULATOR_HAPTIC)	+= regulator-haptic.o
 obj-$(CONFIG_INPUT_RETU_PWRBUTTON)	+= retu-pwrbutton.o
+obj-$(CONFIG_INPUT_RK8XX_PWRKEY)	+= rk8xx-pwrkey.o
 obj-$(CONFIG_INPUT_AXP20X_PEK)		+= axp20x-pek.o
 obj-$(CONFIG_INPUT_GPIO_ROTARY_ENCODER)	+= rotary_encoder.o
 obj-$(CONFIG_INPUT_SGI_BTNS)		+= sgi_btns.o
diff --git a/drivers/input/misc/rk8xx-pwrkey.c b/drivers/input/misc/rk8xx-pwrkey.c
new file mode 100755
index 000000000000..1fbd95f8894b
--- /dev/null
+++ b/drivers/input/misc/rk8xx-pwrkey.c
@@ -0,0 +1,173 @@
+/*
+ * driver/input/misc/rk8xx-pwrkey.c
+ * Power Key driver for RK8xx PMIC Power Button.
+ *
+ * Copyright (C) 2017, Rockchip Technology Co., Ltd.
+ * Author: Chen Jianhong <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/errno.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+struct rk8xx_pwrkey {
+	struct rk808 *rk8xx;
+	struct input_dev *input_dev;
+	int report_key;
+};
+
+static struct input_dev *sinput_dev;
+
+void rk_send_power_key(int state)
+{
+	if (!sinput_dev)
+		return;
+	if (state) {
+		input_report_key(sinput_dev, KEY_POWER, 1);
+		input_sync(sinput_dev);
+	} else {
+		input_report_key(sinput_dev, KEY_POWER, 0);
+		input_sync(sinput_dev);
+	}
+}
+EXPORT_SYMBOL(rk_send_power_key);
+
+void rk_send_wakeup_key(void)
+{
+	if (!sinput_dev)
+		return;
+
+	input_report_key(sinput_dev, KEY_WAKEUP, 1);
+	input_sync(sinput_dev);
+	input_report_key(sinput_dev, KEY_WAKEUP, 0);
+	input_sync(sinput_dev);
+}
+EXPORT_SYMBOL(rk_send_wakeup_key);
+
+static irqreturn_t rk8xx_pwrkey_irq_falling(int irq, void *data)
+{
+	struct rk8xx_pwrkey *pwr = data;
+
+	input_report_key(pwr->input_dev, pwr->report_key, 1);
+	input_sync(pwr->input_dev);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rk8xx_pwrkey_irq_rising(int irq, void *data)
+{
+	struct rk8xx_pwrkey *pwr = data;
+
+	input_report_key(pwr->input_dev, pwr->report_key, 0);
+	input_sync(pwr->input_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int rk8xx_pwrkey_probe(struct platform_device *pdev)
+{
+	struct rk808 *rk8xx = dev_get_drvdata(pdev->dev.parent);
+	struct rk8xx_pwrkey *pwrkey;
+	int fall_irq, rise_irq, err;
+	struct device_node *np;
+
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "pwrkey");
+	if (np) {
+		if (!of_device_is_available(np)) {
+			dev_info(&pdev->dev, "device is disabled\n");
+			return -EINVAL;
+		}
+	}
+
+	pwrkey = devm_kzalloc(&pdev->dev,
+			      sizeof(struct rk8xx_pwrkey), GFP_KERNEL);
+	if (!pwrkey)
+		return -ENOMEM;
+
+	pwrkey->input_dev = devm_input_allocate_device(&pdev->dev);
+	if (!pwrkey->input_dev) {
+		dev_err(&pdev->dev, "Can't allocate power button\n");
+		return -ENOMEM;
+	}
+
+	/* init struct input_dev */
+	pwrkey->rk8xx = rk8xx;
+	pwrkey->report_key = KEY_POWER;
+	pwrkey->input_dev->name = "rk8xx_pwrkey";
+	pwrkey->input_dev->phys = "rk8xx_pwrkey/input0";
+	pwrkey->input_dev->dev.parent = pdev->dev.parent;
+	pwrkey->input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	pwrkey->input_dev->keybit[BIT_WORD(pwrkey->report_key)] =
+					BIT_MASK(pwrkey->report_key);
+	platform_set_drvdata(pdev, pwrkey);
+
+	/* requeset rise and fall irqs */
+	rise_irq = platform_get_irq(pdev, 0);
+	if (rise_irq < 0) {
+		dev_err(&pdev->dev, "no IRQ for rise: %d\n", rise_irq);
+		return rise_irq;
+	}
+
+	fall_irq = platform_get_irq(pdev, 1);
+	if (fall_irq < 0) {
+		dev_err(&pdev->dev, "no IRQ for fall: %d\n", fall_irq);
+		return fall_irq;
+	}
+
+	err = devm_request_threaded_irq(&pdev->dev, fall_irq,
+					NULL, rk8xx_pwrkey_irq_falling,
+					IRQF_TRIGGER_FALLING,
+					"rk8xx_pwrkey_fall", pwrkey);
+	if (err) {
+		dev_err(&pdev->dev, "Can't get fall irq for pwrkey: %d\n", err);
+		return err;
+	}
+	err = devm_request_threaded_irq(&pdev->dev, rise_irq,
+					NULL, rk8xx_pwrkey_irq_rising,
+					IRQF_TRIGGER_RISING,
+					"rk8xx_pwrkey_rise", pwrkey);
+	if (err) {
+		dev_err(&pdev->dev, "Can't get rise irq for pwrkey: %d\n", err);
+		return err;
+	}
+
+	/* register input device */
+	err = input_register_device(pwrkey->input_dev);
+	if (err) {
+		dev_err(&pdev->dev, "Can't register power button: %d\n", err);
+		return err;
+	}
+	sinput_dev = pwrkey->input_dev;
+
+	return 0;
+}
+
+static struct platform_driver rk8xx_pwrkey_driver = {
+	.probe = rk8xx_pwrkey_probe,
+	.driver		= {
+		.name	= "rk8xx-pwrkey",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(rk8xx_pwrkey_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("RK8xx Power Button");
+MODULE_AUTHOR("Chen Jianhong <chenjh@rock-chips.com>");
diff --git a/drivers/mfd/rk808.c b/drivers/mfd/rk808.c
index 0f8acc5882a4..71bdc26a2c84 100644
--- a/drivers/mfd/rk808.c
+++ b/drivers/mfd/rk808.c
@@ -1,15 +1,11 @@
 /*
- * MFD core driver for Rockchip RK808/RK818
+ * MFD core driver for Rockchip RK808
  *
- * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
+ * Copyright (c) 2014-2018, Fuzhou Rockchip Electronics Co., Ltd
  *
  * Author: Chris Zhong <zyw@rock-chips.com>
  * Author: Zhang Qing <zhangqing@rock-chips.com>
  *
- * Copyright (C) 2016 PHYTEC Messtechnik GmbH
- *
- * Author: Wadim Egorov <w.egorov@phytec.de>
- *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
@@ -20,13 +16,25 @@
  * more details.
  */
 
+#include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
+#include <linux/kernel.h>
 #include <linux/mfd/rk808.h>
 #include <linux/mfd/core.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/reboot.h>
 #include <linux/regmap.h>
+#include <linux/syscore_ops.h>
+
+#define CONFIG_ARCH_MESON64_ODROID_COMMON
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/arm-smccc.h>
+#endif
 
 struct rk808_reg_data {
 	int addr;
@@ -62,22 +70,238 @@ static bool rk808_is_volatile_reg(struct device *dev, unsigned int reg)
 	return false;
 }
 
-static const struct regmap_config rk818_regmap_config = {
+static bool rk817_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	/*
+	 * Notes:
+	 * - Technically the ROUND_30s bit makes RTC_CTRL_REG volatile, but
+	 *   we don't use that feature.  It's better to cache.
+	 * - It's unlikely we care that RK808_DEVCTRL_REG is volatile since
+	 *   bits are cleared in case when we shutoff anyway, but better safe.
+	 */
+
+	switch (reg) {
+	case RK817_SECONDS_REG ... RK817_WEEKS_REG:
+	case RK817_RTC_STATUS_REG:
+	case RK817_INT_STS_REG0:
+	case RK817_INT_STS_REG1:
+	case RK817_INT_STS_REG2:
+	case RK817_SYS_STS:
+		return true;
+	}
+
+	return true;
+}
+
+static int (*pm_shutdown)(struct regmap *regmap);
+static int (*pm_shutdown_prepare)(struct rk808 *rk808);
+static struct i2c_client *rk808_i2c_client;
+static struct rk808_reg_data *suspend_reg, *resume_reg;
+static int suspend_reg_num, resume_reg_num;
+
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+static noinline int psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
+                                        u64 arg2)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc((unsigned long)function_id,
+			(unsigned long)arg0,
+			(unsigned long)arg1,
+			(unsigned long)arg2,
+			0, 0, 0, 0, &res);
+	return res.a0;
+}
+
+static void do_aml_poweroff(void)
+{
+       /* TODO: Add poweroff capability */
+	psci_fn_smc(0x82000042, 1, 0, 0);
+	psci_fn_smc(0x84000008, 0, 0, 0);
+}
+
+#endif
+
+
+static int rk808_shutdown(struct regmap *regmap)
+{
+	int ret;
+
+	ret = regmap_update_bits(regmap,
+				 RK808_DEVCTRL_REG,
+				 DEV_OFF_RST, DEV_OFF_RST);
+	return ret;
+}
+
+static int rk816_shutdown(struct regmap *regmap)
+{
+	int ret;
+
+	ret = regmap_update_bits(regmap,
+				 RK816_DEV_CTRL_REG,
+				 DEV_OFF, DEV_OFF);
+	return ret;
+}
+
+static int rk818_shutdown(struct regmap *regmap)
+{
+	int ret;
+
+	if (system_state == SYSTEM_POWER_OFF) {
+		ret = regmap_update_bits(regmap,
+					 RK818_DEVCTRL_REG,
+					 DEV_OFF, DEV_OFF);
+	}
+	else {
+		do_aml_poweroff();
+		ret = regmap_update_bits(regmap,
+					 RK818_DEVCTRL_REG,
+					 DEV_OFF_RST, DEV_OFF_RST);
+	}
+	return ret;
+}
+
+static int rk805_shutdown_prepare(struct rk808 *rk808)
+{
+	int ret;
+
+	/* close rtc int when power off */
+	regmap_update_bits(rk808->regmap,
+			   RK808_INT_STS_MSK_REG1,
+			   (0x3 << 5), (0x3 << 5));
+	regmap_update_bits(rk808->regmap,
+			   RK808_RTC_INT_REG,
+			   (0x3 << 2), (0x0 << 2));
+
+	/* pmic sleep shutdown function */
+	ret = regmap_update_bits(rk808->regmap,
+				 RK805_GPIO_IO_POL_REG,
+				 SLP_SD_MSK, SHUTDOWN_FUN);
+	return ret;
+}
+
+static int rk817_shutdown_prepare(struct rk808 *rk808)
+{
+	int ret;
+
+	/* close rtc int when power off */
+	regmap_update_bits(rk808->regmap,
+			   RK817_INT_STS_MSK_REG1,
+			   (0x3 << 5), (0x3 << 5));
+	regmap_update_bits(rk808->regmap,
+			   RK817_RTC_INT_REG,
+			   (0x3 << 2), (0x0 << 2));
+
+	if (rk808->pins && rk808->pins->p && rk808->pins->power_off) {
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPIN_FUNC_MSK,
+					 SLPPIN_NULL_FUN);
+		if (ret) {
+			pr_err("shutdown: config SLPPIN_NULL_FUN error!\n");
+			return 0;
+		}
+
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPOL_MSK,
+					 RK817_SLPPOL_H);
+		if (ret) {
+			pr_err("shutdown: config RK817_SLPPOL_H error!\n");
+			return 0;
+		}
+		ret = pinctrl_select_state(rk808->pins->p,
+					   rk808->pins->power_off);
+		if (ret)
+			pr_info("%s:failed to activate pwroff state\n",
+				__func__);
+		else
+			return ret;
+	}
+
+	/* pmic sleep shutdown function */
+	ret = regmap_update_bits(rk808->regmap,
+				 RK817_SYS_CFG(3),
+				 RK817_SLPPIN_FUNC_MSK, SLPPIN_DN_FUN);
+	return ret;
+}
+
+static bool rk818_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	/*
+	 * Notes:
+	 * - Technically the ROUND_30s bit makes RTC_CTRL_REG volatile, but
+	 *   we don't use that feature.  It's better to cache.
+	 * - It's unlikely we care that RK808_DEVCTRL_REG is volatile since
+	 *   bits are cleared in case when we shutoff anyway, but better safe.
+	 */
+
+	switch (reg) {
+	case RK808_SECONDS_REG ... RK808_WEEKS_REG:
+	case RK808_RTC_STATUS_REG:
+	case RK808_VB_MON_REG:
+	case RK808_THERMAL_REG:
+	case RK808_DCDC_EN_REG:
+	case RK808_LDO_EN_REG:
+	case RK808_DCDC_UV_STS_REG:
+	case RK808_LDO_UV_STS_REG:
+	case RK808_DCDC_PG_REG:
+	case RK808_LDO_PG_REG:
+	case RK808_DEVCTRL_REG:
+	case RK808_INT_STS_REG1:
+	case RK808_INT_STS_REG2:
+	case RK808_INT_STS_MSK_REG1:
+	case RK808_INT_STS_MSK_REG2:
+	case RK816_INT_STS_REG1:
+	case RK816_INT_STS_MSK_REG1:
+	case RK818_SUP_STS_REG ... RK818_SAVE_DATA19:
+		return true;
+	}
+
+	return false;
+}
+
+static const struct regmap_config rk808_regmap_config = {
 	.reg_bits = 8,
 	.val_bits = 8,
-	.max_register = RK818_USB_CTRL_REG,
+	.max_register = RK808_IO_POL_REG,
 	.cache_type = REGCACHE_RBTREE,
 	.volatile_reg = rk808_is_volatile_reg,
 };
 
-static const struct regmap_config rk808_regmap_config = {
+static const struct regmap_config rk805_regmap_config = {
 	.reg_bits = 8,
 	.val_bits = 8,
-	.max_register = RK808_IO_POL_REG,
+	.max_register = RK805_OFF_SOURCE_REG,
 	.cache_type = REGCACHE_RBTREE,
 	.volatile_reg = rk808_is_volatile_reg,
 };
 
+static const struct regmap_config rk816_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RK816_DATA18_REG,
+	.cache_type = REGCACHE_RBTREE,
+	.volatile_reg = rk818_is_volatile_reg,
+};
+
+static const struct regmap_config rk818_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RK818_SAVE_DATA19,
+	.cache_type = REGCACHE_RBTREE,
+	.volatile_reg = rk818_is_volatile_reg,
+};
+
+static const struct regmap_config rk817_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RK817_GPIO_INT_CFG,
+	.cache_type = REGCACHE_NONE,
+	.volatile_reg = rk817_is_volatile_reg,
+};
+
 static struct resource rtc_resources[] = {
 	{
 		.start  = RK808_IRQ_RTC_ALARM,
@@ -86,23 +310,61 @@ static struct resource rtc_resources[] = {
 	}
 };
 
-static const struct mfd_cell rk808s[] = {
-	{ .name = "rk808-clkout", },
-	{ .name = "rk808-regulator", },
+static struct resource rk816_rtc_resources[] = {
 	{
-		.name = "rk808-rtc",
-		.num_resources = ARRAY_SIZE(rtc_resources),
-		.resources = rtc_resources,
+		.start  = RK816_IRQ_RTC_ALARM,
+		.end    = RK816_IRQ_RTC_ALARM,
+		.flags  = IORESOURCE_IRQ,
+	}
+};
+
+static struct resource rk805_pwrkey_resources[] = {
+	{
+		.start  = RK805_IRQ_PWRON_RISE,
+		.end    = RK805_IRQ_PWRON_RISE,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = RK805_IRQ_PWRON_FALL,
+		.end    = RK805_IRQ_PWRON_FALL,
+		.flags  = IORESOURCE_IRQ,
 	},
 };
 
-static const struct mfd_cell rk818s[] = {
+
+static struct resource rk817_pwrkey_resources[] = {
+	{
+		.start  = RK817_IRQ_PWRON_RISE,
+		.end    = RK817_IRQ_PWRON_RISE,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = RK817_IRQ_PWRON_FALL,
+		.end    = RK817_IRQ_PWRON_FALL,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource rk816_pwrkey_resources[] = {
+	{
+		.start  = RK816_IRQ_PWRON_RISE,
+		.end    = RK816_IRQ_PWRON_RISE,
+		.flags  = IORESOURCE_IRQ,
+	},
+	{
+		.start  = RK816_IRQ_PWRON_FALL,
+		.end    = RK816_IRQ_PWRON_FALL,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static const struct mfd_cell rk808s[] = {
 	{ .name = "rk808-clkout", },
 	{ .name = "rk808-regulator", },
 	{
 		.name = "rk808-rtc",
 		.num_resources = ARRAY_SIZE(rtc_resources),
-		.resources = rtc_resources,
+		.resources = &rtc_resources[0],
 	},
 };
 
@@ -113,28 +375,11 @@ static const struct rk808_reg_data rk808_pre_init_reg[] = {
 	{ RK808_BUCK1_CONFIG_REG, BUCK1_RATE_MASK,  BUCK_ILMIN_200MA },
 	{ RK808_BUCK2_CONFIG_REG, BUCK2_RATE_MASK,  BUCK_ILMIN_200MA },
 	{ RK808_DCDC_UV_ACT_REG,  BUCK_UV_ACT_MASK, BUCK_UV_ACT_DISABLE},
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
 	{ RK808_VB_MON_REG,       MASK_ALL,         VB_LO_ACT |
 						    VB_LO_SEL_3500MV },
 };
 
-static const struct rk808_reg_data rk818_pre_init_reg[] = {
-	/* improve efficiency */
-	{ RK818_BUCK2_CONFIG_REG, BUCK2_RATE_MASK,  BUCK_ILMIN_250MA },
-	{ RK818_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK,  BUCK_ILMIN_250MA },
-	{ RK818_BOOST_CONFIG_REG, BOOST_ILMIN_MASK, BOOST_ILMIN_100MA },
-	{ RK818_USB_CTRL_REG,	  RK818_USB_ILIM_SEL_MASK,
-						    RK818_USB_ILMIN_2000MA },
-	/* close charger when usb lower then 3.4V */
-	{ RK818_USB_CTRL_REG,	  RK818_USB_CHG_SD_VSEL_MASK,
-						    (0x7 << 4) },
-	/* no action when vref */
-	{ RK818_H5V_EN_REG,	  BIT(1),	    RK818_REF_RDY_CTRL },
-	/* enable HDMI 5V */
-	{ RK818_H5V_EN_REG,	  BIT(0),	    RK818_H5V_EN },
-	{ RK808_VB_MON_REG,	  MASK_ALL,	    VB_LO_ACT |
-						    VB_LO_SEL_3500MV },
-};
-
 static const struct regmap_irq rk808_irqs[] = {
 	/* INT_STS */
 	[RK808_IRQ_VOUT_LO] = {
@@ -177,86 +422,337 @@ static const struct regmap_irq rk808_irqs[] = {
 	},
 };
 
-static const struct regmap_irq rk818_irqs[] = {
+static struct regmap_irq_chip rk808_irq_chip = {
+	.name = "rk808",
+	.irqs = rk808_irqs,
+	.num_irqs = ARRAY_SIZE(rk808_irqs),
+	.num_regs = 2,
+	.irq_reg_stride = 2,
+	.status_base = RK808_INT_STS_REG1,
+	.mask_base = RK808_INT_STS_MSK_REG1,
+	.ack_base = RK808_INT_STS_REG1,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk816s[] = {
+	{ .name = "rk808-clkout", },
+	{ .name = "rk808-regulator", },
+	{ .name = "rk8xx-gpio", },
+	{ .name = "rk816-battery", .of_compatible = "rk816-battery", },
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk816_pwrkey_resources),
+		.resources = &rk816_pwrkey_resources[0],
+	},
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rk816_rtc_resources),
+		.resources = &rk816_rtc_resources[0],
+	},
+};
+
+static const struct rk808_reg_data rk816_pre_init_reg[] = {
+	/* buck4 Max ILMIT*/
+	{ RK816_BUCK4_CONFIG_REG, REG_WRITE_MSK, BUCK4_MAX_ILIMIT },
+	/* hotdie temperature: 105c*/
+	{ RK816_THERMAL_REG, REG_WRITE_MSK, TEMP105C },
+	/* set buck 12.5mv/us */
+	{ RK816_BUCK1_CONFIG_REG, BUCK_RATE_MSK, BUCK_RATE_12_5MV_US },
+	{ RK816_BUCK2_CONFIG_REG, BUCK_RATE_MSK, BUCK_RATE_12_5MV_US },
+	/* enable RTC_PERIOD & RTC_ALARM int */
+	{ RK816_INT_STS_MSK_REG2, REG_WRITE_MSK, RTC_PERIOD_ALARM_INT_EN },
+	/* set bat 3.0 low and act shutdown */
+	{ RK816_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK816_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN },
+	/* enable PWRON rising/faling int */
+	{ RK816_INT_STS_MSK_REG1, REG_WRITE_MSK, RK816_PWRON_FALL_RISE_INT_EN },
+	/* enable PLUG IN/OUT int */
+	{ RK816_INT_STS_MSK_REG3, REG_WRITE_MSK, PLUGIN_OUT_INT_EN },
+	/* clear int flags */
+	{ RK816_INT_STS_REG1, REG_WRITE_MSK, ALL_INT_FLAGS_ST },
+	{ RK816_INT_STS_REG2, REG_WRITE_MSK, ALL_INT_FLAGS_ST },
+	{ RK816_INT_STS_REG3, REG_WRITE_MSK, ALL_INT_FLAGS_ST },
+	{ RK816_DCDC_EN_REG2, BOOST_EN_MASK, BOOST_DISABLE },
+	/* set write mask bit 1, otherwise 'is_enabled()' get wrong status */
+	{ RK816_LDO_EN_REG1, REGS_WMSK, REGS_WMSK },
+	{ RK816_LDO_EN_REG2, REGS_WMSK, REGS_WMSK },
+};
+
+static struct rk808_reg_data rk816_suspend_reg[] = {
+	/* set bat 3.4v low and act irq */
+	{ RK816_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK816_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ },
+};
+
+static struct rk808_reg_data rk816_resume_reg[] = {
+	/* set bat 3.0v low and act shutdown*/
+	{ RK816_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK816_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN },
+};
+
+static const struct regmap_irq rk816_irqs[] = {
 	/* INT_STS */
-	[RK818_IRQ_VOUT_LO] = {
-		.mask = RK818_IRQ_VOUT_LO_MSK,
+	[RK816_IRQ_PWRON_FALL] = {
+		.mask = RK816_IRQ_PWRON_FALL_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_VB_LO] = {
-		.mask = RK818_IRQ_VB_LO_MSK,
+	[RK816_IRQ_PWRON_RISE] = {
+		.mask = RK816_IRQ_PWRON_RISE_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_PWRON] = {
-		.mask = RK818_IRQ_PWRON_MSK,
+	[RK816_IRQ_VB_LOW] = {
+		.mask = RK816_IRQ_VB_LOW_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_PWRON] = {
+		.mask = RK816_IRQ_PWRON_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_PWRON_LP] = {
+		.mask = RK816_IRQ_PWRON_LP_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_HOTDIE] = {
+		.mask = RK816_IRQ_HOTDIE_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_RTC_ALARM] = {
+		.mask = RK816_IRQ_RTC_ALARM_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_RTC_PERIOD] = {
+		.mask = RK816_IRQ_RTC_PERIOD_MSK,
+		.reg_offset = 1,
+	},
+	[RK816_IRQ_USB_OV] = {
+		.mask = RK816_IRQ_USB_OV_MSK,
+		.reg_offset = 1,
+	},
+};
+
+static const struct regmap_irq rk816_battery_irqs[] = {
+	/* INT_STS */
+	[RK816_IRQ_PLUG_IN] = {
+		.mask = RK816_IRQ_PLUG_IN_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_PWRON_LP] = {
-		.mask = RK818_IRQ_PWRON_LP_MSK,
+	[RK816_IRQ_PLUG_OUT] = {
+		.mask = RK816_IRQ_PLUG_OUT_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_HOTDIE] = {
-		.mask = RK818_IRQ_HOTDIE_MSK,
+	[RK816_IRQ_CHG_OK] = {
+		.mask = RK816_IRQ_CHG_OK_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_RTC_ALARM] = {
-		.mask = RK818_IRQ_RTC_ALARM_MSK,
+	[RK816_IRQ_CHG_TE] = {
+		.mask = RK816_IRQ_CHG_TE_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_RTC_PERIOD] = {
-		.mask = RK818_IRQ_RTC_PERIOD_MSK,
+	[RK816_IRQ_CHG_TS] = {
+		.mask = RK816_IRQ_CHG_TS_MSK,
 		.reg_offset = 0,
 	},
-	[RK818_IRQ_USB_OV] = {
-		.mask = RK818_IRQ_USB_OV_MSK,
+	[RK816_IRQ_CHG_CVTLIM] = {
+		.mask = RK816_IRQ_CHG_CVTLIM_MSK,
+		.reg_offset = 0,
+	},
+	[RK816_IRQ_DISCHG_ILIM] = {
+		.mask = RK816_IRQ_DISCHG_ILIM_MSK,
 		.reg_offset = 0,
 	},
+};
+
+static struct regmap_irq_chip rk816_irq_chip = {
+	.name = "rk816",
+	.irqs = rk816_irqs,
+	.num_irqs = ARRAY_SIZE(rk816_irqs),
+	.num_regs = 2,
+	.irq_reg_stride = 3,
+	.status_base = RK816_INT_STS_REG1,
+	.mask_base = RK816_INT_STS_MSK_REG1,
+	.ack_base = RK816_INT_STS_REG1,
+	.init_ack_masked = true,
+};
+
+static struct regmap_irq_chip rk816_battery_irq_chip = {
+	.name = "rk816_battery",
+	.irqs = rk816_battery_irqs,
+	.num_irqs = ARRAY_SIZE(rk816_battery_irqs),
+	.num_regs = 1,
+	.status_base = RK816_INT_STS_REG3,
+	.mask_base = RK816_INT_STS_MSK_REG3,
+	.ack_base = RK816_INT_STS_REG3,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk818s[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{ .name = "rk818-regulator", },
+#else
+	{ .name = "rk808-clkout", },
+	{ .name = "rk808-regulator", },
+#endif
+	{ .name = "rk818-battery", .of_compatible = "rk818-battery", },
+	{ .name = "rk818-charger", },
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rtc_resources),
+		.resources = &rtc_resources[0],
+	},
+};
+
+static const struct rk808_reg_data rk818_pre_init_reg[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{ RK818_BUCK1_ON_VSEL_REG, 0x3f, 0x1a},//vdd_cpu_a : default 1.0375
+	{ RK818_BUCK1_SLP_VSEL_REG, 0x3f, 0x1a},//vdd_cpu_a : default 1.0375
+	{ RK818_BUCK2_ON_VSEL_REG, 0x3f, 0x0d},//vdd_ee : default 0.875
+	{ RK818_BUCK2_SLP_VSEL_REG, 0x3f, 0x0d},//vdd_ee : default 0.875
+	{ RK818_BUCK4_ON_VSEL_REG, 0x1f, 0x0c},//vdd_ao3v3 : default 3.3
+	{ RK818_BUCK4_SLP_VSEL_REG, 0x1f, 0x0c},//vdd_ao3v3 : default 3.3
+	{ RK818_LDO5_ON_VSEL_REG, 0x1f, 0x00},//vddio_ao1v8 : default 1.8
+	{ RK818_LDO5_SLP_VSEL_REG, 0x1f, 0x00},//vddio_ao1v8 : default 1.8
+	{ RK818_LDO6_ON_VSEL_REG, 0x1f, 0x11},//vdd_lcd : default 2.5
+	{ RK818_LDO6_SLP_VSEL_REG, 0x1f, 0x11},//vdd_lcd : default 2.5
+	{ RK818_LDO7_ON_VSEL_REG, 0x1f, 0x0a},//vddq_1v8 : default 1.8
+	{ RK818_LDO7_SLP_VSEL_REG, 0x1f, 0x0a},//vddq_1v8 : default 1.8
+	{ RK818_BOOST_LDO9_ON_VSEL_REG, 0x1f, 0x0f},//vddq_1v8 : default 1.8
+	{ RK818_BOOST_LDO9_SLP_VSEL_REG, 0x1f, 0x0f},//vddq_1v8 : default 1.8
+
+	{ RK818_H5V_EN_REG, REF_RDY_CTRL_MASK | H5V_EN_MASK,
+				REF_RDY_CTRL_ENABLE | H5V_EN_ENABLE },
+	{ RK818_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK,  BUCK_ILMIN_400MA },
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{ RK818_DCDC_EN_REG, SWITCH_EN_MASK | LDO9_EN_MASK,
+			LDO9_EN_ENABLE | SWITCH_EN_ENABLE },
+	{ RK818_SLEEP_SET_OFF_REG1, OTG_SLP_SET_MASK, OTG_SLP_SET_OFF },
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+#else
+	{ RK818_H5V_EN_REG, REF_RDY_CTRL_ENABLE | H5V_EN_MASK,
+					REF_RDY_CTRL_ENABLE | H5V_EN_ENABLE },
+	{ RK818_DCDC_EN_REG, BOOST_EN_MASK | SWITCH_EN_MASK,
+					BOOST_EN_ENABLE | SWITCH_EN_ENABLE },
+	{ RK818_SLEEP_SET_OFF_REG1, OTG_SLP_SET_MASK, OTG_SLP_SET_OFF },
+	{ RK818_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK,  BUCK_ILMIN_250MA },
+	{ RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{ RK808_CLK32OUT_REG, CLK32KOUT2_FUNC_MASK, CLK32KOUT2_FUNC},
+#endif
+};
+
+static struct rk808_reg_data rk818_suspend_reg[] = {
+	/* set bat 3.4v low and act irq */
+	{ RK808_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK808_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ },
+};
+
+static struct rk808_reg_data rk818_resume_reg[] = {
+	/* set bat 3.0v low and act shutdown*/
+	{ RK808_VB_MON_REG, VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK,
+	  RK808_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN },
+};
 
+static const struct regmap_irq rk818_irqs[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
 	/* INT_STS2 */
 	[RK818_IRQ_PLUG_IN] = {
-		.mask = RK818_IRQ_PLUG_IN_MSK,
+		.mask = PLUG_IN_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_PLUG_OUT] = {
-		.mask = RK818_IRQ_PLUG_OUT_MSK,
+		.mask = PLUG_OUT_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_OK] = {
-		.mask = RK818_IRQ_CHG_OK_MSK,
+		.mask = CHGOK_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_TE] = {
-		.mask = RK818_IRQ_CHG_TE_MSK,
+		.mask = CHGTE_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_TS1] = {
-		.mask = RK818_IRQ_CHG_TS1_MSK,
+		.mask = CHGTS1_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_TS2] = {
-		.mask = RK818_IRQ_TS2_MSK,
+		.mask = TS2_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_CHG_CVTLIM] = {
-		.mask = RK818_IRQ_CHG_CVTLIM_MSK,
+		.mask = CHG_CVTLIM_MASK,
 		.reg_offset = 1,
 	},
 	[RK818_IRQ_DISCHG_ILIM] = {
-		.mask = RK818_IRQ_DISCHG_ILIM_MSK,
+		.mask = DISCHG_ILIM_MASK,
 		.reg_offset = 1,
 	},
-};
-
-static struct regmap_irq_chip rk808_irq_chip = {
-	.name = "rk808",
-	.irqs = rk808_irqs,
-	.num_irqs = ARRAY_SIZE(rk808_irqs),
-	.num_regs = 2,
-	.irq_reg_stride = 2,
-	.status_base = RK808_INT_STS_REG1,
-	.mask_base = RK808_INT_STS_MSK_REG1,
-	.ack_base = RK808_INT_STS_REG1,
-	.init_ack_masked = true,
+#else
+	/* INT_STS */
+	[RK818_IRQ_VOUT_LO] = {
+		.mask = VOUT_LO_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_VB_LO] = {
+		.mask = VB_LO_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_PWRON] = {
+		.mask = PWRON_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_PWRON_LP] = {
+		.mask = PWRON_LP_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_HOTDIE] = {
+		.mask = HOTDIE_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_RTC_ALARM] = {
+		.mask = RTC_ALARM_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_RTC_PERIOD] = {
+		.mask = RTC_PERIOD_MASK,
+		.reg_offset = 0,
+	},
+	[RK818_IRQ_USB_OV] = {
+		.mask = USB_OV_MASK,
+		.reg_offset = 0,
+	},
+	/* INT_STS2 */
+	[RK818_IRQ_PLUG_IN] = {
+		.mask = PLUG_IN_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_PLUG_OUT] = {
+		.mask = PLUG_OUT_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_OK] = {
+		.mask = CHGOK_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_TE] = {
+		.mask = CHGTE_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_TS1] = {
+		.mask = CHGTS1_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_TS2] = {
+		.mask = TS2_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_CHG_CVTLIM] = {
+		.mask = CHG_CVTLIM_MASK,
+		.reg_offset = 1,
+	},
+	[RK818_IRQ_DISCHG_ILIM] = {
+		.mask = DISCHG_ILIM_MASK,
+		.reg_offset = 1,
+	},
+#endif
 };
 
 static struct regmap_irq_chip rk818_irq_chip = {
@@ -265,14 +761,206 @@ static struct regmap_irq_chip rk818_irq_chip = {
 	.num_irqs = ARRAY_SIZE(rk818_irqs),
 	.num_regs = 2,
 	.irq_reg_stride = 2,
-	.status_base = RK818_INT_STS_REG1,
-	.mask_base = RK818_INT_STS_MSK_REG1,
-	.ack_base = RK818_INT_STS_REG1,
+	.status_base = RK808_INT_STS_REG1,
+	.mask_base = RK808_INT_STS_MSK_REG1,
+	.ack_base = RK808_INT_STS_REG1,
 	.init_ack_masked = true,
 };
 
-static struct i2c_client *rk808_i2c_client;
-static void rk808_device_shutdown(void)
+static const struct regmap_irq rk805_irqs[] = {
+	[RK805_IRQ_PWRON_RISE] = {
+		.mask = RK805_IRQ_PWRON_RISE_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_VB_LOW] = {
+		.mask = RK805_IRQ_VB_LOW_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_PWRON] = {
+		.mask = RK805_IRQ_PWRON_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_PWRON_LP] = {
+		.mask = RK805_IRQ_PWRON_LP_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_HOTDIE] = {
+		.mask = RK805_IRQ_HOTDIE_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_RTC_ALARM] = {
+		.mask = RK805_IRQ_RTC_ALARM_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_RTC_PERIOD] = {
+		.mask = RK805_IRQ_RTC_PERIOD_MSK,
+		.reg_offset = 0,
+	},
+	[RK805_IRQ_PWRON_FALL] = {
+		.mask = RK805_IRQ_PWRON_FALL_MSK,
+		.reg_offset = 0,
+	},
+};
+
+static struct regmap_irq_chip rk805_irq_chip = {
+	.name = "rk805",
+	.irqs = rk805_irqs,
+	.num_irqs = ARRAY_SIZE(rk805_irqs),
+	.num_regs = 1,
+	.status_base = RK805_INT_STS_REG,
+	.mask_base = RK805_INT_STS_MSK_REG,
+	.ack_base = RK805_INT_STS_REG,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk805s[] = {
+	{ .name = "rk808-clkout", },
+	{ .name = "rk818-regulator", },
+	{ .name = "rk8xx-gpio", },
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk805_pwrkey_resources),
+		.resources = &rk805_pwrkey_resources[0],
+	},
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rtc_resources),
+		.resources = &rtc_resources[0],
+	},
+};
+
+static const struct rk808_reg_data rk805_pre_init_reg[] = {
+	{RK805_BUCK4_CONFIG_REG, BUCK_ILMIN_MASK, BUCK_ILMIN_400MA},
+	{RK805_GPIO_IO_POL_REG, SLP_SD_MSK, SLEEP_FUN},
+	{RK808_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{RK805_THERMAL_REG, TEMP_HOTDIE_MSK, TEMP115C},
+	{RK805_DCDC_VRP_REG, REG_WRITE_MSK, BUCK4_VRP_3PERCENT},
+};
+
+static struct rk808_reg_data rk805_suspend_reg[] = {
+	{RK805_BUCK3_CONFIG_REG, PWM_MODE_MSK, AUTO_PWM_MODE},
+};
+
+static struct rk808_reg_data rk805_resume_reg[] = {
+	{RK805_BUCK3_CONFIG_REG, PWM_MODE_MSK, FPWM_MODE},
+};
+
+#define REGMAP_IRQ_M(_id) \
+	[_id] = {				\
+		.mask = BIT(((_id) % 8)),	\
+		.reg_offset = ((_id) / 8),	\
+	}
+
+static const struct regmap_irq rk817_irqs[RK817_IRQ_END] = {
+	REGMAP_IRQ_M(0),
+	REGMAP_IRQ_M(1),
+	REGMAP_IRQ_M(2),
+	REGMAP_IRQ_M(3),
+	REGMAP_IRQ_M(4),
+	REGMAP_IRQ_M(5),
+	REGMAP_IRQ_M(6),
+	REGMAP_IRQ_M(7),
+	REGMAP_IRQ_M(8),
+	REGMAP_IRQ_M(9),
+	REGMAP_IRQ_M(10),
+	REGMAP_IRQ_M(11),
+	REGMAP_IRQ_M(12),
+	REGMAP_IRQ_M(13),
+	REGMAP_IRQ_M(14),
+	REGMAP_IRQ_M(15),
+	REGMAP_IRQ_M(16),
+	REGMAP_IRQ_M(17),
+	REGMAP_IRQ_M(18),
+	REGMAP_IRQ_M(19),
+	REGMAP_IRQ_M(20),
+	REGMAP_IRQ_M(21),
+	REGMAP_IRQ_M(22),
+	REGMAP_IRQ_M(23)
+};
+
+static struct regmap_irq_chip rk817_irq_chip = {
+	.name = "rk817",
+	.irqs = rk817_irqs,
+	.num_irqs = ARRAY_SIZE(rk817_irqs),
+	.num_regs = 3,
+	.irq_reg_stride = 2,
+	.status_base = RK817_INT_STS_REG0,
+	.mask_base = RK817_INT_STS_MSK_REG0,
+	.ack_base = RK817_INT_STS_REG0,
+	.init_ack_masked = true,
+};
+
+static const struct mfd_cell rk817s[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{ .name = "rk808-regulator",},
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk817_pwrkey_resources),
+		.resources = &rk817_pwrkey_resources[0],
+	},
+	{
+		.name = "rk817-codec",
+		.of_compatible = "rockchip,rk817-codec",
+	},
+#else
+	{ .name = "rk808-clkout",},
+	{ .name = "rk808-regulator",},
+	{ .name = "rk817-battery", .of_compatible = "rk817,battery", },
+	{ .name = "rk817-charger", .of_compatible = "rk817,charger", },
+	{
+		.name = "rk8xx-pwrkey",
+		.num_resources = ARRAY_SIZE(rk817_pwrkey_resources),
+		.resources = &rk817_pwrkey_resources[0],
+	},
+	{
+		.name = "rk808-rtc",
+		.num_resources = ARRAY_SIZE(rk817_rtc_resources),
+		.resources = &rk817_rtc_resources[0],
+	},
+	{
+		.name = "rk817-codec",
+		.of_compatible = "rockchip,rk817-codec",
+	},
+#endif
+};
+
+static const struct rk808_reg_data rk817_pre_init_reg[] = {
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	{RK817_BUCK2_ON_VSEL_REG, 0x7f, 0x2B},	/*vddcpu_b : 1.0375 (default)*/
+	{RK817_BUCK3_ON_VSEL_REG, 0x7f, 0x20},	/*vcc_2v3 : 2.4 (default)*/
+
+	{RK817_POWER_EN_REG(0), 0xff, 0x66},
+	{RK817_POWER_EN_REG(1), 0xff, 0x88},
+	{RK817_SYS_CFG(1), RK817_HOTDIE_TEMP_MSK | RK817_TSD_TEMP_MSK,
+					   RK817_HOTDIE_105 | RK817_TSD_140},
+#else
+	{RK817_RTC_CTRL_REG, RTC_STOP, RTC_STOP},
+	{RK817_GPIO_INT_CFG, RK817_INT_POL_MSK, RK817_INT_POL_L},
+	{RK817_SYS_CFG(1), RK817_HOTDIE_TEMP_MSK | RK817_TSD_TEMP_MSK,
+					   RK817_HOTDIE_105 | RK817_TSD_140},
+#endif
+};
+
+static void rk808_device_shutdown_prepare(void)
+{
+	int ret;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	if (!rk808) {
+		dev_warn(&rk808_i2c_client->dev,
+			 "have no rk808, so do nothing here\n");
+		return;
+	}
+
+	if (pm_shutdown_prepare) {
+		ret = pm_shutdown_prepare(rk808);
+		if (ret)
+			dev_err(&rk808_i2c_client->dev,
+				"power off prepare error!\n");
+	}
+}
+
+static void rk808_syscore_shutdown(void)
 {
 	int ret;
 	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
@@ -283,18 +971,295 @@ static void rk808_device_shutdown(void)
 		return;
 	}
 
+	/* close rtc int when power off */
+	regmap_update_bits(rk808->regmap,
+			   RK808_INT_STS_MSK_REG1,
+			   (0x3 << 5), (0x3 << 5));
+	regmap_update_bits(rk808->regmap,
+			   RK808_RTC_INT_REG,
+			   (0x3 << 2), (0x0 << 2));
+	/*
+	 * For PMIC that power off supplies by write register via i2c bus,
+	 * it's better to do power off at syscore shutdown here.
+	 *
+	 * Because when run to kernel's "pm_power_off" call, i2c may has
+	 * been stopped or PMIC may not be able to get i2c transfer while
+	 * there are too many devices are competiting.
+	 */
+	/* power off supplies ! */
+	if (pm_shutdown) {
+		dev_info(&rk808_i2c_client->dev, "System power off\n");
+		ret = pm_shutdown(rk808->regmap);
+		if (ret)
+			dev_err(&rk808_i2c_client->dev,
+				"System power off error!\n");
+		mdelay(10);
+		dev_info(&rk808_i2c_client->dev,
+			 "Cpu should never reach here, stop!\n");
+		while (1)
+			;
+	}
+}
+
+static struct syscore_ops rk808_syscore_ops = {
+	.shutdown = rk808_syscore_shutdown,
+};
+
+/*
+ * RK8xx PMICs would do real power off in syscore shutdown, if "pm_power_off"
+ * is not assigned(e.g. PSCI is not enabled), we have to provide a dummy
+ * callback for it, otherwise there comes a halt in Reboot system call:
+ *
+ * if ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)
+ *		cmd = LINUX_REBOOT_CMD_HALT;
+ */
+static void rk808_pm_power_off_dummy(void)
+{
+	pr_info("Dummy power off for RK8xx PMICs, should never reach here!\n");
+
+	while (1)
+		;
+}
+
+static ssize_t rk8xx_dbg_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int ret;
+	char cmd;
+	u32 input[2], addr, data;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	ret = sscanf(buf, "%c ", &cmd);
+	switch (cmd) {
+	case 'w':
+		ret = sscanf(buf, "%c %x %x ", &cmd, &input[0], &input[1]);
+		if (ret != 3) {
+			pr_err("erro! cmd format: echo w [addr] [value]\n");
+			goto out;
+		}
+		addr = input[0] & 0xff;
+		data = input[1] & 0xff;
+		pr_info("cmd : %c %x %x\n\n", cmd, input[0], input[1]);
+		regmap_write(rk808->regmap, addr, data);
+		regmap_read(rk808->regmap, addr, &data);
+		pr_info("new: %x %x\n", addr, data);
+		break;
+	case 'r':
+		ret = sscanf(buf, "%c %x ", &cmd, &input[0]);
+		if (ret != 2) {
+			pr_err("erro! cmd format: echo r [addr]\n");
+			goto out;
+		}
+		pr_info("cmd : %c %x\n\n", cmd, input[0]);
+		addr = input[0] & 0xff;
+		regmap_read(rk808->regmap, addr, &data);
+		pr_info("%x %x\n", input[0], data);
+		break;
+	default:
+		pr_err("Unknown command\n");
+		break;
+	}
+
+out:
+	return count;
+}
+
+static int rk817_pinctrl_init(struct device *dev, struct rk808 *rk808)
+{
+	int ret;
+	struct platform_device	*pinctrl_dev;
+	struct pinctrl_state *default_st;
+
+	pinctrl_dev = platform_device_alloc("rk805-pinctrl", -1);
+	if (!pinctrl_dev) {
+		dev_err(dev, "Alloc pinctrl dev failed!\n");
+		return -ENOMEM;
+	}
+
+	pinctrl_dev->dev.parent = dev;
+
+	ret = platform_device_add(pinctrl_dev);
+
+	if (ret) {
+		platform_device_put(pinctrl_dev);
+		dev_err(dev, "Add rk805-pinctrl dev failed!\n");
+		return ret;
+	}
+	if (dev->pins && !IS_ERR(dev->pins->p)) {
+		dev_info(dev, "had get a pinctrl!\n");
+		return 0;
+	}
+
+	rk808->pins = devm_kzalloc(dev, sizeof(struct rk808_pin_info),
+				   GFP_KERNEL);
+	if (!rk808->pins)
+		return -ENOMEM;
+
+	rk808->pins->p = devm_pinctrl_get(dev);
+	if (IS_ERR(rk808->pins->p)) {
+		rk808->pins->p = NULL;
+		dev_err(dev, "no pinctrl handle\n");
+		return 0;
+	}
+
+	default_st = pinctrl_lookup_state(rk808->pins->p,
+					  PINCTRL_STATE_DEFAULT);
+
+	if (IS_ERR(default_st)) {
+		dev_dbg(dev, "no default pinctrl state\n");
+			return -EINVAL;
+	}
+
+	ret = pinctrl_select_state(rk808->pins->p, default_st);
+	if (ret) {
+		dev_dbg(dev, "failed to activate default pinctrl state\n");
+		return -EINVAL;
+	}
+
+	rk808->pins->power_off = pinctrl_lookup_state(rk808->pins->p,
+						      "pmic-power-off");
+	if (IS_ERR(rk808->pins->power_off)) {
+		rk808->pins->power_off = NULL;
+		dev_dbg(dev, "no power-off pinctrl state\n");
+	}
+
+	rk808->pins->sleep = pinctrl_lookup_state(rk808->pins->p,
+						  "pmic-sleep");
+	if (IS_ERR(rk808->pins->sleep)) {
+		rk808->pins->sleep = NULL;
+		dev_dbg(dev, "no sleep-setting state\n");
+	}
+
+	rk808->pins->reset = pinctrl_lookup_state(rk808->pins->p,
+						  "pmic-reset");
+	if (IS_ERR(rk808->pins->reset)) {
+		rk808->pins->reset = NULL;
+		dev_dbg(dev, "no reset-setting pinctrl state\n");
+		return 0;
+	}
+
 	ret = regmap_update_bits(rk808->regmap,
-				 RK808_DEVCTRL_REG,
-				 DEV_OFF_RST, DEV_OFF_RST);
+				 RK817_SYS_CFG(3),
+				 RK817_SLPPOL_MSK,
+				 RK817_SLPPOL_L);
+	if (ret) {
+		dev_err(dev, "init: config RK817_SLPPOL_L error!\n");
+		return -1;
+	}
+
+	ret = pinctrl_select_state(rk808->pins->p, rk808->pins->reset);
+
 	if (ret)
-		dev_err(&rk808_i2c_client->dev, "power off error!\n");
+		dev_dbg(dev, "failed to activate reset-setting pinctrl state\n");
+
+	return 0;
 }
 
+struct rk817_reboot_data_t {
+	struct rk808 *rk808;
+	struct notifier_block reboot_notifier;
+};
+
+static struct rk817_reboot_data_t rk817_reboot_data;
+
+static int rk817_reboot_notifier_handler(struct notifier_block *nb,
+					 unsigned long action, void *cmd)
+{
+	struct rk817_reboot_data_t *data;
+	int ret;
+	struct device *dev;
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	int value, power_en_active0, power_en_active1;
+
+	regmap_read(data->rk808->regmap, RK817_POWER_EN_SAVE0,
+		&power_en_active0);
+	regmap_read(data->rk808->regmap, RK817_POWER_EN_SAVE1,
+		&power_en_active1);
+	value = power_en_active0 & 0x0f;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(0), value | 0xf0);
+	value = (power_en_active0 & 0xf0) >> 4;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(1), value | 0xf0);
+	value = power_en_active1 & 0x0f;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(2), value | 0xf0);
+	value = (power_en_active1 & 0xf0) >> 4;
+	regmap_write(data->rk808->regmap, RK817_POWER_EN_REG(3), value | 0xf0);
+#endif
+
+	if (action != SYS_RESTART)
+		return NOTIFY_OK;
+
+	if (!cmd || !strlen(cmd) || !strcmp(cmd, "normal"))
+		return NOTIFY_OK;
+
+	data = container_of(nb, struct rk817_reboot_data_t, reboot_notifier);
+	dev = &data->rk808->i2c->dev;
+
+	ret = regmap_update_bits(data->rk808->regmap, RK817_SYS_CFG(3),
+				 RK817_RST_FUNC_MSK, RK817_RST_FUNC_REG);
+	if (ret)
+		dev_err(dev, "reboot: force RK817_RST_FUNC_REG error!\n");
+	else
+		dev_info(dev, "reboot: force RK817_RST_FUNC_REG ok!\n");
+	return NOTIFY_OK;
+}
+
+static void rk817_of_property_prepare(struct rk808 *rk808, struct device *dev)
+{
+	u32 inner;
+	int ret, func, msk, val;
+	struct device_node *np = dev->of_node;
+	struct regmap *regmap = rk808->regmap;
+return;
+	ret = of_property_read_u32_index(np, "fb-inner-reg-idxs", 0, &inner);
+	if (!ret && inner == RK817_ID_DCDC3)
+		regmap_update_bits(regmap, RK817_POWER_CONFIG,
+				   RK817_BUCK3_FB_RES_MSK,
+				   RK817_BUCK3_FB_RES_INTER);
+	else
+		regmap_update_bits(regmap, RK817_POWER_CONFIG,
+				   RK817_BUCK3_FB_RES_MSK,
+				   RK817_BUCK3_FB_RES_EXT);
+	dev_info(dev, "support dcdc3 fb mode:%d, %d\n", ret, inner);
+
+	ret = of_property_read_u32(np, "pmic-reset-func", &func);
+
+	msk = RK817_SLPPIN_FUNC_MSK | RK817_RST_FUNC_MSK;
+	val = SLPPIN_NULL_FUN;
+
+	if (!ret && func < RK817_RST_FUNC_CNT) {
+		val |= RK817_RST_FUNC_MSK &
+		       (func << RK817_RST_FUNC_SFT);
+	} else {
+		val |= RK817_RST_FUNC_REG;
+	}
+
+	regmap_update_bits(regmap, RK817_SYS_CFG(3), msk, val);
+
+	dev_info(dev, "support pmic reset mode:%d,%d\n", ret, func);
+
+	rk817_reboot_data.rk808 = rk808;
+	rk817_reboot_data.reboot_notifier.notifier_call =
+		rk817_reboot_notifier_handler;
+	ret = register_reboot_notifier(&rk817_reboot_data.reboot_notifier);
+	if (ret)
+		dev_err(dev, "failed to register reboot nb\n");
+}
+
+static struct kobject *rk8xx_kobj;
+static struct device_attribute rk8xx_attrs =
+		__ATTR(rk8xx_dbg, 0200, NULL, rk8xx_dbg_store);
+
 static const struct of_device_id rk808_of_match[] = {
+	{ .compatible = "rockchip,rk805" },
 	{ .compatible = "rockchip,rk808" },
+	{ .compatible = "rockchip,rk809" },
+	{ .compatible = "rockchip,rk816" },
+	{ .compatible = "rockchip,rk817" },
 	{ .compatible = "rockchip,rk818" },
 	{ },
 };
+
 MODULE_DEVICE_TABLE(of, rk808_of_match);
 
 static int rk808_probe(struct i2c_client *client,
@@ -302,119 +1267,406 @@ static int rk808_probe(struct i2c_client *client,
 {
 	struct device_node *np = client->dev.of_node;
 	struct rk808 *rk808;
+	int (*pm_shutdown_fn)(struct regmap *regmap) = NULL;
+	int (*pm_shutdown_prepare_fn)(struct rk808 *rk808) = NULL;
 	const struct rk808_reg_data *pre_init_reg;
-	const struct mfd_cell *cells;
-	int nr_pre_init_regs;
-	int nr_cells;
-	int pm_off = 0;
-	int ret;
-	int i;
-
+	const struct regmap_config *regmap_config;
+	const struct regmap_irq_chip *irq_chip, *battery_irq_chip = NULL;
+	const struct mfd_cell *cell;
+	u8 on_source = 0, off_source = 0;
+	int msb, lsb, reg_num=0, cell_num;
+	int ret, i, pm_off = 0;
+	unsigned int on, off;
+	u8 pmic_id_msb = RK808_ID_MSB, pmic_id_lsb = RK808_ID_LSB;
+	void (*of_property_prepare_fn)(struct rk808 *rk808,
+				       struct device *dev) = NULL;
+	int (*pinctrl_init)(struct device *dev, struct rk808 *rk808) = NULL;
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	int irq_gpio;
+	char sysfs_name[8];
+#endif
 	rk808 = devm_kzalloc(&client->dev, sizeof(*rk808), GFP_KERNEL);
 	if (!rk808)
 		return -ENOMEM;
 
-	rk808->variant = i2c_smbus_read_word_data(client, RK808_ID_MSB);
-	if (rk808->variant < 0) {
-		dev_err(&client->dev, "Failed to read the chip id at 0x%02x\n",
+	if (of_device_is_compatible(np, "rockchip,rk817") ||
+	    of_device_is_compatible(np, "rockchip,rk809")) {
+		pmic_id_msb = RK817_ID_MSB;
+		pmic_id_lsb = RK817_ID_LSB;
+	}
+	/* read Chip variant */
+	msb = i2c_smbus_read_byte_data(client, pmic_id_msb);
+	if (msb < 0) {
+		dev_err(&client->dev, "failed to read the chip id at 0x%x\n",
 			RK808_ID_MSB);
-		return rk808->variant;
+		return msb;
 	}
 
-	dev_dbg(&client->dev, "Chip id: 0x%x\n", (unsigned int)rk808->variant);
+	lsb = i2c_smbus_read_byte_data(client, pmic_id_lsb);
+	if (lsb < 0) {
+		dev_err(&client->dev, "failed to read the chip id at 0x%x\n",
+			RK808_ID_LSB);
+		return lsb;
+	}
 
+	rk808->variant = ((msb << 8) | lsb) & RK8XX_ID_MSK;
+	sprintf(sysfs_name, "rk%lx", rk808->variant);
+	dev_info(&client->dev, "Pmic Chip id: 0x%lx, sysfs: %s\n", rk808->variant,sysfs_name);
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	irq_gpio = of_get_named_gpio(np, "gpio-irq", 0);
+	if (irq_gpio < 0) {
+		dev_err(&client->dev, "No interrupt pin, no core IRQ\n");
+		return -EINVAL;
+	}
+	else dev_info(&client->dev, "Pmic irq gpio pin : %d\n", irq_gpio);
+
+	ret = gpio_request(irq_gpio, "pmic_irq");
+	if (ret)
+		dev_err(&client->dev,"interrupt_pin request failed(%d)\n", ret);
+
+	ret = gpio_direction_input(irq_gpio);
+	if (ret)
+		dev_err(&client->dev,"set interrupt_pin input failed(%d)\n", ret);
+
+	client->irq = gpio_to_irq(irq_gpio);
+	if (client->irq)
+		dev_info(&client->dev, "Pmic irq gpio irq number : %d\n", client->irq);
+
+#endif
+	/* set Chip platform init data*/
 	switch (rk808->variant) {
+	case RK816_ID:
+		cell = rk816s;
+		cell_num = ARRAY_SIZE(rk816s);
+		pre_init_reg = rk816_pre_init_reg;
+		reg_num = ARRAY_SIZE(rk816_pre_init_reg);
+		regmap_config = &rk816_regmap_config;
+		irq_chip = &rk816_irq_chip;
+		battery_irq_chip = &rk816_battery_irq_chip;
+		pm_shutdown_fn = rk816_shutdown;
+		on_source = RK816_ON_SOURCE_REG;
+		off_source = RK816_OFF_SOURCE_REG;
+		suspend_reg = rk816_suspend_reg;
+		suspend_reg_num = ARRAY_SIZE(rk816_suspend_reg);
+		resume_reg = rk816_resume_reg;
+		resume_reg_num = ARRAY_SIZE(rk816_resume_reg);
+		break;
 	case RK808_ID:
-		rk808->regmap_cfg = &rk808_regmap_config;
-		rk808->regmap_irq_chip = &rk808_irq_chip;
+		cell = rk808s;
+		cell_num = ARRAY_SIZE(rk808s);
 		pre_init_reg = rk808_pre_init_reg;
-		nr_pre_init_regs = ARRAY_SIZE(rk808_pre_init_reg);
-		cells = rk808s;
-		nr_cells = ARRAY_SIZE(rk808s);
+		reg_num = ARRAY_SIZE(rk808_pre_init_reg);
+		regmap_config = &rk808_regmap_config;
+		irq_chip = &rk808_irq_chip;
+		pm_shutdown_fn = rk808_shutdown;
+		break;
+	case RK805_ID:
+		cell = rk805s;
+		cell_num = ARRAY_SIZE(rk805s);
+		pre_init_reg = rk805_pre_init_reg;
+		reg_num = ARRAY_SIZE(rk805_pre_init_reg);
+		regmap_config = &rk805_regmap_config;
+		irq_chip = &rk805_irq_chip;
+		pm_shutdown_prepare_fn = rk805_shutdown_prepare;
+		on_source = RK805_ON_SOURCE_REG;
+		off_source = RK805_OFF_SOURCE_REG;
+		suspend_reg = rk805_suspend_reg;
+		suspend_reg_num = ARRAY_SIZE(rk805_suspend_reg);
+		resume_reg = rk805_resume_reg;
+		resume_reg_num = ARRAY_SIZE(rk805_resume_reg);
 		break;
 	case RK818_ID:
-		rk808->regmap_cfg = &rk818_regmap_config;
-		rk808->regmap_irq_chip = &rk818_irq_chip;
+		cell = rk818s;
+		cell_num = ARRAY_SIZE(rk818s);
 		pre_init_reg = rk818_pre_init_reg;
-		nr_pre_init_regs = ARRAY_SIZE(rk818_pre_init_reg);
-		cells = rk818s;
-		nr_cells = ARRAY_SIZE(rk818s);
+		reg_num = ARRAY_SIZE(rk818_pre_init_reg);
+		regmap_config = &rk818_regmap_config;
+		irq_chip = &rk818_irq_chip;
+		pm_shutdown_fn = rk818_shutdown;
+		on_source = RK818_ON_SOURCE_REG;
+		off_source = RK818_OFF_SOURCE_REG;
+		suspend_reg = rk818_suspend_reg;
+		suspend_reg_num = ARRAY_SIZE(rk818_suspend_reg);
+		resume_reg = rk818_resume_reg;
+		resume_reg_num = ARRAY_SIZE(rk818_resume_reg);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		cell = rk817s;
+		cell_num = ARRAY_SIZE(rk817s);
+		pre_init_reg = rk817_pre_init_reg;
+		reg_num = ARRAY_SIZE(rk817_pre_init_reg);
+		regmap_config = &rk817_regmap_config;
+		irq_chip = &rk817_irq_chip;
+		pm_shutdown_prepare_fn = rk817_shutdown_prepare;
+		on_source = RK817_ON_SOURCE_REG;
+		off_source = RK817_OFF_SOURCE_REG;
+		of_property_prepare_fn = rk817_of_property_prepare;
+		pinctrl_init = rk817_pinctrl_init;
 		break;
 	default:
-		dev_err(&client->dev, "Unsupported RK8XX ID %lu\n",
+		dev_err(&client->dev, "unsupported RK8XX ID 0x%lx\n",
 			rk808->variant);
 		return -EINVAL;
 	}
 
-	rk808->i2c = client;
-	i2c_set_clientdata(client, rk808);
-
-	rk808->regmap = devm_regmap_init_i2c(client, rk808->regmap_cfg);
+	rk808->regmap = devm_regmap_init_i2c(client, regmap_config);
 	if (IS_ERR(rk808->regmap)) {
 		dev_err(&client->dev, "regmap initialization failed\n");
 		return PTR_ERR(rk808->regmap);
 	}
 
-	if (!client->irq) {
-		dev_err(&client->dev, "No interrupt support, no core IRQ\n");
-		return -EINVAL;
+	/* on & off source */
+	if (on_source && off_source) {
+		ret = regmap_read(rk808->regmap, on_source, &on);
+		if (ret) {
+			dev_err(&client->dev, "read 0x%x failed\n", on_source);
+			return ret;
+		}
+
+		ret = regmap_read(rk808->regmap, off_source, &off);
+		if (ret) {
+			dev_err(&client->dev, "read 0x%x failed\n", off_source);
+			return ret;
+		}
+
+		dev_info(&client->dev, "source: on=0x%02x, off=0x%02x\n",
+			 on, off);
+	}
+
+	if(reg_num) {
+		for (i = 0; i < reg_num; i++) {
+			ret = regmap_update_bits(rk808->regmap,
+						 pre_init_reg[i].addr,
+						 pre_init_reg[i].mask,
+						 pre_init_reg[i].value);
+			if (ret) {
+				dev_err(&client->dev,
+					"0x%x write err\n",
+					pre_init_reg[i].addr);
+				return ret;
+			}
+		}
 	}
 
-	ret = regmap_add_irq_chip(rk808->regmap, client->irq,
-				  IRQF_ONESHOT, -1,
-				  rk808->regmap_irq_chip, &rk808->irq_data);
+	if (of_property_prepare_fn)
+		of_property_prepare_fn(rk808, &client->dev);
+
+	i2c_set_clientdata(client, rk808);
+	rk808->i2c = client;
+	rk808_i2c_client = client;
+
+	if (pinctrl_init) {
+		ret = pinctrl_init(&client->dev, rk808);
+		if (ret)
+			return ret;
+	}
+
+	ret = regmap_add_irq_chip(rk808->regmap,
+				client->irq, IRQF_ONESHOT | IRQF_SHARED, -1,
+				irq_chip, &rk808->irq_data);
 	if (ret) {
 		dev_err(&client->dev, "Failed to add irq_chip %d\n", ret);
 		return ret;
 	}
 
-	for (i = 0; i < nr_pre_init_regs; i++) {
-		ret = regmap_update_bits(rk808->regmap,
-					pre_init_reg[i].addr,
-					pre_init_reg[i].mask,
-					pre_init_reg[i].value);
+	if (battery_irq_chip) {
+		ret = regmap_add_irq_chip(rk808->regmap,
+					client->irq, IRQF_ONESHOT | IRQF_SHARED, -1,
+					irq_chip, &rk808->battery_irq_data);
 		if (ret) {
 			dev_err(&client->dev,
-				"0x%x write err\n",
-				pre_init_reg[i].addr);
+				"Failed to add batterry irq_chip %d\n", ret);
+			regmap_del_irq_chip(client->irq, rk808->irq_data);
 			return ret;
 		}
 	}
 
-	ret = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_NONE,
-			      cells, nr_cells, NULL, 0,
-			      regmap_irq_get_domain(rk808->irq_data));
+	ret = mfd_add_devices(&client->dev, -1,
+			      cell, cell_num,
+			      NULL, 0, regmap_irq_get_domain(rk808->irq_data));
 	if (ret) {
 		dev_err(&client->dev, "failed to add MFD devices %d\n", ret);
 		goto err_irq;
 	}
 
 	pm_off = of_property_read_bool(np,
-				"rockchip,system-power-controller");
-	if (pm_off && !pm_power_off) {
-		rk808_i2c_client = client;
-		pm_power_off = rk808_device_shutdown;
+				       "rockchip,system-power-controller");
+	if (pm_off) {
+		if (pm_shutdown_prepare_fn) {
+			pm_shutdown_prepare = pm_shutdown_prepare_fn;
+			pm_power_off_prepare = rk808_device_shutdown_prepare;
+		}
+		if (pm_shutdown_fn) {
+			pm_shutdown = pm_shutdown_fn;
+			register_syscore_ops(&rk808_syscore_ops);
+		}
+
+		/*
+		 * If not assigned(e.g. PSCI is not enable), we provide a
+		 * dummy for it to avoid halt in Reboot system call.
+		 */
+		if (!pm_power_off)
+			pm_power_off = rk808_pm_power_off_dummy;
+	}
+
+	rk8xx_kobj = kobject_create_and_add(sysfs_name, NULL);
+	if (rk8xx_kobj) {
+		ret = sysfs_create_file(rk8xx_kobj, &rk8xx_attrs.attr);
+		if (ret)
+			dev_err(&client->dev, "create rk8xx sysfs error\n");
 	}
 
 	return 0;
 
 err_irq:
 	regmap_del_irq_chip(client->irq, rk808->irq_data);
+	if (battery_irq_chip)
+		regmap_del_irq_chip(client->irq, rk808->battery_irq_data);
 	return ret;
 }
 
+static void rk8xx_shutdown(struct i2c_client *client)
+{
+	struct rk808 *rk808 = i2c_get_clientdata(client);
+
+	if (system_state == SYSTEM_POWER_OFF) {
+		dev_info(&client->dev, "%s[%d]Chip id: 0x%lx\n",__func__,__LINE__, rk808->variant);
+
+		switch (rk808->variant) {
+		case RK817_ID:
+			regmap_write(rk808->regmap, RK817_POWER_EN_REG(1), 0x00 | 0xf0);
+			regmap_write(rk808->regmap, RK817_POWER_EN_REG(2), 0x00 | 0xf0);
+			regmap_write(rk808->regmap, RK817_POWER_EN_REG(3), 0x00 | 0xf0);
+			break;
+		default:
+			dev_info(&client->dev, "unsupported RK8XX ID 0x%lx\n",
+				rk808->variant);
+		}
+	}
+
+	return;
+}
+
+static int rk808_suspend(struct device *dev)
+{
+	int i, ret;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	for (i = 0; i < suspend_reg_num; i++) {
+		ret = regmap_update_bits(rk808->regmap,
+					 suspend_reg[i].addr,
+					 suspend_reg[i].mask,
+					 suspend_reg[i].value);
+		if (ret) {
+			dev_err(dev, "0x%x write err\n",
+				suspend_reg[i].addr);
+			return ret;
+		}
+	}
+
+	if (rk808->pins && rk808->pins->p && rk808->pins->sleep) {
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPIN_FUNC_MSK,
+					 SLPPIN_NULL_FUN);
+		if (ret) {
+			dev_err(dev, "suspend: config SLPPIN_NULL_FUN error!\n");
+			return -1;
+		}
+
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPOL_MSK,
+					 RK817_SLPPOL_H);
+		if (ret) {
+			dev_err(dev, "suspend: config RK817_SLPPOL_H error!\n");
+			return -1;
+		}
+
+		ret = pinctrl_select_state(rk808->pins->p, rk808->pins->sleep);
+		if (ret) {
+			dev_err(dev, "failed to act slp pinctrl state\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int rk808_resume(struct device *dev)
+{
+	int i, ret;
+	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
+
+	for (i = 0; i < resume_reg_num; i++) {
+		ret = regmap_update_bits(rk808->regmap,
+					 resume_reg[i].addr,
+					 resume_reg[i].mask,
+					 resume_reg[i].value);
+		if (ret) {
+			dev_err(dev, "0x%x write err\n",
+				resume_reg[i].addr);
+			return ret;
+		}
+	}
+
+	if (rk808->pins && rk808->pins->p && rk808->pins->reset) {
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPIN_FUNC_MSK,
+					 SLPPIN_NULL_FUN);
+		if (ret) {
+			dev_err(dev, "resume: config SLPPIN_NULL_FUN error!\n");
+			return -1;
+		}
+
+		ret = regmap_update_bits(rk808->regmap,
+					 RK817_SYS_CFG(3),
+					 RK817_SLPPOL_MSK,
+					 RK817_SLPPOL_L);
+		if (ret) {
+			dev_err(dev, "resume: config RK817_SLPPOL_L error!\n");
+			return -1;
+		}
+
+		ret = pinctrl_select_state(rk808->pins->p, rk808->pins->reset);
+		if (ret)
+			dev_dbg(dev, "failed to act reset pinctrl state\n");
+	}
+
+	return 0;
+}
+
 static int rk808_remove(struct i2c_client *client)
 {
 	struct rk808 *rk808 = i2c_get_clientdata(client);
 
 	regmap_del_irq_chip(client->irq, rk808->irq_data);
-	pm_power_off = NULL;
+	mfd_remove_devices(&client->dev);
+
+	if (pm_power_off == rk808_pm_power_off_dummy)
+		pm_power_off = NULL;
+	if (pm_power_off_prepare == rk808_device_shutdown_prepare)
+		pm_power_off_prepare = NULL;
+	if (pm_shutdown)
+		unregister_syscore_ops(&rk808_syscore_ops);
 
 	return 0;
 }
 
+static const struct dev_pm_ops rk808_pm_ops = {
+	.suspend = rk808_suspend,
+	.resume =  rk808_resume,
+};
+
 static const struct i2c_device_id rk808_ids[] = {
+	{ "rk805" },
 	{ "rk808" },
+	{ "rk809" },
+	{ "rk816" },
+	{ "rk817" },
 	{ "rk818" },
 	{ },
 };
@@ -424,16 +1676,29 @@ static struct i2c_driver rk808_i2c_driver = {
 	.driver = {
 		.name = "rk808",
 		.of_match_table = rk808_of_match,
+		.pm = &rk808_pm_ops,
 	},
 	.probe    = rk808_probe,
+	.shutdown = rk8xx_shutdown,
 	.remove   = rk808_remove,
 	.id_table = rk808_ids,
 };
 
-module_i2c_driver(rk808_i2c_driver);
+static int __init rk808_pmic_init(void)
+{
+	return i2c_add_driver(&rk808_i2c_driver);
+}
+
+subsys_initcall(rk808_pmic_init);
+
+static void __exit rk808_pmic_exit(void)
+{
+	i2c_del_driver(&rk808_i2c_driver);
+}
+module_exit(rk808_pmic_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Chris Zhong <zyw@rock-chips.com>");
 MODULE_AUTHOR("Zhang Qing <zhangqing@rock-chips.com>");
-MODULE_AUTHOR("Wadim Egorov <w.egorov@phytec.de>");
-MODULE_DESCRIPTION("RK808/RK818 PMIC driver");
+MODULE_AUTHOR("Chen jianhong <chenjh@rock-chips.com>");
+MODULE_DESCRIPTION("RK808 PMIC driver");
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index b0c0fa0444dd..33a74fd3297c 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -255,6 +255,15 @@ config PINCTRL_ZYNQ
 	select GENERIC_PINCONF
 	help
 	  This selects the pinctrl driver for Xilinx Zynq.
+      
+config PINCTRL_RK805
+	tristate "Pinctrl and GPIO driver for RK805 PMIC"
+	depends on MFD_RK808
+	select GPIOLIB
+	select PINMUX
+	select GENERIC_PINCONF
+	help
+	  This selects the pinctrl driver for RK805.
 
 source "drivers/pinctrl/aspeed/Kconfig"
 source "drivers/pinctrl/bcm/Kconfig"
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 11bad373dfe0..5e628257ba72 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_PINCTRL_LPC18XX)	+= pinctrl-lpc18xx.o
 obj-$(CONFIG_PINCTRL_TB10X)	+= pinctrl-tb10x.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
 obj-$(CONFIG_PINCTRL_ZYNQ)	+= pinctrl-zynq.o
+obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
 
 obj-$(CONFIG_ARCH_ASPEED)	+= aspeed/
 obj-y				+= bcm/
diff --git a/drivers/pinctrl/pinctrl-rk805.c b/drivers/pinctrl/pinctrl-rk805.c
new file mode 100755
index 000000000000..8810aabb7555
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-rk805.c
@@ -0,0 +1,689 @@
+/*
+ * Pinctrl driver for Rockchip RK805 PMIC
+ *
+ * Copyright (c) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Author: Joseph Chen <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under  the terms of the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * Based on the pinctrl-as3722 driver
+ */
+
+#include <linux/gpio/driver.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/rk808.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+
+#include "core.h"
+#include "pinconf.h"
+#include "pinctrl-utils.h"
+
+struct rk805_pin_function {
+	const char *name;
+	const char *const *groups;
+	unsigned int ngroups;
+	int mux_option;
+};
+
+struct rk805_pin_group {
+	const char *name;
+	const unsigned int pins[1];
+	unsigned int npins;
+};
+
+/*
+ * @reg: gpio setting register;
+ * @fun_mask: functions select mask value, when set is gpio;
+ * @dir_mask: input or output mask value, when set is output, otherwise input;
+ * @val_mask: gpio set value, when set is level high, otherwise low;
+ *
+ * Different PMIC has different pin features, belowing 3 mask members are not
+ * all necessary for every PMIC. For example, RK805 has 2 pins that can be used
+ * as output only GPIOs, so func_mask and dir_mask are not needed. RK816 has 1
+ * pin that can be used as TS/GPIO, so fun_mask, dir_mask and val_mask are all
+ * necessary.
+ */
+struct rk805_pin_config {
+	u8 reg;
+	u8 fun_msk;
+	u8 dir_msk;
+	u8 val_msk;
+};
+
+struct rk805_pctrl_info {
+	struct rk808 *rk808;
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	struct gpio_chip gpio_chip;
+	struct pinctrl_desc pinctrl_desc;
+	const struct rk805_pin_function *functions;
+	unsigned int num_functions;
+	const struct rk805_pin_group *groups;
+	int num_pin_groups;
+	const struct pinctrl_pin_desc *pins;
+	unsigned int num_pins;
+	struct rk805_pin_config *pin_cfg;
+};
+
+enum rk805_pinmux_option {
+	RK805_PINMUX_GPIO,
+};
+
+enum {
+	RK805_GPIO0,
+	RK805_GPIO1,
+};
+
+static const char *const rk805_gpio_groups[] = {
+	"gpio0",
+	"gpio1",
+};
+
+/* RK805: 2 output only GPIOs */
+static const struct pinctrl_pin_desc rk805_pins_desc[] = {
+	PINCTRL_PIN(RK805_GPIO0, "gpio0"),
+	PINCTRL_PIN(RK805_GPIO1, "gpio1"),
+};
+
+static const struct rk805_pin_function rk805_pin_functions[] = {
+	{
+		.name = "gpio",
+		.groups = rk805_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk805_gpio_groups),
+		.mux_option = RK805_PINMUX_GPIO,
+	},
+};
+
+static const struct rk805_pin_group rk805_pin_groups[] = {
+	{
+		.name = "gpio0",
+		.pins = { RK805_GPIO0 },
+		.npins = 1,
+	},
+	{
+		.name = "gpio1",
+		.pins = { RK805_GPIO1 },
+		.npins = 1,
+	},
+};
+
+#define RK805_GPIO0_VAL_MSK	BIT(0)
+#define RK805_GPIO1_VAL_MSK	BIT(1)
+
+static struct rk805_pin_config rk805_gpio_cfgs[] = {
+	{
+		.reg = RK805_OUT_REG,
+		.val_msk = RK805_GPIO0_VAL_MSK,
+	},
+	{
+		.reg = RK805_OUT_REG,
+		.val_msk = RK805_GPIO1_VAL_MSK,
+	},
+};
+
+enum rk817_pinmux_option {
+	RK817_PINMUX_FUN0 = 0,
+	RK817_PINMUX_FUN1,
+	RK817_PINMUX_FUN2,
+	RK817_PINMUX_FUN3
+};
+
+enum {
+	RK817_GPIO_SLP,
+	RK817_GPIO_TS,
+	RK817_GPIO_GT
+};
+
+/* for rk809 only a sleep pin */
+static const char *const rk817_gpio_groups[] = {
+	"gpio_slp",
+	"gpio_ts",
+	"gpio_gt",
+};
+
+static const struct pinctrl_pin_desc rk817_pins_desc[] = {
+	PINCTRL_PIN(RK817_GPIO_SLP, "gpio_slp"), /* sleep pin */
+	PINCTRL_PIN(RK817_GPIO_TS, "gpio_ts"), /* ts pin */
+	PINCTRL_PIN(RK817_GPIO_GT, "gpio_gt")/* gate pin */
+};
+
+static const struct rk805_pin_function rk817_pin_functions[] = {
+	{
+		.name = "pin_fun0",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN0,
+	},
+	{
+		.name = "pin_fun1",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN1,
+	},
+	{
+		.name = "pin_fun2",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN2,
+	},
+	{
+		.name = "pin_fun3",
+		.groups = rk817_gpio_groups,
+		.ngroups = ARRAY_SIZE(rk817_gpio_groups),
+		.mux_option = RK817_PINMUX_FUN3,
+	},
+};
+
+/* for rk809 only a sleep pin */
+static const struct rk805_pin_group rk817_pin_groups[] = {
+	{
+		.name = "gpio_slp",
+		.pins = { RK817_GPIO_SLP },
+		.npins = 1,
+	},
+	{
+		.name = "gpio_ts",
+		.pins = { RK817_GPIO_TS },
+		.npins = 1,
+	},
+	{
+		.name = "gpio_gt",
+		.pins = { RK817_GPIO_GT },
+		.npins = 1,
+	}
+};
+
+#define RK817_GPIOTS_VAL_MSK	BIT(3)
+#define RK817_GPIOGT_VAL_MSK	BIT(6)
+#define RK817_GPIOTS_FUNC_MSK	BIT(2)
+#define RK817_GPIOGT_FUNC_MSK	BIT(5)
+#define RK817_GPIOTS_DIR_MSK	BIT(4)
+#define RK817_GPIOGT_DIR_MSK	BIT(7)
+
+static struct rk805_pin_config rk817_gpio_cfgs[] = {
+	{
+		.reg = RK817_SYS_CFG(3),
+		.val_msk = 0,
+		.fun_msk = RK817_SLPPIN_FUNC_MSK,
+		.dir_msk = 0
+	},
+	{
+		.reg = RK817_GPIO_INT_CFG,
+		.val_msk = RK817_GPIOTS_VAL_MSK,
+		.fun_msk = RK817_GPIOTS_FUNC_MSK,
+		.dir_msk = RK817_GPIOTS_DIR_MSK
+	},
+	{
+		.reg = RK817_GPIO_INT_CFG,
+		.val_msk = RK817_GPIOGT_VAL_MSK,
+		.fun_msk = RK817_GPIOGT_FUNC_MSK,
+		.dir_msk = RK817_GPIOGT_DIR_MSK
+	}
+};
+
+/* generic gpio chip */
+static int rk805_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	struct rk805_pctrl_info *pci = gpiochip_get_data(chip);
+	int ret, val;
+
+	if (!pci->pin_cfg[offset].val_msk) {
+		dev_dbg(pci->dev, "getting gpio%d value is not support\n",
+			offset);
+		return -1;
+	}
+
+	ret = regmap_read(pci->rk808->regmap, pci->pin_cfg[offset].reg, &val);
+	if (ret) {
+		dev_err(pci->dev, "get gpio%d value failed\n", offset);
+		return ret;
+	}
+
+	return !!(val & pci->pin_cfg[offset].val_msk);
+}
+
+static void rk805_gpio_set(struct gpio_chip *chip,
+			   unsigned int offset,
+			   int value)
+{
+	struct rk805_pctrl_info *pci = gpiochip_get_data(chip);
+	int ret;
+
+	if (!pci->pin_cfg[offset].val_msk)
+		return;
+
+	ret = regmap_update_bits(pci->rk808->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].val_msk,
+				 value ? pci->pin_cfg[offset].val_msk : 0);
+	if (ret)
+		dev_err(pci->dev, "set gpio%d value %d failed\n",
+			offset, value);
+}
+
+static int rk805_gpio_direction_input(struct gpio_chip *chip,
+				      unsigned int offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int rk805_gpio_direction_output(struct gpio_chip *chip,
+				       unsigned int offset, int value)
+{
+	rk805_gpio_set(chip, offset, value);
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static int rk805_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
+{
+	struct rk805_pctrl_info *pci = gpiochip_get_data(chip);
+	unsigned int val;
+	int ret;
+
+	/* default output*/
+	if (!pci->pin_cfg[offset].dir_msk)
+		return 0;
+
+	ret = regmap_read(pci->rk808->regmap,
+			  pci->pin_cfg[offset].reg,
+			  &val);
+	if (ret) {
+		dev_err(pci->dev, "get gpio%d direction failed\n", offset);
+		return ret;
+	}
+
+	return !(val & pci->pin_cfg[offset].dir_msk);
+}
+
+static struct gpio_chip rk805_gpio_chip = {
+	.label			= "rk805-gpio",
+	.request		= gpiochip_generic_request,
+	.free			= gpiochip_generic_free,
+	.get_direction		= rk805_gpio_get_direction,
+	.get			= rk805_gpio_get,
+	.set			= rk805_gpio_set,
+	.direction_input	= rk805_gpio_direction_input,
+	.direction_output	= rk805_gpio_direction_output,
+	.can_sleep		= true,
+	.base			= -1,
+	.owner			= THIS_MODULE,
+};
+
+static struct gpio_chip rk817_gpio_chip = {
+	.label			= "rk817-gpio",
+	.request		= gpiochip_generic_request,
+	.free			= gpiochip_generic_free,
+	.get_direction		= rk805_gpio_get_direction,
+	.get			= rk805_gpio_get,
+	.set			= rk805_gpio_set,
+	.direction_input	= rk805_gpio_direction_input,
+	.direction_output	= rk805_gpio_direction_output,
+	.can_sleep		= true,
+	.base			= -1,
+	.owner			= THIS_MODULE,
+};
+
+/* generic pinctrl */
+static int rk805_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->num_pin_groups;
+}
+
+static const char *rk805_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+						unsigned int group)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->groups[group].name;
+}
+
+static int rk805_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+					unsigned int group,
+					const unsigned int **pins,
+					unsigned int *num_pins)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	*pins = pci->groups[group].pins;
+	*num_pins = pci->groups[group].npins;
+
+	return 0;
+}
+
+static const struct pinctrl_ops rk805_pinctrl_ops = {
+	.get_groups_count = rk805_pinctrl_get_groups_count,
+	.get_group_name = rk805_pinctrl_get_group_name,
+	.get_group_pins = rk805_pinctrl_get_group_pins,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+static int rk805_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->num_functions;
+}
+
+static const char *rk805_pinctrl_get_func_name(struct pinctrl_dev *pctldev,
+					       unsigned int function)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	return pci->functions[function].name;
+}
+
+static int rk805_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,
+					 unsigned int function,
+					 const char *const **groups,
+					 unsigned int *const num_groups)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups = pci->functions[function].groups;
+	*num_groups = pci->functions[function].ngroups;
+
+	return 0;
+}
+
+static int _rk805_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				  unsigned int offset,
+				  int mux)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	if (!pci->pin_cfg[offset].fun_msk)
+		return 0;
+
+	if (mux == RK805_PINMUX_GPIO)  {
+		ret = regmap_update_bits(pci->rk808->regmap,
+					 pci->pin_cfg[offset].reg,
+					 pci->pin_cfg[offset].fun_msk,
+					 pci->pin_cfg[offset].fun_msk);
+		if (ret) {
+			dev_err(pci->dev, "set gpio%d GPIO failed\n", offset);
+			return ret;
+		}
+	} else {
+		dev_err(pci->dev, "Couldn't find function mux %d\n", mux);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int _rk817_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				  unsigned int offset,
+				  int mux)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	if (!pci->pin_cfg[offset].fun_msk)
+		return 0;
+
+	mux <<= ffs(pci->pin_cfg[offset].fun_msk) - 1;
+	ret = regmap_update_bits(pci->rk808->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].fun_msk, mux);
+
+	if (ret)
+		dev_err(pci->dev, "set gpio%d func%d failed\n", offset, mux);
+
+	return ret;
+}
+
+static int rk805_pinctrl_set_mux(struct pinctrl_dev *pctldev,
+				 unsigned int function,
+				 unsigned int group)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int mux = pci->functions[function].mux_option;
+	int offset = group;
+
+	switch (pci->rk808->variant) {
+	case RK805_ID:
+		return _rk805_pinctrl_set_mux(pctldev, offset, mux);
+
+	case RK809_ID:
+	case RK817_ID:
+		return _rk817_pinctrl_set_mux(pctldev, offset, mux);
+	default:
+		dev_err(pci->dev, "Couldn't find the variant id\n");
+		return -EINVAL;
+	}
+}
+
+static int rk805_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+					struct pinctrl_gpio_range *range,
+					unsigned int offset, bool input)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	int ret;
+
+	/* set direction */
+	if (!pci->pin_cfg[offset].dir_msk)
+		return 0;
+
+	ret = regmap_update_bits(pci->rk808->regmap,
+				 pci->pin_cfg[offset].reg,
+				 pci->pin_cfg[offset].dir_msk,
+				 input ? 0 : pci->pin_cfg[offset].dir_msk);
+	if (ret) {
+		dev_err(pci->dev, "set gpio%d direction failed\n", offset);
+		return ret;
+	}
+
+	return ret;
+}
+
+static const struct pinmux_ops rk805_pinmux_ops = {
+	.get_functions_count	= rk805_pinctrl_get_funcs_count,
+	.get_function_name	= rk805_pinctrl_get_func_name,
+	.get_function_groups	= rk805_pinctrl_get_func_groups,
+	.set_mux		= rk805_pinctrl_set_mux,
+	.gpio_set_direction	= rk805_pmx_gpio_set_direction,
+};
+
+static int rk805_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned int pin, unsigned long *config)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param = pinconf_to_config_param(*config);
+	u32 arg = 0;
+
+	switch (param) {
+	case PIN_CONFIG_OUTPUT:
+		arg = rk805_gpio_get(&pci->gpio_chip, pin);
+		break;
+	default:
+		dev_err(pci->dev, "Properties not supported\n");
+		return -ENOTSUPP;
+	}
+
+	*config = pinconf_to_config_packed(param, (u16)arg);
+
+	return 0;
+}
+
+static int rk805_pinconf_set(struct pinctrl_dev *pctldev,
+			     unsigned int pin, unsigned long *configs,
+			     unsigned int num_configs)
+{
+	struct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param;
+	u32 i, arg = 0;
+
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+		case PIN_CONFIG_OUTPUT:
+			rk805_pmx_gpio_set_direction(pctldev, NULL, pin, false);
+			rk805_gpio_set(&pci->gpio_chip, pin, arg);
+			break;
+		case PIN_CONFIG_INPUT_ENABLE:
+			if (arg)
+				rk805_pmx_gpio_set_direction(pctldev, NULL,
+							     pin, true);
+			break;
+		default:
+			dev_err(pci->dev, "Properties not supported\n");
+			return -ENOTSUPP;
+		}
+	}
+
+	return 0;
+}
+
+static const struct pinconf_ops rk805_pinconf_ops = {
+	.pin_config_get = rk805_pinconf_get,
+	.pin_config_set = rk805_pinconf_set,
+};
+
+static struct pinctrl_desc rk805_pinctrl_desc = {
+	.name = "rk805-pinctrl",
+	.pctlops = &rk805_pinctrl_ops,
+	.pmxops = &rk805_pinmux_ops,
+	.confops = &rk805_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static struct pinctrl_desc rk817_pinctrl_desc = {
+	.name = "rk817-pinctrl",
+	.pctlops = &rk805_pinctrl_ops,
+	.pmxops = &rk805_pinmux_ops,
+	.confops = &rk805_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static int rk805_pinctrl_probe(struct platform_device *pdev)
+{
+	struct rk805_pctrl_info *pci;
+	struct device_node *np;
+	int ret;
+
+	pci = devm_kzalloc(&pdev->dev, sizeof(*pci), GFP_KERNEL);
+	if (!pci)
+		return -ENOMEM;
+
+	pci->dev = &pdev->dev;
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "pinctrl_rk8xx");
+	if (np)
+		pci->dev->of_node = np;
+	else
+		pci->dev->of_node = pdev->dev.parent->of_node;
+	pci->rk808 = dev_get_drvdata(pdev->dev.parent);
+
+	platform_set_drvdata(pdev, pci);
+
+	switch (pci->rk808->variant) {
+	case RK805_ID:
+		pci->pinctrl_desc = rk805_pinctrl_desc;
+		pci->gpio_chip = rk805_gpio_chip;
+		pci->pins = rk805_pins_desc;
+		pci->num_pins = ARRAY_SIZE(rk805_pins_desc);
+		pci->functions = rk805_pin_functions;
+		pci->num_functions = ARRAY_SIZE(rk805_pin_functions);
+		pci->groups = rk805_pin_groups;
+		pci->num_pin_groups = ARRAY_SIZE(rk805_pin_groups);
+		pci->pinctrl_desc.pins = rk805_pins_desc;
+		pci->pinctrl_desc.npins = ARRAY_SIZE(rk805_pins_desc);
+		pci->pin_cfg = rk805_gpio_cfgs;
+		pci->gpio_chip.ngpio = ARRAY_SIZE(rk805_gpio_cfgs);
+		break;
+	case RK809_ID:
+	case RK817_ID:
+		pci->pinctrl_desc = rk817_pinctrl_desc;
+		pci->gpio_chip = rk817_gpio_chip;
+		pci->pins = rk817_pins_desc;
+		pci->num_pins = ARRAY_SIZE(rk817_pins_desc);
+		pci->functions = rk817_pin_functions;
+		pci->num_functions = ARRAY_SIZE(rk817_pin_functions);
+		pci->groups = rk817_pin_groups;
+		pci->num_pin_groups = ARRAY_SIZE(rk817_pin_groups);
+		pci->pinctrl_desc.pins = rk817_pins_desc;
+		pci->pinctrl_desc.npins = ARRAY_SIZE(rk817_pins_desc);
+		pci->pin_cfg = rk817_gpio_cfgs;
+		pci->gpio_chip.ngpio = ARRAY_SIZE(rk817_gpio_cfgs);
+		/* for rk809 only a sleep pin */
+		if (pci->rk808->variant == RK809_ID) {
+			pci->pinctrl_desc.npins = 1;
+			pci->num_pin_groups = 1;
+			pci->num_pins = 1;
+			pci->gpio_chip.ngpio = 1;
+		}
+		break;
+	default:
+		dev_err(&pdev->dev, "unsupported RK805 ID %lu\n",
+			pci->rk808->variant);
+		return -EINVAL;
+	}
+
+	pci->gpio_chip.parent = &pdev->dev;
+
+	if (np)
+		pci->gpio_chip.of_node = np;
+	else
+		pci->gpio_chip.of_node = pdev->dev.parent->of_node;
+
+	/* Add gpiochip */
+	ret = devm_gpiochip_add_data(&pdev->dev, &pci->gpio_chip, pci);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Couldn't add gpiochip\n");
+		return ret;
+	}
+
+	/* Add pinctrl */
+	pci->pctl = devm_pinctrl_register(&pdev->dev, &pci->pinctrl_desc, pci);
+	if (IS_ERR(pci->pctl)) {
+		dev_err(&pdev->dev, "Couldn't add pinctrl\n");
+		return PTR_ERR(pci->pctl);
+	}
+
+	/* Add pin range */
+	ret = gpiochip_add_pin_range(&pci->gpio_chip, dev_name(&pdev->dev),
+				     0, 0, pci->gpio_chip.ngpio);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Couldn't add gpiochip pin range\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver rk805_pinctrl_driver = {
+	.probe = rk805_pinctrl_probe,
+	.driver = {
+		.name = "rk805-pinctrl",
+	},
+};
+
+static int __init rk805_pinctrl_driver_register(void)
+{
+	return platform_driver_register(&rk805_pinctrl_driver);
+}
+fs_initcall_sync(rk805_pinctrl_driver_register);
+
+MODULE_DESCRIPTION("RK805 pin control and GPIO driver");
+MODULE_AUTHOR("Joseph Chen <chenjh@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 0de9a958b29a..6eef9d9b996b 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -496,6 +496,22 @@ config BATTERY_RT5033
 	  The fuelgauge calculates and determines the battery state of charge
 	  according to battery open circuit voltage.
 
+config BATTERY_RK818
+	tristate "RK818 Battery driver"
+	depends on MFD_RK808
+	default n
+	help
+	  If you say yes here you will get support for the battery of RK818 PMIC.
+	  This driver can give support for Rk818 Battery Charge Interface.
+
+config CHARGER_RK818
+	tristate "RK818 Charger driver"
+	depends on MFD_RK808
+	default n
+	help
+	  If you say yes here you will get support for the charger of RK818 PMIC.
+	  This driver can give support for Rk818 Charger Interface.
+      
 config CHARGER_RT9455
 	tristate "Richtek RT9455 battery charger driver"
 	depends on I2C
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 36c599d9a495..3368abe76cc9 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -72,3 +72,5 @@ obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_CHARGER_TPS65217)	+= tps65217_charger.o
 obj-$(CONFIG_AXP288_FUEL_GAUGE) += axp288_fuel_gauge.o
 obj-$(CONFIG_AXP288_CHARGER)	+= axp288_charger.o
+obj-$(CONFIG_BATTERY_RK818)	+= rk818_battery.o
+obj-$(CONFIG_CHARGER_RK818)	+= rk818_charger.o
diff --git a/drivers/power/supply/rk818_battery.c b/drivers/power/supply/rk818_battery.c
new file mode 100644
index 000000000000..d3190bdfbd5c
--- /dev/null
+++ b/drivers/power/supply/rk818_battery.c
@@ -0,0 +1,3623 @@
+/*
+ * rk818 battery driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/gpio.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/iio.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/jiffies.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/power/rk_usbbc.h>
+#include <linux/regmap.h>
+#include <linux/rk_keys.h>
+#include <linux/rtc.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include "rk818_battery.h"
+
+static int dbg_enable = 0;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define BAT_INFO(fmt, args...) pr_info("rk818-bat: "fmt, ##args)
+
+/* default param */
+#define DEFAULT_BAT_RES			135
+#define DEFAULT_SLP_ENTER_CUR		300
+#define DEFAULT_SLP_EXIT_CUR		300
+#define DEFAULT_SLP_FILTER_CUR		100
+#define DEFAULT_PWROFF_VOL_THRESD	3400
+#define DEFAULT_MONITOR_SEC		5
+#define DEFAULT_ALGR_VOL_THRESD1	3850
+#define DEFAULT_ALGR_VOL_THRESD2	3950
+#define DEFAULT_MAX_SOC_OFFSET		60
+#define DEFAULT_FB_TEMP			TEMP_105C
+#define DEFAULT_ZERO_RESERVE_DSOC	10
+#define DEFAULT_POFFSET			42
+#define DEFAULT_COFFSET			0x832
+#define DEFAULT_SAMPLE_RES		20
+#define DEFAULT_ENERGY_MODE		0
+#define INVALID_COFFSET_MIN		0x780
+#define INVALID_COFFSET_MAX		0x980
+#define INVALID_VOL_THRESD		2500
+
+/* sample resistor and division */
+#define SAMPLE_RES_10MR			10
+#define SAMPLE_RES_20MR			20
+#define SAMPLE_RES_DIV1			1
+#define SAMPLE_RES_DIV2			2
+
+/* virtual params */
+#define VIRTUAL_CURRENT			1000
+#define VIRTUAL_VOLTAGE			3888
+#define VIRTUAL_SOC			66
+#define VIRTUAL_PRESET			1
+#define VIRTUAL_TEMPERATURE		188
+#define VIRTUAL_STATUS			POWER_SUPPLY_STATUS_CHARGING
+
+/* charge */
+#define FINISH_CHRG_CUR1			1000
+#define FINISH_CHRG_CUR2		1500
+#define FINISH_MAX_SOC_DELAY		20
+#define TERM_CHRG_DSOC			88
+#define TERM_CHRG_CURR			600
+#define TERM_CHRG_K			650
+#define SIMULATE_CHRG_INTV		8
+#define SIMULATE_CHRG_CURR		400
+#define SIMULATE_CHRG_K			1500
+#define FULL_CHRG_K			400
+
+/* zero algorithm */
+#define PWROFF_THRESD			3400
+#define MIN_ZERO_DSOC_ACCURACY		10	/*0.01%*/
+#define MIN_ZERO_OVERCNT		100
+#define MIN_ACCURACY			1
+#define DEF_PWRPATH_RES			50
+#define	WAIT_DSOC_DROP_SEC		15
+#define	WAIT_SHTD_DROP_SEC		30
+#define ZERO_GAP_XSOC1			10
+#define ZERO_GAP_XSOC2			5
+#define ZERO_GAP_XSOC3			3
+#define ZERO_LOAD_LVL1			1400
+#define ZERO_LOAD_LVL2			600
+#define ZERO_GAP_CALIB			5
+
+#define ADC_CALIB_THRESHOLD		4
+#define ADC_CALIB_LMT_MIN		3
+#define ADC_CALIB_CNT			5
+#define NTC_CALC_FACTOR			7
+
+/* time */
+#define	POWER_ON_SEC_BASE		1
+#define MINUTE(x)			((x) * 60)
+
+/* sleep */
+#define SLP_CURR_MAX			40
+#define SLP_CURR_MIN			6
+#define DISCHRG_TIME_STEP1		MINUTE(10)
+#define DISCHRG_TIME_STEP2		MINUTE(60)
+#define SLP_DSOC_VOL_THRESD		3600
+#define REBOOT_PERIOD_SEC		180
+#define REBOOT_MAX_CNT			80
+
+/* fcc */
+#define MIN_FCC				500
+
+/* TS detect battery temperature */
+#define ADC_CUR_MSK			0x03
+#define ADC_CUR_20UA			0x00
+#define ADC_CUR_40UA			0x01
+#define ADC_CUR_60UA			0x02
+#define ADC_CUR_80UA			0x03
+
+#define NTC_CALC_FACTOR_80UA		7
+#define NTC_CALC_FACTOR_60UA		9
+#define NTC_CALC_FACTOR_40UA		13
+#define NTC_CALC_FACTOR_20UA		27
+#define NTC_80UA_MAX_MEASURE		27500
+#define NTC_60UA_MAX_MEASURE		36666
+#define NTC_40UA_MAX_MEASURE		55000
+#define NTC_20UA_MAX_MEASURE		110000
+
+#define INPUT_CUR80MA			(0x01)
+
+static const char *bat_status[] = {
+	"charge off", "dead charge", "trickle charge", "cc cv",
+	"finish", "usb over vol", "bat temp error", "timer error",
+};
+
+struct rk818_battery {
+	struct platform_device		*pdev;
+	struct rk808			*rk818;
+	struct i2c_client		*client;
+	struct regmap			*regmap;
+	struct device			*dev;
+	struct power_supply		*bat;
+	struct power_supply		*usb_psy;
+	struct power_supply		*ac_psy;
+	struct battery_platform_data	*pdata;
+	struct workqueue_struct		*bat_monitor_wq;
+	struct delayed_work		bat_delay_work;
+	struct delayed_work		calib_delay_work;
+	struct notifier_block           fb_nb;
+	struct timer_list		caltimer;
+	time_t				rtc_base;
+	int				bat_res;
+	int				chrg_status;
+	bool				is_initialized;
+	bool				is_first_power_on;
+	u8				res_div;
+	int				current_max;
+	int				voltage_max;
+	int				current_avg;
+	int				voltage_avg;
+	int				voltage_ocv;
+	int				voltage_relax;
+	int				voltage_k;
+	int				voltage_b;
+	int				remain_cap;
+	int				design_cap;
+	int				nac;
+	int				fcc;
+	int				qmax;
+	int				dsoc;
+	int				rsoc;
+	int				poffset;
+	int				age_ocv_soc;
+	bool				age_allow_update;
+	int				age_level;
+	int				age_ocv_cap;
+	int				age_voltage;
+	int				age_adjust_cap;
+	unsigned long			age_keep_sec;
+	int				zero_timeout_cnt;
+	int				zero_remain_cap;
+	int				zero_dsoc;
+	int				zero_linek;
+	u64				zero_drop_sec;
+	u64				shtd_drop_sec;
+	int				sm_remain_cap;
+	int				sm_linek;
+	int				sm_chrg_dsoc;
+	int				sm_dischrg_dsoc;
+	int				algo_rest_val;
+	int				algo_rest_mode;
+	int				sleep_sum_cap;
+	int				sleep_remain_cap;
+	unsigned long			sleep_dischrg_sec;
+	unsigned long			sleep_sum_sec;
+	bool				sleep_chrg_online;
+	u8				sleep_chrg_status;
+	bool				adc_allow_update;
+	int                             fb_blank;
+	bool				s2r; /*suspend to resume*/
+	u32				work_mode;
+	int				temperature;
+	u32				monitor_ms;
+	u32				pwroff_min;
+	u32				adc_calib_cnt;
+	unsigned long			finish_base;
+	unsigned long			boot_base;
+	unsigned long			flat_match_sec;
+	unsigned long			plug_in_base;
+	unsigned long			plug_out_base;
+	u8				halt_cnt;
+	bool				is_halt;
+	bool				is_max_soc_offset;
+	bool				is_sw_reset;
+	bool				is_ocv_calib;
+	bool				is_first_on;
+	bool				is_force_calib;
+	int				last_dsoc;
+	int				ocv_pre_dsoc;
+	int				ocv_new_dsoc;
+	int				max_pre_dsoc;
+	int				max_new_dsoc;
+	int				force_pre_dsoc;
+	int				force_new_dsoc;
+	int				dbg_cap_low0;
+	int				dbg_pwr_dsoc;
+	int				dbg_pwr_rsoc;
+	int				dbg_pwr_vol;
+	int				dbg_chrg_min[10];
+	int				dbg_meet_soc;
+	int				dbg_calc_dsoc;
+	int				dbg_calc_rsoc;
+	u8				ac_in;
+	u8				usb_in;
+	int				is_charging;
+	unsigned long			charge_count;
+};
+
+#define DIV(x)	((x) ? (x) : 1)
+
+static u64 get_boot_sec(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return ts.tv_sec;
+}
+
+static unsigned long base2sec(unsigned long x)
+{
+	if (x)
+		return (get_boot_sec() > x) ? (get_boot_sec() - x) : 0;
+	else
+		return 0;
+}
+
+static unsigned long base2min(unsigned long x)
+{
+	return base2sec(x) / 60;
+}
+
+static u32 interpolate(int value, u32 *table, int size)
+{
+	u8 i;
+	u16 d;
+
+	for (i = 0; i < size; i++) {
+		if (value < table[i])
+			break;
+	}
+
+	if ((i > 0) && (i < size)) {
+		d = (value - table[i - 1]) * (MAX_INTERPOLATE / (size - 1));
+		d /= table[i] - table[i - 1];
+		d = d + (i - 1) * (MAX_INTERPOLATE / (size - 1));
+	} else {
+		d = i * ((MAX_INTERPOLATE + size / 2) / size);
+	}
+
+	if (d > 1000)
+		d = 1000;
+
+	return d;
+}
+
+/* (a*b)/c */
+static int32_t ab_div_c(u32 a, u32 b, u32 c)
+{
+	bool sign;
+	u32 ans = MAX_INT;
+	int tmp;
+
+	sign = ((((a ^ b) ^ c) & 0x80000000) != 0);
+	if (c != 0) {
+		if (sign)
+			c = -c;
+		tmp = (a * b + (c >> 1)) / c;
+		if (tmp < MAX_INT)
+			ans = tmp;
+	}
+
+	if (sign)
+		ans = -ans;
+
+	return ans;
+}
+
+static int rk818_bat_read(struct rk818_battery *di, u8 reg)
+{
+	int ret, val;
+
+	ret = regmap_read(di->regmap, reg, &val);
+	if (ret)
+		dev_err(di->dev, "read reg:0x%x failed\n", reg);
+
+	return val;
+}
+
+static int rk818_bat_write(struct rk818_battery *di, u8 reg, u8 buf)
+{
+	int ret;
+
+	ret = regmap_write(di->regmap, reg, buf);
+	if (ret)
+		dev_err(di->dev, "i2c write reg: 0x%2x error\n", reg);
+
+	return ret;
+}
+
+static int rk818_bat_set_bits(struct rk818_battery *di, u8 reg, u8 mask, u8 buf)
+{
+	int ret;
+
+	ret = regmap_update_bits(di->regmap, reg, mask, buf);
+	if (ret)
+		dev_err(di->dev, "write reg:0x%x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_bat_clear_bits(struct rk818_battery *di, u8 reg, u8 mask)
+{
+	int ret;
+
+	ret = regmap_update_bits(di->regmap, reg, mask, 0);
+	if (ret)
+		dev_err(di->dev, "clr reg:0x%02x failed\n", reg);
+
+	return ret;
+}
+
+static void rk818_bat_dump_regs(struct rk818_battery *di, u8 start, u8 end)
+{
+	int i;
+
+	if (!dbg_enable)
+		return;
+
+	DBG("dump regs from: 0x%x-->0x%x\n", start, end);
+	for (i = start; i < end; i++)
+		DBG("0x%x: 0x%0x\n", i, rk818_bat_read(di, i));
+}
+
+static bool rk818_bat_chrg_online(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_VB_MON_REG);
+
+	return (buf & PLUG_IN_STS) ? true : false;
+}
+
+static int rk818_bat_get_coulomb_cap(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_GASCNT3_REG) << 24;
+	val |= rk818_bat_read(di, RK818_GASCNT2_REG) << 16;
+	val |= rk818_bat_read(di, RK818_GASCNT1_REG) << 8;
+	val |= rk818_bat_read(di, RK818_GASCNT0_REG) << 0;
+
+	return (val / 2390) * di->res_div;
+}
+
+static int rk818_bat_get_rsoc(struct rk818_battery *di)
+{
+	int remain_cap;
+
+	remain_cap = rk818_bat_get_coulomb_cap(di);
+	return (remain_cap + di->fcc / 200) * 100 / DIV(di->fcc);
+}
+
+static ssize_t bat_info_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	char cmd;
+	struct rk818_battery *di = dev_get_drvdata(dev);
+
+	sscanf(buf, "%c", &cmd);
+
+	if (cmd == 'n')
+		rk818_bat_set_bits(di, RK818_MISC_MARK_REG,
+				   FG_RESET_NOW, FG_RESET_NOW);
+	else if (cmd == 'm')
+		rk818_bat_set_bits(di, RK818_MISC_MARK_REG,
+				   FG_RESET_LATE, FG_RESET_LATE);
+	else if (cmd == 'c')
+		rk818_bat_clear_bits(di, RK818_MISC_MARK_REG,
+				     FG_RESET_LATE | FG_RESET_NOW);
+	else if (cmd == 'r')
+		BAT_INFO("0x%2x\n", rk818_bat_read(di, RK818_MISC_MARK_REG));
+	else
+		BAT_INFO("command error\n");
+
+	return count;
+}
+
+static struct device_attribute rk818_bat_attr[] = {
+	__ATTR(bat, 0664, NULL, bat_info_store),
+};
+
+static void rk818_bat_enable_gauge(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf |= GG_EN;
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+}
+
+static void rk818_bat_save_age_level(struct rk818_battery *di, u8 level)
+{
+	rk818_bat_write(di, RK818_UPDAT_LEVE_REG, level);
+}
+
+static u8 rk818_bat_get_age_level(struct  rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_UPDAT_LEVE_REG);
+}
+
+static int rk818_bat_get_vcalib0(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_VCALIB0_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_VCALIB0_REGH) << 8;
+
+	DBG("<%s>. voffset0: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_vcalib1(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_VCALIB1_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_VCALIB1_REGH) << 8;
+
+	DBG("<%s>. voffset1: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_ioffset(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_IOFFSET_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_IOFFSET_REGH) << 8;
+
+	DBG("<%s>. ioffset: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_coffset(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_CAL_OFFSET_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_CAL_OFFSET_REGH) << 8;
+
+	DBG("<%s>. coffset: 0x%x\n", __func__, val);
+	return val;
+}
+
+static void rk818_bat_set_coffset(struct rk818_battery *di, int val)
+{
+	u8 buf;
+
+	if ((val < INVALID_COFFSET_MIN) || (val > INVALID_COFFSET_MAX)) {
+		BAT_INFO("set invalid coffset=0x%x\n", val);
+		return;
+	}
+
+	buf = (val >> 8) & 0xff;
+	rk818_bat_write(di, RK818_CAL_OFFSET_REGH, buf);
+	buf = (val >> 0) & 0xff;
+	rk818_bat_write(di, RK818_CAL_OFFSET_REGL, buf);
+	DBG("<%s>. coffset: 0x%x\n", __func__, val);
+}
+
+static void rk818_bat_init_voltage_kb(struct rk818_battery *di)
+{
+	int vcalib0, vcalib1;
+
+	vcalib0 = rk818_bat_get_vcalib0(di);
+	vcalib1 = rk818_bat_get_vcalib1(di);
+	di->voltage_k = (4200 - 3000) * 1000 / DIV(vcalib1 - vcalib0);
+	di->voltage_b = 4200 - (di->voltage_k * vcalib1) / 1000;
+
+	DBG("voltage_k=%d(*1000),voltage_b=%d\n", di->voltage_k, di->voltage_b);
+}
+
+static int rk818_bat_get_ocv_voltage(struct rk818_battery *di)
+{
+	int vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_OCV_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_OCV_REGH) << 8;
+
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static int rk818_bat_get_avg_voltage(struct rk818_battery *di)
+{
+	int vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_VOL_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_VOL_REGH) << 8;
+
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static bool is_rk818_bat_relax_mode(struct rk818_battery *di)
+{
+	u8 status;
+
+	status = rk818_bat_read(di, RK818_GGSTS_REG);
+	if (!(status & RELAX_VOL1_UPD) || !(status & RELAX_VOL2_UPD))
+		return false;
+	else
+		return true;
+}
+
+static u16 rk818_bat_get_relax_vol1(struct rk818_battery *di)
+{
+	u16 vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_RELAX_VOL1_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_RELAX_VOL1_REGH) << 8;
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static u16 rk818_bat_get_relax_vol2(struct rk818_battery *di)
+{
+	u16 vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_RELAX_VOL2_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_RELAX_VOL2_REGH) << 8;
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static u16 rk818_bat_get_relax_voltage(struct rk818_battery *di)
+{
+	u16 relax_vol1, relax_vol2;
+
+	if (!is_rk818_bat_relax_mode(di))
+		return 0;
+
+	relax_vol1 = rk818_bat_get_relax_vol1(di);
+	relax_vol2 = rk818_bat_get_relax_vol2(di);
+
+	return relax_vol1 > relax_vol2 ? relax_vol1 : relax_vol2;
+}
+
+static int rk818_bat_get_avg_current(struct rk818_battery *di)
+{
+	int cur, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGH) << 8;
+
+	if (val & 0x800)
+		val -= 4096;
+	cur = val * di->res_div * 1506 / 1000;
+
+	return cur;
+}
+
+static int rk818_bat_vol_to_ocvsoc(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, ocv_soc;
+
+	ocv_table = di->pdata->ocv_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	ocv_soc = ab_div_c(temp, MAX_PERCENTAGE, MAX_INTERPOLATE);
+
+	return ocv_soc;
+}
+
+static int rk818_bat_vol_to_ocvcap(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, cap;
+
+	ocv_table = di->pdata->ocv_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	cap = ab_div_c(temp, di->fcc, MAX_INTERPOLATE);
+
+	return cap;
+}
+
+static int rk818_bat_vol_to_zerosoc(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, ocv_soc;
+
+	ocv_table = di->pdata->zero_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	ocv_soc = ab_div_c(temp, MAX_PERCENTAGE, MAX_INTERPOLATE);
+
+	return ocv_soc;
+}
+
+static int rk818_bat_vol_to_zerocap(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, cap;
+
+	ocv_table = di->pdata->zero_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	cap = ab_div_c(temp, di->fcc, MAX_INTERPOLATE);
+
+	return cap;
+}
+
+static int rk818_bat_get_iadc(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGH) << 8;
+	if (val > 2047)
+		val -= 4096;
+
+	return val;
+}
+
+static bool rk818_bat_adc_calib(struct rk818_battery *di)
+{
+	int i, ioffset, coffset, adc, save_coffset;
+
+	if ((di->chrg_status != CHARGE_FINISH) ||
+	    (di->adc_calib_cnt > ADC_CALIB_CNT) ||
+	    (base2min(di->boot_base) < ADC_CALIB_LMT_MIN) ||
+	    (abs(di->current_avg) < ADC_CALIB_THRESHOLD))
+		return false;
+
+	di->adc_calib_cnt++;
+	save_coffset = rk818_bat_get_coffset(di);
+	for (i = 0; i < 5; i++) {
+		adc = rk818_bat_get_iadc(di);
+		if (!rk818_bat_chrg_online(di)) {
+			rk818_bat_set_coffset(di, save_coffset);
+			BAT_INFO("quit, charger plugout when calib adc\n");
+			return false;
+		}
+		coffset = rk818_bat_get_coffset(di);
+		rk818_bat_set_coffset(di, coffset + adc);
+		msleep(2000);
+		adc = rk818_bat_get_iadc(di);
+		if (abs(adc) < ADC_CALIB_THRESHOLD) {
+			coffset = rk818_bat_get_coffset(di);
+			ioffset = rk818_bat_get_ioffset(di);
+			di->poffset = coffset - ioffset;
+			rk818_bat_write(di, RK818_POFFSET_REG, di->poffset);
+			BAT_INFO("new offset:c=0x%x, i=0x%x, p=0x%x\n",
+				 coffset, ioffset, di->poffset);
+			return true;
+		} else {
+			BAT_INFO("coffset calib again %d.., max_cnt=%d\n",
+				 i, di->adc_calib_cnt);
+			rk818_bat_set_coffset(di, coffset);
+			msleep(2000);
+		}
+	}
+
+	rk818_bat_set_coffset(di, save_coffset);
+
+	return false;
+}
+
+static void rk818_bat_set_ioffset_sample(struct rk818_battery *di)
+{
+	u8 ggcon;
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggcon &= ~ADC_CAL_MIN_MSK;
+	ggcon |= ADC_CAL_8MIN;
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+}
+
+static void rk818_bat_set_ocv_sample(struct rk818_battery *di)
+{
+	u8 ggcon;
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggcon &= ~OCV_SAMP_MIN_MSK;
+	ggcon |= OCV_SAMP_8MIN;
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+}
+
+static void rk818_bat_restart_relax(struct rk818_battery *di)
+{
+	u8 ggsts;
+
+	ggsts = rk818_bat_read(di, RK818_GGSTS_REG);
+	ggsts &= ~RELAX_VOL12_UPD_MSK;
+	rk818_bat_write(di, RK818_GGSTS_REG, ggsts);
+}
+
+static void rk818_bat_set_relax_sample(struct rk818_battery *di)
+{
+	u8 buf;
+	int enter_thres, exit_thres;
+	struct battery_platform_data *pdata = di->pdata;
+
+	enter_thres = pdata->sleep_enter_current * 1000 / 1506 / DIV(di->res_div);
+	exit_thres = pdata->sleep_exit_current * 1000 / 1506 / DIV(di->res_div);
+
+	/* set relax enter and exit threshold */
+	buf = enter_thres & 0xff;
+	rk818_bat_write(di, RK818_RELAX_ENTRY_THRES_REGL, buf);
+	buf = (enter_thres >> 8) & 0xff;
+	rk818_bat_write(di, RK818_RELAX_ENTRY_THRES_REGH, buf);
+
+	buf = exit_thres & 0xff;
+	rk818_bat_write(di, RK818_RELAX_EXIT_THRES_REGL, buf);
+	buf = (exit_thres >> 8) & 0xff;
+	rk818_bat_write(di, RK818_RELAX_EXIT_THRES_REGH, buf);
+
+	/* reset relax update state */
+	rk818_bat_restart_relax(di);
+	DBG("<%s>. sleep_enter_current = %d, sleep_exit_current = %d\n",
+	    __func__, pdata->sleep_enter_current, pdata->sleep_exit_current);
+}
+
+static bool is_rk818_bat_exist(struct rk818_battery *di)
+{
+	return (rk818_bat_read(di, RK818_SUP_STS_REG) & BAT_EXS) ? true : false;
+}
+
+static bool is_rk818_bat_first_pwron(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_GGSTS_REG);
+	buf &= ~BAT_CON;
+	rk818_bat_write(di, RK818_GGSTS_REG, buf);
+	return true;
+}
+
+static u8 rk818_bat_get_pwroff_min(struct rk818_battery *di)
+{
+	u8 cur, last;
+
+	cur = rk818_bat_read(di, RK818_NON_ACT_TIMER_CNT_REG);
+	last = rk818_bat_read(di, RK818_NON_ACT_TIMER_CNT_SAVE_REG);
+	rk818_bat_write(di, RK818_NON_ACT_TIMER_CNT_SAVE_REG, cur);
+
+	return (cur != last) ? cur : 0;
+}
+
+static u8 is_rk818_bat_initialized(struct rk818_battery *di)
+{
+	u8 val = rk818_bat_read(di, RK818_MISC_MARK_REG);
+
+	if (val & FG_INIT) {
+		val &= ~FG_INIT;
+		rk818_bat_write(di, RK818_MISC_MARK_REG, val);
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static bool is_rk818_bat_ocv_valid(struct rk818_battery *di)
+{
+	return (!di->is_initialized && di->pwroff_min >= 30) ? true : false;
+}
+
+static void rk818_bat_init_age_algorithm(struct rk818_battery *di)
+{
+	int age_level, ocv_soc, ocv_cap, ocv_vol;
+
+	if (di->is_first_power_on || is_rk818_bat_ocv_valid(di)) {
+		DBG("<%s> enter.\n", __func__);
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		if (ocv_soc < 20) {
+			di->age_voltage = ocv_vol;
+			di->age_ocv_cap = ocv_cap;
+			di->age_ocv_soc = ocv_soc;
+			di->age_adjust_cap = 0;
+
+			if (ocv_soc <= 0)
+				di->age_level = 100;
+			else if (ocv_soc < 5)
+				di->age_level = 95;
+			else if (ocv_soc < 10)
+				di->age_level = 90;
+			else
+				di->age_level = 80;
+
+			age_level = rk818_bat_get_age_level(di);
+			if (age_level > di->age_level) {
+				di->age_allow_update = false;
+				age_level -= 5;
+				if (age_level <= 80)
+					age_level = 80;
+				rk818_bat_save_age_level(di, age_level);
+			} else {
+				di->age_allow_update = true;
+				di->age_keep_sec = get_boot_sec();
+			}
+
+			BAT_INFO("init_age_algorithm: "
+				 "age_vol:%d, age_ocv_cap:%d, "
+				 "age_ocv_soc:%d, old_age_level:%d, "
+				 "age_allow_update:%d, new_age_level:%d\n",
+				 di->age_voltage, di->age_ocv_cap,
+				 ocv_soc, age_level, di->age_allow_update,
+				 di->age_level);
+		}
+	}
+}
+
+static enum power_supply_property rk818_bat_props[] = {
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+static int rk818_bat_get_usb_psy(struct device *dev, void *data)
+{
+	struct rk818_battery *di = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_USB) {
+		di->usb_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int rk818_bat_get_ac_psy(struct device *dev, void *data)
+{
+	struct rk818_battery *di = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_MAINS) {
+		di->ac_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void rk818_bat_get_chrg_psy(struct rk818_battery *di)
+{
+	if (!di->usb_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)di,
+				      rk818_bat_get_usb_psy);
+	if (!di->ac_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)di,
+				      rk818_bat_get_ac_psy);
+}
+
+static int rk818_bat_get_charge_state(struct rk818_battery *di)
+{
+	union power_supply_propval val;
+	int ret;
+
+	if (!di->usb_psy || !di->ac_psy)
+		rk818_bat_get_chrg_psy(di);
+
+	if (di->usb_psy) {
+		ret = di->usb_psy->desc->get_property(di->usb_psy,
+						      POWER_SUPPLY_PROP_ONLINE,
+						      &val);
+		if (!ret)
+			di->usb_in = val.intval;
+	}
+
+	if (di->ac_psy) {
+		ret = di->ac_psy->desc->get_property(di->ac_psy,
+						     POWER_SUPPLY_PROP_ONLINE,
+						     &val);
+		if (!ret)
+			di->ac_in = val.intval;
+	}
+
+	DBG("%s: ac_online=%d, usb_online=%d\n",
+	    __func__, di->ac_in, di->usb_in);
+
+	return (di->usb_in || di->ac_in);
+}
+
+static int rk818_get_capacity_leve(struct rk818_battery *di)
+{
+	if (di->pdata->bat_mode == MODE_VIRTUAL)
+		return POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;
+
+	if (di->dsoc < 1)
+		return POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;
+	else if (di->dsoc <= 20)
+		return POWER_SUPPLY_CAPACITY_LEVEL_LOW;
+	else if (di->dsoc <= 70)
+		return POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;
+	else if (di->dsoc <= 90)
+		return POWER_SUPPLY_CAPACITY_LEVEL_HIGH;
+	else
+		return POWER_SUPPLY_CAPACITY_LEVEL_FULL;
+}
+
+static int rk818_battery_time_to_full(struct rk818_battery *di)
+{
+	int time_sec;
+	int cap_temp;
+
+	if (di->pdata->bat_mode == MODE_VIRTUAL) {
+		time_sec = 3600;
+	} else if (di->voltage_avg > 0) {
+		cap_temp = di->pdata->design_capacity - di->remain_cap;
+		if (cap_temp < 0)
+			cap_temp = 0;
+		time_sec = (3600 * cap_temp) / di->voltage_avg;
+	} else {
+		time_sec = 3600 * 24; /* One day */
+	}
+
+	return time_sec;
+}
+
+static int rk818_battery_get_property(struct power_supply *psy,
+				      enum power_supply_property psp,
+				      union power_supply_propval *val)
+{
+	struct rk818_battery *di = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = di->current_avg * 1000;/*uA*/
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_CURRENT * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = di->voltage_avg * 1000;/*uV*/
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_VOLTAGE * 1000;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = is_rk818_bat_exist(di);
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_PRESET;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = di->dsoc;
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_SOC;
+		DBG("<%s>. report dsoc: %d\n", __func__, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		val->intval = rk818_get_capacity_leve(di);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = di->temperature;
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_TEMPERATURE;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_STATUS;
+		else if (di->dsoc == 100)
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if (rk818_bat_get_charge_state(di))
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		val->intval = di->charge_count;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = di->pdata->design_capacity * 1000;/* uAh */
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		val->intval = rk818_battery_time_to_full(di);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = di->voltage_max;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = di->current_max;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct power_supply_desc rk818_bat_desc = {
+	.name		= "battery",
+	.type		= POWER_SUPPLY_TYPE_BATTERY,
+	.properties	= rk818_bat_props,
+	.num_properties	= ARRAY_SIZE(rk818_bat_props),
+	.get_property	= rk818_battery_get_property,
+};
+
+static int rk818_bat_init_power_supply(struct rk818_battery *di)
+{
+	struct power_supply_config psy_cfg = { .drv_data = di, };
+
+	di->bat = devm_power_supply_register(di->dev, &rk818_bat_desc, &psy_cfg);
+	if (IS_ERR(di->bat)) {
+		dev_err(di->dev, "register bat power supply fail\n");
+		return PTR_ERR(di->bat);
+	}
+
+	return 0;
+}
+
+static void rk818_bat_save_cap(struct rk818_battery *di, int cap)
+{
+	u8 buf;
+	static u32 old_cap;
+
+	if (cap >= di->qmax)
+		cap = di->qmax;
+	if (cap <= 0)
+		cap = 0;
+	if (old_cap == cap)
+		return;
+
+	old_cap = cap;
+	buf = (cap >> 24) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG3, buf);
+	buf = (cap >> 16) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG2, buf);
+	buf = (cap >> 8) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG1, buf);
+	buf = (cap >> 0) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG0, buf);
+}
+
+static int rk818_bat_get_prev_cap(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG3) << 24;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG2) << 16;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG1) << 8;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG0) << 0;
+
+	return val;
+}
+
+static void rk818_bat_save_fcc(struct rk818_battery *di, u32 fcc)
+{
+	u8 buf;
+
+	buf = (fcc >> 24) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG3, buf);
+	buf = (fcc >> 16) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG2, buf);
+	buf = (fcc >> 8) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG1, buf);
+	buf = (fcc >> 0) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG0, buf);
+
+	BAT_INFO("save fcc: %d\n", fcc);
+}
+
+static int rk818_bat_get_fcc(struct rk818_battery *di)
+{
+	u32 fcc = 0;
+
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG3) << 24;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG2) << 16;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG1) << 8;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG0) << 0;
+
+	if (fcc < MIN_FCC) {
+		BAT_INFO("invalid fcc(%d), use design cap", fcc);
+		fcc = di->pdata->design_capacity;
+		rk818_bat_save_fcc(di, fcc);
+	} else if (fcc > di->pdata->design_qmax) {
+		BAT_INFO("invalid fcc(%d), use qmax", fcc);
+		fcc = di->pdata->design_qmax;
+		rk818_bat_save_fcc(di, fcc);
+	}
+
+	return fcc;
+}
+
+static void rk818_bat_init_coulomb_cap(struct rk818_battery *di, u32 capacity)
+{
+	u8 buf;
+	u32 cap;
+
+	cap = capacity * 2390 / DIV(di->res_div);
+	buf = (cap >> 24) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG3, buf);
+	buf = (cap >> 16) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG2, buf);
+	buf = (cap >> 8) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG1, buf);
+	buf = ((cap >> 0) & 0xff);
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG0, buf);
+
+	DBG("<%s>. new coulomb cap = %d\n", __func__, capacity);
+	di->remain_cap = capacity;
+	di->rsoc = rk818_bat_get_rsoc(di);
+}
+
+static void rk818_bat_save_dsoc(struct rk818_battery *di, u8 save_soc)
+{
+	static int last_soc = -1;
+
+	if (last_soc != save_soc) {
+		rk818_bat_write(di, RK818_SOC_REG, save_soc);
+		last_soc = save_soc;
+	}
+}
+
+static int rk818_bat_get_prev_dsoc(struct rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_SOC_REG);
+}
+
+static void rk818_bat_save_reboot_cnt(struct rk818_battery *di, u8 save_cnt)
+{
+	rk818_bat_write(di, RK818_REBOOT_CNT_REG, save_cnt);
+}
+
+static int rk818_bat_fb_notifier(struct notifier_block *nb,
+				 unsigned long event, void *data)
+{
+	struct rk818_battery *di;
+	struct fb_event *evdata = data;
+
+	if (event != FB_EARLY_EVENT_BLANK && event != FB_EVENT_BLANK)
+		return NOTIFY_OK;
+
+	di = container_of(nb, struct rk818_battery, fb_nb);
+	di->fb_blank = *(int *)evdata->data;
+
+	return 0;
+}
+
+static int rk818_bat_register_fb_notify(struct rk818_battery *di)
+{
+	memset(&di->fb_nb, 0, sizeof(di->fb_nb));
+	di->fb_nb.notifier_call = rk818_bat_fb_notifier;
+
+	return fb_register_client(&di->fb_nb);
+}
+
+static int rk818_bat_unregister_fb_notify(struct rk818_battery *di)
+{
+	return fb_unregister_client(&di->fb_nb);
+}
+
+static u8 rk818_bat_get_halt_cnt(struct rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_HALT_CNT_REG);
+}
+
+static void rk818_bat_inc_halt_cnt(struct rk818_battery *di)
+{
+	u8 cnt;
+
+	cnt = rk818_bat_read(di, RK818_HALT_CNT_REG);
+	rk818_bat_write(di, RK818_HALT_CNT_REG, ++cnt);
+}
+
+static bool is_rk818_bat_last_halt(struct rk818_battery *di)
+{
+	int pre_cap = rk818_bat_get_prev_cap(di);
+	int now_cap = rk818_bat_get_coulomb_cap(di);
+
+	/* over 10%: system halt last time */
+	if (abs(now_cap - pre_cap) > (di->fcc / 10)) {
+		rk818_bat_inc_halt_cnt(di);
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void rk818_bat_first_pwron(struct rk818_battery *di)
+{
+	int ocv_vol;
+
+	rk818_bat_save_fcc(di, di->design_cap);
+	ocv_vol = rk818_bat_get_ocv_voltage(di);
+	di->fcc = rk818_bat_get_fcc(di);
+	di->nac = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+	di->rsoc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+	di->dsoc = di->rsoc;
+	di->is_first_on = true;
+
+	DBG("first on: dsoc=%d, rsoc=%d cap=%d, fcc=%d, ov=%d\n",
+		 di->dsoc, di->rsoc, di->nac, di->fcc, ocv_vol);
+}
+
+static void rk818_bat_not_first_pwron(struct rk818_battery *di)
+{
+	int now_cap, pre_soc, pre_cap, ocv_cap, ocv_soc, ocv_vol;
+
+	di->fcc = rk818_bat_get_fcc(di);
+	pre_soc = rk818_bat_get_prev_dsoc(di);
+	pre_cap = rk818_bat_get_prev_cap(di);
+	now_cap = rk818_bat_get_coulomb_cap(di);
+	di->is_halt = is_rk818_bat_last_halt(di);
+	di->halt_cnt = rk818_bat_get_halt_cnt(di);
+	di->is_initialized = is_rk818_bat_initialized(di);
+	di->is_ocv_calib = is_rk818_bat_ocv_valid(di);
+
+	if (di->is_initialized) {
+		BAT_INFO("initialized yet..\n");
+		goto finish;
+	} else if (di->is_halt) {
+		BAT_INFO("system halt last time... cap: pre=%d, now=%d\n",
+			 pre_cap, now_cap);
+		if (now_cap < 0)
+			now_cap = 0;
+		rk818_bat_init_coulomb_cap(di, now_cap);
+		pre_cap = now_cap;
+		pre_soc = di->rsoc;
+		goto finish;
+	} else if (di->is_ocv_calib) {
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		pre_cap = ocv_cap;
+		di->ocv_pre_dsoc = pre_soc;
+		di->ocv_new_dsoc = ocv_soc;
+		if (abs(ocv_soc - pre_soc) >= di->pdata->max_soc_offset) {
+			di->ocv_pre_dsoc = pre_soc;
+			di->ocv_new_dsoc = ocv_soc;
+			di->is_max_soc_offset = true;
+			BAT_INFO("trigger max soc offset, dsoc: %d -> %d\n",
+				 pre_soc, ocv_soc);
+			pre_soc = ocv_soc;
+		}
+		BAT_INFO("OCV calib: cap=%d, rsoc=%d\n", ocv_cap, ocv_soc);
+	} else if (di->pwroff_min > 0) {
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		di->force_pre_dsoc = pre_soc;
+		di->force_new_dsoc = ocv_soc;
+		if (abs(ocv_soc - pre_soc) >= 80) {
+			di->is_force_calib = true;
+			BAT_INFO("dsoc force calib: %d -> %d\n",
+				 pre_soc, ocv_soc);
+			pre_soc = ocv_soc;
+			pre_cap = ocv_cap;
+		}
+	}
+
+finish:
+	di->dsoc = pre_soc;
+	di->nac = pre_cap;
+	if (di->nac < 0)
+		di->nac = 0;
+
+	BAT_INFO("dsoc=%d cap=%d v=%d ov=%d rv=%d min=%d psoc=%d pcap=%d\n",
+		 di->dsoc, di->nac, rk818_bat_get_avg_voltage(di),
+		 rk818_bat_get_ocv_voltage(di), rk818_bat_get_relax_voltage(di),
+		 di->pwroff_min, rk818_bat_get_prev_dsoc(di),
+		 rk818_bat_get_prev_cap(di));
+}
+
+static bool rk818_bat_ocv_sw_reset(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	if (((buf & FG_RESET_LATE) && di->pwroff_min >= 30) ||
+	    (buf & FG_RESET_NOW)) {
+		buf &= ~FG_RESET_LATE;
+		buf &= ~FG_RESET_NOW;
+		rk818_bat_write(di, RK818_MISC_MARK_REG, buf);
+		BAT_INFO("manual reset fuel gauge\n");
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void rk818_bat_init_rsoc(struct rk818_battery *di)
+{
+	di->is_first_power_on = is_rk818_bat_first_pwron(di);
+	di->is_sw_reset = rk818_bat_ocv_sw_reset(di);
+	di->pwroff_min = rk818_bat_get_pwroff_min(di);
+
+	if (di->is_first_power_on || di->is_sw_reset)
+		rk818_bat_first_pwron(di);
+	else
+		rk818_bat_not_first_pwron(di);
+}
+
+static u8 rk818_bat_get_chrg_status(struct rk818_battery *di)
+{
+	u8 status;
+
+	status = rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK;
+	switch (status) {
+	case CHARGE_OFF:
+		DBG("CHARGE-OFF ...\n");
+		break;
+	case DEAD_CHARGE:
+		BAT_INFO("DEAD CHARGE...\n");
+		break;
+	case TRICKLE_CHARGE:
+		BAT_INFO("TRICKLE CHARGE...\n ");
+		break;
+	case CC_OR_CV:
+		DBG("CC or CV...\n");
+		break;
+	case CHARGE_FINISH:
+		DBG("CHARGE FINISH...\n");
+		break;
+	case USB_OVER_VOL:
+		BAT_INFO("USB OVER VOL...\n");
+		break;
+	case BAT_TMP_ERR:
+		BAT_INFO("BAT TMP ERROR...\n");
+		break;
+	case TIMER_ERR:
+		BAT_INFO("TIMER ERROR...\n");
+		break;
+	case USB_EXIST:
+		BAT_INFO("USB EXIST...\n");
+		break;
+	case USB_EFF:
+		BAT_INFO("USB EFF...\n");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return status;
+}
+
+static u8 rk818_bat_parse_fb_temperature(struct rk818_battery *di)
+{
+	u8 reg;
+	int index, fb_temp;
+
+	reg = DEFAULT_FB_TEMP;
+	fb_temp = di->pdata->fb_temp;
+	for (index = 0; index < ARRAY_SIZE(feedback_temp_array); index++) {
+		if (fb_temp < feedback_temp_array[index])
+			break;
+		reg = (index << FB_TEMP_SHIFT);
+	}
+
+	return reg;
+}
+
+static u8 rk818_bat_parse_finish_ma(struct rk818_battery *di, int fcc)
+{
+	u8 ma;
+
+	if (di->pdata->sample_res == SAMPLE_RES_10MR)
+		ma = FINISH_100MA;
+	else if (fcc > 5000)
+		ma = FINISH_250MA;
+	else if (fcc >= 4000)
+		ma = FINISH_200MA;
+	else if (fcc >= 3000)
+		ma = FINISH_150MA;
+	else
+		ma = FINISH_100MA;
+
+	return ma;
+}
+
+static void rk818_bat_init_chrg_config(struct rk818_battery *di)
+{
+	u8 usb_ctrl, chrg_ctrl2, chrg_ctrl3;
+	u8 thermal, ggcon, finish_ma, fb_temp;
+
+	finish_ma = rk818_bat_parse_finish_ma(di, di->fcc);
+	fb_temp = rk818_bat_parse_fb_temperature(di);
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	chrg_ctrl2 = rk818_bat_read(di, RK818_CHRG_CTRL_REG2);
+	chrg_ctrl3 = rk818_bat_read(di, RK818_CHRG_CTRL_REG3);
+
+	/* set charge finish current */
+	chrg_ctrl3 |= CHRG_TERM_DIG_SIGNAL;
+	chrg_ctrl2 &= ~FINISH_CUR_MSK;
+	chrg_ctrl2 |= finish_ma;
+
+	/* disable cccv mode */
+	chrg_ctrl3 &= ~CHRG_TIMER_CCCV_EN;
+
+	/* set feed back temperature */
+	if (di->pdata->fb_temp)
+		usb_ctrl |= CHRG_CT_EN;
+	else
+		usb_ctrl &= ~CHRG_CT_EN;
+	thermal &= ~FB_TEMP_MSK;
+	thermal |= fb_temp;
+
+	/* adc current mode */
+	ggcon |= ADC_CUR_MODE;
+
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+	rk818_bat_write(di, RK818_THERMAL_REG, thermal);
+	rk818_bat_write(di, RK818_USB_CTRL_REG, usb_ctrl);
+	rk818_bat_write(di, RK818_CHRG_CTRL_REG2, chrg_ctrl2);
+	rk818_bat_write(di, RK818_CHRG_CTRL_REG3, chrg_ctrl3);
+}
+
+static void rk818_bat_init_coffset(struct rk818_battery *di)
+{
+	int coffset, ioffset;
+
+	ioffset = rk818_bat_get_ioffset(di);
+	di->poffset = rk818_bat_read(di, RK818_POFFSET_REG);
+	if (!di->poffset)
+		di->poffset = DEFAULT_POFFSET;
+
+	coffset = di->poffset + ioffset;
+	if (coffset < INVALID_COFFSET_MIN || coffset > INVALID_COFFSET_MAX)
+		coffset = DEFAULT_COFFSET;
+
+	rk818_bat_set_coffset(di, coffset);
+
+	DBG("<%s>. offset: p=0x%x, i=0x%x, c=0x%x\n",
+	    __func__, di->poffset, ioffset, rk818_bat_get_coffset(di));
+}
+
+static void rk818_bat_caltimer_isr(unsigned long data)
+{
+	struct rk818_battery *di = (struct rk818_battery *)data;
+
+	mod_timer(&di->caltimer, jiffies + MINUTE(8) * HZ);
+	queue_delayed_work(di->bat_monitor_wq, &di->calib_delay_work,
+			   msecs_to_jiffies(10));
+}
+
+static void rk818_bat_internal_calib(struct work_struct *work)
+{
+	int ioffset, poffset;
+	struct rk818_battery *di = container_of(work,
+			struct rk818_battery, calib_delay_work.work);
+
+	/* calib coffset */
+	poffset = rk818_bat_read(di, RK818_POFFSET_REG);
+	if (poffset)
+		di->poffset = poffset;
+	else
+		di->poffset = DEFAULT_POFFSET;
+
+	ioffset = rk818_bat_get_ioffset(di);
+	rk818_bat_set_coffset(di, ioffset + di->poffset);
+
+	/* calib voltage kb */
+	rk818_bat_init_voltage_kb(di);
+	DBG("caltimer: ioffset=0x%x, coffset=0x%x, poffset=%d\n",
+		 ioffset, rk818_bat_get_coffset(di), di->poffset);
+}
+
+static void rk818_bat_init_caltimer(struct rk818_battery *di)
+{
+	setup_timer(&di->caltimer, rk818_bat_caltimer_isr, (unsigned long)di);
+	di->caltimer.expires = jiffies + MINUTE(8) * HZ;
+	add_timer(&di->caltimer);
+	INIT_DELAYED_WORK(&di->calib_delay_work, rk818_bat_internal_calib);
+}
+
+static void rk818_bat_init_zero_table(struct rk818_battery *di)
+{
+	int i, diff, min, max;
+	size_t ocv_size, length;
+
+	ocv_size = di->pdata->ocv_size;
+	length = sizeof(di->pdata->zero_table) * ocv_size;
+	di->pdata->zero_table =
+			devm_kzalloc(di->dev, length, GFP_KERNEL);
+	if (!di->pdata->zero_table) {
+		di->pdata->zero_table = di->pdata->ocv_table;
+		dev_err(di->dev, "malloc zero table fail\n");
+		return;
+	}
+
+	min = di->pdata->pwroff_vol,
+	max = di->pdata->ocv_table[ocv_size - 4];
+	diff = (max - min) / DIV(ocv_size - 1);
+	for (i = 0; i < ocv_size; i++)
+		di->pdata->zero_table[i] = min + (i * diff);
+
+	for (i = 0; i < ocv_size; i++)
+		DBG("zero[%d] = %d\n", i, di->pdata->zero_table[i]);
+
+	for (i = 0; i < ocv_size; i++)
+		DBG("ocv[%d] = %d\n", i, di->pdata->ocv_table[i]);
+}
+
+static void rk818_bat_calc_sm_linek(struct rk818_battery *di)
+{
+	int linek, current_avg;
+	u8 diff, delta;
+
+	delta = abs(di->dsoc - di->rsoc);
+	diff = delta * 3;/* speed:3/4 */
+	current_avg = rk818_bat_get_avg_current(di);
+	if (current_avg >= 0) {
+		if (di->dsoc < di->rsoc)
+			linek = 1000 * (delta + diff) / DIV(diff);
+		else if (di->dsoc > di->rsoc)
+			linek = 1000 * diff / DIV(delta + diff);
+		else
+			linek = 1000;
+		di->dbg_meet_soc = (di->dsoc >= di->rsoc) ?
+				   (di->dsoc + diff) : (di->rsoc + diff);
+	} else {
+		if (di->dsoc < di->rsoc)
+			linek = -1000 * diff / DIV(delta + diff);
+		else if (di->dsoc > di->rsoc)
+			linek = -1000 * (delta + diff) / DIV(diff);
+		else
+			linek = -1000;
+		di->dbg_meet_soc = (di->dsoc >= di->rsoc) ?
+				   (di->dsoc - diff) : (di->rsoc - diff);
+	}
+
+	di->sm_linek = linek;
+	di->sm_remain_cap = di->remain_cap;
+	di->dbg_calc_dsoc = di->dsoc;
+	di->dbg_calc_rsoc = di->rsoc;
+
+	DBG("<%s>.diff=%d, k=%d, cur=%d\n", __func__, diff, linek, current_avg);
+}
+
+static void rk818_bat_calc_zero_linek(struct rk818_battery *di)
+{
+	int dead_voltage, ocv_voltage;
+	int voltage_avg, current_avg, vsys;
+	int ocv_cap, dead_cap, xsoc;
+	int ocv_soc, dead_soc;
+	int pwroff_vol;
+	int i, cnt = 0, vol_old, vol_now;
+	int org_linek = 0, min_gap_xsoc;
+
+	if ((abs(di->current_avg) < 500) && (di->dsoc > 10))
+		pwroff_vol = di->pdata->pwroff_vol + 50;
+	else
+		pwroff_vol = di->pdata->pwroff_vol;
+
+	do {
+		vol_old = rk818_bat_get_avg_voltage(di);
+		msleep(100);
+		vol_now = rk818_bat_get_avg_voltage(di);
+		cnt++;
+	} while ((vol_old == vol_now) && (cnt < 11));
+
+	voltage_avg = 0;
+	for (i = 0; i < 10; i++) {
+		voltage_avg += rk818_bat_get_avg_voltage(di);
+		msleep(100);
+	}
+
+	/* calc estimate ocv voltage */
+	voltage_avg /= 10;
+	current_avg = rk818_bat_get_avg_current(di);
+	vsys = voltage_avg + (current_avg * DEF_PWRPATH_RES) / 1000;
+
+	DBG("ZERO0: shtd_vol: org = %d, now = %d, zero_reserve_dsoc = %d\n",
+	    di->pdata->pwroff_vol, pwroff_vol, di->pdata->zero_reserve_dsoc);
+
+	dead_voltage = pwroff_vol - current_avg *
+				(di->bat_res + DEF_PWRPATH_RES) / 1000;
+	ocv_voltage = voltage_avg - (current_avg * di->bat_res) / 1000;
+	DBG("ZERO0: dead_voltage(shtd) = %d, ocv_voltage(now) = %d\n",
+	    dead_voltage, ocv_voltage);
+
+	/* calc estimate soc and cap */
+	dead_soc = rk818_bat_vol_to_zerosoc(di, dead_voltage);
+	dead_cap = rk818_bat_vol_to_zerocap(di, dead_voltage);
+	DBG("ZERO0: dead_soc = %d, dead_cap = %d\n",
+	    dead_soc, dead_cap);
+
+	ocv_soc = rk818_bat_vol_to_zerosoc(di, ocv_voltage);
+	ocv_cap = rk818_bat_vol_to_zerocap(di, ocv_voltage);
+	DBG("ZERO0: ocv_soc = %d, ocv_cap = %d\n",
+	    ocv_soc, ocv_cap);
+
+	/* xsoc: available rsoc */
+	xsoc = ocv_soc - dead_soc;
+
+	/* min_gap_xsoc: reserve xsoc */
+	if (abs(current_avg) > ZERO_LOAD_LVL1)
+		min_gap_xsoc = ZERO_GAP_XSOC3;
+	else if (abs(current_avg) > ZERO_LOAD_LVL2)
+		min_gap_xsoc = ZERO_GAP_XSOC2;
+	else
+		min_gap_xsoc = ZERO_GAP_XSOC1;
+
+	if ((xsoc <= 30) && (di->dsoc >= di->pdata->zero_reserve_dsoc))
+		min_gap_xsoc = min_gap_xsoc + ZERO_GAP_CALIB;
+
+	di->zero_remain_cap = di->remain_cap;
+	di->zero_timeout_cnt = 0;
+	if ((di->dsoc <= 1) && (xsoc > 0)) {
+		di->zero_linek = 400;
+		di->zero_drop_sec = 0;
+	} else if (xsoc >= 0) {
+		di->zero_drop_sec = 0;
+		di->zero_linek = (di->zero_dsoc + xsoc / 2) / DIV(xsoc);
+		org_linek = di->zero_linek;
+		/* battery energy mode to use up voltage */
+		if ((di->pdata->energy_mode) &&
+		    (xsoc - di->dsoc >= ZERO_GAP_XSOC3) &&
+		    (di->dsoc <= 10) && (di->zero_linek < 300)) {
+			di->zero_linek = 300;
+			DBG("ZERO-new: zero_linek adjust step0...\n");
+		/* reserve enough power yet, slow down any way */
+		} else if ((xsoc - di->dsoc >= min_gap_xsoc) ||
+			   ((xsoc - di->dsoc >= ZERO_GAP_XSOC2) &&
+			    (di->dsoc <= 10) && (xsoc > 15))) {
+			if (xsoc <= 20 &&
+			    di->dsoc >= di->pdata->zero_reserve_dsoc)
+				di->zero_linek = 1200;
+			else if (xsoc - di->dsoc >= 2 * min_gap_xsoc)
+				di->zero_linek = 400;
+			else if (xsoc - di->dsoc >= 3 + min_gap_xsoc)
+				di->zero_linek = 600;
+			else
+				di->zero_linek = 800;
+			DBG("ZERO-new: zero_linek adjust step1...\n");
+		/* control zero mode beginning enter */
+		} else if ((di->zero_linek > 1800) && (di->dsoc > 70)) {
+			di->zero_linek = 1800;
+			DBG("ZERO-new: zero_linek adjust step2...\n");
+		/* dsoc close to xsoc: it must reserve power */
+		} else if ((di->zero_linek > 1000) && (di->zero_linek < 1200)) {
+			di->zero_linek = 1200;
+			DBG("ZERO-new: zero_linek adjust step3...\n");
+		/* dsoc[5~15], dsoc < xsoc */
+		} else if ((di->dsoc <= 15 && di->dsoc > 5) &&
+			   (di->zero_linek <= 1200)) {
+			/* slow down */
+			if (xsoc - di->dsoc >= min_gap_xsoc)
+				di->zero_linek = 800;
+			/* reserve power */
+			else
+				di->zero_linek = 1200;
+			DBG("ZERO-new: zero_linek adjust step4...\n");
+		/* dsoc[5, 100], dsoc < xsoc */
+		} else if ((di->zero_linek < 1000) && (di->dsoc >= 5)) {
+			if ((xsoc - di->dsoc) < min_gap_xsoc) {
+				/* reserve power */
+				di->zero_linek = 1200;
+			} else {
+				if (abs(di->current_avg) > 500)/* heavy */
+					di->zero_linek = 900;
+				else
+					di->zero_linek = 1000;
+			}
+			DBG("ZERO-new: zero_linek adjust step5...\n");
+		/* dsoc[0~5], dsoc < xsoc */
+		} else if ((di->zero_linek < 1000) && (di->dsoc <= 5)) {
+			if ((xsoc - di->dsoc) <= 3)
+				di->zero_linek = 1200;
+			else
+				di->zero_linek = 800;
+				DBG("ZERO-new: zero_linek adjust step6...\n");
+		}
+	} else {
+		/* xsoc < 0 */
+		di->zero_linek = 1000;
+		if (!di->zero_drop_sec)
+			di->zero_drop_sec = get_boot_sec();
+		if (base2sec(di->zero_drop_sec) >= WAIT_DSOC_DROP_SEC) {
+			DBG("ZERO0: t=%lu\n", base2sec(di->zero_drop_sec));
+			di->zero_drop_sec = 0;
+			di->dsoc--;
+			di->zero_dsoc = (di->dsoc + 1) * 1000 -
+						MIN_ACCURACY;
+		}
+	}
+
+	if (voltage_avg < pwroff_vol - 70) {
+		if (!di->shtd_drop_sec)
+			di->shtd_drop_sec = get_boot_sec();
+		if (base2sec(di->shtd_drop_sec) > WAIT_SHTD_DROP_SEC) {
+			BAT_INFO("voltage extreme low...soc:%d->0\n", di->dsoc);
+			di->shtd_drop_sec = 0;
+			di->dsoc = 0;
+		}
+	} else {
+		di->shtd_drop_sec = 0;
+	}
+
+	DBG("ZERO-new: org_linek=%d, zero_linek=%d, dsoc=%d, Xsoc=%d, "
+	    "rsoc=%d, gap=%d, v=%d, vsys=%d\n"
+	    "ZERO-new: di->zero_dsoc=%d, zero_remain_cap=%d, zero_drop=%ld, "
+	    "sht_drop=%ld\n\n",
+	    org_linek, di->zero_linek, di->dsoc, xsoc, di->rsoc,
+	    min_gap_xsoc, voltage_avg, vsys, di->zero_dsoc, di->zero_remain_cap,
+	    base2sec(di->zero_drop_sec), base2sec(di->shtd_drop_sec));
+}
+
+static void rk818_bat_finish_algo_prepare(struct rk818_battery *di)
+{
+	di->finish_base = get_boot_sec();
+	if (!di->finish_base)
+		di->finish_base = 1;
+}
+
+static void rk818_bat_smooth_algo_prepare(struct rk818_battery *di)
+{
+	int tmp_soc;
+
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc)
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc)
+		di->sm_dischrg_dsoc =
+		(di->dsoc + 1) * 1000 - MIN_ACCURACY;
+
+	DBG("<%s>. tmp_soc=%d, dsoc=%d, dsoc:sm_dischrg=%d, sm_chrg=%d\n",
+	    __func__, tmp_soc, di->dsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+
+	rk818_bat_calc_sm_linek(di);
+}
+
+static void rk818_bat_zero_algo_prepare(struct rk818_battery *di)
+{
+	int tmp_dsoc;
+
+	di->zero_timeout_cnt = 0;
+	tmp_dsoc = di->zero_dsoc / 1000;
+	if (tmp_dsoc != di->dsoc)
+		di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+
+	DBG("<%s>. first calc, reinit linek\n", __func__);
+
+	rk818_bat_calc_zero_linek(di);
+}
+
+static void rk818_bat_calc_zero_algorithm(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0;
+
+	tmp_soc = di->zero_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when discharge slow down, take sm chrg into calc */
+	if (di->dsoc < di->rsoc) {
+		/* take sm charge rest into calc */
+		tmp_soc = di->sm_chrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_chrg_dsoc - di->dsoc * 1000;
+			di->sm_chrg_dsoc = di->dsoc * 1000;
+			di->zero_dsoc += sm_delta_dsoc;
+			DBG("ZERO1: take sm chrg,delta=%d\n", sm_delta_dsoc);
+		}
+	}
+
+	/* when discharge speed up, take sm dischrg into calc */
+	if (di->dsoc > di->rsoc) {
+		/* take sm discharge rest into calc */
+		tmp_soc = di->sm_dischrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_dischrg_dsoc -
+				((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 -
+								MIN_ACCURACY;
+			di->zero_dsoc += sm_delta_dsoc;
+			DBG("ZERO1: take sm dischrg,delta=%d\n", sm_delta_dsoc);
+		}
+	}
+
+	/* check overflow */
+	if (di->zero_dsoc > (di->dsoc + 1) * 1000 - MIN_ACCURACY) {
+		DBG("ZERO1: zero dsoc overflow: %d\n", di->zero_dsoc);
+		di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->zero_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		/* avoid dsoc jump when heavy load */
+		if ((di->dsoc - tmp_soc) > 1) {
+			di->dsoc--;
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			DBG("ZERO1: heavy load...\n");
+		} else {
+			di->dsoc = tmp_soc;
+		}
+		di->zero_drop_sec = 0;
+	}
+
+out:
+	DBG("ZERO1: zero_dsoc(Y0)=%d, dsoc=%d, rsoc=%d, tmp_soc=%d\n",
+	    di->zero_dsoc, di->dsoc, di->rsoc, tmp_soc);
+	DBG("ZERO1: sm_dischrg_dsoc=%d, sm_chrg_dsoc=%d\n",
+	    di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+}
+
+static void rk818_bat_zero_algorithm(struct rk818_battery *di)
+{
+	int delta_cap = 0, delta_soc = 0;
+
+	di->zero_timeout_cnt++;
+	delta_cap = di->zero_remain_cap - di->remain_cap;
+	delta_soc = di->zero_linek * (delta_cap * 100) / DIV(di->fcc);
+
+	DBG("ZERO1: zero_linek=%d, zero_dsoc(Y0)=%d, dsoc=%d, rsoc=%d\n"
+	    "ZERO1: delta_soc(X0)=%d, delta_cap=%d, zero_remain_cap = %d\n"
+	    "ZERO1: timeout_cnt=%d, sm_dischrg=%d, sm_chrg=%d\n\n",
+	    di->zero_linek, di->zero_dsoc, di->dsoc, di->rsoc,
+	    delta_soc, delta_cap, di->zero_remain_cap,
+	    di->zero_timeout_cnt, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+
+	if ((delta_soc >= MIN_ZERO_DSOC_ACCURACY) ||
+	    (di->zero_timeout_cnt > MIN_ZERO_OVERCNT) ||
+	    (di->zero_linek == 0)) {
+		DBG("ZERO1:--------- enter calc -----------\n");
+		di->zero_timeout_cnt = 0;
+		di->zero_dsoc -= delta_soc;
+		rk818_bat_calc_zero_algorithm(di);
+		rk818_bat_calc_zero_linek(di);
+	}
+}
+
+static void rk818_bat_dump_time_table(struct rk818_battery *di)
+{
+	u8 i;
+	static int old_index;
+	static int old_min;
+	int mod = di->dsoc % 10;
+	int index = di->dsoc / 10;
+	u32 time;
+
+	if (rk818_bat_chrg_online(di))
+		time = base2min(di->plug_in_base);
+	else
+		time = base2min(di->plug_out_base);
+
+	if ((mod == 0) && (index > 0) && (old_index != index)) {
+		di->dbg_chrg_min[index - 1] = time - old_min;
+		old_min = time;
+		old_index = index;
+	}
+
+	for (i = 1; i < 11; i++)
+		DBG("Time[%d]=%d, ", (i * 10), di->dbg_chrg_min[i - 1]);
+	DBG("\n");
+}
+
+static void rk818_bat_debug_info(struct rk818_battery *di)
+{
+	u8 sup_tst, ggcon, ggsts, vb_mod, ts_ctrl, reboot_cnt;
+	u8 usb_ctrl, chrg_ctrl1, thermal;
+	u8 int_sts1, int_sts2;
+	u8 int_msk1, int_msk2;
+	u8 chrg_ctrl2, chrg_ctrl3, rtc, misc, dcdc_en;
+	char *work_mode[] = {"ZERO", "FINISH", "UN", "UN", "SMOOTH"};
+	char *bat_mode[] = {"BAT", "VIRTUAL"};
+
+	if (rk818_bat_chrg_online(di))
+		di->plug_out_base = get_boot_sec();
+	else
+		di->plug_in_base = get_boot_sec();
+
+	rk818_bat_dump_time_table(di);
+
+	if (!dbg_enable)
+		return;
+
+	ts_ctrl = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	misc = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggsts = rk818_bat_read(di, RK818_GGSTS_REG);
+	sup_tst = rk818_bat_read(di, RK818_SUP_STS_REG);
+	vb_mod = rk818_bat_read(di, RK818_VB_MON_REG);
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	chrg_ctrl1 = rk818_bat_read(di, RK818_CHRG_CTRL_REG1);
+	chrg_ctrl2 = rk818_bat_read(di, RK818_CHRG_CTRL_REG2);
+	chrg_ctrl3 = rk818_bat_read(di, RK818_CHRG_CTRL_REG3);
+	rtc = rk818_bat_read(di, 0);
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	int_sts1 = rk818_bat_read(di, RK818_INT_STS_REG1);
+	int_sts2 = rk818_bat_read(di, RK818_INT_STS_REG2);
+	int_msk1 = rk818_bat_read(di, RK818_INT_STS_MSK_REG1);
+	int_msk2 = rk818_bat_read(di, RK818_INT_STS_MSK_REG2);
+	dcdc_en = rk818_bat_read(di, RK818_DCDC_EN_REG);
+	reboot_cnt = rk818_bat_read(di, RK818_REBOOT_CNT_REG);
+
+	DBG("\n------- DEBUG REGS, [Ver: %s] -------------------\n"
+	    "GGCON=0x%2x, GGSTS=0x%2x, RTC=0x%2x, DCDC_EN2=0x%2x\n"
+	    "SUP_STS= 0x%2x, VB_MOD=0x%2x, USB_CTRL=0x%2x\n"
+	    "THERMAL=0x%2x, MISC_MARK=0x%2x, TS_CTRL=0x%2x\n"
+	    "CHRG_CTRL:REG1=0x%2x, REG2=0x%2x, REG3=0x%2x\n"
+	    "INT_STS:  REG1=0x%2x, REG2=0x%2x\n"
+	    "INT_MSK:  REG1=0x%2x, REG2=0x%2x\n",
+	    DRIVER_VERSION, ggcon, ggsts, rtc, dcdc_en,
+	    sup_tst, vb_mod, usb_ctrl,
+	    thermal, misc, ts_ctrl,
+	    chrg_ctrl1, chrg_ctrl2, chrg_ctrl3,
+	    int_sts1, int_sts2, int_msk1, int_msk2
+	   );
+
+	DBG("###############################################################\n"
+	    "Dsoc=%d, Rsoc=%d, Vavg=%d, Iavg=%d, Cap=%d, Fcc=%d, d=%d\n"
+	    "K=%d, Mode=%s, Oldcap=%d, Is=%d, Ip=%d, Vs=%d\n"
+	    "fb_temp=%d, bat_temp=%d, sample_res=%d, USB=%d, DC=%d\n"
+	    "off:i=0x%x, c=0x%x, p=%d, Rbat=%d, age_ocv_cap=%d, fb=%d, hot=%d\n"
+	    "adp:finish=%lu, boot_min=%lu, sleep_min=%lu, adc=%d, Vsys=%d\n"
+	    "bat:%s, meet: soc=%d, calc: dsoc=%d, rsoc=%d, Vocv=%d\n"
+	    "pwr: dsoc=%d, rsoc=%d, vol=%d, halt: st=%d, cnt=%d, reboot=%d\n"
+	    "ocv_c=%d: %d -> %d; max_c=%d: %d -> %d; force_c=%d: %d -> %d\n"
+	    "min=%d, init=%d, sw=%d, below0=%d, first=%d, changed=%d\n"
+	    "###############################################################\n",
+	    di->dsoc, di->rsoc, di->voltage_avg, di->current_avg,
+	    di->remain_cap, di->fcc, di->rsoc - di->dsoc,
+	    di->sm_linek, work_mode[di->work_mode], di->sm_remain_cap,
+	    di->res_div * chrg_cur_sel_array[chrg_ctrl1 & 0x0f],
+	    chrg_cur_input_array[usb_ctrl & 0x0f],
+	    chrg_vol_sel_array[(chrg_ctrl1 & 0x70) >> 4],
+	    feedback_temp_array[(thermal & 0x0c) >> 2], di->temperature,
+	    di->pdata->sample_res, di->usb_in, di->ac_in,
+	    rk818_bat_get_ioffset(di),
+	    rk818_bat_get_coffset(di), di->poffset, di->bat_res,
+	    di->age_adjust_cap, di->fb_blank, !!(thermal & HOTDIE_STS),
+	    base2min(di->finish_base),
+	    base2min(di->boot_base), di->sleep_sum_sec / 60,
+	    di->adc_allow_update,
+	    di->voltage_avg + di->current_avg * DEF_PWRPATH_RES / 1000,
+	    bat_mode[di->pdata->bat_mode], di->dbg_meet_soc, di->dbg_calc_dsoc,
+	    di->dbg_calc_rsoc, di->voltage_ocv, di->dbg_pwr_dsoc,
+	    di->dbg_pwr_rsoc, di->dbg_pwr_vol, di->is_halt, di->halt_cnt,
+	    reboot_cnt, di->is_ocv_calib, di->ocv_pre_dsoc, di->ocv_new_dsoc,
+	    di->is_max_soc_offset, di->max_pre_dsoc, di->max_new_dsoc,
+	    di->is_force_calib, di->force_pre_dsoc, di->force_new_dsoc,
+	    di->pwroff_min, di->is_initialized, di->is_sw_reset,
+	    di->dbg_cap_low0, di->is_first_on, di->last_dsoc
+	   );
+}
+
+static void rk818_bat_init_capacity(struct rk818_battery *di, u32 cap)
+{
+	int delta_cap;
+
+	delta_cap = cap - di->remain_cap;
+	if (!delta_cap)
+		return;
+
+	di->age_adjust_cap += delta_cap;
+	rk818_bat_init_coulomb_cap(di, cap);
+	rk818_bat_smooth_algo_prepare(di);
+	rk818_bat_zero_algo_prepare(di);
+}
+
+static void rk818_bat_update_age_fcc(struct rk818_battery *di)
+{
+	int fcc, remain_cap, age_keep_min, lock_fcc;
+
+	lock_fcc = rk818_bat_get_coulomb_cap(di);
+	remain_cap = lock_fcc - di->age_ocv_cap - di->age_adjust_cap;
+	age_keep_min = base2min(di->age_keep_sec);
+
+	DBG("%s: lock_fcc=%d, age_ocv_cap=%d, age_adjust_cap=%d, remain_cap=%d,"
+	    "age_allow_update=%d, age_keep_min=%d\n",
+	    __func__, lock_fcc, di->age_ocv_cap, di->age_adjust_cap, remain_cap,
+	    di->age_allow_update, age_keep_min);
+
+	if ((di->chrg_status == CHARGE_FINISH) && (di->age_allow_update) &&
+	    (age_keep_min < 1200)) {
+		di->age_allow_update = false;
+		fcc = remain_cap * 100 / DIV(100 - di->age_ocv_soc);
+		BAT_INFO("lock_fcc=%d, calc_cap=%d, age: soc=%d, cap=%d, "
+			 "level=%d, fcc:%d->%d?\n",
+			 lock_fcc, remain_cap, di->age_ocv_soc,
+			 di->age_ocv_cap, di->age_level, di->fcc, fcc);
+
+		if ((fcc < di->qmax) && (fcc > MIN_FCC)) {
+			BAT_INFO("fcc:%d->%d!\n", di->fcc, fcc);
+			di->fcc = fcc;
+			rk818_bat_init_capacity(di, di->fcc);
+			rk818_bat_save_fcc(di, di->fcc);
+			rk818_bat_save_age_level(di, di->age_level);
+		}
+	}
+}
+
+static void rk818_bat_wait_finish_sig(struct rk818_battery *di)
+{
+	int chrg_finish_vol = di->pdata->max_chrg_voltage;
+
+	if (!rk818_bat_chrg_online(di))
+		return;
+
+	if ((di->chrg_status == CHARGE_FINISH) && (di->adc_allow_update) &&
+	    (di->voltage_avg > chrg_finish_vol - 150)) {
+		rk818_bat_update_age_fcc(di);
+		if (rk818_bat_adc_calib(di))
+			di->adc_allow_update = false;
+	}
+}
+
+static void rk818_bat_finish_algorithm(struct rk818_battery *di)
+{
+	unsigned long finish_sec, soc_sec;
+	int plus_soc, finish_current, rest = 0;
+
+	/* rsoc */
+	if ((di->remain_cap != di->fcc) &&
+	    (rk818_bat_get_chrg_status(di) == CHARGE_FINISH)) {
+		di->age_adjust_cap += (di->fcc - di->remain_cap);
+		rk818_bat_init_coulomb_cap(di, di->fcc);
+	}
+
+	/* dsoc */
+	if (di->dsoc < 100) {
+		if (!di->finish_base)
+			di->finish_base = get_boot_sec();
+		finish_current = (di->rsoc - di->dsoc) >  FINISH_MAX_SOC_DELAY ?
+					FINISH_CHRG_CUR2 : FINISH_CHRG_CUR1;
+		finish_sec = base2sec(di->finish_base);
+		soc_sec = di->fcc * 3600 / 100 / DIV(finish_current);
+		plus_soc = finish_sec / DIV(soc_sec);
+		if (finish_sec > soc_sec) {
+			rest = finish_sec % soc_sec;
+			di->dsoc += plus_soc;
+			di->finish_base = get_boot_sec();
+			if (di->finish_base > rest)
+				di->finish_base = get_boot_sec() - rest;
+		}
+		DBG("<%s>.CHARGE_FINISH:dsoc<100,dsoc=%d\n"
+		    "soc_time=%lu, sec_finish=%lu, plus_soc=%d, rest=%d\n",
+		    __func__, di->dsoc, soc_sec, finish_sec, plus_soc, rest);
+	}
+}
+
+static void rk818_bat_calc_smooth_dischrg(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0, zero_delta_dsoc = 0;
+
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when dischrge slow down, take sm charge rest into calc */
+	if (di->dsoc < di->rsoc) {
+		tmp_soc = di->sm_chrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_chrg_dsoc - di->dsoc * 1000;
+			di->sm_chrg_dsoc = di->dsoc * 1000;
+			di->sm_dischrg_dsoc += sm_delta_dsoc;
+			DBG("<%s>. take sm dischrg, delta=%d\n",
+			    __func__, sm_delta_dsoc);
+		}
+	}
+
+	/* when discharge speed up, take zero discharge rest into calc */
+	if (di->dsoc > di->rsoc) {
+		tmp_soc = di->zero_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			zero_delta_dsoc = di->zero_dsoc - ((di->dsoc + 1) *
+						1000 - MIN_ACCURACY);
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			di->sm_dischrg_dsoc += zero_delta_dsoc;
+			DBG("<%s>. take zero schrg, delta=%d\n",
+			    __func__, zero_delta_dsoc);
+		}
+	}
+
+	/* check up overflow */
+	if ((di->sm_dischrg_dsoc) > ((di->dsoc + 1) * 1000 - MIN_ACCURACY)) {
+		DBG("<%s>. dischrg_dsoc up overflow\n", __func__);
+		di->sm_dischrg_dsoc = (di->dsoc + 1) *
+					1000 - MIN_ACCURACY;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		di->dsoc = tmp_soc;
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+	}
+out:
+	DBG("<%s>. dsoc=%d, rsoc=%d, dsoc:sm_dischrg=%d, sm_chrg=%d, zero=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc,
+	    di->zero_dsoc);
+
+}
+
+static void rk818_bat_calc_smooth_chrg(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0, zero_delta_dsoc = 0;
+
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when charge slow down, take zero & sm dischrg into calc */
+	if (di->dsoc > di->rsoc) {
+		/* take sm discharge rest into calc */
+		tmp_soc = di->sm_dischrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_dischrg_dsoc -
+					((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 -
+							MIN_ACCURACY;
+			di->sm_chrg_dsoc += sm_delta_dsoc;
+			DBG("<%s>. take sm dischrg, delta=%d\n",
+			   __func__, sm_delta_dsoc);
+		}
+
+		/* take zero discharge rest into calc */
+		tmp_soc = di->zero_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			zero_delta_dsoc = di->zero_dsoc -
+			((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			di->sm_chrg_dsoc += zero_delta_dsoc;
+			DBG("<%s>. take zero dischrg, delta=%d\n",
+			    __func__, zero_delta_dsoc);
+		}
+	}
+
+	/* check down overflow */
+	if (di->sm_chrg_dsoc < di->dsoc * 1000) {
+		DBG("<%s>. chrg_dsoc down overflow\n", __func__);
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		di->dsoc = tmp_soc;
+		di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+	}
+out:
+	DBG("<%s>.dsoc=%d, rsoc=%d, dsoc: sm_dischrg=%d, sm_chrg=%d, zero=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc,
+	    di->zero_dsoc);
+}
+
+static void rk818_bat_smooth_algorithm(struct rk818_battery *di)
+{
+	int ydsoc = 0, delta_cap = 0, old_cap = 0;
+	unsigned long tgt_sec = 0;
+
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+
+	/* full charge: slow down */
+	if ((di->dsoc == 99) && (di->chrg_status == CC_OR_CV) &&
+	    (di->current_avg > 0)) {
+		di->sm_linek = FULL_CHRG_K;
+	/* terminal charge, slow down */
+	} else if ((di->current_avg >= TERM_CHRG_CURR) &&
+	    (di->chrg_status == CC_OR_CV) && (di->dsoc >= TERM_CHRG_DSOC)) {
+		di->sm_linek = TERM_CHRG_K;
+		DBG("<%s>. terminal mode..\n", __func__);
+	/* simulate charge, speed up */
+	} else if ((di->current_avg <= SIMULATE_CHRG_CURR) &&
+		   (di->current_avg > 0) && (di->chrg_status == CC_OR_CV) &&
+		   (di->dsoc < TERM_CHRG_DSOC) &&
+		   ((di->rsoc - di->dsoc) >= SIMULATE_CHRG_INTV)) {
+		di->sm_linek = SIMULATE_CHRG_K;
+		DBG("<%s>. simulate mode..\n", __func__);
+	} else {
+		/* charge and discharge switch */
+		if ((di->sm_linek * di->current_avg <= 0) ||
+		    (di->sm_linek == TERM_CHRG_K) ||
+		    (di->sm_linek == FULL_CHRG_K) ||
+		    (di->sm_linek == SIMULATE_CHRG_K)) {
+			DBG("<%s>. linek mode, retinit sm linek..\n", __func__);
+			rk818_bat_calc_sm_linek(di);
+		}
+	}
+
+	old_cap = di->sm_remain_cap;
+	/*
+	 * when dsoc equal rsoc(not include full, term, simulate case),
+	 * sm_linek should change to -1000/1000 smoothly to avoid dsoc+1/-1
+	 * right away, so change it after flat seconds
+	 */
+	if ((di->dsoc == di->rsoc) && (abs(di->sm_linek) != 1000) &&
+	    (di->sm_linek != FULL_CHRG_K && di->sm_linek != TERM_CHRG_K &&
+	     di->sm_linek != SIMULATE_CHRG_K)) {
+		if (!di->flat_match_sec)
+			di->flat_match_sec = get_boot_sec();
+		tgt_sec = di->fcc * 3600 / 100 / DIV(abs(di->current_avg)) / 3;
+		if (base2sec(di->flat_match_sec) >= tgt_sec) {
+			di->flat_match_sec = 0;
+			di->sm_linek = (di->current_avg >= 0) ? 1000 : -1000;
+		}
+		DBG("<%s>. flat_sec=%ld, tgt_sec=%ld, sm_k=%d\n", __func__,
+		    base2sec(di->flat_match_sec), tgt_sec, di->sm_linek);
+	} else {
+		di->flat_match_sec = 0;
+	}
+
+	/* abs(k)=1000 or dsoc=100, stop calc */
+	if ((abs(di->sm_linek) == 1000) || (di->current_avg >= 0 &&
+	     di->chrg_status == CC_OR_CV && di->dsoc >= 100)) {
+		DBG("<%s>. sm_linek=%d\n", __func__, di->sm_linek);
+		if (abs(di->sm_linek) == 1000) {
+			di->dsoc = di->rsoc;
+			di->sm_linek = (di->sm_linek > 0) ? 1000 : -1000;
+			DBG("<%s>. dsoc == rsoc, sm_linek=%d\n",
+			    __func__, di->sm_linek);
+		}
+		di->sm_remain_cap = di->remain_cap;
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+		di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+		DBG("<%s>. sm_dischrg_dsoc=%d, sm_chrg_dsoc=%d\n",
+		    __func__, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+	} else {
+		delta_cap = di->remain_cap - di->sm_remain_cap;
+		if (delta_cap == 0) {
+			DBG("<%s>. delta_cap = 0\n", __func__);
+			return;
+		}
+		ydsoc = di->sm_linek * abs(delta_cap) * 100 / DIV(di->fcc);
+		if (ydsoc == 0) {
+			DBG("<%s>. ydsoc = 0\n", __func__);
+			return;
+		}
+		di->sm_remain_cap = di->remain_cap;
+
+		DBG("<%s>. k=%d, ydsoc=%d; cap:old=%d, new:%d; delta_cap=%d\n",
+		    __func__, di->sm_linek, ydsoc, old_cap,
+		    di->sm_remain_cap, delta_cap);
+
+		/* discharge mode */
+		if (ydsoc < 0) {
+			di->sm_dischrg_dsoc += ydsoc;
+			rk818_bat_calc_smooth_dischrg(di);
+		/* charge mode */
+		} else {
+			di->sm_chrg_dsoc += ydsoc;
+			rk818_bat_calc_smooth_chrg(di);
+		}
+
+		if (di->s2r) {
+			di->s2r = false;
+			rk818_bat_calc_sm_linek(di);
+		}
+	}
+}
+
+/*
+ * cccv and finish switch all the time will cause dsoc freeze,
+ * if so, do finish chrg, 100ma is less than min finish_ma.
+ */
+static bool rk818_bat_fake_finish_mode(struct rk818_battery *di)
+{
+	if ((di->rsoc == 100) && (rk818_bat_get_chrg_status(di) == CC_OR_CV) &&
+	    (abs(di->current_avg) <= 100))
+		return true;
+	else
+		return false;
+}
+
+static void rk818_bat_display_smooth(struct rk818_battery *di)
+{
+	/* discharge: reinit "zero & smooth" algorithm to avoid handling dsoc */
+	if (di->s2r && !di->sleep_chrg_online) {
+		DBG("s2r: discharge, reset algorithm...\n");
+		di->s2r = false;
+		rk818_bat_zero_algo_prepare(di);
+		rk818_bat_smooth_algo_prepare(di);
+		return;
+	}
+
+	if (di->work_mode == MODE_FINISH) {
+		DBG("step1: charge finish...\n");
+		rk818_bat_finish_algorithm(di);
+		if ((rk818_bat_get_chrg_status(di) != CHARGE_FINISH) &&
+		    !rk818_bat_fake_finish_mode(di)) {
+			if ((di->current_avg < 0) &&
+			    (di->voltage_avg < di->pdata->zero_algorithm_vol)) {
+				DBG("step1: change to zero mode...\n");
+				rk818_bat_zero_algo_prepare(di);
+				di->work_mode = MODE_ZERO;
+			} else {
+				DBG("step1: change to smooth mode...\n");
+				rk818_bat_smooth_algo_prepare(di);
+				di->work_mode = MODE_SMOOTH;
+			}
+		}
+	} else if (di->work_mode == MODE_ZERO) {
+		DBG("step2: zero algorithm...\n");
+		rk818_bat_zero_algorithm(di);
+		if ((di->voltage_avg >= di->pdata->zero_algorithm_vol + 50) ||
+		    (di->current_avg >= 0)) {
+			DBG("step2: change to smooth mode...\n");
+			rk818_bat_smooth_algo_prepare(di);
+			di->work_mode = MODE_SMOOTH;
+		} else if ((rk818_bat_get_chrg_status(di) == CHARGE_FINISH) ||
+			   rk818_bat_fake_finish_mode(di)) {
+			DBG("step2: change to finish mode...\n");
+			rk818_bat_finish_algo_prepare(di);
+			di->work_mode = MODE_FINISH;
+		}
+	} else {
+		DBG("step3: smooth algorithm...\n");
+		rk818_bat_smooth_algorithm(di);
+		if ((di->current_avg < 0) &&
+		    (di->voltage_avg < di->pdata->zero_algorithm_vol)) {
+			DBG("step3: change to zero mode...\n");
+			rk818_bat_zero_algo_prepare(di);
+			di->work_mode = MODE_ZERO;
+		} else if ((rk818_bat_get_chrg_status(di) == CHARGE_FINISH) ||
+			   rk818_bat_fake_finish_mode(di)) {
+			DBG("step3: change to finish mode...\n");
+			rk818_bat_finish_algo_prepare(di);
+			di->work_mode = MODE_FINISH;
+		}
+	}
+}
+
+static void rk818_bat_relax_vol_calib(struct rk818_battery *di)
+{
+	int soc, cap, vol;
+
+	vol = di->voltage_relax;
+	soc = rk818_bat_vol_to_ocvsoc(di, vol);
+	cap = rk818_bat_vol_to_ocvcap(di, vol);
+	rk818_bat_init_capacity(di, cap);
+	BAT_INFO("sleep ocv calib: rsoc=%d, cap=%d\n", soc, cap);
+}
+
+static void rk818_bat_relife_age_flag(struct rk818_battery *di)
+{
+	u8 ocv_soc, ocv_cap, soc_level;
+
+	if (di->voltage_relax <= 0)
+		return;
+
+	ocv_soc = rk818_bat_vol_to_ocvsoc(di, di->voltage_relax);
+	ocv_cap = rk818_bat_vol_to_ocvcap(di, di->voltage_relax);
+	DBG("<%s>. ocv_soc=%d, min=%lu, vol=%d\n", __func__,
+	    ocv_soc, di->sleep_dischrg_sec / 60, di->voltage_relax);
+
+	/* sleep enough time and ocv_soc enough low */
+	if (!di->age_allow_update && ocv_soc <= 10) {
+		di->age_voltage = di->voltage_relax;
+		di->age_ocv_cap = ocv_cap;
+		di->age_ocv_soc = ocv_soc;
+		di->age_adjust_cap = 0;
+
+		if (ocv_soc <= 1)
+			di->age_level = 100;
+		else if (ocv_soc < 5)
+			di->age_level = 90;
+		else
+			di->age_level = 80;
+
+		soc_level = rk818_bat_get_age_level(di);
+		if (soc_level > di->age_level) {
+			di->age_allow_update = false;
+		} else {
+			di->age_allow_update = true;
+			di->age_keep_sec = get_boot_sec();
+		}
+
+		BAT_INFO("resume: age_vol:%d, age_ocv_cap:%d, age_ocv_soc:%d, "
+			 "soc_level:%d, age_allow_update:%d, "
+			 "age_level:%d\n",
+			 di->age_voltage, di->age_ocv_cap, ocv_soc, soc_level,
+			 di->age_allow_update, di->age_level);
+	}
+}
+
+static int rk818_bat_sleep_dischrg(struct rk818_battery *di)
+{
+	bool ocv_soc_updated = false;
+	int tgt_dsoc, gap_soc, sleep_soc = 0;
+	int pwroff_vol = di->pdata->pwroff_vol;
+	unsigned long sleep_sec = di->sleep_dischrg_sec;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d, rv=%d, v=%d, sleep_min=%lu\n",
+	    __func__, di->dsoc, di->rsoc, di->voltage_relax,
+	    di->voltage_avg, sleep_sec / 60);
+
+	if (di->voltage_relax >= di->voltage_avg) {
+		rk818_bat_relax_vol_calib(di);
+		rk818_bat_restart_relax(di);
+		rk818_bat_relife_age_flag(di);
+		ocv_soc_updated = true;
+	}
+
+	/* handle dsoc */
+	if (di->dsoc <= di->rsoc) {
+		di->sleep_sum_cap = (SLP_CURR_MIN * sleep_sec / 3600);
+		sleep_soc = di->sleep_sum_cap * 100 / DIV(di->fcc);
+		tgt_dsoc = di->dsoc - sleep_soc;
+		if (sleep_soc > 0) {
+			BAT_INFO("calib0: rl=%d, dl=%d, intval=%d\n",
+				 di->rsoc, di->dsoc, sleep_soc);
+			if (di->dsoc < 5) {
+				di->dsoc--;
+			} else if ((tgt_dsoc < 5) && (di->dsoc >= 5)) {
+				if (di->dsoc == 5)
+					di->dsoc--;
+				else
+					di->dsoc = 5;
+			} else if (tgt_dsoc > 5) {
+				di->dsoc = tgt_dsoc;
+			}
+		}
+
+		DBG("%s: dsoc<=rsoc, sum_cap=%d==>sleep_soc=%d, tgt_dsoc=%d\n",
+		    __func__, di->sleep_sum_cap, sleep_soc, tgt_dsoc);
+	} else {
+		/* di->dsoc > di->rsoc */
+		di->sleep_sum_cap = (SLP_CURR_MAX * sleep_sec / 3600);
+		sleep_soc = di->sleep_sum_cap / DIV(di->fcc / 100);
+		gap_soc = di->dsoc - di->rsoc;
+
+		BAT_INFO("calib1: rsoc=%d, dsoc=%d, intval=%d\n",
+			 di->rsoc, di->dsoc, sleep_soc);
+		if (gap_soc > sleep_soc) {
+			if ((gap_soc - 5) > (sleep_soc * 2))
+				di->dsoc -= (sleep_soc * 2);
+			else
+				di->dsoc -= sleep_soc;
+		} else {
+			di->dsoc = di->rsoc;
+		}
+
+		DBG("%s: dsoc>rsoc, sum_cap=%d=>sleep_soc=%d, gap_soc=%d\n",
+		    __func__, di->sleep_sum_cap, sleep_soc, gap_soc);
+	}
+
+	if (di->voltage_avg <= pwroff_vol - 70) {
+		di->dsoc = 0;
+		rk_send_wakeup_key();
+		BAT_INFO("low power sleeping, shutdown... %d\n", di->dsoc);
+	}
+
+	if (ocv_soc_updated && sleep_soc && (di->rsoc - di->dsoc) < 5 &&
+	    di->dsoc < 40) {
+		di->dsoc--;
+		BAT_INFO("low power sleeping, reserved... %d\n", di->dsoc);
+	}
+
+	if (di->dsoc <= 0) {
+		di->dsoc = 0;
+		rk_send_wakeup_key();
+		BAT_INFO("sleep dsoc is %d...\n", di->dsoc);
+	}
+
+	DBG("<%s>. out: dsoc=%d, rsoc=%d, sum_cap=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sleep_sum_cap);
+
+	return sleep_soc;
+}
+
+static void rk818_bat_power_supply_changed(struct rk818_battery *di)
+{
+	u8 status, thermal;
+	static int old_soc = -1;
+
+	if (di->dsoc > 100)
+		di->dsoc = 100;
+	else if (di->dsoc < 0)
+		di->dsoc = 0;
+
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	status = rk818_bat_read(di, RK818_SUP_STS_REG);
+	status = (status & CHRG_STATUS_MSK) >> 4;
+	old_soc = di->dsoc;
+	di->last_dsoc = di->dsoc;
+	power_supply_changed(di->bat);
+	DBG("changed: dsoc=%d, rsoc=%d, v=%d, ov=%d c=%d, "
+		 "cap=%d, f=%d, st=%s, hotdie=%d\n",
+		 di->dsoc, di->rsoc, di->voltage_avg, di->voltage_ocv,
+		 di->current_avg, di->remain_cap, di->fcc, bat_status[status],
+		 !!(thermal & HOTDIE_STS));
+
+	DBG("dl=%d, rl=%d, v=%d, halt=%d, halt_n=%d, max=%d, "
+		 "init=%d, sw=%d, calib=%d, below0=%d, force=%d\n",
+		 di->dbg_pwr_dsoc, di->dbg_pwr_rsoc, di->dbg_pwr_vol,
+		 di->is_halt, di->halt_cnt, di->is_max_soc_offset,
+		 di->is_initialized, di->is_sw_reset, di->is_ocv_calib,
+		 di->dbg_cap_low0, di->is_force_calib);
+
+	/* system poweroff condition */
+	if (((di->remain_cap < 40) ||
+		(di->voltage_avg < di->pdata->pwroff_vol)) &&
+			(status == 0))
+		rk_send_power_key(1);
+}
+
+static u8 rk818_bat_check_reboot(struct rk818_battery *di)
+{
+	u8 cnt;
+
+	cnt = rk818_bat_read(di, RK818_REBOOT_CNT_REG);
+	cnt++;
+
+	if (cnt >= REBOOT_MAX_CNT) {
+		BAT_INFO("reboot: %d --> %d\n", di->dsoc, di->rsoc);
+		di->dsoc = di->rsoc;
+		if (di->dsoc > 100)
+			di->dsoc = 100;
+		else if (di->dsoc < 0)
+			di->dsoc = 0;
+		rk818_bat_save_dsoc(di, di->dsoc);
+		cnt = REBOOT_MAX_CNT;
+	}
+
+	rk818_bat_save_reboot_cnt(di, cnt);
+	DBG("reboot cnt: %d\n", cnt);
+
+	return cnt;
+}
+
+static void rk818_bat_rsoc_daemon(struct rk818_battery *di)
+{
+	int est_vol, remain_cap;
+	static unsigned long sec;
+
+	if ((di->remain_cap < 0) && (di->fb_blank != 0)) {
+		if (!sec)
+			sec = get_boot_sec();
+
+		DBG("sec=%ld, hold_sec=%ld\n", sec, base2sec(sec));
+		if (base2sec(sec) >= 60) {
+			sec = 0;
+			di->dbg_cap_low0++;
+			est_vol = di->voltage_avg -
+					(di->bat_res * di->current_avg) / 1000;
+			remain_cap = rk818_bat_vol_to_ocvcap(di, est_vol);
+			rk818_bat_init_capacity(di, remain_cap);
+			BAT_INFO("adjust cap below 0 --> %d, rsoc=%d\n",
+				 di->remain_cap, di->rsoc);
+		}
+	} else {
+		sec = 0;
+	}
+}
+
+static void rk818_bat_update_info(struct rk818_battery *di)
+{
+	int is_charging;
+
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->chrg_status = rk818_bat_get_chrg_status(di);
+	is_charging = rk818_bat_get_charge_state(di);
+	if (is_charging != di->is_charging) {
+		di->is_charging = is_charging;
+		if (is_charging)
+			di->charge_count++;
+	}
+	if (di->voltage_avg > di->voltage_max)
+		di->voltage_max = di->voltage_avg;
+	if (di->current_avg > di->current_max)
+		di->current_max = di->current_avg;
+
+	/* smooth charge */
+	if (di->remain_cap > di->fcc) {
+		di->sm_remain_cap -= (di->remain_cap - di->fcc);
+		DBG("<%s>. cap: remain=%d, sm_remain=%d\n",
+		    __func__, di->remain_cap, di->sm_remain_cap);
+		rk818_bat_init_coulomb_cap(di, di->fcc);
+	}
+
+	if (di->chrg_status != CHARGE_FINISH)
+		di->finish_base = get_boot_sec();
+
+	/*
+	 * we need update fcc in continuous charging state, if discharge state
+	 * keep at least 2 hour, we decide not to update fcc, so clear the
+	 * fcc update flag: age_allow_update.
+	 */
+	if (base2min(di->plug_out_base) > 120)
+		di->age_allow_update = false;
+
+	/* do adc calib: status must from cccv mode to finish mode */
+	if (di->chrg_status == CC_OR_CV) {
+		di->adc_allow_update = true;
+		di->adc_calib_cnt = 0;
+	}
+}
+
+static void rk818_bat_init_ts1_detect(struct rk818_battery *di)
+{
+	u8 buf;
+	u32 *ntc_table = di->pdata->ntc_table;
+
+	if (!di->pdata->ntc_size)
+		return;
+
+	/* select ua */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf &= ~TS1_CUR_MSK;
+	/* chose suitable UA for temperature detect */
+	if (ntc_table[0] < NTC_80UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_80UA;
+		di->pdata->ntc_uA = 80;
+		buf |= ADC_CUR_80UA;
+	} else if (ntc_table[0] < NTC_60UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_60UA;
+		di->pdata->ntc_uA = 60;
+		buf |= ADC_CUR_60UA;
+	} else if (ntc_table[0] < NTC_40UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_40UA;
+		di->pdata->ntc_uA = 40;
+		buf |= ADC_CUR_40UA;
+	} else {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_20UA;
+		di->pdata->ntc_uA = 20;
+		buf |= ADC_CUR_20UA;
+	}
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+
+	/* enable ADC_TS1_EN */
+	buf = rk818_bat_read(di, RK818_ADC_CTRL_REG);
+	buf |= ADC_TS1_EN;
+	rk818_bat_write(di, RK818_ADC_CTRL_REG, buf);
+}
+
+/*
+ * Due to hardware design issue, Vdelta = "(R_sample + R_other) * I_avg" will be
+ * included into TS1 adc value. We must subtract it to get correct adc value.
+ * The solution:
+ *
+ * (1) calculate Vdelta:
+ *
+ *   adc1 - Vdelta    ua1			  (adc2 * ua1) - (adc1 * ua2)
+ *   ------------- = -----  ==> equals: Vdelta = -----------------------------
+ *   adc2 - Vdelta    ua2				ua1 - ua2
+ *
+ *
+ * (2) calculate correct ADC value:
+ *
+ *     charging: ADC = adc1 - abs(Vdelta);
+ *  discharging: ADC = adc1 + abs(Vdelta);
+ */
+static int rk818_bat_get_ntc_res(struct rk818_battery *di)
+{
+	int adc1 = 0, adc2 = 0;
+	int ua1, ua2, v_delta, res, val;
+	u8 buf;
+
+	/* read sample ua1 */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	DBG("<%s>. read adc1, sample uA=%d\n",
+	    __func__, ((buf & 0x03) + 1) * 20);
+
+	/* read adc adc1 */
+	ua1 = di->pdata->ntc_uA;
+	adc1 |= rk818_bat_read(di, RK818_TS1_ADC_REGL) << 0;
+	adc1 |= rk818_bat_read(di, RK818_TS1_ADC_REGH) << 8;
+
+	/* chose reference UA for adc2 */
+	ua2 = (ua1 != 20) ? 20 : 40;
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf &= ~TS1_CUR_MSK;
+	buf |= ((ua2 - 20) / 20);
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+
+	/* read adc adc2 */
+	msleep(1000);
+
+	/* read sample ua2 */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	DBG("<%s>. read adc2, sample uA=%d\n",
+	    __func__, ((buf & 0x03) + 1) * 20);
+
+	adc2 |= rk818_bat_read(di, RK818_TS1_ADC_REGL) << 0;
+	adc2 |= rk818_bat_read(di, RK818_TS1_ADC_REGH) << 8;
+
+	DBG("<%s>. ua1=%d, ua2=%d, adc1=%d, adc2=%d\n",
+	    __func__, ua1, ua2, adc1, adc2);
+
+	/* calculate delta voltage */
+	if (adc2 != adc1)
+		v_delta = abs((adc2 * ua1 - adc1 * ua2) / (ua2 - ua1));
+	else
+		v_delta = 0;
+
+	/* considering current avg direction, calcuate real adc value */
+	val = (di->current_avg >= 0) ? (adc1 - v_delta) : (adc1 + v_delta);
+
+	DBG("<%s>. Iavg=%d, Vdelta=%d, Vadc=%d\n",
+	    __func__, di->current_avg, v_delta, val);
+
+	res = val * di->pdata->ntc_factor;
+
+	DBG("<%s>. val=%d, ntc_res=%d, ntc_factor=%d, Rdelta=%d\n",
+	    __func__, val, res, di->pdata->ntc_factor,
+	    v_delta * di->pdata->ntc_factor);
+
+	DBG("<%s>. t=[%d'C(%d) ~ %dC(%d)]\n", __func__,
+	    di->pdata->ntc_degree_from, di->pdata->ntc_table[0],
+	    di->pdata->ntc_degree_from + di->pdata->ntc_size - 1,
+	    di->pdata->ntc_table[di->pdata->ntc_size - 1]);
+
+	rk818_bat_init_ts1_detect(di);
+
+	return res;
+}
+
+static void rk818_bat_set_input_current(struct rk818_battery *di,
+					int input_current)
+{
+	u8 usb_ctrl;
+
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	usb_ctrl &= ~0x0f;
+	usb_ctrl |= (input_current);
+	rk818_bat_write(di, RK818_USB_CTRL_REG, usb_ctrl);
+}
+
+static BLOCKING_NOTIFIER_HEAD(rk818_bat_notifier_chain);
+
+int rk818_bat_temp_notifier_register(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&rk818_bat_notifier_chain, nb);
+}
+EXPORT_SYMBOL_GPL(rk818_bat_temp_notifier_register);
+
+int rk818_bat_temp_notifier_unregister(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&rk818_bat_notifier_chain, nb);
+}
+EXPORT_SYMBOL_GPL(rk818_bat_temp_notifier_unregister);
+
+static void rk818_bat_temp_notifier_callback(int temp)
+{
+	blocking_notifier_call_chain(&rk818_bat_notifier_chain, temp, NULL);
+}
+
+static void rk818_bat_update_temperature(struct rk818_battery *di)
+{
+	static int old_temp, first_time = 1;
+	u32 ntc_size, *ntc_table;
+	int i, res, temp;
+
+	ntc_table = di->pdata->ntc_table;
+	ntc_size = di->pdata->ntc_size;
+	di->temperature = VIRTUAL_TEMPERATURE;
+
+	if (ntc_size) {
+		res = rk818_bat_get_ntc_res(di);
+		if (res < ntc_table[ntc_size - 1]) {
+			di->temperature = di->pdata->ntc_degree_from +
+					  di->pdata->ntc_size - 1;
+			if (di->pdata->bat_mode != MODE_VIRTUAL)
+				rk818_bat_set_input_current(di, INPUT_CUR80MA);
+			BAT_INFO("bat ntc upper max degree: R=%d\n", res);
+		} else if (res > ntc_table[0]) {
+			di->temperature = di->pdata->ntc_degree_from;
+			if (di->pdata->bat_mode != MODE_VIRTUAL)
+				rk818_bat_set_input_current(di, INPUT_CUR80MA);
+			BAT_INFO("bat ntc lower min degree: R=%d\n", res);
+		} else {
+			for (i = 0; i < ntc_size; i++) {
+				if (res >= ntc_table[i])
+					break;
+			}
+
+			/* if first in, init old_temp */
+			temp = (i + di->pdata->ntc_degree_from) * 10;
+			if (first_time == 1) {
+				di->temperature = temp;
+				old_temp = temp;
+				first_time = 0;
+			}
+
+			/*
+			 * compare with old one, it's invalid when over 50
+			 * and we should use old data.
+			 */
+			if (abs(temp - old_temp) > 50)
+				temp = old_temp;
+			else
+				old_temp = temp;
+
+			di->temperature = temp;
+			DBG("<%s>. temperature = %d\n",
+			    __func__, di->temperature);
+			rk818_bat_temp_notifier_callback(di->temperature / 10);
+		}
+	}
+}
+
+static void rk818_bat_init_dsoc_algorithm(struct rk818_battery *di)
+{
+	u8 buf;
+	int16_t rest = 0;
+	unsigned long soc_sec;
+	const char *mode_name[] = { "MODE_ZERO", "MODE_FINISH",
+		"MODE_SMOOTH_CHRG", "MODE_SMOOTH_DISCHRG", "MODE_SMOOTH", };
+
+	/* get rest */
+	rest |= rk818_bat_read(di, RK818_CALC_REST_REGH) << 8;
+	rest |= rk818_bat_read(di, RK818_CALC_REST_REGL) << 0;
+
+	/* get mode */
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	di->algo_rest_mode = (buf & ALGO_REST_MODE_MSK) >> ALGO_REST_MODE_SHIFT;
+
+	if (rk818_bat_get_chrg_status(di) == CHARGE_FINISH) {
+		if (di->algo_rest_mode == MODE_FINISH) {
+			soc_sec = di->fcc * 3600 / 100 / FINISH_CHRG_CUR1;
+			if ((rest / DIV(soc_sec)) > 0) {
+				if (di->dsoc < 100) {
+					di->dsoc++;
+					di->algo_rest_val = rest % soc_sec;
+					BAT_INFO("algorithm rest(%d) dsoc "
+						 "inc: %d\n",
+						 rest, di->dsoc);
+				} else {
+					di->algo_rest_val = 0;
+				}
+			} else {
+				di->algo_rest_val = rest;
+			}
+		} else {
+			di->algo_rest_val = rest;
+		}
+	} else {
+		/* charge speed up */
+		if ((rest / 1000) > 0 && rk818_bat_chrg_online(di)) {
+			if (di->dsoc < di->rsoc) {
+				di->dsoc++;
+				di->algo_rest_val = rest % 1000;
+				BAT_INFO("algorithm rest(%d) dsoc inc: %d\n",
+					 rest, di->dsoc);
+			} else {
+				di->algo_rest_val = 0;
+			}
+		/* discharge speed up */
+		} else if (((rest / 1000) < 0) && !rk818_bat_chrg_online(di)) {
+			if (di->dsoc > di->rsoc) {
+				di->dsoc--;
+				di->algo_rest_val = rest % 1000;
+				BAT_INFO("algorithm rest(%d) dsoc sub: %d\n",
+					 rest, di->dsoc);
+			} else {
+				di->algo_rest_val = 0;
+			}
+		} else {
+			di->algo_rest_val = rest;
+		}
+	}
+
+	if (di->dsoc >= 100)
+		di->dsoc = 100;
+	else if (di->dsoc <= 0)
+		di->dsoc = 0;
+
+	/* init current mode */
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	if (rk818_bat_get_chrg_status(di) == CHARGE_FINISH) {
+		rk818_bat_finish_algo_prepare(di);
+		di->work_mode = MODE_FINISH;
+	} else {
+		rk818_bat_smooth_algo_prepare(di);
+		di->work_mode = MODE_SMOOTH;
+	}
+
+	DBG("<%s>. init: org_rest=%d, rest=%d, mode=%s; "
+	    "doc(x1000): zero=%d, chrg=%d, dischrg=%d, finish=%lu\n",
+	    __func__, rest, di->algo_rest_val, mode_name[di->algo_rest_mode],
+	    di->zero_dsoc, di->sm_chrg_dsoc, di->sm_dischrg_dsoc,
+	    di->finish_base);
+}
+
+static void rk818_bat_save_algo_rest(struct rk818_battery *di)
+{
+	u8 buf, mode;
+	int16_t algo_rest = 0;
+	int tmp_soc;
+	int zero_rest = 0, sm_chrg_rest = 0;
+	int sm_dischrg_rest = 0, finish_rest = 0;
+	const char *mode_name[] = { "MODE_ZERO", "MODE_FINISH",
+		"MODE_SMOOTH_CHRG", "MODE_SMOOTH_DISCHRG", "MODE_SMOOTH", };
+
+	/* zero dischrg */
+	tmp_soc = (di->zero_dsoc) / 1000;
+	if (tmp_soc == di->dsoc)
+		zero_rest = di->zero_dsoc - ((di->dsoc + 1) * 1000 -
+				MIN_ACCURACY);
+
+	/* sm chrg */
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		sm_chrg_rest = di->sm_chrg_dsoc - di->dsoc * 1000;
+
+	/* sm dischrg */
+	tmp_soc = (di->sm_dischrg_dsoc) / 1000;
+	if (tmp_soc == di->dsoc)
+		sm_dischrg_rest = di->sm_dischrg_dsoc - ((di->dsoc + 1) * 1000 -
+				MIN_ACCURACY);
+
+	/* last time is also finish chrg, then add last rest */
+	if (di->algo_rest_mode == MODE_FINISH && di->algo_rest_val)
+		finish_rest = base2sec(di->finish_base) + di->algo_rest_val;
+	else
+		finish_rest = base2sec(di->finish_base);
+
+	/* total calc */
+	if ((rk818_bat_chrg_online(di) && (di->dsoc > di->rsoc)) ||
+	    (!rk818_bat_chrg_online(di) && (di->dsoc < di->rsoc)) ||
+	    (di->dsoc == di->rsoc)) {
+		di->algo_rest_val = 0;
+		algo_rest = 0;
+		DBG("<%s>. step1..\n", __func__);
+	} else if (di->work_mode == MODE_FINISH) {
+		algo_rest = finish_rest;
+		DBG("<%s>. step2..\n", __func__);
+	} else if (di->algo_rest_mode == MODE_FINISH) {
+		algo_rest = zero_rest + sm_dischrg_rest + sm_chrg_rest;
+		DBG("<%s>. step3..\n", __func__);
+	} else {
+		if (rk818_bat_chrg_online(di) && (di->dsoc < di->rsoc))
+			algo_rest = sm_chrg_rest + di->algo_rest_val;
+		else if (!rk818_bat_chrg_online(di) && (di->dsoc > di->rsoc))
+			algo_rest = zero_rest + sm_dischrg_rest +
+				    di->algo_rest_val;
+		else
+			algo_rest = zero_rest + sm_dischrg_rest + sm_chrg_rest +
+				    di->algo_rest_val;
+		DBG("<%s>. step4..\n", __func__);
+	}
+
+	/* check mode */
+	if ((di->work_mode == MODE_FINISH) || (di->work_mode == MODE_ZERO)) {
+		mode = di->work_mode;
+	} else {/* MODE_SMOOTH */
+		if (di->sm_linek > 0)
+			mode = MODE_SMOOTH_CHRG;
+		else
+			mode = MODE_SMOOTH_DISCHRG;
+	}
+
+	/* save mode */
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	buf &= ~ALGO_REST_MODE_MSK;
+	buf |= (mode << ALGO_REST_MODE_SHIFT);
+	rk818_bat_write(di, RK818_MISC_MARK_REG, buf);
+
+	/* save rest */
+	buf = (algo_rest >> 8) & 0xff;
+	rk818_bat_write(di, RK818_CALC_REST_REGH, buf);
+	buf = (algo_rest >> 0) & 0xff;
+	rk818_bat_write(di, RK818_CALC_REST_REGL, buf);
+
+	DBG("<%s>. rest: algo=%d, mode=%s, last_rest=%d; zero=%d, "
+	    "chrg=%d, dischrg=%d, finish=%lu\n",
+	    __func__, algo_rest, mode_name[mode], di->algo_rest_val, zero_rest,
+	    sm_chrg_rest, sm_dischrg_rest, base2sec(di->finish_base));
+}
+
+static void rk818_bat_save_data(struct rk818_battery *di)
+{
+	rk818_bat_save_dsoc(di, di->dsoc);
+	rk818_bat_save_cap(di, di->remain_cap);
+	rk818_bat_save_algo_rest(di);
+}
+
+static void rk818_battery_work(struct work_struct *work)
+{
+	struct rk818_battery *di =
+		container_of(work, struct rk818_battery, bat_delay_work.work);
+
+	rk818_bat_update_info(di);
+	rk818_bat_wait_finish_sig(di);
+	rk818_bat_rsoc_daemon(di);
+	rk818_bat_update_temperature(di);
+	rk818_bat_display_smooth(di);
+	rk818_bat_power_supply_changed(di);
+	rk818_bat_save_data(di);
+	rk818_bat_debug_info(di);
+
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(di->monitor_ms));
+}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+static irqreturn_t rk818_vb_low_irq(int irq, void *bat)
+{
+	struct rk818_battery *di = (struct rk818_battery *)bat;
+
+	di->dsoc = 0;
+	rk_send_wakeup_key();
+	BAT_INFO("lower power yet, power off system! v=%d, c=%d, dsoc=%d\n",
+		 di->voltage_avg, di->current_avg, di->dsoc);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static void rk818_bat_init_sysfs(struct rk818_battery *di)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(rk818_bat_attr); i++) {
+		ret = sysfs_create_file(&di->dev->kobj,
+					&rk818_bat_attr[i].attr);
+		if (ret)
+			dev_err(di->dev, "create bat node(%s) error\n",
+				rk818_bat_attr[i].attr.name);
+	}
+}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+static int rk818_bat_init_irqs(struct rk818_battery *di)
+{
+	struct rk808 *rk818 = di->rk818;
+	struct platform_device *pdev = di->pdev;
+	int ret, vb_lo_irq;
+
+	vb_lo_irq = regmap_irq_get_virq(rk818->irq_data, RK818_IRQ_VB_LO);
+	if (vb_lo_irq < 0) {
+		dev_err(di->dev, "vb_lo_irq request failed!\n");
+		return vb_lo_irq;
+	}
+
+	ret = devm_request_threaded_irq(di->dev, vb_lo_irq, NULL,
+					rk818_vb_low_irq,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					"rk818_vb_low", di);
+	if (ret) {
+		dev_err(&pdev->dev, "vb_lo_irq request failed!\n");
+		return ret;
+	}
+	enable_irq_wake(vb_lo_irq);
+
+	return 0;
+}
+#endif
+
+static void rk818_bat_init_info(struct rk818_battery *di)
+{
+	di->design_cap = di->pdata->design_capacity;
+	di->qmax = di->pdata->design_qmax;
+	di->bat_res = di->pdata->bat_res;
+	di->monitor_ms = di->pdata->monitor_sec * TIMER_MS_COUNTS;
+	di->boot_base = POWER_ON_SEC_BASE;
+	di->res_div = (di->pdata->sample_res == SAMPLE_RES_20MR) ?
+		       SAMPLE_RES_DIV1 : SAMPLE_RES_DIV2;
+}
+
+static time_t rk818_get_rtc_sec(void)
+{
+	int err;
+	struct rtc_time tm;
+	struct timespec tv = { .tv_nsec = NSEC_PER_SEC >> 1, };
+	struct rtc_device *rtc = rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);
+	time_t sec;
+
+	err = rtc_read_time(rtc, &tm);
+	if (err) {
+		dev_err(rtc->dev.parent, "read hardware clk failed\n");
+		return 0;
+	}
+
+	err = rtc_valid_tm(&tm);
+	if (err) {
+		dev_err(rtc->dev.parent, "invalid date time\n");
+		return 0;
+	}
+
+	rtc_tm_to_time(&tm, &tv.tv_sec);
+	sec = tv.tv_sec;
+
+	return sec;
+}
+
+static int rk818_bat_rtc_sleep_sec(struct rk818_battery *di)
+{
+	int interval_sec;
+
+	interval_sec = rk818_get_rtc_sec() - di->rtc_base;
+
+	return (interval_sec > 0) ? interval_sec : 0;
+}
+
+static void rk818_bat_set_shtd_vol(struct rk818_battery *di)
+{
+	u8 val;
+
+	/* set vbat lowest 3.0v shutdown */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= ~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK);
+	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+
+	/* disable low irq */
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1,
+			   VB_LOW_INT_EN, VB_LOW_INT_EN);
+}
+
+static void rk818_bat_init_fg(struct rk818_battery *di)
+{
+	rk818_bat_enable_gauge(di);
+	rk818_bat_init_voltage_kb(di);
+	rk818_bat_init_coffset(di);
+	rk818_bat_set_relax_sample(di);
+	rk818_bat_set_ioffset_sample(di);
+	rk818_bat_set_ocv_sample(di);
+	rk818_bat_init_ts1_detect(di);
+	rk818_bat_init_rsoc(di);
+	rk818_bat_init_coulomb_cap(di, di->nac);
+	rk818_bat_init_age_algorithm(di);
+	rk818_bat_init_chrg_config(di);
+	rk818_bat_set_shtd_vol(di);
+	rk818_bat_init_zero_table(di);
+	rk818_bat_init_caltimer(di);
+	rk818_bat_init_dsoc_algorithm(di);
+
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->voltage_ocv = rk818_bat_get_ocv_voltage(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->dbg_pwr_dsoc = di->dsoc;
+	di->dbg_pwr_rsoc = di->rsoc;
+	di->dbg_pwr_vol = di->voltage_avg;
+
+	rk818_bat_dump_regs(di, 0x99, 0xee);
+	DBG("nac=%d cap=%d ov=%d v=%d rv=%d dl=%d rl=%d c=%d\n",
+	    di->nac, di->remain_cap, di->voltage_ocv, di->voltage_avg,
+	    di->voltage_relax, di->dsoc, di->rsoc, di->current_avg);
+}
+
+#ifdef CONFIG_OF
+static int rk818_bat_parse_dt(struct rk818_battery *di)
+{
+	u32 out_value;
+	int length, ret;
+	size_t size;
+	struct device_node *np = di->dev->of_node;
+	struct battery_platform_data *pdata;
+	struct device *dev = di->dev;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	di->pdata = pdata;
+	/* init default param */
+	pdata->bat_res = DEFAULT_BAT_RES;
+	pdata->monitor_sec = DEFAULT_MONITOR_SEC;
+	pdata->pwroff_vol = DEFAULT_PWROFF_VOL_THRESD;
+	pdata->sleep_exit_current = DEFAULT_SLP_EXIT_CUR;
+	pdata->sleep_enter_current = DEFAULT_SLP_ENTER_CUR;
+	pdata->bat_mode = MODE_BATTARY;
+	pdata->max_soc_offset = DEFAULT_MAX_SOC_OFFSET;
+	pdata->sample_res = DEFAULT_SAMPLE_RES;
+	pdata->energy_mode = DEFAULT_ENERGY_MODE;
+	pdata->fb_temp = DEFAULT_FB_TEMP;
+	pdata->zero_reserve_dsoc = DEFAULT_ZERO_RESERVE_DSOC;
+
+	/* parse necessary param */
+	if (!of_find_property(np, "ocv_table", &length)) {
+		dev_err(dev, "ocv_table not found!\n");
+		return -EINVAL;
+	}
+
+	pdata->ocv_size = length / sizeof(u32);
+	if (pdata->ocv_size <= 0) {
+		dev_err(dev, "invalid ocv table\n");
+		return -EINVAL;
+	}
+
+	size = sizeof(*pdata->ocv_table) * pdata->ocv_size;
+	pdata->ocv_table = devm_kzalloc(di->dev, size, GFP_KERNEL);
+	if (!pdata->ocv_table)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "ocv_table",
+					 pdata->ocv_table,
+					 pdata->ocv_size);
+	if (ret < 0)
+		return ret;
+
+	ret = of_property_read_u32(np, "design_capacity", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "design_capacity not found!\n");
+		return ret;
+	}
+	pdata->design_capacity = out_value;
+
+	ret = of_property_read_u32(np, "design_qmax", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "design_qmax not found!\n");
+		return ret;
+	}
+	pdata->design_qmax = out_value;
+	ret = of_property_read_u32(np, "max_chrg_voltage", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "max_chrg_voltage missing!\n");
+		return ret;
+	}
+	pdata->max_chrg_voltage = out_value;
+	if (out_value >= 4300)
+		pdata->zero_algorithm_vol = DEFAULT_ALGR_VOL_THRESD2;
+	else
+		pdata->zero_algorithm_vol = DEFAULT_ALGR_VOL_THRESD1;
+
+	ret = of_property_read_u32(np, "fb_temperature", &pdata->fb_temp);
+	if (ret < 0)
+		dev_err(dev, "fb_temperature missing!\n");
+
+	ret = of_property_read_u32(np, "sample_res", &pdata->sample_res);
+	if (ret < 0)
+		dev_err(dev, "sample_res missing!\n");
+
+	ret = of_property_read_u32(np, "energy_mode", &pdata->energy_mode);
+	if (ret < 0)
+		dev_err(dev, "energy_mode missing!\n");
+
+	ret = of_property_read_u32(np, "max_soc_offset",
+				   &pdata->max_soc_offset);
+	if (ret < 0)
+		dev_err(dev, "max_soc_offset missing!\n");
+
+	ret = of_property_read_u32(np, "monitor_sec", &pdata->monitor_sec);
+	if (ret < 0)
+		dev_err(dev, "monitor_sec missing!\n");
+
+	ret = of_property_read_u32(np, "zero_algorithm_vol",
+				   &pdata->zero_algorithm_vol);
+	if (ret < 0)
+		dev_err(dev, "zero_algorithm_vol missing!\n");
+
+	ret = of_property_read_u32(np, "zero_reserve_dsoc",
+				  &pdata->zero_reserve_dsoc);
+
+	ret = of_property_read_u32(np, "virtual_power", &pdata->bat_mode);
+	if (ret < 0)
+		dev_err(dev, "virtual_power missing!\n");
+
+	ret = of_property_read_u32(np, "bat_res", &pdata->bat_res);
+	if (ret < 0)
+		dev_err(dev, "bat_res missing!\n");
+
+	ret = of_property_read_u32(np, "sleep_enter_current",
+				   &pdata->sleep_enter_current);
+	if (ret < 0)
+		dev_err(dev, "sleep_enter_current missing!\n");
+
+	ret = of_property_read_u32(np, "sleep_exit_current",
+				   &pdata->sleep_exit_current);
+	if (ret < 0)
+		dev_err(dev, "sleep_exit_current missing!\n");
+
+	ret = of_property_read_u32(np, "power_off_thresd", &pdata->pwroff_vol);
+	if (ret < 0)
+		dev_err(dev, "power_off_thresd missing!\n");
+
+	if (!of_find_property(np, "ntc_table", &length)) {
+		pdata->ntc_size = 0;
+	} else {
+		/* get ntc degree base value */
+		ret = of_property_read_s32(np, "ntc_degree_from_v2",
+					   &pdata->ntc_degree_from);
+		if (ret) {
+			dev_err(dev, "invalid ntc_degree_from_v2\n");
+			return -EINVAL;
+		}
+
+		pdata->ntc_size = length / sizeof(u32);
+	}
+
+	if (pdata->ntc_size) {
+		size = sizeof(*pdata->ntc_table) * pdata->ntc_size;
+		pdata->ntc_table = devm_kzalloc(di->dev, size, GFP_KERNEL);
+		if (!pdata->ntc_table)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(np, "ntc_table",
+						 pdata->ntc_table,
+						 pdata->ntc_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	DBG("the battery dts info dump:\n"
+	    "bat_res:%d\n"
+	    "design_capacity:%d\n"
+	    "design_qmax :%d\n"
+	    "sleep_enter_current:%d\n"
+	    "sleep_exit_current:%d\n"
+	    "zero_algorithm_vol:%d\n"
+	    "zero_reserve_dsoc:%d\n"
+	    "monitor_sec:%d\n"
+	    "max_soc_offset:%d\n"
+	    "virtual_power:%d\n"
+	    "pwroff_vol:%d\n"
+	    "sample_res:%d\n"
+	    "ntc_size=%d\n"
+	    "ntc_degree_from_v2:%d\n"
+	    "ntc_degree_to:%d\n",
+	    pdata->bat_res, pdata->design_capacity, pdata->design_qmax,
+	    pdata->sleep_enter_current, pdata->sleep_exit_current,
+	    pdata->zero_algorithm_vol, pdata->zero_reserve_dsoc,
+	    pdata->monitor_sec,
+	    pdata->max_soc_offset, pdata->bat_mode, pdata->pwroff_vol,
+	    pdata->sample_res, pdata->ntc_size, pdata->ntc_degree_from,
+	    pdata->ntc_degree_from + pdata->ntc_size - 1
+	    );
+
+	return 0;
+}
+#else
+static int rk818_bat_parse_dt(struct rk818_battery *di)
+{
+	return -ENODEV;
+}
+#endif
+
+static const struct of_device_id rk818_battery_of_match[] = {
+	{.compatible = "rk818-battery",},
+	{ },
+};
+
+static int rk818_battery_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(rk818_battery_of_match, &pdev->dev);
+	struct rk818_battery *di;
+	struct rk808 *rk818 = dev_get_drvdata(pdev->dev.parent);
+	struct i2c_client *client = rk818->i2c;
+	int ret;
+
+	if (!of_id) {
+		dev_err(&pdev->dev, "Failed to find matching dt id\n");
+		return -ENODEV;
+	}
+
+	di = devm_kzalloc(&client->dev, sizeof(*di), GFP_KERNEL);
+	if (!di)
+		return -ENOMEM;
+
+	di->rk818 = rk818;
+	di->client = client;
+	di->pdev = pdev;
+	di->dev = &pdev->dev;
+	di->regmap = rk818->regmap;
+	platform_set_drvdata(pdev, di);
+
+	ret = rk818_bat_parse_dt(di);
+	if (ret < 0) {
+		dev_err(di->dev, "rk818 battery parse dt failed!\n");
+		return ret;
+	}
+
+	if (!is_rk818_bat_exist(di)) {
+		di->pdata->bat_mode = MODE_VIRTUAL;
+		dev_err(di->dev, "no battery, virtual power mode\n");
+	}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	ret = rk818_bat_init_irqs(di);
+	if (ret != 0) {
+		dev_err(di->dev, "rk818 bat init irqs failed!\n");
+		return ret;
+	}
+#endif
+	ret = rk818_bat_init_power_supply(di);
+	if (ret) {
+		dev_err(di->dev, "rk818 power supply register failed!\n");
+		return ret;
+	}
+
+	rk818_bat_init_info(di);
+	rk818_bat_init_fg(di);
+	rk818_bat_init_sysfs(di);
+	rk818_bat_register_fb_notify(di);
+	di->bat_monitor_wq = alloc_ordered_workqueue("%s",
+			WQ_MEM_RECLAIM | WQ_FREEZABLE, "rk818-bat-monitor-wq");
+	INIT_DELAYED_WORK(&di->bat_delay_work, rk818_battery_work);
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(TIMER_MS_COUNTS * 5));
+
+	BAT_INFO("driver version %s\n", DRIVER_VERSION);
+
+	return ret;
+}
+
+static int rk818_battery_suspend(struct platform_device *dev,
+				 pm_message_t state)
+{
+	struct rk818_battery *di = platform_get_drvdata(dev);
+	u8 val, st;
+
+	cancel_delayed_work_sync(&di->bat_delay_work);
+
+	di->s2r = false;
+	di->sleep_chrg_online = rk818_bat_chrg_online(di);
+	di->sleep_chrg_status = rk818_bat_get_chrg_status(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	di->rtc_base = rk818_get_rtc_sec();
+	rk818_bat_save_data(di);
+	st = (rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK) >> 4;
+
+	/* if not CHARGE_FINISH, reinit finish_base.
+	 * avoid sleep loop between suspend and resume
+	 */
+	if (di->sleep_chrg_status != CHARGE_FINISH)
+		di->finish_base = get_boot_sec();
+
+	/* avoid: enter suspend from MODE_ZERO: load from heavy to light */
+	if ((di->work_mode == MODE_ZERO) &&
+	    (di->sleep_chrg_online) && (di->current_avg >= 0)) {
+		DBG("suspend: MODE_ZERO exit...\n");
+		/* it need't do prepare for mode finish and smooth, it will
+		 * be done in display_smooth
+		 */
+		if (di->sleep_chrg_status == CHARGE_FINISH) {
+			di->work_mode = MODE_FINISH;
+			di->finish_base = get_boot_sec();
+		} else {
+			di->work_mode = MODE_SMOOTH;
+			rk818_bat_smooth_algo_prepare(di);
+		}
+	}
+
+	/* set vbat low than 3.4v to generate a wakeup irq */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= (~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK));
+	val |= (RK818_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1, VB_LOW_INT_EN, 0);
+
+	BAT_INFO("suspend: dl=%d rl=%d c=%d v=%d cap=%d at=%ld ch=%d st=%s\n",
+		 di->dsoc, di->rsoc, di->current_avg,
+		 rk818_bat_get_avg_voltage(di), rk818_bat_get_coulomb_cap(di),
+		 di->sleep_dischrg_sec, di->sleep_chrg_online, bat_status[st]);
+
+	return 0;
+}
+
+static int rk818_battery_resume(struct platform_device *dev)
+{
+	struct rk818_battery *di = platform_get_drvdata(dev);
+	int interval_sec, time_step = 0, pwroff_vol;
+	u8 val, st;
+
+	di->s2r = true;
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	interval_sec = rk818_bat_rtc_sleep_sec(di);
+	di->sleep_sum_sec += interval_sec;
+	pwroff_vol = di->pdata->pwroff_vol;
+	st = (rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK) >> 4;
+
+	if (!di->sleep_chrg_online) {
+		/* only add up discharge sleep seconds */
+		di->sleep_dischrg_sec += interval_sec;
+		if (di->voltage_avg <= pwroff_vol + 50)
+			time_step = DISCHRG_TIME_STEP1;
+		else
+			time_step = DISCHRG_TIME_STEP2;
+	}
+
+	BAT_INFO("resume: dl=%d rl=%d c=%d v=%d rv=%d "
+		 "cap=%d dt=%d at=%ld ch=%d st=%s\n",
+		 di->dsoc, di->rsoc, di->current_avg, di->voltage_avg,
+		 di->voltage_relax, rk818_bat_get_coulomb_cap(di), interval_sec,
+		 di->sleep_dischrg_sec, di->sleep_chrg_online, bat_status[st]);
+
+	/* sleep: enough time and discharge */
+	if ((di->sleep_dischrg_sec > time_step) && (!di->sleep_chrg_online)) {
+		if (rk818_bat_sleep_dischrg(di))
+			di->sleep_dischrg_sec = 0;
+	}
+
+	rk818_bat_save_data(di);
+
+	/* set vbat lowest 3.0v shutdown */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= ~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK);
+	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1,
+			   VB_LOW_INT_EN, VB_LOW_INT_EN);
+
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(1000));
+
+	return 0;
+}
+
+static void rk818_battery_shutdown(struct platform_device *dev)
+{
+	u8 cnt = 0;
+	struct rk818_battery *di = platform_get_drvdata(dev);
+
+	cancel_delayed_work_sync(&di->bat_delay_work);
+	cancel_delayed_work_sync(&di->calib_delay_work);
+	rk818_bat_unregister_fb_notify(di);
+	del_timer(&di->caltimer);
+	if (base2sec(di->boot_base) < REBOOT_PERIOD_SEC)
+		cnt = rk818_bat_check_reboot(di);
+	else
+		rk818_bat_save_reboot_cnt(di, 0);
+
+	BAT_INFO("shutdown: dl=%d rl=%d c=%d v=%d cap=%d f=%d ch=%d n=%d "
+		 "mode=%d rest=%d\n",
+		 di->dsoc, di->rsoc, di->current_avg, di->voltage_avg,
+		 di->remain_cap, di->fcc, rk818_bat_chrg_online(di), cnt,
+		 di->algo_rest_mode, di->algo_rest_val);
+}
+
+static struct platform_driver rk818_battery_driver = {
+	.probe = rk818_battery_probe,
+	.suspend = rk818_battery_suspend,
+	.resume = rk818_battery_resume,
+	.shutdown = rk818_battery_shutdown,
+	.driver = {
+		.name = "rk818-battery",
+		.of_match_table = rk818_battery_of_match,
+	},
+};
+
+static int __init battery_init(void)
+{
+	return platform_driver_register(&rk818_battery_driver);
+}
+fs_initcall_sync(battery_init);
+
+static void __exit battery_exit(void)
+{
+	platform_driver_unregister(&rk818_battery_driver);
+}
+module_exit(battery_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rk818-battery");
+MODULE_AUTHOR("chenjh<chenjh@rock-chips.com>");
diff --git a/drivers/power/supply/rk818_battery.h b/drivers/power/supply/rk818_battery.h
new file mode 100644
index 000000000000..66cbbe9dac4c
--- /dev/null
+++ b/drivers/power/supply/rk818_battery.h
@@ -0,0 +1,168 @@
+/*
+ * rk818_battery.h: fuel gauge driver structures
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * Author: chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef RK818_BATTERY
+#define RK818_BATTERY
+
+/* RK818_INT_STS_MSK_REG2 */
+#define PLUG_IN_MSK		BIT(0)
+#define PLUG_OUT_MSK		BIT(1)
+#define CHRG_CVTLMT_INT_MSK	BIT(6)
+
+/* RK818_TS_CTRL_REG */
+#define GG_EN			BIT(7)
+#define ADC_CUR_EN		BIT(6)
+#define ADC_TS1_EN		BIT(5)
+#define ADC_TS2_EN		BIT(4)
+#define TS1_CUR_MSK		0x03
+
+/* RK818_GGCON */
+#define OCV_SAMP_MIN_MSK	0x0c
+#define OCV_SAMP_8MIN		(0x00 << 2)
+
+#define ADC_CAL_MIN_MSK		0x30
+#define ADC_CAL_8MIN		(0x00 << 4)
+#define ADC_CUR_MODE		BIT(1)
+
+/* RK818_GGSTS */
+#define BAT_CON			BIT(4)
+#define RELAX_VOL1_UPD		BIT(3)
+#define RELAX_VOL2_UPD		BIT(2)
+#define RELAX_VOL12_UPD_MSK	(RELAX_VOL1_UPD | RELAX_VOL2_UPD)
+
+/* RK818_SUP_STS_REG */
+#define CHRG_STATUS_MSK		0x70
+#define BAT_EXS			BIT(7)
+#define CHARGE_OFF		(0x0 << 4)
+#define DEAD_CHARGE		(0x1 << 4)
+#define TRICKLE_CHARGE		(0x2 << 4)
+#define CC_OR_CV		(0x3 << 4)
+#define CHARGE_FINISH		(0x4 << 4)
+#define USB_OVER_VOL		(0x5 << 4)
+#define BAT_TMP_ERR		(0x6 << 4)
+#define TIMER_ERR		(0x7 << 4)
+#define USB_VLIMIT_EN		BIT(3)
+#define USB_CLIMIT_EN		BIT(2)
+#define USB_EXIST		BIT(1)
+#define USB_EFF			BIT(0)
+
+/* RK818_USB_CTRL_REG */
+#define CHRG_CT_EN		BIT(7)
+#define FINISH_CUR_MSK		0xc0
+#define TEMP_105C		(0x02 << 2)
+#define FINISH_100MA		(0x00 << 6)
+#define FINISH_150MA		(0x01 << 6)
+#define FINISH_200MA		(0x02 << 6)
+#define FINISH_250MA		(0x03 << 6)
+
+/* RK818_CHRG_CTRL_REG3 */
+#define CHRG_TERM_MODE_MSK	BIT(5)
+#define CHRG_TERM_ANA_SIGNAL	(0 << 5)
+#define CHRG_TERM_DIG_SIGNAL	BIT(5)
+#define CHRG_TIMER_CCCV_EN	BIT(2)
+#define CHRG_EN			BIT(7)
+
+/* RK818_VB_MON_REG */
+#define	RK818_VBAT_LOW_3V0      0x02
+#define	RK818_VBAT_LOW_3V4      0x06
+#define PLUG_IN_STS		BIT(6)
+
+/* RK818_THERMAL_REG */
+#define FB_TEMP_MSK		0x0c
+#define HOTDIE_STS		BIT(1)
+
+/* RK818_INT_STS_MSK_REG1 */
+#define VB_LOW_INT_EN		BIT(1)
+
+/* RK818_MISC_MARK_REG */
+#define FG_INIT			BIT(5)
+#define FG_RESET_LATE		BIT(4)
+#define FG_RESET_NOW		BIT(3)
+#define ALGO_REST_MODE_MSK	(0xc0)
+#define ALGO_REST_MODE_SHIFT	6
+
+/* bit shift */
+#define FB_TEMP_SHIFT		2
+
+/* parse ocv table param */
+#define TIMER_MS_COUNTS		1000
+#define MAX_PERCENTAGE		100
+#define MAX_INTERPOLATE		1000
+#define MAX_INT			0x7FFF
+
+#define DRIVER_VERSION		"7.1"
+
+struct battery_platform_data {
+	u32 *ocv_table;
+	u32 *zero_table;
+	u32 *ntc_table;
+	u32 ocv_size;
+	u32 max_chrg_voltage;
+	u32 ntc_size;
+	int ntc_degree_from;
+	u32 pwroff_vol;
+	u32 monitor_sec;
+	u32 zero_algorithm_vol;
+	u32 zero_reserve_dsoc;
+	u32 bat_res;
+	u32 design_capacity;
+	u32 design_qmax;
+	u32 sleep_enter_current;
+	u32 sleep_exit_current;
+	u32 max_soc_offset;
+	u32 sample_res;
+	u32 bat_mode;
+	u32 fb_temp;
+	u32 energy_mode;
+	u32 cccv_hour;
+	u32 ntc_uA;
+	u32 ntc_factor;
+};
+
+enum work_mode {
+	MODE_ZERO = 0,
+	MODE_FINISH,
+	MODE_SMOOTH_CHRG,
+	MODE_SMOOTH_DISCHRG,
+	MODE_SMOOTH,
+};
+
+enum bat_mode {
+	MODE_BATTARY = 0,
+	MODE_VIRTUAL,
+};
+
+static const u16 feedback_temp_array[] = {
+	85, 95, 105, 115
+};
+
+static const u16 chrg_vol_sel_array[] = {
+	4050, 4100, 4150, 4200, 4250, 4300, 4350
+};
+
+static const u16 chrg_cur_sel_array[] = {
+	1000, 1200, 1400, 1600, 1800, 2000, 2250, 2400, 2600, 2800, 3000
+};
+
+static const u16 chrg_cur_input_array[] = {
+	450, 80, 850, 1000, 1250, 1500, 1750, 2000, 2250, 2500, 2750, 3000
+};
+
+void kernel_power_off(void);
+int rk818_bat_temp_notifier_register(struct notifier_block *nb);
+int rk818_bat_temp_notifier_unregister(struct notifier_block *nb);
+
+#endif
diff --git a/drivers/power/supply/rk818_charger.c b/drivers/power/supply/rk818_charger.c
new file mode 100644
index 000000000000..3935fbea58e6
--- /dev/null
+++ b/drivers/power/supply/rk818_charger.c
@@ -0,0 +1,1992 @@
+/*
+ * rk818 charger driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/extcon.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/power/rk_usbbc.h>
+#include <linux/regmap.h>
+#include <linux/rk_keys.h>
+#include <linux/rtc.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include "rk818_battery.h"
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+#include <linux/amlogic/usbtype.h>
+#include <linux/platform_data/board_odroid.h>
+#endif
+
+static int dbg_enable = 0;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define CG_INFO(fmt, args...) pr_info("rk818-charger: "fmt, ##args)
+
+#define DEFAULT_CHRG_CURRENT	1400
+#define DEFAULT_INPUT_CURRENT	2000
+#define DEFAULT_CHRG_VOLTAGE	4200
+#define SAMPLE_RES_10MR		10
+#define SAMPLE_RES_20MR		20
+#define SAMPLE_RES_DIV1		1
+#define SAMPLE_RES_DIV2		2
+
+/* RK818_USB_CTRL_REG */
+#define INPUT_CUR450MA		(0x00)
+#define INPUT_CUR80MA		(0x01)
+#define INPUT_CUR850MA		(0x02)
+#define INPUT_CUR1500MA		(0x05)
+#define INPUT_CUR_MSK		(0x0f)
+/* RK818_CHRG_CTRL_REG3 */
+#define CHRG_FINISH_MODE_MSK	BIT(5)
+#define CHRG_FINISH_ANA_SIGNAL	(0)
+#define CHRG_FINISH_DIG_SIGNAL	BIT(5)
+/* RK818_SUP_STS_REG */
+#define BAT_EXS			BIT(7)
+#define USB_VLIMIT_EN		BIT(3)
+#define USB_CLIMIT_EN		BIT(2)
+/* RK818_CHRG_CTRL_REG1 */
+#define CHRG_EN			BIT(7)
+#define CHRG_CUR_MSK		(0x0f)
+/* RK818_INT_STS_MSK_REG2 */
+#define CHRG_CVTLMT_INT_MSK	BIT(6)
+#define PLUG_OUT_MSK		BIT(1)
+#define PLUG_IN_MSK		BIT(0)
+/* RK818_VB_MON_REG */
+#define PLUG_IN_STS		BIT(6)
+/* RK818_TS_CTRL_REG */
+#define GG_EN			BIT(7)
+#define TS2_FUN_ADC		BIT(5)
+/* RK818_ADC_CTRL_REG */
+#define ADC_TS2_EN		BIT(4)
+
+#define CG_DRIVER_VERSION		"2.0"
+
+#define DEFAULT_TS2_THRESHOLD_VOL      4350
+#define DEFAULT_TS2_VALID_VOL          1000
+#define DEFAULT_TS2_VOL_MULTI          0
+#define DEFAULT_TS2_CHECK_CNT          5
+
+enum charger_t {
+	USB_TYPE_UNKNOWN_CHARGER,
+	USB_TYPE_NONE_CHARGER,
+	USB_TYPE_USB_CHARGER,
+	USB_TYPE_AC_CHARGER,
+	USB_TYPE_CDP_CHARGER,
+	DC_TYPE_DC_CHARGER,
+	DC_TYPE_NONE_CHARGER,
+};
+
+enum {
+	OFFLINE = 0,
+	ONLINE
+};
+
+struct temp_chrg_table {
+	int temp_down;
+	int temp_up;
+	u32 chrg_current;
+	u8 set_chrg_current;
+};
+
+struct charger_platform_data {
+	u32 max_input_current;
+	u32 max_chrg_current;
+	u32 max_chrg_voltage;
+	u32 pwroff_vol;
+	u32 power_dc2otg;
+	u32 dc_det_level;
+	int dc_det_pin;
+	bool support_dc_det;
+	int virtual_power;
+	int sample_res;
+	int otg5v_suspend_enable;
+	bool extcon;
+	int ts2_vol_multi;
+	struct temp_chrg_table *tc_table;
+	u32 tc_count;
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	int chg_led_pin;
+	bool chg_led_on;
+#endif
+};
+
+struct rk818_charger {
+	struct platform_device *pdev;
+	struct device *dev;
+	struct rk808 *rk818;
+	struct regmap *regmap;
+	struct power_supply *ac_psy;
+	struct power_supply *usb_psy;
+	struct power_supply *bat_psy;
+	struct extcon_dev *cable_edev;
+	struct charger_platform_data *pdata;
+	struct workqueue_struct *usb_charger_wq;
+	struct workqueue_struct *dc_charger_wq;
+	struct workqueue_struct *finish_sig_wq;
+	struct workqueue_struct *ts2_wq;
+	struct delayed_work dc_work;
+	struct delayed_work usb_work;
+	struct delayed_work host_work;
+	struct delayed_work discnt_work;
+	struct delayed_work finish_sig_work;
+	struct delayed_work irq_work;
+	struct delayed_work ts2_vol_work;
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	struct workqueue_struct *led_wq;
+	struct delayed_work led_work;
+#endif
+	struct notifier_block bc_nb;
+	struct notifier_block cable_cg_nb;
+	struct notifier_block cable_host_nb;
+	struct notifier_block cable_discnt_nb;
+	struct notifier_block temp_nb;
+	unsigned int bc_event;
+	enum charger_t usb_charger;
+	enum charger_t dc_charger;
+	struct regulator *otg5v_rdev;
+	u8 ac_in;
+	u8 usb_in;
+	u8 otg_in;	/* OTG device attached status */
+	u8 otg_pmic5v;	/* OTG device power supply from PMIC */
+	u8 dc_in;
+	u8 prop_status;
+	u8 chrg_voltage;
+	u8 chrg_input;
+	u8 chrg_current;
+	u8 res_div;
+	u8 sleep_set_off_reg1;
+	u8 plugin_trigger;
+	u8 plugout_trigger;
+	int plugin_irq;
+	int plugout_irq;
+	int charger_changed;
+};
+
+static int rk818_reg_read(struct rk818_charger *cg, u8 reg)
+{
+	int ret, val;
+
+	ret = regmap_read(cg->regmap, reg, &val);
+	if (ret)
+		dev_err(cg->dev, "i2c read reg: 0x%2x failed\n", reg);
+
+	return val;
+}
+
+static int rk818_reg_write(struct rk818_charger *cg, u8 reg, u8 buf)
+{
+	int ret;
+
+	ret = regmap_write(cg->regmap, reg, buf);
+	if (ret)
+		dev_err(cg->dev, "i2c write reg: 0x%2x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_reg_set_bits(struct rk818_charger *cg, u8 reg, u8 mask, u8 buf)
+{
+	int ret;
+
+	ret = regmap_update_bits(cg->regmap, reg, mask, buf);
+	if (ret)
+		dev_err(cg->dev, "i2c set reg: 0x%2x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_reg_clear_bits(struct rk818_charger *cg, u8 reg, u8 mask)
+{
+	int ret;
+
+	ret = regmap_update_bits(cg->regmap, reg, mask, 0);
+	if (ret)
+		dev_err(cg->dev, "i2c clr reg: 0x%02x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_cg_online(struct rk818_charger *cg)
+{
+	return (cg->ac_in | cg->usb_in | cg->dc_in);
+}
+
+static int rk818_cg_get_dsoc(struct rk818_charger *cg)
+{
+	return rk818_reg_read(cg, RK818_SOC_REG);
+}
+
+static int rk818_cg_get_avg_current(struct rk818_charger *cg)
+{
+	int cur, val = 0;
+
+	val |= rk818_reg_read(cg, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_reg_read(cg, RK818_BAT_CUR_AVG_REGH) << 8;
+
+	if (val & 0x800)
+		val -= 4096;
+	cur = val * cg->res_div * 1506 / 1000;
+
+	return cur;
+}
+
+static int rk818_cg_get_ts2_voltage(struct rk818_charger *cg)
+{
+	u32 val = 0;
+	int voltage;
+
+	val |= rk818_reg_read(cg, RK818_TS2_ADC_REGL) << 0;
+	val |= rk818_reg_read(cg, RK818_TS2_ADC_REGH) << 8;
+
+	/* refer voltage 2.2V, 12bit adc accuracy */
+	voltage = val * 2200 * cg->pdata->ts2_vol_multi / 4095;
+
+	DBG("********* ts2 adc=%d, vol=%d\n", val, voltage);
+
+	return voltage;
+}
+
+static u64 get_boot_sec(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return ts.tv_sec;
+}
+
+static int rk818_cg_lowpwr_check(struct rk818_charger *cg)
+{
+	u8 buf;
+	static u64 time;
+	int current_avg, dsoc, fake_offline = 0;
+
+	buf = rk818_reg_read(cg, RK818_TS_CTRL_REG);
+	if (!(buf & GG_EN))
+		return fake_offline;
+
+	dsoc = rk818_cg_get_dsoc(cg);
+	current_avg = rk818_cg_get_avg_current(cg);
+	if ((current_avg < 0) && (dsoc == 0)) {
+		if (!time)
+			time = get_boot_sec();
+		if ((get_boot_sec() - time) >= 30) {
+			fake_offline = 1;
+			CG_INFO("low power....soc=%d, current=%d\n",
+				dsoc, current_avg);
+		}
+	} else {
+		time = 0;
+		fake_offline = 0;
+	}
+
+	DBG("<%s>. t=%lld, dsoc=%d, current=%d, fake_offline=%d\n",
+	    __func__, get_boot_sec() - time, dsoc, current_avg, fake_offline);
+
+	return fake_offline;
+}
+
+static int rk818_cg_get_bat_psy(struct device *dev, void *data)
+{
+	struct rk818_charger *cg = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_BATTERY) {
+		cg->bat_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void rk818_cg_get_psy(struct rk818_charger *cg)
+{
+	if (!cg->bat_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)cg,
+				      rk818_cg_get_bat_psy);
+}
+
+static int rk818_cg_get_bat_max_cur(struct rk818_charger *cg)
+{
+	union power_supply_propval val;
+	int ret;
+
+	rk818_cg_get_psy(cg);
+
+	if (!cg->bat_psy)
+		return cg->pdata->max_chrg_current;
+
+	ret = cg->bat_psy->desc->get_property(cg->bat_psy,
+					      POWER_SUPPLY_PROP_CURRENT_MAX,
+					      &val);
+	if (!ret && val.intval)
+		return val.intval;
+
+	return cg->pdata->max_chrg_current;
+}
+
+static int rk818_cg_get_bat_max_vol(struct rk818_charger *cg)
+{
+	union power_supply_propval val;
+	int ret;
+
+	rk818_cg_get_psy(cg);
+
+	if (!cg->bat_psy)
+		return cg->pdata->max_chrg_voltage;
+
+	ret = cg->bat_psy->desc->get_property(cg->bat_psy,
+					      POWER_SUPPLY_PROP_VOLTAGE_MAX,
+					      &val);
+	if (!ret && val.intval)
+		return val.intval;
+
+	return cg->pdata->max_chrg_voltage;
+}
+
+static enum power_supply_property rk818_ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+static enum power_supply_property rk818_usb_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+static int rk818_cg_ac_get_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    union power_supply_propval *val)
+{
+	struct rk818_charger *cg = power_supply_get_drvdata(psy);
+	int fake_offline = 0, ret = 0;
+
+	if (rk818_cg_online(cg))
+		fake_offline = rk818_cg_lowpwr_check(cg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (cg->pdata->virtual_power)
+			val->intval = 1;
+		else if (fake_offline)
+			val->intval = 0;
+		else
+			val->intval = (cg->ac_in | cg->dc_in);
+
+		DBG("report online: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		if (cg->pdata->virtual_power)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (fake_offline)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			val->intval = cg->prop_status;
+
+		DBG("report prop: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = rk818_cg_get_bat_max_vol(cg);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = rk818_cg_get_bat_max_cur(cg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rk818_cg_usb_get_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     union power_supply_propval *val)
+{
+	struct rk818_charger *cg = power_supply_get_drvdata(psy);
+	int fake_offline = 0, ret = 0;
+
+	if (rk818_cg_online(cg))
+		fake_offline = rk818_cg_lowpwr_check(cg);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (cg->pdata->virtual_power)
+			val->intval = 1;
+		else if (fake_offline)
+			val->intval = 0;
+		else
+			val->intval = cg->usb_in;
+
+		DBG("report online: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		if (cg->pdata->virtual_power)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (fake_offline)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			val->intval = cg->prop_status;
+
+		DBG("report prop: %d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = rk818_cg_get_bat_max_vol(cg);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = rk818_cg_get_bat_max_cur(cg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct power_supply_desc rk818_ac_desc = {
+	.name		= "ac",
+	.type		= POWER_SUPPLY_TYPE_MAINS,
+	.properties	= rk818_ac_props,
+	.num_properties	= ARRAY_SIZE(rk818_ac_props),
+	.get_property	= rk818_cg_ac_get_property,
+};
+
+static const struct power_supply_desc rk818_usb_desc = {
+	.name		= "usb",
+	.type		= POWER_SUPPLY_TYPE_USB,
+	.properties	= rk818_usb_props,
+	.num_properties	= ARRAY_SIZE(rk818_usb_props),
+	.get_property	= rk818_cg_usb_get_property,
+};
+
+static int rk818_cg_init_power_supply(struct rk818_charger *cg)
+{
+	struct power_supply_config psy_cfg = { .drv_data = cg, };
+
+	cg->usb_psy = devm_power_supply_register(cg->dev, &rk818_usb_desc,
+						 &psy_cfg);
+	if (IS_ERR(cg->usb_psy)) {
+		dev_err(cg->dev, "register usb power supply fail\n");
+		return PTR_ERR(cg->usb_psy);
+	}
+
+	cg->ac_psy = devm_power_supply_register(cg->dev, &rk818_ac_desc,
+						&psy_cfg);
+	if (IS_ERR(cg->ac_psy)) {
+		dev_err(cg->dev, "register ac power supply fail\n");
+		return PTR_ERR(cg->ac_psy);
+	}
+
+	return 0;
+}
+
+static void rk818_cg_pr_info(struct rk818_charger *cg)
+{
+	u8 usb_ctrl, chrg_ctrl1;
+
+	usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+	chrg_ctrl1 = rk818_reg_read(cg, RK818_CHRG_CTRL_REG1);
+	CG_INFO("ac=%d usb=%d dc=%d otg=%d 5v=%d, v=%d chrg=%d input=%d virt=%d\n",
+		cg->ac_in, cg->usb_in, cg->dc_in, cg->otg_in, cg->otg_pmic5v,
+		chrg_vol_sel_array[(chrg_ctrl1 & 0x70) >> 4],
+		chrg_cur_sel_array[chrg_ctrl1 & 0x0f] * cg->res_div,
+		chrg_cur_input_array[usb_ctrl & 0x0f],
+		cg->pdata->virtual_power);
+}
+
+static bool is_battery_exist(struct rk818_charger *cg)
+{
+	return (rk818_reg_read(cg, RK818_SUP_STS_REG) & BAT_EXS) ? true : false;
+}
+
+static void rk818_cg_set_chrg_current(struct rk818_charger *cg,
+				      u8 chrg_current)
+{
+	u8 chrg_ctrl_reg1;
+
+	chrg_ctrl_reg1 = rk818_reg_read(cg, RK818_CHRG_CTRL_REG1);
+	chrg_ctrl_reg1 &= ~CHRG_CUR_MSK;
+	chrg_ctrl_reg1 |= (chrg_current);
+	rk818_reg_write(cg, RK818_CHRG_CTRL_REG1, chrg_ctrl_reg1);
+}
+
+static void rk818_cg_set_input_current(struct rk818_charger *cg,
+				       int input_current)
+{
+	u8 usb_ctrl;
+
+	if (cg->pdata->virtual_power) {
+		CG_INFO("warning: virtual power mode...\n");
+		input_current = cg->chrg_input;
+	}
+
+	usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+	usb_ctrl &= ~INPUT_CUR_MSK;
+	usb_ctrl |= (input_current);
+	rk818_reg_write(cg, RK818_USB_CTRL_REG, usb_ctrl);
+}
+
+static void rk818_cg_set_finish_sig(struct rk818_charger *cg, int mode)
+{
+	u8 buf;
+
+	buf = rk818_reg_read(cg, RK818_CHRG_CTRL_REG3);
+	buf &= ~CHRG_FINISH_MODE_MSK;
+	buf |= mode;
+	rk818_reg_write(cg, RK818_CHRG_CTRL_REG3, buf);
+}
+
+static void rk818_cg_finish_sig_work(struct work_struct *work)
+{
+	struct rk818_charger *cg;
+
+	cg = container_of(work, struct rk818_charger, finish_sig_work.work);
+	if (rk818_cg_online(cg))
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_DIG_SIGNAL);
+	else
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_ANA_SIGNAL);
+}
+
+static void rk818_cg_set_chrg_param(struct rk818_charger *cg,
+				    enum charger_t charger)
+{
+	u8 buf;
+
+	switch (charger) {
+	case USB_TYPE_NONE_CHARGER:
+		cg->usb_in = 0;
+		cg->ac_in = 0;
+		if (cg->dc_in == 0) {
+			cg->prop_status = POWER_SUPPLY_STATUS_DISCHARGING;
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case USB_TYPE_USB_CHARGER:
+		cg->usb_in = 1;
+		cg->ac_in = 0;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (cg->dc_in == 0) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case USB_TYPE_CDP_CHARGER:
+		cg->usb_in = 1;
+		cg->ac_in = 0;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (cg->dc_in == 0) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR1500MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case USB_TYPE_AC_CHARGER:
+		cg->ac_in = 1;
+		cg->usb_in = 0;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (charger == USB_TYPE_AC_CHARGER) {
+			if (cg->pdata->ts2_vol_multi) {
+				rk818_cg_set_chrg_current(cg, cg->chrg_current);
+				rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+				queue_delayed_work(cg->ts2_wq,
+						   &cg->ts2_vol_work,
+						   msecs_to_jiffies(0));
+			} else {
+				rk818_cg_set_chrg_current(cg, cg->chrg_current);
+				rk818_cg_set_input_current(cg, cg->chrg_input);
+			}
+		} else {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR1500MA);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case DC_TYPE_DC_CHARGER:
+		cg->dc_in = 1;
+		cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		if (cg->pdata->ts2_vol_multi) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+			queue_delayed_work(cg->ts2_wq,
+					   &cg->ts2_vol_work,
+					   msecs_to_jiffies(0));
+		} else {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, cg->chrg_input);
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	case DC_TYPE_NONE_CHARGER:
+		cg->dc_in = 0;
+		buf = rk818_reg_read(cg, RK818_VB_MON_REG);
+		if ((buf & PLUG_IN_STS) == 0) {
+			cg->ac_in = 0;
+			cg->usb_in = 0;
+			cg->prop_status = POWER_SUPPLY_STATUS_DISCHARGING;
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		} else if (cg->usb_in) {
+			rk818_cg_set_chrg_current(cg, cg->chrg_current);
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+			cg->prop_status = POWER_SUPPLY_STATUS_CHARGING;
+		}
+		power_supply_changed(cg->usb_psy);
+		power_supply_changed(cg->ac_psy);
+		break;
+	default:
+		cg->prop_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	}
+
+	cg->charger_changed = 1;
+
+	if (rk818_cg_online(cg) && rk818_cg_get_dsoc(cg) == 100)
+		cg->prop_status = POWER_SUPPLY_STATUS_FULL;
+
+	if (cg->finish_sig_wq)
+		queue_delayed_work(cg->finish_sig_wq, &cg->finish_sig_work,
+				   msecs_to_jiffies(1000));
+}
+
+static void rk818_cg_set_otg_in(struct rk818_charger *cg, int online)
+{
+	cg->otg_in = online;
+}
+
+static void rk818_cg_set_otg_power(struct rk818_charger *cg, int state)
+{
+	int ret;
+
+	switch (state) {
+	case USB_OTG_POWER_ON:
+		if (cg->otg_pmic5v) {
+			CG_INFO("otg5v is on yet, ignore..\n");
+		} else {
+			if (IS_ERR(cg->otg5v_rdev)) {
+				CG_INFO("not get otg_switch regulator!\n");
+				return;
+			}
+
+			if (!regulator_is_enabled(cg->otg5v_rdev)) {
+				ret = regulator_enable(cg->otg5v_rdev);
+				if (ret) {
+					CG_INFO("enable otg5v failed:%d\n",
+						ret);
+					return;
+				}
+			}
+			cg->otg_pmic5v = 1;
+			disable_irq(cg->plugin_irq);
+			disable_irq(cg->plugout_irq);
+			CG_INFO("enable otg5v\n");
+		}
+		break;
+
+	case USB_OTG_POWER_OFF:
+		if (!cg->otg_pmic5v) {
+			CG_INFO("otg5v is off yet, ignore..\n");
+		} else {
+			if (IS_ERR(cg->otg5v_rdev)) {
+				CG_INFO("not get otg_switch regulator!\n");
+				return;
+			}
+
+			if (regulator_is_enabled(cg->otg5v_rdev)) {
+				ret = regulator_disable(cg->otg5v_rdev);
+				if (ret) {
+					CG_INFO("disable otg5v failed: %d\n",
+						ret);
+					return;
+				}
+			}
+			cg->otg_pmic5v = 0;
+			enable_irq(cg->plugin_irq);
+			enable_irq(cg->plugout_irq);
+			CG_INFO("disable otg5v\n");
+		}
+		break;
+	default:
+		dev_err(cg->dev, "error otg type\n");
+		break;
+	}
+}
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+static void rk818_cg_led_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, led_work.work);
+
+	/* battery status check */
+	if (rk818_cg_online(cg)) {
+		if (cg->prop_status == POWER_SUPPLY_STATUS_CHARGING)
+			gpio_set_value(cg->pdata->chg_led_pin,
+					!gpio_get_value(cg->pdata->chg_led_pin));
+		else
+			gpio_set_value(cg->pdata->chg_led_pin,
+					cg->pdata->chg_led_on);
+	}
+	else
+		gpio_set_value(cg->pdata->chg_led_pin,
+				!cg->pdata->chg_led_on);
+
+	queue_delayed_work(cg->led_wq, &cg->led_work,
+		msecs_to_jiffies(1000));
+}
+#endif
+
+static enum charger_t rk818_cg_get_dc_state(struct rk818_charger *cg)
+{
+	int level;
+
+	if (!gpio_is_valid(cg->pdata->dc_det_pin))
+		return DC_TYPE_NONE_CHARGER;
+
+	level = gpio_get_value(cg->pdata->dc_det_pin);
+
+	return (level == cg->pdata->dc_det_level) ?
+		DC_TYPE_DC_CHARGER : DC_TYPE_NONE_CHARGER;
+}
+
+static void rk818_cg_dc_det_worker(struct work_struct *work)
+{
+	enum charger_t charger;
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, dc_work.work);
+
+	charger = rk818_cg_get_dc_state(cg);
+	if (charger == DC_TYPE_DC_CHARGER) {
+		//CG_INFO("detect dc charger in..\n");
+		rk818_cg_set_chrg_param(cg, DC_TYPE_DC_CHARGER);
+		/* check otg supply */
+		if (cg->otg_in && cg->pdata->power_dc2otg) {
+			CG_INFO("otg power from dc adapter\n");
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+		}
+	} else {
+		//CG_INFO("detect dc charger out..\n");
+		rk818_cg_set_chrg_param(cg, DC_TYPE_NONE_CHARGER);
+		/* check otg supply, power on anyway */
+		if (cg->otg_in)
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_ON);
+	}
+
+	rk_send_wakeup_key();
+	//rk818_cg_pr_info(cg);
+}
+
+static u8 rk818_cg_decode_chrg_vol(struct rk818_charger *cg, u32 chrg_vol)
+{
+	u8 val = 0, index;
+
+	for (index = 0; index < ARRAY_SIZE(chrg_vol_sel_array); index++) {
+		if (chrg_vol < chrg_vol_sel_array[index])
+			break;
+		val = index << 4;
+	}
+
+	return val;
+}
+
+static u8 rk818_cg_decode_input_current(struct rk818_charger *cg,
+					u32 input_current)
+{
+	u8 val = 0, index;
+
+	for (index = 2; index < ARRAY_SIZE(chrg_cur_input_array); index++) {
+		if (input_current < 850 && input_current > 80) {
+			val = 0x0;	/* 450mA */
+			break;
+		} else if (input_current <= 80) {
+			val = 0x1;	/* 80mA */
+			break;
+		} else {
+			if (input_current < chrg_cur_input_array[index])
+				break;
+			val = index <<  0;
+		}
+	}
+
+	return val;
+}
+
+static u8 rk818_cg_decode_chrg_current(struct rk818_charger *cg,
+				       u32 chrg_current)
+{
+	u8 val = 0, index;
+
+	if (cg->pdata->sample_res == SAMPLE_RES_10MR) {
+		if (chrg_current > 2000)
+			chrg_current /= cg->res_div;
+		else
+			chrg_current = 1000;
+	}
+
+	for (index = 0; index < ARRAY_SIZE(chrg_cur_sel_array); index++) {
+		if (chrg_current < chrg_cur_sel_array[index])
+			break;
+		val = index << 0;
+	}
+
+	return val;
+}
+
+static void rk818_cg_init_config(struct rk818_charger *cg)
+{
+	u8 usb_ctrl, sup_sts, chrg_ctrl1;
+
+	cg->chrg_voltage = rk818_cg_decode_chrg_vol(cg,
+				cg->pdata->max_chrg_voltage);
+	cg->chrg_current = rk818_cg_decode_chrg_current(cg,
+				cg->pdata->max_chrg_current);
+	cg->chrg_input = rk818_cg_decode_input_current(cg,
+				cg->pdata->max_input_current);
+
+	sup_sts = rk818_reg_read(cg, RK818_SUP_STS_REG);
+	usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+
+	/* set charge current and voltage */
+	usb_ctrl &= ~INPUT_CUR_MSK;
+	usb_ctrl |= cg->chrg_input;
+	chrg_ctrl1 = (CHRG_EN | cg->chrg_voltage | cg->chrg_current);
+
+	/* disable voltage limit and enable input current limit */
+	sup_sts &= ~USB_VLIMIT_EN;
+	sup_sts |= USB_CLIMIT_EN;
+
+	rk818_reg_write(cg, RK818_SUP_STS_REG, sup_sts);
+	rk818_reg_write(cg, RK818_USB_CTRL_REG, usb_ctrl);
+	rk818_reg_write(cg, RK818_CHRG_CTRL_REG1, chrg_ctrl1);
+}
+
+static void rk818_ts2_vol_work(struct work_struct *work)
+{
+	struct rk818_charger *cg;
+	int ts2_vol, input_current, invalid_cnt = 0, confirm_cnt = 0;
+
+	cg = container_of(work, struct rk818_charger, ts2_vol_work.work);
+
+	input_current = INPUT_CUR80MA;
+	while (input_current < cg->chrg_input) {
+		msleep(100);
+		ts2_vol = rk818_cg_get_ts2_voltage(cg);
+
+		/* filter invalid voltage */
+		if (ts2_vol <= DEFAULT_TS2_VALID_VOL) {
+			invalid_cnt++;
+			DBG("%s: invalid ts2 voltage: %d\n, cnt=%d",
+			    __func__, ts2_vol, invalid_cnt);
+			if (invalid_cnt < DEFAULT_TS2_CHECK_CNT)
+				continue;
+
+			/* if fail, set max input current as default */
+			input_current = cg->chrg_input;
+			rk818_cg_set_input_current(cg, input_current);
+			break;
+		}
+
+		/* update input current */
+		if (ts2_vol >= DEFAULT_TS2_THRESHOLD_VOL) {
+			/* update input current */
+			input_current++;
+			rk818_cg_set_input_current(cg, input_current);
+			DBG("********* input=%d\n",
+			    chrg_cur_input_array[input_current & 0x0f]);
+		} else {
+			/* confirm lower threshold voltage */
+			confirm_cnt++;
+			if (confirm_cnt < DEFAULT_TS2_CHECK_CNT) {
+				DBG("%s: confirm ts2 voltage: %d\n, cnt=%d",
+				    __func__, ts2_vol, confirm_cnt);
+				continue;
+			}
+
+			/* trigger threshold, so roll back 1 step */
+			input_current--;
+			if (input_current == INPUT_CUR80MA ||
+			    input_current < 0)
+				input_current = INPUT_CUR450MA;
+			rk818_cg_set_input_current(cg, input_current);
+			break;
+		}
+	}
+
+	if (input_current != cg->chrg_input)
+		CG_INFO("adjust input current: %dma\n",
+			chrg_cur_input_array[input_current & 0x0f]);
+}
+
+static int rk818_cg_charger_evt_notifier(struct notifier_block *nb,
+					 unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, cable_cg_nb);
+
+	queue_delayed_work(cg->usb_charger_wq, &cg->usb_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static int rk818_cg_discnt_evt_notfier(struct notifier_block *nb,
+				       unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, cable_discnt_nb);
+
+	queue_delayed_work(cg->usb_charger_wq, &cg->discnt_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static int rk818_cg_host_evt_notifier(struct notifier_block *nb,
+				      unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, cable_host_nb);
+
+	queue_delayed_work(cg->usb_charger_wq, &cg->host_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static int rk818_cg_bc_evt_notifier(struct notifier_block *nb,
+				    unsigned long event, void *ptr)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, bc_nb);
+
+	cg->bc_event = event;
+	queue_delayed_work(cg->usb_charger_wq, &cg->usb_work,
+			   msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+
+static void rk818_cg_bc_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+					struct rk818_charger, usb_work.work);
+	const char *event_name[] = {"DISCNT", "USB", "AC", "CDP1.5A",
+				    "UNKNOWN", "OTG ON", "OTG OFF"};
+
+	switch (cg->bc_event) {
+	case USB_BC_TYPE_DISCNT:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_NONE_CHARGER);
+		break;
+	case USB_BC_TYPE_SDP:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_USB_CHARGER);
+		break;
+	case USB_BC_TYPE_DCP:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_AC_CHARGER);
+		break;
+	case USB_BC_TYPE_CDP:
+		rk818_cg_set_chrg_param(cg, USB_TYPE_CDP_CHARGER);
+		break;
+	case USB_OTG_POWER_ON:
+		rk818_cg_set_otg_in(cg, ONLINE);
+		if (cg->pdata->power_dc2otg && cg->dc_in)
+			CG_INFO("otg power from dc adapter\n");
+		else
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_ON);
+		break;
+	case USB_OTG_POWER_OFF:
+		rk818_cg_set_otg_in(cg, OFFLINE);
+		rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+		break;
+	default:
+		break;
+	}
+
+	CG_INFO("receive bc notifier event: %s..\n", event_name[cg->bc_event]);
+
+	rk818_cg_pr_info(cg);
+}
+
+static void rk818_cg_irq_delay_work(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, irq_work.work);
+
+	if (cg->plugin_trigger) {
+		CG_INFO("pmic: plug in\n");
+		cg->plugin_trigger = 0;
+		rk_send_wakeup_key();
+		if (cg->pdata->extcon)
+			queue_delayed_work(cg->usb_charger_wq, &cg->usb_work,
+					   msecs_to_jiffies(10));
+	} else if (cg->plugout_trigger) {
+		CG_INFO("pmic: plug out\n");
+		cg->plugout_trigger = 0;
+		rk818_cg_set_chrg_param(cg, USB_TYPE_NONE_CHARGER);
+		rk818_cg_set_chrg_param(cg, DC_TYPE_NONE_CHARGER);
+		rk_send_wakeup_key();
+		rk818_cg_pr_info(cg);
+	} else {
+		CG_INFO("pmic: unknown irq\n");
+	}
+}
+
+static irqreturn_t rk818_plug_in_isr(int irq, void *cg)
+{
+	struct rk818_charger *icg;
+
+	icg = (struct rk818_charger *)cg;
+	icg->plugin_trigger = 1;
+	queue_delayed_work(icg->usb_charger_wq, &icg->irq_work,
+			   msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rk818_plug_out_isr(int irq, void *cg)
+{
+	struct rk818_charger *icg;
+
+	icg = (struct rk818_charger *)cg;
+	icg->plugout_trigger = 1;
+	queue_delayed_work(icg->usb_charger_wq, &icg->irq_work,
+			   msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rk818_dc_det_isr(int irq, void *charger)
+{
+	struct rk818_charger *cg = (struct rk818_charger *)charger;
+
+	if (gpio_get_value(cg->pdata->dc_det_pin))
+		irq_set_irq_type(irq, IRQF_TRIGGER_LOW);
+	else
+		irq_set_irq_type(irq, IRQF_TRIGGER_HIGH);
+
+	queue_delayed_work(cg->dc_charger_wq, &cg->dc_work,
+			   msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+static int rk818_cg_init_irqs(struct rk818_charger *cg)
+{
+	struct rk808 *rk818 = cg->rk818;
+	struct platform_device *pdev = cg->pdev;
+	int ret, plug_in_irq, plug_out_irq;
+
+	plug_in_irq = regmap_irq_get_virq(rk818->irq_data, RK818_IRQ_PLUG_IN);
+	if (plug_in_irq < 0) {
+		dev_err(cg->dev, "plug_in_irq request failed!\n");
+		return plug_in_irq;
+	}
+
+	plug_out_irq = regmap_irq_get_virq(rk818->irq_data, RK818_IRQ_PLUG_OUT);
+	if (plug_out_irq < 0) {
+		dev_err(cg->dev, "plug_out_irq request failed!\n");
+		return plug_out_irq;
+	}
+
+	ret = devm_request_threaded_irq(cg->dev, plug_in_irq, NULL,
+					rk818_plug_in_isr,
+					IRQF_TRIGGER_RISING,
+					"rk818_plug_in", cg);
+	if (ret) {
+		dev_err(&pdev->dev, "plug_in_irq request failed!\n");
+		return ret;
+	}
+
+	ret = devm_request_threaded_irq(cg->dev, plug_out_irq, NULL,
+					rk818_plug_out_isr,
+					IRQF_TRIGGER_FALLING,
+					"rk818_plug_out", cg);
+	if (ret) {
+		dev_err(&pdev->dev, "plug_out_irq request failed!\n");
+		return ret;
+	}
+
+	cg->plugin_irq = plug_in_irq;
+	cg->plugout_irq = plug_out_irq;
+
+	INIT_DELAYED_WORK(&cg->irq_work, rk818_cg_irq_delay_work);
+
+	return 0;
+}
+
+static int rk818_cg_init_dc(struct rk818_charger *cg)
+{
+	int ret, level;
+	unsigned long irq_flags;
+	unsigned int dc_det_irq;
+
+	cg->dc_charger_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-dc-wq");
+	INIT_DELAYED_WORK(&cg->dc_work, rk818_cg_dc_det_worker);
+	cg->dc_charger = DC_TYPE_NONE_CHARGER;
+
+	if (!cg->pdata->support_dc_det)
+		return 0;
+
+	ret = devm_gpio_request(cg->dev, cg->pdata->dc_det_pin, "rk818_dc_det");
+	if (ret < 0) {
+		dev_err(cg->dev, "failed to request gpio %d\n",
+			cg->pdata->dc_det_pin);
+		return ret;
+	}
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	gpiod_set_pull(gpio_to_desc(cg->pdata->dc_det_pin),
+			GPIOD_PULL_UP);
+#endif
+	ret = gpio_direction_input(cg->pdata->dc_det_pin);
+	if (ret) {
+		dev_err(cg->dev, "failed to set gpio input\n");
+		return ret;
+	}
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	if (cg->pdata->chg_led_pin) {
+		ret = devm_gpio_request(cg->dev,
+					cg->pdata->chg_led_pin,
+					"rk817_chg_led");
+		if (ret < 0)
+			dev_err(cg->dev, "failed to request gpio %d\n",
+				cg->pdata->chg_led_pin);
+		else
+			gpio_direction_output(cg->pdata->chg_led_pin,
+					     !cg->pdata->chg_led_on);
+	}
+
+	cg->led_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk817-led-wq");
+	INIT_DELAYED_WORK(&cg->led_work, rk818_cg_led_worker);
+
+	queue_delayed_work(cg->led_wq, &cg->led_work,
+		msecs_to_jiffies(500));
+#endif
+
+
+	level = gpio_get_value(cg->pdata->dc_det_pin);
+	if (level == cg->pdata->dc_det_level)
+		cg->dc_charger = DC_TYPE_DC_CHARGER;
+	else
+		cg->dc_charger = DC_TYPE_NONE_CHARGER;
+
+	if (level)
+		irq_flags = IRQF_TRIGGER_LOW;
+	else
+		irq_flags = IRQF_TRIGGER_HIGH;
+
+	dc_det_irq = gpio_to_irq(cg->pdata->dc_det_pin);
+	ret = devm_request_irq(cg->dev, dc_det_irq, rk818_dc_det_isr,
+			       irq_flags, "rk818_dc_det", cg);
+	if (ret != 0) {
+		dev_err(cg->dev, "rk818_dc_det_irq request failed!\n");
+		return ret;
+	}
+
+	enable_irq_wake(dc_det_irq);
+	return 0;
+}
+
+static void rk818_cg_discnt_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, discnt_work.work);
+
+	if (extcon_get_state(cg->cable_edev, EXTCON_USB) == 0) {
+		CG_INFO("receive type-c notifier event: DISCNT...\n");
+		rk818_cg_set_chrg_param(cg, USB_TYPE_NONE_CHARGER);
+		rk818_cg_pr_info(cg);
+	}
+}
+
+static void rk818_cg_host_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+			struct rk818_charger, host_work.work);
+	struct extcon_dev *edev = cg->cable_edev;
+
+	/* Determine charger type */
+	if (extcon_get_state(edev, EXTCON_USB_VBUS_EN) > 0) {
+		rk818_cg_set_otg_in(cg, ONLINE);
+		CG_INFO("receive type-c notifier event: OTG ON...\n");
+		if (cg->dc_in && cg->pdata->power_dc2otg)
+			CG_INFO("otg power from dc adapter\n");
+		else
+			rk818_cg_set_otg_power(cg, USB_OTG_POWER_ON);
+	} else if (extcon_get_state(edev, EXTCON_USB_VBUS_EN) == 0) {
+		CG_INFO("receive type-c notifier event: OTG OFF...\n");
+		rk818_cg_set_otg_in(cg, OFFLINE);
+		rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+	}
+
+	rk818_cg_pr_info(cg);
+}
+
+static void rk818_cg_charger_evt_worker(struct work_struct *work)
+{
+	struct rk818_charger *cg = container_of(work,
+				struct rk818_charger, usb_work.work);
+	struct extcon_dev *edev = cg->cable_edev;
+	enum charger_t charger = USB_TYPE_UNKNOWN_CHARGER;
+	const char *event[] = {"UN", "NONE", "USB", "AC", "CDP1.5A"};
+
+	/* Determine charger type */
+	if (extcon_get_state(edev, EXTCON_CHG_USB_SDP) > 0)
+		charger = USB_TYPE_USB_CHARGER;
+	else if (extcon_get_state(edev, EXTCON_CHG_USB_DCP) > 0)
+		charger = USB_TYPE_AC_CHARGER;
+	else if (extcon_get_state(edev, EXTCON_CHG_USB_CDP) > 0)
+		charger = USB_TYPE_CDP_CHARGER;
+
+	if (charger != USB_TYPE_UNKNOWN_CHARGER) {
+		CG_INFO("receive type-c notifier event: %s...\n",
+			event[charger]);
+		cg->usb_charger = charger;
+		rk818_cg_set_chrg_param(cg, charger);
+		rk818_cg_pr_info(cg);
+	}
+}
+
+static long rk818_cg_init_usb(struct rk818_charger *cg)
+{
+	enum charger_t charger;
+	enum bc_port_type bc_type;
+	struct extcon_dev *edev;
+	struct device *dev = cg->dev;
+	int ret;
+
+	cg->usb_charger_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-usb-wq");
+	cg->usb_charger = USB_TYPE_NONE_CHARGER;
+
+	/* type-C */
+	if (cg->pdata->extcon) {
+		edev = extcon_get_edev_by_phandle(dev->parent, 0);
+		if (IS_ERR(edev)) {
+			if (PTR_ERR(edev) != -EPROBE_DEFER)
+				dev_err(dev, "Invalid or missing extcon\n");
+			return PTR_ERR(edev);
+		}
+
+		/* Register chargers  */
+		INIT_DELAYED_WORK(&cg->usb_work, rk818_cg_charger_evt_worker);
+		cg->cable_cg_nb.notifier_call = rk818_cg_charger_evt_notifier;
+		ret = extcon_register_notifier(edev, EXTCON_CHG_USB_SDP,
+					       &cg->cable_cg_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for SDP\n");
+			return ret;
+		}
+
+		ret = extcon_register_notifier(edev, EXTCON_CHG_USB_DCP,
+					       &cg->cable_cg_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for DCP\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			return ret;
+		}
+
+		ret = extcon_register_notifier(edev, EXTCON_CHG_USB_CDP,
+					       &cg->cable_cg_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for CDP\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_DCP,
+						   &cg->cable_cg_nb);
+			return ret;
+		}
+
+		/* Register host */
+		INIT_DELAYED_WORK(&cg->host_work, rk818_cg_host_evt_worker);
+		cg->cable_host_nb.notifier_call = rk818_cg_host_evt_notifier;
+		ret = extcon_register_notifier(edev, EXTCON_USB_VBUS_EN,
+					       &cg->cable_host_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for HOST\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_DCP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_CDP,
+						   &cg->cable_cg_nb);
+
+			return ret;
+		}
+
+		/* Register discnt usb */
+		INIT_DELAYED_WORK(&cg->discnt_work, rk818_cg_discnt_evt_worker);
+		cg->cable_discnt_nb.notifier_call = rk818_cg_discnt_evt_notfier;
+		ret = extcon_register_notifier(edev, EXTCON_USB,
+					       &cg->cable_discnt_nb);
+		if (ret < 0) {
+			dev_err(dev, "failed to register notifier for HOST\n");
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_SDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_DCP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_CHG_USB_CDP,
+						   &cg->cable_cg_nb);
+			extcon_unregister_notifier(edev, EXTCON_USB_VBUS_EN,
+						   &cg->cable_host_nb);
+			return ret;
+		}
+
+		cg->cable_edev = edev;
+
+		schedule_delayed_work(&cg->host_work, 0);
+		schedule_delayed_work(&cg->usb_work, 0);
+
+		CG_INFO("register typec extcon evt notifier\n");
+	} else {
+		INIT_DELAYED_WORK(&cg->usb_work, rk818_cg_bc_evt_worker);
+		cg->bc_nb.notifier_call = rk818_cg_bc_evt_notifier;
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+		bc_type = USB_BC_TYPE_DISCNT;
+		ret = dwc_otg_charger_detect_register_notifier(&cg->bc_nb);
+		if (ret) {
+			dev_err(dev, "failed to register notifier for bc\n");
+			return -EINVAL;
+		}
+#else
+		ret = rk_bc_detect_notifier_register(&cg->bc_nb, &bc_type);
+		if (ret) {
+			dev_err(dev, "failed to register notifier for bc\n");
+			return -EINVAL;
+		}
+#endif
+		switch (bc_type) {
+		case USB_BC_TYPE_DISCNT:
+			charger = USB_TYPE_NONE_CHARGER;
+			break;
+		case USB_BC_TYPE_SDP:
+		case USB_BC_TYPE_CDP:
+			charger = USB_TYPE_USB_CHARGER;
+			break;
+		case USB_BC_TYPE_DCP:
+			charger = USB_TYPE_AC_CHARGER;
+			break;
+		default:
+			charger = USB_TYPE_NONE_CHARGER;
+			break;
+		}
+
+		cg->usb_charger = charger;
+		CG_INFO("register bc evt notifier\n");
+	}
+
+	return 0;
+}
+
+static void rk818_cg_init_finish_sig(struct rk818_charger *cg)
+{
+	if (rk818_cg_online(cg))
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_DIG_SIGNAL);
+	else
+		rk818_cg_set_finish_sig(cg, CHRG_FINISH_ANA_SIGNAL);
+
+	cg->finish_sig_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-finish-sig-wq");
+	INIT_DELAYED_WORK(&cg->finish_sig_work, rk818_cg_finish_sig_work);
+}
+
+static void rk818_cg_init_ts2_detect(struct rk818_charger *cg)
+{
+	u8 buf;
+
+	cg->ts2_wq = alloc_ordered_workqueue("%s",
+				WQ_MEM_RECLAIM | WQ_FREEZABLE,
+				"rk818-ts2-wq");
+	INIT_DELAYED_WORK(&cg->ts2_vol_work, rk818_ts2_vol_work);
+
+	if (!cg->pdata->ts2_vol_multi)
+		return;
+
+	/* TS2 adc mode */
+	buf = rk818_reg_read(cg, RK818_TS_CTRL_REG);
+	buf |= TS2_FUN_ADC;
+	rk818_reg_write(cg, RK818_TS_CTRL_REG, buf);
+
+	/* TS2 adc enable */
+	buf = rk818_reg_read(cg, RK818_ADC_CTRL_REG);
+	buf |= ADC_TS2_EN;
+	rk818_reg_write(cg, RK818_ADC_CTRL_REG, buf);
+
+	CG_INFO("enable ts2 voltage detect, multi=%d\n",
+		cg->pdata->ts2_vol_multi);
+}
+
+static void rk818_cg_init_charger_state(struct rk818_charger *cg)
+{
+	rk818_cg_init_config(cg);
+	rk818_cg_init_finish_sig(cg);
+	rk818_cg_set_chrg_param(cg, cg->dc_charger);
+	rk818_cg_set_chrg_param(cg, cg->usb_charger);
+
+	if (cg->otg_in && cg->dc_in && cg->pdata->power_dc2otg) {
+		CG_INFO("otg power from dc adapter\n");
+		rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+	}
+
+	CG_INFO("ac=%d, usb=%d, dc=%d, otg=%d, 5v=%d\n",
+		cg->ac_in, cg->usb_in, cg->dc_in, cg->otg_in, cg->otg_pmic5v);
+}
+
+static int rk818_cg_temperature_notifier_call(struct notifier_block *nb,
+					      unsigned long temp, void *data)
+{
+	struct rk818_charger *cg =
+		container_of(nb, struct rk818_charger, temp_nb);
+	static int temp_triggered, config_index = -1;
+	int i, up_temp, down_temp, cfg_current;
+	int now_temp = temp;
+	u8 usb_ctrl, chrg_ctrl1;
+
+	DBG("%s: receive notify temperature = %d\n", __func__, now_temp);
+	for (i = 0; i < cg->pdata->tc_count; i++) {
+		up_temp = cg->pdata->tc_table[i].temp_up;
+		down_temp = cg->pdata->tc_table[i].temp_down;
+		cfg_current = cg->pdata->tc_table[i].chrg_current;
+
+		if (now_temp >= down_temp && now_temp <= up_temp) {
+			/* Temp range or charger are not update, return */
+			if (config_index == i && !cg->charger_changed)
+				return NOTIFY_DONE;
+
+			config_index = i;
+			cg->charger_changed = 0;
+			temp_triggered = 1;
+
+			if (cg->pdata->tc_table[i].set_chrg_current) {
+				rk818_cg_set_chrg_current(cg, cfg_current);
+				CG_INFO("temperature = %d'C[%d~%d'C], "
+					"chrg current = %d\n",
+					now_temp, down_temp, up_temp,
+					chrg_cur_sel_array[cfg_current] *
+					cg->res_div);
+			} else {
+				rk818_cg_set_input_current(cg, cfg_current);
+				CG_INFO("temperature = %d'C[%d~%d'C], "
+					"input current = %d\n",
+					now_temp, down_temp, up_temp,
+					chrg_cur_input_array[cfg_current]);
+			}
+			return NOTIFY_DONE;
+		}
+	}
+
+	/*
+	 * means: current temperature not covers above case, temperature rolls
+	 * back to normal range, so restore default value
+	 */
+	if (temp_triggered) {
+		temp_triggered = 0;
+		config_index = -1;
+		rk818_cg_set_chrg_current(cg, cg->chrg_current);
+		if (cg->ac_in || cg->dc_in)
+			rk818_cg_set_input_current(cg, cg->chrg_input);
+		else
+			rk818_cg_set_input_current(cg, INPUT_CUR450MA);
+		usb_ctrl = rk818_reg_read(cg, RK818_USB_CTRL_REG);
+		chrg_ctrl1 = rk818_reg_read(cg, RK818_CHRG_CTRL_REG1);
+		CG_INFO("roll back temp %d'C, current chrg = %d, input = %d\n",
+			now_temp,
+			chrg_cur_sel_array[(chrg_ctrl1 & 0x0f)] * cg->res_div,
+			chrg_cur_input_array[(usb_ctrl & 0x0f)]);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int parse_temperature_chrg_table(struct rk818_charger *cg,
+					struct device_node *np)
+{
+	int size, count;
+	int i, chrg_current;
+	const __be32 *list;
+
+	if (!of_find_property(np, "temperature_chrg_table_v2", &size))
+		return 0;
+
+	list = of_get_property(np, "temperature_chrg_table_v2", &size);
+	size /= sizeof(u32);
+	if (!size || (size % 3)) {
+		dev_err(cg->dev,
+			"invalid temperature_chrg_table: size=%d\n", size);
+		return -EINVAL;
+	}
+
+	count = size / 3;
+	cg->pdata->tc_count = count;
+	cg->pdata->tc_table = devm_kzalloc(cg->dev,
+					   count * sizeof(*cg->pdata->tc_table),
+					   GFP_KERNEL);
+	if (!cg->pdata->tc_table)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		/* temperature */
+		cg->pdata->tc_table[i].temp_down = be32_to_cpu(*list++);
+		cg->pdata->tc_table[i].temp_up = be32_to_cpu(*list++);
+
+		/*
+		 * because charge current lowest level is 1000mA:
+		 * higher than or equal 1000ma, select charge current;
+		 * lower than 1000ma, must select input current.
+		 */
+		chrg_current = be32_to_cpu(*list++);
+		if (chrg_current >= 1000) {
+			cg->pdata->tc_table[i].set_chrg_current = 1;
+			cg->pdata->tc_table[i].chrg_current =
+				rk818_cg_decode_chrg_current(cg, chrg_current);
+		} else {
+			cg->pdata->tc_table[i].chrg_current =
+				rk818_cg_decode_input_current(cg, chrg_current);
+		}
+
+		DBG("temp%d: [%d, %d], chrg_current=%d\n",
+		    i, cg->pdata->tc_table[i].temp_down,
+		    cg->pdata->tc_table[i].temp_up,
+		    cg->pdata->tc_table[i].chrg_current);
+	}
+
+	return 0;
+
+}
+
+static int rk818_cg_register_temp_notifier(struct rk818_charger *cg)
+{
+	int ret;
+
+	if (!cg->pdata->tc_count)
+		return 0;
+	cg->temp_nb.notifier_call = rk818_cg_temperature_notifier_call,
+	ret = rk818_bat_temp_notifier_register(&cg->temp_nb);
+	if (ret) {
+		dev_err(cg->dev,
+			"battery temperature notify register failed:%d\n", ret);
+		return ret;
+	}
+
+	CG_INFO("enable set charge current by temperature\n");
+
+	return 0;
+}
+
+static int rk818_cg_get_otg5v_regulator(struct rk818_charger *cg)
+{
+	int ret;
+
+	/* not necessary */
+	cg->otg5v_rdev = devm_regulator_get(cg->dev, "otg_switch");
+	if (IS_ERR(cg->otg5v_rdev)) {
+		ret = PTR_ERR(cg->otg5v_rdev);
+		dev_warn(cg->dev, "failed to get otg regulator: %d\n", ret);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int rk818_cg_parse_dt(struct rk818_charger *cg)
+{
+	struct device_node *np;
+	struct charger_platform_data *pdata;
+	enum of_gpio_flags flags;
+	struct device *dev = cg->dev;
+	int ret;
+
+	np = of_find_node_by_name(cg->pdev->dev.of_node, "battery");
+	if (!np) {
+		dev_err(dev, "battery node not found!\n");
+		return -ENODEV;
+	}
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	cg->pdata = pdata;
+	pdata->max_chrg_current = DEFAULT_CHRG_CURRENT;
+	pdata->max_input_current = DEFAULT_INPUT_CURRENT;
+	pdata->max_chrg_voltage = DEFAULT_CHRG_VOLTAGE;
+
+	pdata->extcon = device_property_read_bool(dev->parent, "extcon");
+
+	ret = of_property_read_u32(np, "max_chrg_current",
+				   &pdata->max_chrg_current);
+	if (ret < 0)
+		dev_err(dev, "max_chrg_current missing!\n");
+
+	ret = of_property_read_u32(np, "max_input_current",
+				   &pdata->max_input_current);
+	if (ret < 0)
+		dev_err(dev, "max_input_current missing!\n");
+
+	ret = of_property_read_u32(np, "max_chrg_voltage",
+				   &pdata->max_chrg_voltage);
+	if (ret < 0)
+		dev_err(dev, "max_chrg_voltage missing!\n");
+
+	ret = of_property_read_u32(np, "virtual_power", &pdata->virtual_power);
+	if (ret < 0)
+		dev_err(dev, "virtual_power missing!\n");
+
+	ret = of_property_read_u32(np, "power_dc2otg", &pdata->power_dc2otg);
+	if (ret < 0)
+		dev_err(dev, "power_dc2otg missing!\n");
+
+	ret = of_property_read_u32(np, "sample_res", &pdata->sample_res);
+	if (ret < 0) {
+		pdata->sample_res = SAMPLE_RES_20MR;
+		dev_err(dev, "sample_res missing!\n");
+	}
+
+	ret = of_property_read_u32(np, "otg5v_suspend_enable",
+				   &pdata->otg5v_suspend_enable);
+	if (ret < 0) {
+		pdata->otg5v_suspend_enable = 1;
+		dev_err(dev, "otg5v_suspend_enable missing!\n");
+	}
+
+	ret = of_property_read_u32(np, "ts2_vol_multi",
+				   &pdata->ts2_vol_multi);
+
+	if (!is_battery_exist(cg))
+		pdata->virtual_power = 1;
+
+	cg->res_div = (cg->pdata->sample_res == SAMPLE_RES_20MR) ?
+		       SAMPLE_RES_DIV1 : SAMPLE_RES_DIV2;
+
+	if (!of_find_property(np, "dc_det_gpio", &ret)) {
+		pdata->support_dc_det = false;
+		CG_INFO("not support dc\n");
+	} else {
+		pdata->support_dc_det = true;
+		pdata->dc_det_pin = of_get_named_gpio_flags(np, "dc_det_gpio",
+							    0, &flags);
+		if (gpio_is_valid(pdata->dc_det_pin)) {
+			CG_INFO("support dc\n");
+			pdata->dc_det_level = (flags & OF_GPIO_ACTIVE_LOW) ?
+					       0 : 1;
+		} else {
+			dev_err(dev, "invalid dc det gpio!\n");
+			return -EINVAL;
+		}
+	}
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	if (!of_find_property(np, "chg_led_gpio", &ret)) {
+		CG_INFO("not support charge led\n");
+		pdata->chg_led_pin = 0;
+	} else {
+		pdata->chg_led_pin = of_get_named_gpio_flags(np,
+						"chg_led_gpio",
+						0, &flags);
+		if (gpio_is_valid(pdata->chg_led_pin)) {
+			CG_INFO("support charge led\n");
+			pdata->chg_led_on =
+				(flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		}
+	}
+#endif
+
+
+	ret = parse_temperature_chrg_table(cg, np);
+	if (ret)
+		return ret;
+
+	CG_INFO("input_current:%d\n"
+	    "chrg_current:%d\n"
+	    "chrg_voltage:%d\n"
+	    "sample_res:%d\n"
+	    "extcon:%d\n"
+	    "ts2_vol_multi:%d\n"
+	    "virtual_power:%d\n"
+	    "power_dc2otg:%d\n",
+	    pdata->max_input_current, pdata->max_chrg_current,
+	    pdata->max_chrg_voltage, pdata->sample_res, pdata->extcon,
+	    pdata->ts2_vol_multi, pdata->virtual_power, pdata->power_dc2otg);
+
+	return 0;
+}
+#else
+static int rk818_cg_parse_dt(struct rk818_charger *cg)
+{
+	return -ENODEV;
+}
+#endif
+
+static int rk818_charger_probe(struct platform_device *pdev)
+{
+	struct rk808 *rk818 = dev_get_drvdata(pdev->dev.parent);
+	struct rk818_charger *cg;
+	int ret;
+
+	cg = devm_kzalloc(&pdev->dev, sizeof(*cg), GFP_KERNEL);
+	if (!cg)
+		return -ENOMEM;
+
+	cg->rk818 = rk818;
+	cg->pdev = pdev;
+	cg->dev = &pdev->dev;
+	cg->regmap = rk818->regmap;
+	platform_set_drvdata(pdev, cg);
+
+	ret = rk818_cg_parse_dt(cg);
+	if (ret < 0) {
+		dev_err(cg->dev, "parse dt failed!\n");
+		return ret;
+	}
+
+	rk818_cg_init_ts2_detect(cg);
+	rk818_cg_get_otg5v_regulator(cg);
+
+	ret = rk818_cg_init_dc(cg);
+	if (ret) {
+		dev_err(cg->dev, "init dc failed!\n");
+		return ret;
+	}
+
+	ret = rk818_cg_init_usb(cg);
+	if (ret) {
+		dev_err(cg->dev, "init usb failed!\n");
+		return ret;
+	}
+
+	ret = rk818_cg_init_power_supply(cg);
+	if (ret) {
+		dev_err(cg->dev, "init power supply fail!\n");
+		return ret;
+	}
+
+	rk818_cg_init_charger_state(cg);
+
+	ret = rk818_cg_register_temp_notifier(cg);
+	if (ret) {
+		dev_err(cg->dev, "register temp notify failed!\n");
+		goto notify_fail;
+	}
+
+	ret = rk818_cg_init_irqs(cg);
+	if (ret) {
+		dev_err(cg->dev, "init irqs failed!\n");
+		goto irq_fail;
+	}
+
+	CG_INFO("driver version: %s\n", CG_DRIVER_VERSION);
+
+	return 0;
+
+irq_fail:
+	rk818_bat_temp_notifier_unregister(&cg->temp_nb);
+
+notify_fail:
+	/* type-c only */
+	if (cg->pdata->extcon) {
+		cancel_delayed_work_sync(&cg->host_work);
+		cancel_delayed_work_sync(&cg->discnt_work);
+	}
+
+	cancel_delayed_work_sync(&cg->usb_work);
+	cancel_delayed_work_sync(&cg->dc_work);
+	cancel_delayed_work_sync(&cg->finish_sig_work);
+	cancel_delayed_work_sync(&cg->irq_work);
+	cancel_delayed_work_sync(&cg->ts2_vol_work);
+	destroy_workqueue(cg->ts2_wq);
+	destroy_workqueue(cg->usb_charger_wq);
+	destroy_workqueue(cg->dc_charger_wq);
+	destroy_workqueue(cg->finish_sig_wq);
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	cancel_delayed_work_sync(&cg->led_work);
+	destroy_workqueue(cg->led_wq);
+#endif
+
+	if (cg->pdata->extcon) {
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_SDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_DCP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_CDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB_VBUS_EN,
+					   &cg->cable_host_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB,
+					   &cg->cable_discnt_nb);
+	} else {
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+		dwc_otg_charger_detect_unregister_notifier(&cg->bc_nb);
+#else
+		rk_bc_detect_notifier_unregister(&cg->bc_nb);
+#endif
+	}
+
+	return ret;
+}
+
+static void rk818_charger_shutdown(struct platform_device *pdev)
+{
+	struct rk818_charger *cg = platform_get_drvdata(pdev);
+
+	/* type-c only */
+	if (cg->pdata->extcon) {
+		cancel_delayed_work_sync(&cg->host_work);
+		cancel_delayed_work_sync(&cg->discnt_work);
+	}
+
+	rk818_cg_set_otg_power(cg, USB_OTG_POWER_OFF);
+	disable_irq(cg->plugin_irq);
+	disable_irq(cg->plugout_irq);
+
+	cancel_delayed_work_sync(&cg->usb_work);
+	cancel_delayed_work_sync(&cg->dc_work);
+	cancel_delayed_work_sync(&cg->finish_sig_work);
+	cancel_delayed_work_sync(&cg->irq_work);
+	cancel_delayed_work_sync(&cg->ts2_vol_work);
+	flush_workqueue(cg->ts2_wq);
+	flush_workqueue(cg->usb_charger_wq);
+	flush_workqueue(cg->dc_charger_wq);
+	flush_workqueue(cg->finish_sig_wq);
+
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	cancel_delayed_work_sync(&cg->led_work);
+	destroy_workqueue(cg->led_wq);
+#endif
+
+	if (cg->pdata->extcon) {
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_SDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_DCP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_CHG_USB_CDP,
+					   &cg->cable_cg_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB_VBUS_EN,
+					   &cg->cable_host_nb);
+		extcon_unregister_notifier(cg->cable_edev, EXTCON_USB,
+					   &cg->cable_discnt_nb);
+	} else {
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+		dwc_otg_charger_detect_unregister_notifier(&cg->bc_nb);
+#else
+		rk_bc_detect_notifier_unregister(&cg->bc_nb);
+#endif
+	}
+
+	rk818_bat_temp_notifier_unregister(&cg->temp_nb);
+
+	rk818_cg_set_finish_sig(cg, CHRG_FINISH_ANA_SIGNAL);
+
+	CG_INFO("shutdown: ac=%d usb=%d dc=%d otg=%d 5v=%d\n",
+		cg->ac_in, cg->usb_in, cg->dc_in, cg->otg_in, cg->otg_pmic5v);
+}
+
+static int rk818_charger_suspend(struct platform_device *pdev,
+				 pm_message_t state)
+{
+	struct rk818_charger *cg = platform_get_drvdata(pdev);
+
+	cg->sleep_set_off_reg1 = rk818_reg_read(cg, RK818_SLEEP_SET_OFF_REG1);
+
+	/* enable sleep boost5v and otg5v */
+	if (cg->pdata->otg5v_suspend_enable) {
+		if ((cg->otg_in && !cg->dc_in) ||
+		    (cg->otg_in && cg->dc_in && !cg->pdata->power_dc2otg)) {
+			rk818_reg_clear_bits(cg, RK818_SLEEP_SET_OFF_REG1,
+					     OTG_BOOST_SLP_OFF);
+			CG_INFO("suspend: otg 5v on\n");
+			return 0;
+		}
+	}
+
+	/* disable sleep otg5v */
+	rk818_reg_set_bits(cg, RK818_SLEEP_SET_OFF_REG1,
+			   OTG_SLP_SET_OFF, OTG_SLP_SET_OFF);
+	CG_INFO("suspend: otg 5v off\n");
+
+	return 0;
+}
+
+static int rk818_charger_resume(struct platform_device *pdev)
+{
+	struct rk818_charger *cg = platform_get_drvdata(pdev);
+
+	/* resume sleep boost5v and otg5v */
+	rk818_reg_set_bits(cg, RK818_SLEEP_SET_OFF_REG1,
+			   OTG_BOOST_SLP_OFF, cg->sleep_set_off_reg1);
+
+	return 0;
+}
+
+static struct platform_driver rk818_charger_driver = {
+	.probe = rk818_charger_probe,
+	.suspend = rk818_charger_suspend,
+	.resume = rk818_charger_resume,
+	.shutdown = rk818_charger_shutdown,
+	.driver = {
+		.name	= "rk818-charger",
+	},
+};
+
+static int __init charger_init(void)
+{
+	return platform_driver_register(&rk818_charger_driver);
+}
+module_init(charger_init);
+
+static void __exit charger_exit(void)
+{
+	platform_driver_unregister(&rk818_charger_driver);
+}
+module_exit(charger_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rk818-charger");
+MODULE_AUTHOR("chenjh<chenjh@rock-chips.com>");
diff --git a/drivers/regulator/rk808-regulator.c b/drivers/regulator/rk808-regulator.c
index 28646e4cf3ba..65178ff04252 100644
--- a/drivers/regulator/rk808-regulator.c
+++ b/drivers/regulator/rk808-regulator.c
@@ -31,11 +31,18 @@
 #include <linux/regulator/of_regulator.h>
 #include <linux/gpio/consumer.h>
 
+#define CONFIG_ARCH_MESON64_ODROID_COMMON
+
 /* Field Definitions */
 #define RK808_BUCK_VSEL_MASK	0x3f
 #define RK808_BUCK4_VSEL_MASK	0xf
 #define RK808_LDO_VSEL_MASK	0x1f
 
+#define RK816_DCDC_SLP_EN_REG_OFFSET	2
+#define RK816_SWITCH_SLP_EN_REG_OFFSET	1
+#define RK816_LDO1_4_SLP_EN_REG_OFFSET	1
+#define RK816_LDO5_6_SLP_EN_REG_OFFSET	2
+
 #define RK818_BUCK_VSEL_MASK		0x3f
 #define RK818_BUCK4_VSEL_MASK		0x1f
 #define RK818_LDO_VSEL_MASK		0x1f
@@ -62,8 +69,8 @@
 /* Offset from XXX_EN_REG to SLEEP_SET_OFF_XXX */
 #define RK808_SLP_SET_OFF_REG_OFFSET 2
 
-/* max steps for increase voltage of Buck1/2, equal 100mv*/
-#define MAX_STEPS_ONE_TIME 8
+/* max steps for increase voltage of Buck1/2, equal 25mv*/
+#define MAX_STEPS_ONE_TIME 2
 
 #define RK8XX_DESC(_id, _match, _supply, _min, _max, _step, _vreg,	\
 	_vmask, _ereg, _emask, _etime)					\
@@ -86,6 +93,76 @@
 		.ops		= &rk808_reg_ops,			\
 	}
 
+#define RK816_DESC(_id, _match, _supply, _min, _max, _step, _vreg,	\
+	_vmask, _ereg, _emask, _enval, _disval, _etime)		\
+	[_id] = {							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),	\
+		.owner		= THIS_MODULE,				\
+		.min_uV		= (_min) * 1000,			\
+		.uV_step	= (_step) * 1000,			\
+		.vsel_reg	= (_vreg),				\
+		.vsel_mask	= (_vmask),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.enable_time	= (_etime),				\
+		.ops		= &rk808_reg_ops,			\
+	}
+
+#define RK817_DESC(_id, _match, _supply, _min, _max, _step, _vreg,	\
+	_vmask, _ereg, _emask, _enval, _disval, _etime)		\
+	{							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),	\
+		.owner		= THIS_MODULE,				\
+		.min_uV		= (_min) * 1000,			\
+		.uV_step	= (_step) * 1000,			\
+		.vsel_reg	= (_vreg),				\
+		.vsel_mask	= (_vmask),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.enable_time	= (_etime),				\
+		.ops		= &rk817_reg_ops,			\
+	}
+
+#define RK817_BOOST_DESC(_id, _match, _supply, _min, _max, _step, _vreg,\
+	_vmask, _ereg, _emask, _enval, _disval, _etime, m_drop)		\
+	{							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),	\
+		.owner		= THIS_MODULE,				\
+		.min_uV		= (_min) * 1000,			\
+		.uV_step	= (_step) * 1000,			\
+		.vsel_reg	= (_vreg),				\
+		.vsel_mask	= (_vmask),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.enable_time	= (_etime),				\
+		.min_dropout_uV = (m_drop) * 1000,			\
+		.ops		= &rk817_boost_ops,			\
+	}
+
 #define RK8XX_DESC_SWITCH(_id, _match, _supply, _ereg, _emask)		\
 	[_id] = {							\
 		.name		= (_match),				\
@@ -100,6 +177,22 @@
 		.ops		= &rk808_switch_ops			\
 	}
 
+#define RK817_DESC_SWITCH(_id, _match, _supply, _ereg, _emask,\
+	_enval, _disval)		\
+	{							\
+		.name		= (_match),				\
+		.supply_name	= (_supply),				\
+		.of_match	= of_match_ptr(_match),			\
+		.regulators_node = of_match_ptr("regulators"),		\
+		.type		= REGULATOR_VOLTAGE,			\
+		.id		= (_id),				\
+		.enable_reg	= (_ereg),				\
+		.enable_mask	= (_emask),				\
+		.enable_val     = (_enval),				\
+		.disable_val     = (_disval),				\
+		.owner		= THIS_MODULE,				\
+		.ops		= &rk817_switch_ops			\
+	}
 
 struct rk808_regulator_data {
 	struct gpio_desc *dvs_gpio[2];
@@ -117,10 +210,76 @@ static const struct regulator_linear_range rk808_ldo3_voltage_ranges[] = {
 	REGULATOR_LINEAR_RANGE(2500000, 15, 15, 0),
 };
 
+static const struct regulator_linear_range rk816_buck_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(712500, 0, 59, 12500),	/* 0.7125v - 1.45v */
+	REGULATOR_LINEAR_RANGE(1800000, 60, 62, 200000),/* 1.8v - 2.2v */
+	REGULATOR_LINEAR_RANGE(2300000, 63, 63, 0),	/* 2.3v - 2.3v */
+};
+
+static const struct regulator_linear_range rk816_buck4_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(800000, 0, 26, 100000),	/* 0.8v - 3.4 */
+	REGULATOR_LINEAR_RANGE(3500000, 27, 31, 0),	/* 3.5v */
+};
+
+#define RK817_BUCK1_MIN0 500000
+#define RK817_BUCK1_MAX0 1500000
+
+#define RK817_BUCK1_MIN1 1600000
+#define RK817_BUCK1_MAX1 2400000
+
+#define RK817_BUCK3_MAX1 3400000
+
+#define RK817_BUCK1_STP0 12500
+#define RK817_BUCK1_STP1 100000
+
+#define RK817_BUCK1_SEL0 ((RK817_BUCK1_MAX0 - RK817_BUCK1_MIN0) /\
+						  RK817_BUCK1_STP0)
+#define RK817_BUCK1_SEL1 ((RK817_BUCK1_MAX1 - RK817_BUCK1_MIN1) /\
+						  RK817_BUCK1_STP1)
+
+#define RK817_BUCK3_SEL1 ((RK817_BUCK3_MAX1 - RK817_BUCK1_MIN1) /\
+						  RK817_BUCK1_STP1)
+
+#define RK817_BUCK1_SEL_CNT (RK817_BUCK1_SEL0 + RK817_BUCK1_SEL1 + 1)
+#define RK817_BUCK3_SEL_CNT (RK817_BUCK1_SEL0 + RK817_BUCK3_SEL1 + 1)
+
+static const struct regulator_linear_range rk817_buck1_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN0, 0,
+			       RK817_BUCK1_SEL0, RK817_BUCK1_STP0),
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN1, RK817_BUCK1_SEL0 + 1,
+			       RK817_BUCK1_SEL_CNT, RK817_BUCK1_STP1),
+};
+
+static const struct regulator_linear_range rk817_buck3_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN0, 0,
+			       RK817_BUCK1_SEL0, RK817_BUCK1_STP0),
+	REGULATOR_LINEAR_RANGE(RK817_BUCK1_MIN1, RK817_BUCK1_SEL0 + 1,
+			       RK817_BUCK3_SEL_CNT, RK817_BUCK1_STP1),
+};
+
+#define RK809_BUCK5_SEL_CNT		(8)
+
+static const struct regulator_linear_range rk809_buck5_voltage_ranges[] = {
+	REGULATOR_LINEAR_RANGE(1500000, 0, 0, 0),
+	REGULATOR_LINEAR_RANGE(1800000, 1, 3, 200000),
+	REGULATOR_LINEAR_RANGE(2800000, 4, 5, 200000),
+	REGULATOR_LINEAR_RANGE(3300000, 6, 7, 300000),
+};
+
+static unsigned int rk8xx_regulator_of_map_mode(unsigned int mode)
+{
+	if (mode == 1)
+		return REGULATOR_MODE_FAST;
+	if (mode == 2)
+		return REGULATOR_MODE_NORMAL;
+
+	return -EINVAL;
+}
+
 static int rk808_buck1_2_get_voltage_sel_regmap(struct regulator_dev *rdev)
 {
 	struct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);
-	int id = rdev->desc->id - RK808_ID_DCDC1;
+	int id = rdev_get_id(rdev);
 	struct gpio_desc *gpio = pdata->dvs_gpio[id];
 	unsigned int val;
 	int ret;
@@ -189,11 +348,63 @@ static int rk808_buck1_2_i2c_set_voltage_sel(struct regulator_dev *rdev,
 	return ret;
 }
 
+#ifdef CONFIG_CPU_RK312X
+extern void rkclk_cpuclk_div_setting(int div);
+#else
+static inline void rkclk_cpuclk_div_setting(int div) {}
+#endif
+
+static int rk816_regulator_set_voltage_sel_regmap(struct regulator_dev *rdev,
+						  unsigned int sel)
+{
+	int ret, real_sel, delay = 100;
+	int rk816_type;
+	int id = rdev_get_id(rdev);
+
+	regmap_read(rdev->regmap, RK816_CHIP_VER_REG, &rk816_type);
+	rk816_type &= RK816_CHIP_VERSION_MASK;
+	sel <<= ffs(rdev->desc->vsel_mask) - 1;
+
+	if ((rk816_type != RK816_TYPE_ES2) && (id == 0)) {
+		if (sel > 23)
+			rkclk_cpuclk_div_setting(4);
+		else
+			rkclk_cpuclk_div_setting(2);
+	}
+
+	do {
+		ret = regmap_update_bits(rdev->regmap,
+					 rdev->desc->vsel_reg,
+					 rdev->desc->vsel_mask, sel);
+		if (ret)
+			return ret;
+
+		if (rk816_type == RK816_TYPE_ES2) {
+			ret = regmap_update_bits(rdev->regmap,
+						 RK816_DCDC_EN_REG2,
+						 RK816_BUCK_DVS_CONFIRM,
+						 RK816_BUCK_DVS_CONFIRM);
+			if (ret)
+				return ret;
+		}
+
+		regmap_read(rdev->regmap,
+			    rdev->desc->vsel_reg, &real_sel);
+		real_sel &= rdev->desc->vsel_mask;
+		delay--;
+	} while ((sel != real_sel) && (delay > 0));
+
+	if ((rk816_type != RK816_TYPE_ES2) && (id == 0))
+		rkclk_cpuclk_div_setting(1);
+
+	return ret;
+}
+
 static int rk808_buck1_2_set_voltage_sel(struct regulator_dev *rdev,
 					 unsigned sel)
 {
 	struct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);
-	int id = rdev->desc->id - RK808_ID_DCDC1;
+	int id = rdev_get_id(rdev);
 	struct gpio_desc *gpio = pdata->dvs_gpio[id];
 	unsigned int reg = rdev->desc->vsel_reg;
 	unsigned old_sel;
@@ -228,11 +439,11 @@ static int rk808_buck1_2_set_voltage_sel(struct regulator_dev *rdev,
 }
 
 static int rk808_buck1_2_set_voltage_time_sel(struct regulator_dev *rdev,
-				       unsigned int old_selector,
-				       unsigned int new_selector)
+					      unsigned int old_selector,
+					      unsigned int new_selector)
 {
 	struct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);
-	int id = rdev->desc->id - RK808_ID_DCDC1;
+	int id = rdev_get_id(rdev);
 	struct gpio_desc *gpio = pdata->dvs_gpio[id];
 
 	/* if there is no dvs1/2 pin, we don't need wait extra time here. */
@@ -245,8 +456,7 @@ static int rk808_buck1_2_set_voltage_time_sel(struct regulator_dev *rdev,
 static int rk808_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
 {
 	unsigned int ramp_value = RK808_RAMP_RATE_10MV_PER_US;
-	unsigned int reg = rk808_buck_config_regs[rdev->desc->id -
-						  RK808_ID_DCDC1];
+	unsigned int reg = rk808_buck_config_regs[rdev_get_id(rdev)];
 
 	switch (ramp_delay) {
 	case 1 ... 2000:
@@ -269,6 +479,35 @@ static int rk808_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
 				  RK808_RAMP_RATE_MASK, ramp_value);
 }
 
+/*
+ * RK817 RK809
+ */
+static int rk817_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
+{
+	unsigned int ramp_value = RK817_RAMP_RATE_25MV_PER_US;
+	unsigned int reg = RK817_BUCK_CONFIG_REG(rdev_get_id(rdev));
+
+	switch (ramp_delay) {
+	case 0 ... 3000:
+		ramp_value = RK817_RAMP_RATE_3MV_PER_US;
+		break;
+	case 3001 ... 6300:
+		ramp_value = RK817_RAMP_RATE_6_3MV_PER_US;
+		break;
+	case 6301 ... 12500:
+		ramp_value = RK817_RAMP_RATE_12_5MV_PER_US;
+		break;
+	case 12501 ... 25000:
+		break;
+	default:
+		pr_warn("%s ramp_delay: %d not supported, setting 10000\n",
+			rdev->desc->name, ramp_delay);
+	}
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  RK817_RAMP_RATE_MASK, ramp_value);
+}
+
 static int rk808_set_suspend_voltage(struct regulator_dev *rdev, int uv)
 {
 	unsigned int reg;
@@ -284,6 +523,29 @@ static int rk808_set_suspend_voltage(struct regulator_dev *rdev, int uv)
 				  sel);
 }
 
+static int rk817_check_suspend_voltage(int id)
+{
+	if (id >= RK817_ID_DCDC1 && id <= RK817_ID_LDO9)
+		return 0;
+	return -1;
+}
+
+static int rk817_set_suspend_voltage(struct regulator_dev *rdev, int uv)
+{
+	unsigned int reg;
+	int id = rdev_get_id(rdev);
+	int sel = regulator_map_voltage_linear(rdev, uv, uv);
+	/* only ldo1~ldo9 */
+	if (sel < 0 || rk817_check_suspend_voltage(id))
+		return -EINVAL;
+
+	reg = rdev->desc->vsel_reg + RK808_SLP_REG_OFFSET;
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  rdev->desc->vsel_mask,
+				  sel);
+}
+
 static int rk808_set_suspend_voltage_range(struct regulator_dev *rdev, int uv)
 {
 	unsigned int reg;
@@ -299,9 +561,61 @@ static int rk808_set_suspend_voltage_range(struct regulator_dev *rdev, int uv)
 				  sel);
 }
 
+static int rk816_set_suspend_enable(struct regulator_dev *rdev)
+{
+	unsigned int reg, val;
+
+	if (rdev->desc->id <= RK816_ID_DCDC4) {
+		reg = rdev->desc->enable_reg +
+			RK816_DCDC_SLP_EN_REG_OFFSET;
+		val = 1 << rdev->desc->id;
+	} else if ((rdev->desc->id > RK816_ID_DCDC4) &&
+		   (rdev->desc->id <= RK816_ID_LDO4)) {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO1_4_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	} else {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO5_6_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	}
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  val,
+				  val);
+}
+
+static int rk816_set_suspend_disable(struct regulator_dev *rdev)
+{
+	unsigned int reg, val;
+
+	if (rdev->desc->id <= RK816_ID_DCDC4) {
+		reg = rdev->desc->enable_reg +
+			RK816_DCDC_SLP_EN_REG_OFFSET;
+		val = 1 << rdev->desc->id;
+	} else if ((rdev->desc->id > RK816_ID_DCDC4) &&
+		   (rdev->desc->id <= RK816_ID_LDO4)) {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO1_4_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	} else {
+		reg = rdev->desc->enable_reg -
+			RK816_LDO5_6_SLP_EN_REG_OFFSET;
+		val = 1 << (rdev->desc->id - RK816_ID_LDO1);
+	}
+
+	return regmap_update_bits(rdev->regmap, reg,
+				  val,
+				  0);
+}
+
 static int rk808_set_suspend_enable(struct regulator_dev *rdev)
 {
 	unsigned int reg;
+	struct rk808 *rk808 = dev_get_drvdata(rdev->dev.parent);
+
+	if (rk808->variant == RK816_ID)
+		return rk816_set_suspend_enable(rdev);
 
 	reg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;
 
@@ -313,6 +627,10 @@ static int rk808_set_suspend_enable(struct regulator_dev *rdev)
 static int rk808_set_suspend_disable(struct regulator_dev *rdev)
 {
 	unsigned int reg;
+	struct rk808 *rk808 = dev_get_drvdata(rdev->dev.parent);
+
+	if (rk808->variant == RK816_ID)
+		return rk816_set_suspend_disable(rdev);
 
 	reg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;
 
@@ -321,6 +639,119 @@ static int rk808_set_suspend_disable(struct regulator_dev *rdev)
 				  rdev->desc->enable_mask);
 }
 
+static int rk817_set_suspend_enable_ctrl(struct regulator_dev *rdev,
+					 unsigned int en)
+{
+	unsigned int reg;
+	int id = rdev_get_id(rdev);
+	unsigned int id_slp, msk, val;
+
+	if (id >= RK817_ID_DCDC1 && id <= RK817_ID_DCDC4)
+		id_slp = id;
+	else if (id >= RK817_ID_LDO1 && id <= RK817_ID_LDO8)
+		id_slp = 8 + (id - RK817_ID_LDO1);
+	else if (id >= RK817_ID_LDO9 && id <= RK809_ID_SW2)
+		id_slp = 4 + (id - RK817_ID_LDO9);
+	else
+		return -EINVAL;
+
+	reg = RK817_POWER_SLP_EN_REG(id_slp / 8);
+
+	msk = BIT(id_slp % 8);
+	if (en)
+		val = msk;
+	else
+		val = 0;
+
+	return regmap_update_bits(rdev->regmap, reg, msk, val);
+}
+
+static int rk817_set_suspend_enable(struct regulator_dev *rdev)
+{
+	return rk817_set_suspend_enable_ctrl(rdev, 1);
+}
+
+static int rk817_set_suspend_disable(struct regulator_dev *rdev)
+{
+	return rk817_set_suspend_enable_ctrl(rdev, 0);
+}
+
+static int rk8xx_set_suspend_mode(struct regulator_dev *rdev, unsigned int mode)
+{
+	unsigned int reg;
+
+	reg = rdev->desc->vsel_reg + RK808_SLP_REG_OFFSET;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return regmap_update_bits(rdev->regmap, reg,
+					  PWM_MODE_MSK, FPWM_MODE);
+	case REGULATOR_MODE_NORMAL:
+		return regmap_update_bits(rdev->regmap, reg,
+					  PWM_MODE_MSK, AUTO_PWM_MODE);
+	default:
+		pr_err("do not support this mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk8xx_set_mode(struct regulator_dev *rdev, unsigned int mode)
+{
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
+					  PWM_MODE_MSK, FPWM_MODE);
+	case REGULATOR_MODE_NORMAL:
+		return regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
+					  PWM_MODE_MSK, AUTO_PWM_MODE);
+	default:
+		pr_err("do not support this mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int rk8xx_get_mode(struct regulator_dev *rdev)
+{
+	unsigned int val;
+	int err;
+
+	err = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);
+	if (err)
+		return err;
+
+	if (val & FPWM_MODE)
+		return REGULATOR_MODE_FAST;
+	else
+		return REGULATOR_MODE_NORMAL;
+}
+
+static int rk8xx_is_enabled_wmsk_regmap(struct regulator_dev *rdev)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(rdev->regmap, rdev->desc->enable_reg, &val);
+	if (ret != 0)
+		return ret;
+
+	/* add write mask bit */
+	val |= (rdev->desc->enable_mask & 0xf0);
+	val &= rdev->desc->enable_mask;
+
+	if (rdev->desc->enable_is_inverted) {
+		if (rdev->desc->enable_val)
+			return val != rdev->desc->enable_val;
+		return (val == 0);
+	}
+	if (rdev->desc->enable_val)
+		return val == rdev->desc->enable_val;
+	return val != 0;
+}
+
 static struct regulator_ops rk808_buck1_2_ops = {
 	.list_voltage		= regulator_list_voltage_linear,
 	.map_voltage		= regulator_map_voltage_linear,
@@ -330,12 +761,65 @@ static struct regulator_ops rk808_buck1_2_ops = {
 	.enable			= regulator_enable_regmap,
 	.disable		= regulator_disable_regmap,
 	.is_enabled		= regulator_is_enabled_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
 	.set_ramp_delay		= rk808_set_ramp_delay,
 	.set_suspend_voltage	= rk808_set_suspend_voltage,
 	.set_suspend_enable	= rk808_set_suspend_enable,
 	.set_suspend_disable	= rk808_set_suspend_disable,
 };
 
+static struct regulator_ops rk8xx_buck_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+	.set_ramp_delay		= rk808_set_ramp_delay,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk808_set_suspend_enable,
+	.set_suspend_disable	= rk808_set_suspend_disable,
+};
+
+static struct regulator_ops rk817_buck_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+	.set_ramp_delay		= rk817_set_ramp_delay,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
+static struct regulator_ops rk809_buck5_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
 static struct regulator_ops rk808_reg_ops = {
 	.list_voltage		= regulator_list_voltage_linear,
 	.map_voltage		= regulator_map_voltage_linear,
@@ -343,12 +827,40 @@ static struct regulator_ops rk808_reg_ops = {
 	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
 	.enable			= regulator_enable_regmap,
 	.disable		= regulator_disable_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
 	.is_enabled		= regulator_is_enabled_regmap,
 	.set_suspend_voltage	= rk808_set_suspend_voltage,
 	.set_suspend_enable	= rk808_set_suspend_enable,
 	.set_suspend_disable	= rk808_set_suspend_disable,
 };
 
+static struct regulator_ops rk817_reg_ops = {
+	.list_voltage		= regulator_list_voltage_linear,
+	.map_voltage		= regulator_map_voltage_linear,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_voltage	= rk817_set_suspend_voltage,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
+static struct regulator_ops rk817_boost_ops = {
+	.list_voltage		= regulator_list_voltage_linear,
+	.map_voltage		= regulator_map_voltage_linear,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
 static struct regulator_ops rk808_reg_ops_ranges = {
 	.list_voltage		= regulator_list_voltage_linear_range,
 	.map_voltage		= regulator_map_voltage_linear_range,
@@ -356,6 +868,9 @@ static struct regulator_ops rk808_reg_ops_ranges = {
 	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
 	.enable			= regulator_enable_regmap,
 	.disable		= regulator_disable_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
 	.is_enabled		= regulator_is_enabled_regmap,
 	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
 	.set_suspend_enable	= rk808_set_suspend_enable,
@@ -368,6 +883,35 @@ static struct regulator_ops rk808_switch_ops = {
 	.is_enabled		= regulator_is_enabled_regmap,
 	.set_suspend_enable	= rk808_set_suspend_enable,
 	.set_suspend_disable	= rk808_set_suspend_disable,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+};
+
+static struct regulator_ops rk817_switch_ops = {
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= rk8xx_is_enabled_wmsk_regmap,
+	.set_suspend_enable	= rk817_set_suspend_enable,
+	.set_suspend_disable	= rk817_set_suspend_disable,
+};
+
+static struct regulator_ops rk816_buck_ops_range = {
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.map_voltage		= regulator_map_voltage_linear_range,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.set_voltage_sel	= rk816_regulator_set_voltage_sel_regmap,
+	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+	.set_mode		= rk8xx_set_mode,
+	.get_mode		= rk8xx_get_mode,
+	.set_suspend_mode	= rk8xx_set_suspend_mode,
+	.set_ramp_delay		= rk808_set_ramp_delay,
+	.set_suspend_voltage	= rk808_set_suspend_voltage_range,
+	.set_suspend_enable	= rk808_set_suspend_enable,
+	.set_suspend_disable	= rk808_set_suspend_disable,
 };
 
 static const struct regulator_desc rk808_reg[] = {
@@ -464,6 +1008,106 @@ static const struct regulator_desc rk808_reg[] = {
 		RK808_DCDC_EN_REG, BIT(6)),
 };
 
+static const struct regulator_desc rk816_reg[] = {
+	{
+		.name = "DCDC_REG1",
+		.supply_name = "vcc1",
+		.of_match = of_match_ptr("DCDC_REG1"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK816_ID_DCDC1,
+		.ops = &rk816_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 64,
+		.linear_ranges = rk816_buck_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk816_buck_voltage_ranges),
+		.vsel_reg = RK816_BUCK1_ON_VSEL_REG,
+		.vsel_mask = RK818_BUCK_VSEL_MASK,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(4) | BIT(0),
+		.enable_val = BIT(4) | BIT(0),
+		.disable_val = BIT(4),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG2",
+		.supply_name = "vcc2",
+		.of_match = of_match_ptr("DCDC_REG2"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK816_ID_DCDC2,
+		.ops = &rk816_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 64,
+		.linear_ranges = rk816_buck_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk816_buck_voltage_ranges),
+		.vsel_reg = RK816_BUCK2_ON_VSEL_REG,
+		.vsel_mask = RK818_BUCK_VSEL_MASK,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(5) | BIT(1),
+		.enable_val = BIT(5) | BIT(1),
+		.disable_val = BIT(5),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG3",
+		.supply_name = "vcc3",
+		.of_match = of_match_ptr("DCDC_REG3"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK818_ID_DCDC3,
+		.ops = &rk808_switch_ops,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 1,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(6) | BIT(2),
+		.enable_val =  BIT(6) | BIT(2),
+		.disable_val = BIT(6),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG4",
+		.supply_name = "vcc4",
+		.of_match = of_match_ptr("DCDC_REG4"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK816_ID_DCDC4,
+		.ops = &rk8xx_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = 32,
+		.linear_ranges = rk816_buck4_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk816_buck4_voltage_ranges),
+		.vsel_reg = RK816_BUCK4_ON_VSEL_REG,
+		.vsel_mask = RK818_BUCK4_VSEL_MASK,
+		.enable_reg = RK816_DCDC_EN_REG1,
+		.enable_mask = BIT(7) | BIT(3),
+		.enable_val = BIT(7) | BIT(3),
+		.disable_val = BIT(7),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	RK816_DESC(RK816_ID_LDO1, "LDO_REG1", "vcc5", 800, 3400, 100,
+		   RK816_LDO1_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(4) | BIT(0), BIT(4) | BIT(0),
+		   BIT(4), 400),
+	RK816_DESC(RK816_ID_LDO2, "LDO_REG2", "vcc5", 800, 3400, 100,
+		   RK816_LDO2_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(5) | BIT(1), BIT(5) | BIT(1),
+		   BIT(5), 400),
+	RK816_DESC(RK816_ID_LDO3, "LDO_REG3", "vcc5", 800, 3400, 100,
+		   RK816_LDO3_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(6) | BIT(2), BIT(6) | BIT(2),
+		   BIT(6), 400),
+	RK816_DESC(RK816_ID_LDO4, "LDO_REG4", "vcc6", 800, 3400, 100,
+		   RK816_LDO4_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG1, BIT(7) | BIT(3), BIT(7) | BIT(3),
+		   BIT(7), 400),
+	RK816_DESC(RK816_ID_LDO5, "LDO_REG5", "vcc6", 800, 3400, 100,
+		   RK816_LDO5_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG2, BIT(4) | BIT(0), BIT(4) | BIT(0),
+		   BIT(4), 400),
+	RK816_DESC(RK816_ID_LDO6, "LDO_REG6", "vcc6", 800, 3400, 100,
+		   RK816_LDO6_ON_VSEL_REG, RK818_LDO_VSEL_MASK,
+		   RK816_LDO_EN_REG2, BIT(5) | BIT(1), BIT(5) | BIT(1),
+		   BIT(5), 400),
+};
+
 static const struct regulator_desc rk818_reg[] = {
 	{
 		.name = "DCDC_REG1",
@@ -566,10 +1210,283 @@ static const struct regulator_desc rk818_reg[] = {
 		RK818_DCDC_EN_REG, BIT(7)),
 };
 
+#define RK817_LDO_VSEL_MASK		0x7f
+#define RK817_BOOST_VSEL_MASK		0x7
+#define RK817_BUCK_VSEL_MASK		0x7f
+#define RK809_BUCK5_VSEL_MASK		0x7
+
+#define ENABLE_MASK(id)			(BIT(id) | BIT(4 + (id)))
+#define DISABLE_VAL(id)			(BIT(4 + (id)))
+
+static const struct regulator_desc rk817_reg[] = {
+	{
+		.name = "DCDC_REG1",
+		.supply_name = "vcc1",
+		.of_match = of_match_ptr("DCDC_REG1"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC1,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK1_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC1),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC1),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC1),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG2",
+		.supply_name = "vcc2",
+		.of_match = of_match_ptr("DCDC_REG2"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC2,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK2_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC2),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC2),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC2),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG3",
+		.supply_name = "vcc3",
+		.of_match = of_match_ptr("DCDC_REG3"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC3,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK3_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC3),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC3),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC3),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG4",
+		.supply_name = "vcc4",
+		.of_match = of_match_ptr("DCDC_REG4"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC4,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK3_SEL_CNT + 1,
+		.linear_ranges = rk817_buck3_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck3_voltage_ranges),
+		.vsel_reg = RK817_BUCK4_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC4),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC4),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC4),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	RK817_DESC(RK817_ID_LDO1, "LDO_REG1", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(0), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO2, "LDO_REG2", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(1), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO3, "LDO_REG3", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(2), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO4, "LDO_REG4", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(3), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO5, "LDO_REG5", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(4), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO6, "LDO_REG6", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(5), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO7, "LDO_REG7", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(6), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO8, "LDO_REG8", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(7), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO9, "LDO_REG9", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(8), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(3), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_BOOST_DESC(RK817_ID_BOOST, "BOOST", "vcc8", 4700, 5400, 100,
+			 RK817_BOOST_OTG_CFG, RK817_BOOST_VSEL_MASK,
+			 RK817_POWER_EN_REG(3), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400, 3500 - 5400),
+	RK817_DESC_SWITCH(RK817_ID_BOOST_OTG_SW, "OTG_SWITCH", "vcc9",
+			  RK817_POWER_EN_REG(3), ENABLE_MASK(2),
+			  ENABLE_MASK(2), DISABLE_VAL(2)),
+};
+
+static const struct regulator_desc rk809_reg[] = {
+	{
+		.name = "DCDC_REG1",
+		.supply_name = "vcc1",
+		.of_match = of_match_ptr("DCDC_REG1"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC1,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK1_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC1),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC1),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC1),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG2",
+		.supply_name = "vcc2",
+		.of_match = of_match_ptr("DCDC_REG2"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC2,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK2_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC2),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC2),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC2),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG3",
+		.supply_name = "vcc3",
+		.of_match = of_match_ptr("DCDC_REG3"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC3,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK1_SEL_CNT + 1,
+		.linear_ranges = rk817_buck1_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck1_voltage_ranges),
+		.vsel_reg = RK817_BUCK3_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC3),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC3),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC3),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	}, {
+		.name = "DCDC_REG4",
+		.supply_name = "vcc4",
+		.of_match = of_match_ptr("DCDC_REG4"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK817_ID_DCDC4,
+		.ops = &rk817_buck_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK817_BUCK3_SEL_CNT + 1,
+		.linear_ranges = rk817_buck3_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk817_buck3_voltage_ranges),
+		.vsel_reg = RK817_BUCK4_ON_VSEL_REG,
+		.vsel_mask = RK817_BUCK_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(0),
+		.enable_mask = ENABLE_MASK(RK817_ID_DCDC4),
+		.enable_val = ENABLE_MASK(RK817_ID_DCDC4),
+		.disable_val = DISABLE_VAL(RK817_ID_DCDC4),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	{
+		.name = "DCDC_REG5",
+		.supply_name = "vcc9",
+		.of_match = of_match_ptr("DCDC_REG5"),
+		.regulators_node = of_match_ptr("regulators"),
+		.id = RK809_ID_DCDC5,
+		.ops = &rk809_buck5_ops_range,
+		.type = REGULATOR_VOLTAGE,
+		.n_voltages = RK809_BUCK5_SEL_CNT,
+		.linear_ranges = rk809_buck5_voltage_ranges,
+		.n_linear_ranges = ARRAY_SIZE(rk809_buck5_voltage_ranges),
+		.vsel_reg = RK809_BUCK5_CONFIG(0),
+		.vsel_mask = RK809_BUCK5_VSEL_MASK,
+		.enable_reg = RK817_POWER_EN_REG(3),
+		.enable_mask = ENABLE_MASK(1),
+		.enable_val = ENABLE_MASK(1),
+		.disable_val = DISABLE_VAL(1),
+		.of_map_mode = rk8xx_regulator_of_map_mode,
+		.owner = THIS_MODULE,
+	},
+	RK817_DESC(RK817_ID_LDO1, "LDO_REG1", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(0), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO2, "LDO_REG2", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(1), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO3, "LDO_REG3", "vcc5", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(2), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO4, "LDO_REG4", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(3), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(1), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO5, "LDO_REG5", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(4), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC(RK817_ID_LDO6, "LDO_REG6", "vcc6", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(5), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(1), ENABLE_MASK(1),
+		   DISABLE_VAL(1), 400),
+	RK817_DESC(RK817_ID_LDO7, "LDO_REG7", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(6), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(2), ENABLE_MASK(2),
+		   DISABLE_VAL(2), 400),
+	RK817_DESC(RK817_ID_LDO8, "LDO_REG8", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(7), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(2), ENABLE_MASK(3), ENABLE_MASK(3),
+		   DISABLE_VAL(3), 400),
+	RK817_DESC(RK817_ID_LDO9, "LDO_REG9", "vcc7", 600, 3400, 25,
+		   RK817_LDO_ON_VSEL_REG(8), RK817_LDO_VSEL_MASK,
+		   RK817_POWER_EN_REG(3), ENABLE_MASK(0), ENABLE_MASK(0),
+		   DISABLE_VAL(0), 400),
+	RK817_DESC_SWITCH(RK809_ID_SW1, "SWITCH_REG1", "vcc9",
+			  RK817_POWER_EN_REG(3), ENABLE_MASK(2),
+			  ENABLE_MASK(2), DISABLE_VAL(2)),
+	RK817_DESC_SWITCH(RK809_ID_SW2, "SWITCH_REG2", "vcc8",
+			  RK817_POWER_EN_REG(3), ENABLE_MASK(3),
+			  ENABLE_MASK(3), DISABLE_VAL(3)),
+};
+
 static int rk808_regulator_dt_parse_pdata(struct device *dev,
-				   struct device *client_dev,
-				   struct regmap *map,
-				   struct rk808_regulator_data *pdata)
+					  struct device *client_dev,
+					  struct regmap *map,
+					  struct rk808_regulator_data *pdata)
 {
 	struct device_node *np;
 	int tmp, ret = 0, i;
@@ -589,7 +1506,7 @@ static int rk808_regulator_dt_parse_pdata(struct device *dev,
 		}
 
 		if (!pdata->dvs_gpio[i]) {
-			dev_info(dev, "there is no dvs%d gpio\n", i);
+			dev_warn(dev, "there is no dvs%d gpio\n", i);
 			continue;
 		}
 
@@ -630,10 +1547,22 @@ static int rk808_regulator_probe(struct platform_device *pdev)
 		regulators = rk808_reg;
 		nregulators = RK808_NUM_REGULATORS;
 		break;
+	case RK809_ID:
+		regulators = rk809_reg;
+		nregulators = RK809_NUM_REGULATORS;
+		break;
 	case RK818_ID:
 		regulators = rk818_reg;
 		nregulators = RK818_NUM_REGULATORS;
 		break;
+	case RK816_ID:
+		regulators = rk816_reg;
+		nregulators = RK816_NUM_REGULATORS;
+		break;
+	case RK817_ID:
+		regulators = rk817_reg;
+		nregulators = RK817_NUM_REGULATORS;
+		break;
 	default:
 		dev_err(&client->dev, "unsupported RK8XX ID %lu\n",
 			rk808->variant);
@@ -667,7 +1596,18 @@ static struct platform_driver rk808_regulator_driver = {
 
 module_platform_driver(rk808_regulator_driver);
 
-MODULE_DESCRIPTION("regulator driver for the RK808/RK818 series PMICs");
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+static struct platform_driver rk818_regulator_driver = {
+	.probe = rk808_regulator_probe,
+	.driver = {
+		.name = "rk818-regulator"
+	},
+};
+
+module_platform_driver(rk818_regulator_driver);
+#endif
+
+MODULE_DESCRIPTION("regulator driver for the RK808/RK816/RK818 series PMICs");
 MODULE_AUTHOR("Chris Zhong <zyw@rock-chips.com>");
 MODULE_AUTHOR("Zhang Qing <zhangqing@rock-chips.com>");
 MODULE_AUTHOR("Wadim Egorov <w.egorov@phytec.de>");
diff --git a/drivers/rtc/rtc-rk808.c b/drivers/rtc/rtc-rk808.c
index 35c9aada07c8..b84f0f210169 100644
--- a/drivers/rtc/rtc-rk808.c
+++ b/drivers/rtc/rtc-rk808.c
@@ -50,9 +50,18 @@
 #define NUM_TIME_REGS	(RK808_WEEKS_REG - RK808_SECONDS_REG + 1)
 #define NUM_ALARM_REGS	(RK808_ALARM_YEARS_REG - RK808_ALARM_SECONDS_REG + 1)
 
+struct rk_rtc_compat_reg {
+	unsigned int ctrl_reg;
+	unsigned int status_reg;
+	unsigned int alarm_seconds_reg;
+	unsigned int int_reg;
+	unsigned int seconds_reg;
+};
+
 struct rk808_rtc {
 	struct rk808 *rk808;
 	struct rtc_device *rtc;
+	struct rk_rtc_compat_reg *creg;
 	int irq;
 };
 
@@ -81,6 +90,7 @@ static void gregorian_to_rockchip(struct rtc_time *tm)
 {
 	time64_t extra_days = nov2dec_transitions(tm);
 	time64_t time = rtc_tm_to_time64(tm);
+
 	rtc_time64_to_tm(time - extra_days * 86400, tm);
 
 	/* Compensate if we went back over Nov 31st (will work up to 2381) */
@@ -101,7 +111,7 @@ static int rk808_rtc_readtime(struct device *dev, struct rtc_time *tm)
 	int ret;
 
 	/* Force an update of the shadowed registers right now */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_RTC_GET_TIME,
 				 BIT_RTC_CTRL_REG_RTC_GET_TIME);
 	if (ret) {
@@ -115,7 +125,7 @@ static int rk808_rtc_readtime(struct device *dev, struct rtc_time *tm)
 	 * 32khz. If we clear the GET_TIME bit here, the time of i2c transfer
 	 * certainly more than 31.25us: 16 * 2.5us at 400kHz bus frequency.
 	 */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_RTC_GET_TIME,
 				 0);
 	if (ret) {
@@ -123,7 +133,7 @@ static int rk808_rtc_readtime(struct device *dev, struct rtc_time *tm)
 		return ret;
 	}
 
-	ret = regmap_bulk_read(rk808->regmap, RK808_SECONDS_REG,
+	ret = regmap_bulk_read(rk808->regmap, rk808_rtc->creg->seconds_reg,
 			       rtc_data, NUM_TIME_REGS);
 	if (ret) {
 		dev_err(dev, "Failed to bulk read rtc_data: %d\n", ret);
@@ -166,7 +176,7 @@ static int rk808_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	rtc_data[6] = bin2bcd(tm->tm_wday);
 
 	/* Stop RTC while updating the RTC registers */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M);
 	if (ret) {
@@ -174,14 +184,14 @@ static int rk808_rtc_set_time(struct device *dev, struct rtc_time *tm)
 		return ret;
 	}
 
-	ret = regmap_bulk_write(rk808->regmap, RK808_SECONDS_REG,
+	ret = regmap_bulk_write(rk808->regmap, rk808_rtc->creg->seconds_reg,
 				rtc_data, NUM_TIME_REGS);
 	if (ret) {
 		dev_err(dev, "Failed to bull write rtc_data: %d\n", ret);
 		return ret;
 	}
 	/* Start RTC again */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M, 0);
 	if (ret) {
 		dev_err(dev, "Failed to update RTC control: %d\n", ret);
@@ -190,6 +200,7 @@ static int rk808_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	return 0;
 }
 
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
 /* Read alarm time and date in RTC */
 static int rk808_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
 {
@@ -199,8 +210,13 @@ static int rk808_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
 	uint32_t int_reg;
 	int ret;
 
-	ret = regmap_bulk_read(rk808->regmap, RK808_ALARM_SECONDS_REG,
+	ret = regmap_bulk_read(rk808->regmap,
+			       rk808_rtc->creg->alarm_seconds_reg,
 			       alrm_data, NUM_ALARM_REGS);
+	if (ret) {
+		dev_err(dev, "Failed to read RTC alarm date REG: %d\n", ret);
+		return ret;
+	}
 
 	alrm->time.tm_sec = bcd2bin(alrm_data[0] & SECONDS_REG_MSK);
 	alrm->time.tm_min = bcd2bin(alrm_data[1] & MINUTES_REG_MAK);
@@ -210,7 +226,7 @@ static int rk808_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
 	alrm->time.tm_year = (bcd2bin(alrm_data[5] & YEARS_REG_MSK)) + 100;
 	rockchip_to_gregorian(&alrm->time);
 
-	ret = regmap_read(rk808->regmap, RK808_RTC_INT_REG, &int_reg);
+	ret = regmap_read(rk808->regmap, rk808_rtc->creg->int_reg, &int_reg);
 	if (ret) {
 		dev_err(dev, "Failed to read RTC INT REG: %d\n", ret);
 		return ret;
@@ -231,7 +247,7 @@ static int rk808_rtc_stop_alarm(struct rk808_rtc *rk808_rtc)
 	struct rk808 *rk808 = rk808_rtc->rk808;
 	int ret;
 
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_INT_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->int_reg,
 				 BIT_RTC_INTERRUPTS_REG_IT_ALARM_M, 0);
 
 	return ret;
@@ -242,7 +258,7 @@ static int rk808_rtc_start_alarm(struct rk808_rtc *rk808_rtc)
 	struct rk808 *rk808 = rk808_rtc->rk808;
 	int ret;
 
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_INT_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->int_reg,
 				 BIT_RTC_INTERRUPTS_REG_IT_ALARM_M,
 				 BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
 
@@ -274,7 +290,8 @@ static int rk808_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
 	alrm_data[4] = bin2bcd(alrm->time.tm_mon + 1);
 	alrm_data[5] = bin2bcd(alrm->time.tm_year - 100);
 
-	ret = regmap_bulk_write(rk808->regmap, RK808_ALARM_SECONDS_REG,
+	ret = regmap_bulk_write(rk808->regmap,
+				rk808_rtc->creg->alarm_seconds_reg,
 				alrm_data, NUM_ALARM_REGS);
 	if (ret) {
 		dev_err(dev, "Failed to bulk write: %d\n", ret);
@@ -300,6 +317,7 @@ static int rk808_rtc_alarm_irq_enable(struct device *dev,
 
 	return rk808_rtc_stop_alarm(rk808_rtc);
 }
+#endif
 
 /*
  * We will just handle setting the frequency and make use the framework for
@@ -318,7 +336,7 @@ static irqreturn_t rk808_alarm_irq(int irq, void *data)
 	struct i2c_client *client = rk808->i2c;
 	int ret;
 
-	ret = regmap_write(rk808->regmap, RK808_RTC_STATUS_REG,
+	ret = regmap_write(rk808->regmap, rk808_rtc->creg->status_reg,
 			   RTC_STATUS_MASK);
 	if (ret) {
 		dev_err(&client->dev,
@@ -328,16 +346,18 @@ static irqreturn_t rk808_alarm_irq(int irq, void *data)
 
 	rtc_update_irq(rk808_rtc->rtc, 1, RTC_IRQF | RTC_AF);
 	dev_dbg(&client->dev,
-		 "%s:irq=%d\n", __func__, irq);
+		"%s:irq=%d\n", __func__, irq);
 	return IRQ_HANDLED;
 }
 
 static const struct rtc_class_ops rk808_rtc_ops = {
 	.read_time = rk808_rtc_readtime,
 	.set_time = rk808_rtc_set_time,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
 	.read_alarm = rk808_rtc_readalarm,
 	.set_alarm = rk808_rtc_setalarm,
 	.alarm_irq_enable = rk808_rtc_alarm_irq_enable,
+#endif
 };
 
 #ifdef CONFIG_PM_SLEEP
@@ -371,22 +391,65 @@ static int rk808_rtc_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(rk808_rtc_pm_ops,
 	rk808_rtc_suspend, rk808_rtc_resume);
 
+static struct rk_rtc_compat_reg rk808_creg = {
+	.ctrl_reg = RK808_RTC_CTRL_REG,
+	.status_reg = RK808_RTC_STATUS_REG,
+	.alarm_seconds_reg = RK808_ALARM_SECONDS_REG,
+	.int_reg = RK808_RTC_INT_REG,
+	.seconds_reg = RK808_SECONDS_REG,
+};
+
+static struct rk_rtc_compat_reg rk817_creg = {
+	.ctrl_reg = RK817_RTC_CTRL_REG,
+	.status_reg = RK817_RTC_STATUS_REG,
+	.alarm_seconds_reg = RK817_ALARM_SECONDS_REG,
+	.int_reg = RK817_RTC_INT_REG,
+	.seconds_reg = RK817_SECONDS_REG,
+};
+
 static int rk808_rtc_probe(struct platform_device *pdev)
 {
 	struct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);
 	struct rk808_rtc *rk808_rtc;
 	struct rtc_time tm;
+	struct device_node *np;
 	int ret;
 
+	switch (rk808->variant) {
+	case RK805_ID:
+	case RK808_ID:
+	case RK809_ID:
+	case RK816_ID:
+	case RK818_ID:
+	case RK817_ID:
+		np = of_get_child_by_name(pdev->dev.parent->of_node, "rtc");
+		if (np && !of_device_is_available(np)) {
+			dev_info(&pdev->dev, "device is disabled\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		break;
+	}
+
 	rk808_rtc = devm_kzalloc(&pdev->dev, sizeof(*rk808_rtc), GFP_KERNEL);
-	if (rk808_rtc == NULL)
+	if (!rk808_rtc)
 		return -ENOMEM;
 
+	switch (rk808->variant) {
+	case RK809_ID:
+	case RK817_ID:
+		rk808_rtc->creg = &rk817_creg;
+		break;
+	default:
+		rk808_rtc->creg = &rk808_creg;
+		break;
+	}
 	platform_set_drvdata(pdev, rk808_rtc);
 	rk808_rtc->rk808 = rk808;
 
 	/* start rtc running by default, and use shadowed timer. */
-	ret = regmap_update_bits(rk808->regmap, RK808_RTC_CTRL_REG,
+	ret = regmap_update_bits(rk808->regmap, rk808_rtc->creg->ctrl_reg,
 				 BIT_RTC_CTRL_REG_STOP_RTC_M |
 				 BIT_RTC_CTRL_REG_RTC_READSEL_M,
 				 BIT_RTC_CTRL_REG_RTC_READSEL_M);
@@ -396,7 +459,7 @@ static int rk808_rtc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = regmap_write(rk808->regmap, RK808_RTC_STATUS_REG,
+	ret = regmap_write(rk808->regmap, rk808_rtc->creg->status_reg,
 			   RTC_STATUS_MASK);
 	if (ret) {
 		dev_err(&pdev->dev,
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 9116cb293c7d..0f1c150a1d9d 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -25,7 +25,8 @@
 #define CLK_SET_PARENT_GATE	BIT(1) /* must be gated across re-parent */
 #define CLK_SET_RATE_PARENT	BIT(2) /* propagate rate change up one level */
 #define CLK_IGNORE_UNUSED	BIT(3) /* do not gate even if unused */
-				/* unused */
+				/* unused for CE kernel, but added from HK */
+#define CLK_IS_ROOT               BIT(4) /* root clk, has no parent */
 #define CLK_IS_BASIC		BIT(5) /* Basic clk, can't do a to_clk_foo() */
 #define CLK_GET_RATE_NOCACHE	BIT(6) /* do not use the cached clk rate */
 #define CLK_SET_RATE_NO_REPARENT BIT(7) /* don't re-parent on rate change */
diff --git a/include/linux/extcon.h b/include/linux/extcon.h
index 291345187854..472d73f27d99 100644
--- a/include/linux/extcon.h
+++ b/include/linux/extcon.h
@@ -45,6 +45,7 @@
 /* USB external connector */
 #define EXTCON_USB		1
 #define EXTCON_USB_HOST		2
+#define EXTCON_USB_VBUS_EN	3
 
 /* Charging external connector */
 #define EXTCON_CHG_USB_SDP	5	/* Standard Downstream Port */
diff --git a/include/linux/mfd/rk808.h b/include/linux/mfd/rk808.h
index 6d435a3c06bc..b433c7359734 100644
--- a/include/linux/mfd/rk808.h
+++ b/include/linux/mfd/rk808.h
@@ -1,15 +1,11 @@
 /*
- * Register definitions for Rockchip's RK808/RK818 PMIC
+ * rk808.h for Rockchip RK808
  *
  * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
  *
  * Author: Chris Zhong <zyw@rock-chips.com>
  * Author: Zhang Qing <zhangqing@rock-chips.com>
  *
- * Copyright (C) 2016 PHYTEC Messtechnik GmbH
- *
- * Author: Wadim Egorov <w.egorov@phytec.de>
- *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
@@ -20,8 +16,8 @@
  * more details.
  */
 
-#ifndef __LINUX_REGULATOR_RK808_H
-#define __LINUX_REGULATOR_RK808_H
+#ifndef __LINUX_REGULATOR_rk808_H
+#define __LINUX_REGULATOR_rk808_H
 
 #include <linux/regulator/machine.h>
 #include <linux/regmap.h>
@@ -32,7 +28,7 @@
 
 #define RK808_DCDC1	0 /* (0+RK808_START) */
 #define RK808_LDO1	4 /* (4+RK808_START) */
-#define RK808_NUM_REGULATORS	14
+#define RK808_NUM_REGULATORS   14
 
 enum rk808_reg {
 	RK808_ID_DCDC1,
@@ -51,6 +47,49 @@ enum rk808_reg {
 	RK808_ID_SWITCH2,
 };
 
+enum rk816_reg {
+	RK816_ID_DCDC1,
+	RK816_ID_DCDC2,
+	RK816_ID_DCDC3,
+	RK816_ID_DCDC4,
+	RK816_ID_LDO1,
+	RK816_ID_LDO2,
+	RK816_ID_LDO3,
+	RK816_ID_LDO4,
+	RK816_ID_LDO5,
+	RK816_ID_LDO6,
+};
+
+enum rk818_reg {
+	RK818_ID_DCDC1,
+	RK818_ID_DCDC2,
+	RK818_ID_DCDC3,
+	RK818_ID_DCDC4,
+	RK818_ID_BOOST,
+	RK818_ID_LDO1,
+	RK818_ID_LDO2,
+	RK818_ID_LDO3,
+	RK818_ID_LDO4,
+	RK818_ID_LDO5,
+	RK818_ID_LDO6,
+	RK818_ID_LDO7,
+	RK818_ID_LDO8,
+	RK818_ID_LDO9,
+	RK818_ID_SWITCH,
+	RK818_ID_HDMI_SWITCH,
+	RK818_ID_OTG_SWITCH,
+};
+
+enum rk805_reg {
+	RK805_ID_DCDC1,
+	RK805_ID_DCDC2,
+	RK805_ID_DCDC3,
+	RK805_ID_DCDC4,
+	RK805_ID_LDO1,
+	RK805_ID_LDO2,
+	RK805_ID_LDO3,
+};
+
 #define RK808_SECONDS_REG	0x00
 #define RK808_MINUTES_REG	0x01
 #define RK808_HOURS_REG		0x02
@@ -121,31 +160,8 @@ enum rk808_reg {
 #define RK808_INT_STS_MSK_REG2	0x4f
 #define RK808_IO_POL_REG	0x50
 
-/* RK818 */
-#define RK818_DCDC1			0
-#define RK818_LDO1			4
-#define RK818_NUM_REGULATORS		17
-
-enum rk818_reg {
-	RK818_ID_DCDC1,
-	RK818_ID_DCDC2,
-	RK818_ID_DCDC3,
-	RK818_ID_DCDC4,
-	RK818_ID_BOOST,
-	RK818_ID_LDO1,
-	RK818_ID_LDO2,
-	RK818_ID_LDO3,
-	RK818_ID_LDO4,
-	RK818_ID_LDO5,
-	RK818_ID_LDO6,
-	RK818_ID_LDO7,
-	RK818_ID_LDO8,
-	RK818_ID_LDO9,
-	RK818_ID_SWITCH,
-	RK818_ID_HDMI_SWITCH,
-	RK818_ID_OTG_SWITCH,
-};
-
+#define RK818_VB_MON_REG		0x21
+#define RK818_THERMAL_REG		0x22
 #define RK818_DCDC_EN_REG		0x23
 #define RK818_LDO_EN_REG		0x24
 #define RK818_SLEEP_SET_OFF_REG1	0x25
@@ -184,29 +200,99 @@ enum rk818_reg {
 #define RK818_LDO7_SLP_VSEL_REG		0x48
 #define RK818_LDO8_ON_VSEL_REG		0x49
 #define RK818_LDO8_SLP_VSEL_REG		0x4a
-#define RK818_BOOST_LDO9_ON_VSEL_REG	0x54
-#define RK818_BOOST_LDO9_SLP_VSEL_REG	0x55
 #define RK818_DEVCTRL_REG		0x4b
 #define RK818_INT_STS_REG1		0X4c
-#define RK818_INT_STS_MSK_REG1		0x4d
-#define RK818_INT_STS_REG2		0x4e
-#define RK818_INT_STS_MSK_REG2		0x4f
-#define RK818_IO_POL_REG		0x50
+#define RK818_INT_STS_MSK_REG1		0X4d
+#define RK818_INT_STS_REG2		0X4e
+#define RK818_INT_STS_MSK_REG2		0X4f
+#define RK818_IO_POL_REG		0X50
+#define RK818_OTP_VDD_EN_REG		0x51
 #define RK818_H5V_EN_REG		0x52
 #define RK818_SLEEP_SET_OFF_REG3	0x53
 #define RK818_BOOST_LDO9_ON_VSEL_REG	0x54
 #define RK818_BOOST_LDO9_SLP_VSEL_REG	0x55
 #define RK818_BOOST_CTRL_REG		0x56
-#define RK818_DCDC_ILMAX		0x90
+#define RK818_DCDC_ILMAX_REG		0x90
+#define RK818_CHRG_COMP_REG		0x9a
+#define RK818_SUP_STS_REG		0xa0
 #define RK818_USB_CTRL_REG		0xa1
+#define RK818_CHRG_CTRL_REG1		0xa3
+#define RK818_CHRG_CTRL_REG2		0xa4
+#define RK818_CHRG_CTRL_REG3		0xa5
+#define RK818_BAT_CTRL_REG		0xa6
+#define RK818_BAT_HTS_TS1_REG		0xa8
+#define RK818_BAT_LTS_TS1_REG		0xa9
+#define RK818_BAT_HTS_TS2_REG		0xaa
+#define RK818_BAT_LTS_TS2_REG		0xab
+#define RK818_TS_CTRL_REG		0xac
+#define RK818_ADC_CTRL_REG		0xad
+#define RK818_ON_SOURCE_REG		0xae
+#define RK818_OFF_SOURCE_REG		0xaf
+#define RK818_GGCON_REG			0xb0
+#define RK818_GGSTS_REG			0xb1
+#define RK818_FRAME_SMP_INTERV_REG	0xb2
+#define RK818_AUTO_SLP_CUR_THR_REG	0xb3
+#define RK818_GASCNT_CAL_REG3		0xb4
+#define RK818_GASCNT_CAL_REG2		0xb5
+#define RK818_GASCNT_CAL_REG1		0xb6
+#define RK818_GASCNT_CAL_REG0		0xb7
+#define RK818_GASCNT3_REG		0xb8
+#define RK818_GASCNT2_REG		0xb9
+#define RK818_GASCNT1_REG		0xba
+#define RK818_GASCNT0_REG		0xbb
+#define RK818_BAT_CUR_AVG_REGH		0xbc
+#define RK818_BAT_CUR_AVG_REGL		0xbd
+#define RK818_TS1_ADC_REGH		0xbe
+#define RK818_TS1_ADC_REGL		0xbf
+#define RK818_TS2_ADC_REGH		0xc0
+#define RK818_TS2_ADC_REGL		0xc1
+#define RK818_BAT_OCV_REGH		0xc2
+#define RK818_BAT_OCV_REGL		0xc3
+#define RK818_BAT_VOL_REGH		0xc4
+#define RK818_BAT_VOL_REGL		0xc5
+#define RK818_RELAX_ENTRY_THRES_REGH	0xc6
+#define RK818_RELAX_ENTRY_THRES_REGL	0xc7
+#define RK818_RELAX_EXIT_THRES_REGH	0xc8
+#define RK818_RELAX_EXIT_THRES_REGL	0xc9
+#define RK818_RELAX_VOL1_REGH		0xca
+#define RK818_RELAX_VOL1_REGL		0xcb
+#define RK818_RELAX_VOL2_REGH		0xcc
+#define RK818_RELAX_VOL2_REGL		0xcd
+#define RK818_BAT_CUR_R_CALC_REGH	0xce
+#define RK818_BAT_CUR_R_CALC_REGL	0xcf
+#define RK818_BAT_VOL_R_CALC_REGH	0xd0
+#define RK818_BAT_VOL_R_CALC_REGL	0xd1
+#define RK818_CAL_OFFSET_REGH		0xd2
+#define RK818_CAL_OFFSET_REGL		0xd3
+#define RK818_NON_ACT_TIMER_CNT_REG	0xd4
+#define RK818_VCALIB0_REGH		0xd5
+#define RK818_VCALIB0_REGL		0xd6
+#define RK818_VCALIB1_REGH		0xd7
+#define RK818_VCALIB1_REGL		0xd8
+#define RK818_IOFFSET_REGH		0xdd
+#define RK818_IOFFSET_REGL		0xde
+#define RK818_SOC_REG			0xe0
+#define RK818_REMAIN_CAP_REG3		0xe1
+#define RK818_REMAIN_CAP_REG2		0xe2
+#define RK818_REMAIN_CAP_REG1		0xe3
+#define RK818_REMAIN_CAP_REG0		0xe4
+#define RK818_UPDAT_LEVE_REG		0xe5
+#define RK818_NEW_FCC_REG3		0xe6
+#define RK818_NEW_FCC_REG2		0xe7
+#define RK818_NEW_FCC_REG1		0xe8
+#define RK818_NEW_FCC_REG0		0xe9
+#define RK818_NON_ACT_TIMER_CNT_SAVE_REG 0xea
+#define RK818_OCV_VOL_VALID_REG		0xeb
+#define RK818_REBOOT_CNT_REG		0xec
+#define RK818_POFFSET_REG		0xed
+#define RK818_MISC_MARK_REG		0xee
+#define RK818_HALT_CNT_REG		0xef
+#define RK818_CALC_REST_REGH		0xf0
+#define RK818_CALC_REST_REGL		0xf1
+#define RK818_SAVE_DATA19		0xf2
+#define RK818_NUM_REGULATORS		17
 
-#define RK818_H5V_EN			BIT(0)
-#define RK818_REF_RDY_CTRL		BIT(1)
-#define RK818_USB_ILIM_SEL_MASK		0xf
-#define RK818_USB_ILMIN_2000MA		0x7
-#define RK818_USB_CHG_SD_VSEL_MASK	0x70
-
-/* RK808 IRQ Definitions */
+/* IRQ Definitions */
 #define RK808_IRQ_VOUT_LO	0
 #define RK808_IRQ_VB_LO		1
 #define RK808_IRQ_PWRON		2
@@ -228,43 +314,6 @@ enum rk818_reg {
 #define RK808_IRQ_PLUG_IN_INT_MSK	BIT(0)
 #define RK808_IRQ_PLUG_OUT_INT_MSK	BIT(1)
 
-/* RK818 IRQ Definitions */
-#define RK818_IRQ_VOUT_LO	0
-#define RK818_IRQ_VB_LO		1
-#define RK818_IRQ_PWRON		2
-#define RK818_IRQ_PWRON_LP	3
-#define RK818_IRQ_HOTDIE	4
-#define RK818_IRQ_RTC_ALARM	5
-#define RK818_IRQ_RTC_PERIOD	6
-#define RK818_IRQ_USB_OV	7
-#define RK818_IRQ_PLUG_IN	8
-#define RK818_IRQ_PLUG_OUT	9
-#define RK818_IRQ_CHG_OK	10
-#define RK818_IRQ_CHG_TE	11
-#define RK818_IRQ_CHG_TS1	12
-#define RK818_IRQ_TS2		13
-#define RK818_IRQ_CHG_CVTLIM	14
-#define RK818_IRQ_DISCHG_ILIM	15
-
-#define RK818_IRQ_VOUT_LO_MSK		BIT(0)
-#define RK818_IRQ_VB_LO_MSK		BIT(1)
-#define RK818_IRQ_PWRON_MSK		BIT(2)
-#define RK818_IRQ_PWRON_LP_MSK		BIT(3)
-#define RK818_IRQ_HOTDIE_MSK		BIT(4)
-#define RK818_IRQ_RTC_ALARM_MSK		BIT(5)
-#define RK818_IRQ_RTC_PERIOD_MSK	BIT(6)
-#define RK818_IRQ_USB_OV_MSK		BIT(7)
-#define RK818_IRQ_PLUG_IN_MSK		BIT(0)
-#define RK818_IRQ_PLUG_OUT_MSK		BIT(1)
-#define RK818_IRQ_CHG_OK_MSK		BIT(2)
-#define RK818_IRQ_CHG_TE_MSK		BIT(3)
-#define RK818_IRQ_CHG_TS1_MSK		BIT(4)
-#define RK818_IRQ_TS2_MSK		BIT(5)
-#define RK818_IRQ_CHG_CVTLIM_MSK	BIT(6)
-#define RK818_IRQ_DISCHG_ILIM_MSK	BIT(7)
-
-#define RK818_NUM_IRQ		16
-
 #define RK808_VBAT_LOW_2V8	0x00
 #define RK808_VBAT_LOW_2V9	0x01
 #define RK808_VBAT_LOW_3V0	0x02
@@ -290,12 +339,619 @@ enum rk818_reg {
 #define SWITCH2_EN	BIT(6)
 #define SWITCH1_EN	BIT(5)
 #define DEV_OFF_RST	BIT(3)
+#define DEV_OFF		BIT(0)
+#define RTC_STOP	BIT(0)
 
 #define VB_LO_ACT		BIT(4)
 #define VB_LO_SEL_3500MV	(7 << 0)
 
 #define VOUT_LO_INT	BIT(0)
 #define CLK32KOUT2_EN	BIT(0)
+#define CLK32KOUT2_FUNC		(0 << 1)
+#define CLK32KOUT2_FUNC_MASK	BIT(1)
+#define H5V_EN_MASK		BIT(0)
+#define H5V_EN_ENABLE		BIT(0)
+#define REF_RDY_CTRL_MASK	BIT(1)
+#define REF_RDY_CTRL_ENABLE	BIT(1)
+
+/*RK818_DCDC_EN_REG*/
+#define BUCK1_EN_MASK		BIT(0)
+#define BUCK2_EN_MASK		BIT(1)
+#define BUCK3_EN_MASK		BIT(2)
+#define BUCK4_EN_MASK		BIT(3)
+#define BOOST_EN_MASK		BIT(4)
+#define LDO9_EN_MASK		BIT(5)
+#define SWITCH_EN_MASK		BIT(6)
+#define OTG_EN_MASK		BIT(7)
+
+#define BUCK1_EN_ENABLE		BIT(0)
+#define BUCK2_EN_ENABLE		BIT(1)
+#define BUCK3_EN_ENABLE		BIT(2)
+#define BUCK4_EN_ENABLE		BIT(3)
+#define BOOST_EN_ENABLE		BIT(4)
+#define LDO9_EN_ENABLE		BIT(5)
+#define SWITCH_EN_ENABLE	BIT(6)
+#define OTG_EN_ENABLE		BIT(7)
+
+/* IRQ Definitions */
+#define RK818_IRQ_VOUT_LO	0
+#define RK818_IRQ_VB_LO		1
+#define RK818_IRQ_PWRON		2
+#define RK818_IRQ_PWRON_LP	3
+#define RK818_IRQ_HOTDIE	4
+#define RK818_IRQ_RTC_ALARM	5
+#define RK818_IRQ_RTC_PERIOD	6
+#define RK818_IRQ_USB_OV	7
+#define RK818_IRQ_PLUG_IN	8
+#define RK818_IRQ_PLUG_OUT	9
+#define RK818_IRQ_CHG_OK	10
+#define RK818_IRQ_CHG_TE	11
+#define RK818_IRQ_CHG_TS1	12
+#define RK818_IRQ_TS2		13
+#define RK818_IRQ_CHG_CVTLIM	14
+#define RK818_IRQ_DISCHG_ILIM	15
+
+#define BUCK1_SLP_SET_MASK	BIT(0)
+#define BUCK2_SLP_SET_MASK	BIT(1)
+#define BUCK3_SLP_SET_MASK	BIT(2)
+#define BUCK4_SLP_SET_MASK	BIT(3)
+#define BOOST_SLP_SET_MASK	BIT(4)
+#define LDO9_SLP_SET_MASK	BIT(5)
+#define SWITCH_SLP_SET_MASK	BIT(6)
+#define OTG_SLP_SET_MASK	BIT(7)
+
+#define BUCK1_SLP_SET_OFF	BIT(0)
+#define BUCK2_SLP_SET_OFF	BIT(1)
+#define BUCK3_SLP_SET_OFF	BIT(2)
+#define BUCK4_SLP_SET_OFF	BIT(3)
+#define BOOST_SLP_SET_OFF	BIT(4)
+#define LDO9_SLP_SET_OFF	BIT(5)
+#define SWITCH_SLP_SET_OFF	BIT(6)
+#define OTG_SLP_SET_OFF		BIT(7)
+#define OTG_BOOST_SLP_OFF	(BOOST_SLP_SET_OFF | OTG_SLP_SET_OFF)
+
+#define BUCK1_SLP_SET_ON	BIT(0)
+#define BUCK2_SLP_SET_ON	BIT(1)
+#define BUCK3_SLP_SET_ON	BIT(2)
+#define BUCK4_SLP_SET_ON	BIT(3)
+#define BOOST_SLP_SET_ON	BIT(4)
+#define LDO9_SLP_SET_ON		BIT(5)
+#define SWITCH_SLP_SET_ON	BIT(6)
+#define OTG_SLP_SET_ON		BIT(7)
+
+#define VOUT_LO_MASK		BIT(0)
+#define VB_LO_MASK		BIT(1)
+#define PWRON_MASK		BIT(2)
+#define PWRON_LP_MASK		BIT(3)
+#define HOTDIE_MASK		BIT(4)
+#define RTC_ALARM_MASK		BIT(5)
+#define RTC_PERIOD_MASK		BIT(6)
+#define USB_OV_MASK		BIT(7)
+
+#define VOUT_LO_DISABLE		BIT(0)
+#define VB_LO_DISABLE		BIT(1)
+#define PWRON_DISABLE		BIT(2)
+#define PWRON_LP_DISABLE	BIT(3)
+#define HOTDIE_DISABLE		BIT(4)
+#define RTC_ALARM_DISABLE	BIT(5)
+#define RTC_PERIOD_DISABLE	BIT(6)
+#define USB_OV_INT_DISABLE	BIT(7)
+
+#define VOUT_LO_ENABLE		(0 << 0)
+#define VB_LO_ENABLE		(0 << 1)
+#define PWRON_ENABLE		(0 << 2)
+#define PWRON_LP_ENABLE		(0 << 3)
+#define HOTDIE_ENABLE		(0 << 4)
+#define RTC_ALARM_ENABLE	(0 << 5)
+#define RTC_PERIOD_ENABLE	(0 << 6)
+#define USB_OV_INT_ENABLE	(0 << 7)
+
+#define PLUG_IN_MASK		BIT(0)
+#define PLUG_OUT_MASK		BIT(1)
+#define CHGOK_MASK		BIT(2)
+#define CHGTE_MASK		BIT(3)
+#define CHGTS1_MASK		BIT(4)
+#define TS2_MASK		BIT(5)
+#define CHG_CVTLIM_MASK		BIT(6)
+#define DISCHG_ILIM_MASK	BIT(7)
+
+#define PLUG_IN_DISABLE		BIT(0)
+#define PLUG_OUT_DISABLE	BIT(1)
+#define CHGOK_DISABLE		BIT(2)
+#define CHGTE_DISABLE		BIT(3)
+#define CHGTS1_DISABLE		BIT(4)
+#define TS2_DISABLE		BIT(5)
+#define CHG_CVTLIM_DISABLE	BIT(6)
+#define DISCHG_ILIM_DISABLE	BIT(7)
+
+#define PLUG_IN_ENABLE		BIT(0)
+#define PLUG_OUT_ENABLE		BIT(1)
+#define CHGOK_ENABLE		BIT(2)
+#define CHGTE_ENABLE		BIT(3)
+#define CHGTS1_ENABLE		BIT(4)
+#define TS2_ENABLE		BIT(5)
+#define CHG_CVTLIM_ENABLE	BIT(6)
+#define DISCHG_ILIM_ENABLE	BIT(7)
+
+/* IRQ Definitions */
+#define RK805_IRQ_VB_LOW		1
+#define RK805_IRQ_PWRON			2
+#define RK805_IRQ_PWRON_LP		3
+#define RK805_IRQ_HOTDIE		4
+#define RK805_IRQ_RTC_ALARM		5
+#define RK805_IRQ_RTC_PERIOD		6
+
+/*
+ * When PMIC irq occurs, regmap-irq.c will traverse all PMIC child
+ * interrupts from low index 0 to high index, we give fall interrupt
+ * high priority to be called earlier than rise, so that it can be
+ * override by late rise event. This can helps to solve key release
+ * glitch which make a wrongly fall event immediately after rise.
+ */
+#define RK805_IRQ_PWRON_FALL		0
+#define RK805_IRQ_PWRON_RISE		7
+
+#define RK805_IRQ_PWRON_RISE_MSK	BIT(0)
+#define RK805_IRQ_VB_LOW_MSK		BIT(1)
+#define RK805_IRQ_PWRON_MSK		BIT(2)
+#define RK805_IRQ_PWRON_LP_MSK		BIT(3)
+#define RK805_IRQ_HOTDIE_MSK		BIT(4)
+#define RK805_IRQ_RTC_ALARM_MSK		BIT(5)
+#define RK805_IRQ_RTC_PERIOD_MSK	BIT(6)
+#define RK805_IRQ_PWRON_FALL_MSK	BIT(7)
+
+#define RK805_PWR_RISE_INT_STATUS	BIT(0)
+#define RK805_VB_LOW_INT_STATUS		BIT(1)
+#define RK805_PWRON_INT_STATUS		BIT(2)
+#define RK805_PWRON_LP_INT_STATUS	BIT(3)
+#define RK805_HOTDIE_INT_STATUS		BIT(4)
+#define RK805_ALARM_INT_STATUS		BIT(5)
+#define RK805_PERIOD_INT_STATUS		BIT(6)
+#define RK805_PWR_FALL_INT_STATUS	BIT(7)
+
+/*INTERRUPT REGISTER*/
+#define RK805_INT_STS_REG		0x4C
+#define RK805_INT_STS_MSK_REG		0x4D
+#define RK805_GPIO_IO_POL_REG		0x50
+#define RK805_OUT_REG			0x52
+#define RK805_ON_SOURCE_REG		0xAE
+#define RK805_OFF_SOURCE_REG		0xAF
+
+/*POWER CHANNELS ENABLE REGISTER*/
+#define RK805_DCDC_EN_REG		0x23
+#define RK805_SLP_DCDC_EN_REG		0x25
+#define RK805_SLP_LDO_EN_REG		0x26
+#define RK805_LDO_EN_REG		0x27
+
+/*CONFIG REGISTER*/
+#define RK805_THERMAL_REG		0x22
+
+/*BUCK AND LDO CONFIG REGISTER*/
+#define RK805_BUCK_LDO_SLP_LP_EN_REG	0x2A
+#define RK805_BUCK1_CONFIG_REG		0x2E
+#define RK805_BUCK1_ON_VSEL_REG		0x2F
+#define RK805_BUCK1_SLP_VSEL_REG	0x30
+#define RK805_BUCK2_CONFIG_REG		0x32
+#define RK805_BUCK2_ON_VSEL_REG		0x33
+#define RK805_BUCK2_SLP_VSEL_REG	0x34
+#define RK805_BUCK3_CONFIG_REG		0x36
+#define RK805_BUCK4_CONFIG_REG		0x37
+#define RK805_BUCK4_ON_VSEL_REG		0x38
+#define RK805_BUCK4_SLP_VSEL_REG	0x39
+#define RK805_LDO1_ON_VSEL_REG		0x3B
+#define RK805_LDO1_SLP_VSEL_REG		0x3C
+#define RK805_LDO2_ON_VSEL_REG		0x3D
+#define RK805_LDO2_SLP_VSEL_REG		0x3E
+#define RK805_LDO3_ON_VSEL_REG		0x3F
+#define RK805_LDO3_SLP_VSEL_REG		0x40
+#define RK805_OUT_REG			0x52
+#define RK805_ON_SOURCE_REG		0xAE
+#define RK805_OFF_SOURCE_REG		0xAF
+#define RK805_DCDC_VRP_REG		0x92
+
+#define RK805_NUM_REGULATORS		7
+
+#define RK805_PWRON_FALL_RISE_INT_EN	0x0
+#define RK805_PWRON_FALL_RISE_INT_MSK	0x81
+
+/*VERSION REGISTER*/
+#define RK816_CHIP_NAME_REG			0x17
+#define RK816_CHIP_VER_REG			0x18
+#define RK816_OTP_VER_REG			0x19
+#define RK816_NUM_REGULATORS			10
+
+/*POWER ON/OFF REGISTER*/
+#define RK816_VB_MON_REG			0x21
+#define RK816_THERMAL_REG			0x22
+#define RK816_PWRON_LP_INT_TIME_REG		0x47
+#define RK816_PWRON_DB_REG			0x48
+#define RK816_DEV_CTRL_REG			0x4B
+#define RK816_ON_SOURCE_REG			0xAE
+#define RK816_OFF_SOURCE_REG			0xAF
+
+/*POWER CHANNELS ENABLE REGISTER*/
+#define RK816_DCDC_EN_REG1			0x23
+#define RK816_DCDC_EN_REG2			0x24
+#define RK816_SLP_DCDC_EN_REG			0x25
+#define RK816_SLP_LDO_EN_REG			0x26
+#define RK816_LDO_EN_REG1			0x27
+#define RK816_LDO_EN_REG2			0x28
+
+/*BUCK AND LDO CONFIG REGISTER*/
+#define RK816_BUCK1_CONFIG_REG			0x2E
+#define RK816_BUCK1_ON_VSEL_REG			0x2F
+#define RK816_BUCK1_SLP_VSEL_REG		0x30
+#define RK816_BUCK2_CONFIG_REG			0x32
+#define RK816_BUCK2_ON_VSEL_REG			0x33
+#define RK816_BUCK2_SLP_VSEL_REG		0x34
+#define RK816_BUCK3_CONFIG_REG			0x36
+#define RK816_BUCK4_CONFIG_REG			0x37
+#define RK816_BUCK4_ON_VSEL_REG			0x38
+#define RK816_BUCK4_SLP_VSEL_REG		0x39
+#define RK816_LDO1_ON_VSEL_REG			0x3B
+#define RK816_LDO1_SLP_VSEL_REG			0x3C
+#define RK816_LDO2_ON_VSEL_REG			0x3D
+#define RK816_LDO2_SLP_VSEL_REG			0x3E
+#define RK816_LDO3_ON_VSEL_REG			0x3F
+#define RK816_LDO3_SLP_VSEL_REG			0x40
+#define RK816_LDO4_ON_VSEL_REG			0x41
+#define RK816_LDO4_SLP_VSEL_REG			0x42
+#define RK816_LDO5_ON_VSEL_REG			0x43
+#define RK816_LDO5_SLP_VSEL_REG			0x44
+#define RK816_LDO6_ON_VSEL_REG			0x45
+#define RK816_LDO6_SLP_VSEL_REG			0x46
+
+/*CHARGER BOOST AND OTG REGISTER*/
+#define RK816_OTG_BUCK_LDO_CONFIG_REG           0x2A
+#define RK816_CHRG_CONFIG_REG                   0x2B
+#define RK816_BOOST_ON_VESL_REG                 0x54
+#define RK816_BOOST_SLP_VSEL_REG                0x55
+#define RK816_CHRG_BOOST_CONFIG_REG             0x9A
+#define RK816_SUP_STS_REG                       0xA0
+#define RK816_USB_CTRL_REG                      0xA1
+#define RK816_CHRG_CTRL_REG1                    0xA3
+#define RK816_CHRG_CTRL_REG2                    0xA4
+#define RK816_CHRG_CTRL_REG3                    0xA5
+#define RK816_BAT_CTRL_REG                      0xA6
+#define RK816_BAT_HTS_TS_REG                    0xA8
+#define RK816_BAT_LTS_TS_REG                    0xA9
+
+#define RK816_TS_CTRL_REG			0xAC
+#define RK816_ADC_CTRL_REG			0xAD
+#define RK816_GGCON_REG				0xB0
+#define RK816_GGSTS_REG				0xB1
+#define RK816_ZERO_CUR_ADC_REGH			0xB2
+#define RK816_ZERO_CUR_ADC_REGL			0xB3
+#define RK816_GASCNT_CAL_REG3			0xB4
+#define RK816_GASCNT_CAL_REG2			0xB5
+#define RK816_GASCNT_CAL_REG1			0xB6
+#define RK816_GASCNT_CAL_REG0			0xB7
+#define RK816_GASCNT_REG3			0xB8
+#define RK816_GASCNT_REG2			0xB9
+#define RK816_GASCNT_REG1			0xBA
+#define RK816_GASCNT_REG0			0xBB
+#define RK816_BAT_CUR_AVG_REGH			0xBC
+#define RK816_BAT_CUR_AVG_REGL			0xBD
+#define RK816_TS_ADC_REGH			0xBE
+#define RK816_TS_ADC_REGL			0xBF
+#define RK816_USB_ADC_REGH			0xC0
+#define RK816_USB_ADC_REGL			0xC1
+#define RK816_BAT_OCV_REGH			0xC2
+#define RK816_BAT_OCV_REGL			0xC3
+#define RK816_BAT_VOL_REGH			0xC4
+#define RK816_BAT_VOL_REGL			0xC5
+#define RK816_RELAX_ENTRY_THRES_REGH		0xC6
+#define RK816_RELAX_ENTRY_THRES_REGL		0xC7
+#define RK816_RELAX_EXIT_THRES_REGH		0xC8
+#define RK816_RELAX_EXIT_THRES_REGL		0xC9
+#define RK816_RELAX_VOL1_REGH			0xCA
+#define RK816_RELAX_VOL1_REGL			0xCB
+#define RK816_RELAX_VOL2_REGH			0xCC
+#define RK816_RELAX_VOL2_REGL			0xCD
+#define RK816_RELAX_CUR1_REGH			0xCE
+#define RK816_RELAX_CUR1_REGL			0xCF
+#define RK816_RELAX_CUR2_REGH			0xD0
+#define RK816_RELAX_CUR2_REGL			0xD1
+#define RK816_CAL_OFFSET_REGH			0xD2
+#define RK816_CAL_OFFSET_REGL			0xD3
+#define RK816_NON_ACT_TIMER_CNT_REG		0xD4
+#define RK816_VCALIB0_REGH			0xD5
+#define RK816_VCALIB0_REGL			0xD6
+#define RK816_VCALIB1_REGH			0xD7
+#define RK816_VCALIB1_REGL			0xD8
+#define RK816_FCC_GASCNT_REG3			0xD9
+#define RK816_FCC_GASCNT_REG2			0xDA
+#define RK816_FCC_GASCNT_REG1			0xDB
+#define RK816_FCC_GASCNT_REG0			0xDC
+#define RK816_IOFFSET_REGH			0xDD
+#define RK816_IOFFSET_REGL			0xDE
+#define RK816_SLEEP_CON_SAMP_CUR_REG		0xDF
+
+/*DATA REGISTER*/
+#define RK816_SOC_REG				0xE0
+#define	RK816_REMAIN_CAP_REG3			0xE1
+#define	RK816_REMAIN_CAP_REG2			0xE2
+#define	RK816_REMAIN_CAP_REG1			0xE3
+#define	RK816_REMAIN_CAP_REG0			0xE4
+#define	RK816_UPDATE_LEVE_REG			0xE5
+#define	RK816_NEW_FCC_REG3			0xE6
+#define	RK816_NEW_FCC_REG2			0xE7
+#define	RK816_NEW_FCC_REG1			0xE8
+#define	RK816_NEW_FCC_REG0			0xE9
+#define RK816_NON_ACT_TIMER_CNT_REG_SAVE	0xEA
+#define RK816_OCV_VOL_VALID_REG			0xEB
+#define RK816_REBOOT_CNT_REG			0xEC
+#define RK816_PCB_IOFFSET_REG			0xED
+#define RK816_MISC_MARK_REG			0xEE
+#define RK816_HALT_CNT_REG			0xEF
+#define RK816_CALC_REST_REGH			0xF0
+#define RK816_CALC_REST_REGL			0xF1
+#define DATA18_REG				0xF2
+
+/*INTERRUPT REGISTER*/
+#define RK816_INT_STS_REG1			0x49
+#define RK816_INT_STS_MSK_REG1			0x4A
+#define RK816_INT_STS_REG2			0x4C
+#define RK816_INT_STS_MSK_REG2			0x4D
+#define RK816_INT_STS_REG3			0x4E
+#define RK816_INT_STS_MSK_REG3			0x4F
+#define RK816_GPIO_IO_POL_REG			0x50
+
+#define RK816_DATA18_REG			0xF2
+
+/* IRQ Definitions */
+#define RK816_IRQ_PWRON_FALL			0
+#define RK816_IRQ_PWRON_RISE			1
+#define RK816_IRQ_VB_LOW			2
+#define RK816_IRQ_PWRON				3
+#define RK816_IRQ_PWRON_LP			4
+#define RK816_IRQ_HOTDIE			5
+#define RK816_IRQ_RTC_ALARM			6
+#define RK816_IRQ_RTC_PERIOD			7
+#define RK816_IRQ_USB_OV			8
+#define RK816_IRQ_PLUG_IN			9
+#define RK816_IRQ_PLUG_OUT			10
+#define RK816_IRQ_CHG_OK			11
+#define RK816_IRQ_CHG_TE			12
+#define RK816_IRQ_CHG_TS			13
+#define RK816_IRQ_CHG_CVTLIM			14
+#define RK816_IRQ_DISCHG_ILIM			15
+
+#define RK816_IRQ_PWRON_FALL_MSK		BIT(5)
+#define RK816_IRQ_PWRON_RISE_MSK		BIT(6)
+#define RK816_IRQ_VB_LOW_MSK			BIT(1)
+#define RK816_IRQ_PWRON_MSK			BIT(2)
+#define RK816_IRQ_PWRON_LP_MSK			BIT(3)
+#define RK816_IRQ_HOTDIE_MSK			BIT(4)
+#define RK816_IRQ_RTC_ALARM_MSK			BIT(5)
+#define RK816_IRQ_RTC_PERIOD_MSK		BIT(6)
+#define RK816_IRQ_USB_OV_MSK			BIT(7)
+#define RK816_IRQ_PLUG_IN_MSK			BIT(0)
+#define RK816_IRQ_PLUG_OUT_MSK			BIT(1)
+#define RK816_IRQ_CHG_OK_MSK			BIT(2)
+#define RK816_IRQ_CHG_TE_MSK			BIT(3)
+#define RK816_IRQ_CHG_TS_MSK			BIT(4)
+#define RK816_IRQ_CHG_CVTLIM_MSK		BIT(6)
+#define RK816_IRQ_DISCHG_ILIM_MSK		BIT(7)
+
+#define RK816_VBAT_LOW_2V8			0x00
+#define RK816_VBAT_LOW_2V9			0x01
+#define RK816_VBAT_LOW_3V0			0x02
+#define RK816_VBAT_LOW_3V1			0x03
+#define RK816_VBAT_LOW_3V2			0x04
+#define RK816_VBAT_LOW_3V3			0x05
+#define RK816_VBAT_LOW_3V4			0x06
+#define RK816_VBAT_LOW_3V5			0x07
+#define RK816_PWR_FALL_INT_STATUS		(0x1 << 5)
+#define RK816_PWR_RISE_INT_STATUS		(0x1 << 6)
+#define RK816_ALARM_INT_STATUS			(0x1 << 5)
+#define EN_VBAT_LOW_IRQ				(0x1 << 4)
+#define VBAT_LOW_ACT_MASK			(0x1 << 4)
+#define RTC_TIMER_ALARM_INT_MSK			(0x3 << 2)
+#define RTC_TIMER_ALARM_INT_DIS			(0x0 << 2)
+#define RTC_PERIOD_ALARM_INT_MSK		(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_ST			(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_DIS		(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_EN			(0x9f)
+#define REG_WRITE_MSK				0xff
+#define BUCK4_MAX_ILIMIT			0x2c
+#define BUCK_RATE_MSK				(0x3 << 3)
+#define BUCK_RATE_12_5MV_US			(0x2 << 3)
+#define ALL_INT_FLAGS_ST			0xff
+#define PLUGIN_OUT_INT_EN			0xfc
+#define RK816_PWRON_FALL_RISE_INT_EN		0x9f
+#define BUCK1_2_IMAX_MAX			(0x3 << 6)
+#define BUCK3_4_IMAX_MAX			(0x3 << 3)
+#define BOOST_DISABLE				((0x1 << 5) | (0x0 << 1))
+#define BUCK4_VRP_3PERCENT			0xc0
+#define RK816_BUCK_DVS_CONFIRM			(0x1 << 7)
+#define RK816_TYPE_ES2				0x05
+#define RK816_CHIP_VERSION_MASK			0x0f
+
+#define TEMP105C			0x08
+#define TEMP115C			0x0c
+#define TEMP_HOTDIE_MSK			0x0c
+#define SLP_SD_MSK			(0x3 << 2)
+#define SHUTDOWN_FUN			(0x2 << 2)
+#define SLEEP_FUN			(0x1 << 2)
+#define RK8XX_ID_MSK			0xfff0
+#define PWM_MODE_MSK			BIT(7)
+#define FPWM_MODE			BIT(7)
+#define AUTO_PWM_MODE			0
+#define REGS_WMSK			0xf0
+
+enum rk817_reg_id {
+	RK817_ID_DCDC1 = 0,
+	RK817_ID_DCDC2,
+	RK817_ID_DCDC3,
+	RK817_ID_DCDC4,
+	RK817_ID_LDO1,
+	RK817_ID_LDO2,
+	RK817_ID_LDO3,
+	RK817_ID_LDO4,
+	RK817_ID_LDO5,
+	RK817_ID_LDO6,
+	RK817_ID_LDO7,
+	RK817_ID_LDO8,
+	RK817_ID_LDO9,
+	RK817_ID_BOOST,
+	RK817_ID_BOOST_OTG_SW,
+	RK817_NUM_REGULATORS
+};
+
+enum rk809_reg_id {
+	RK809_ID_DCDC5 = RK817_ID_BOOST,
+	RK809_ID_SW1,
+	RK809_ID_SW2,
+	RK809_NUM_REGULATORS
+};
+
+#define RK817_SECONDS_REG		0x00
+#define RK817_MINUTES_REG		0x01
+#define RK817_HOURS_REG			0x02
+#define RK817_DAYS_REG			0x03
+#define RK817_MONTHS_REG		0x04
+#define RK817_YEARS_REG			0x05
+#define RK817_WEEKS_REG			0x06
+#define RK817_ALARM_SECONDS_REG		0x07
+#define RK817_ALARM_MINUTES_REG		0x08
+#define RK817_ALARM_HOURS_REG		0x09
+#define RK817_ALARM_DAYS_REG		0x0a
+#define RK817_ALARM_MONTHS_REG		0x0b
+#define RK817_ALARM_YEARS_REG		0x0c
+#define RK817_RTC_CTRL_REG		0xd
+#define RK817_RTC_STATUS_REG		0xe
+#define RK817_RTC_INT_REG		0xf
+#define RK817_RTC_COMP_LSB_REG		0x10
+#define RK817_RTC_COMP_MSB_REG		0x11
+
+#define RK817_POWER_EN_SAVE0		0x99
+#define RK817_POWER_EN_SAVE1		0xa4
+
+#define RK817_POWER_EN_REG(i)		(0xb1 + (i))
+#define RK817_POWER_SLP_EN_REG(i)	(0xb5 + (i))
+
+#define RK817_POWER_CONFIG		(0xb9)
+
+#define RK817_BUCK_CONFIG_REG(i)	(0xba + (i) * 3)
+
+#define RK817_BUCK1_ON_VSEL_REG		0xBB
+#define RK817_BUCK1_SLP_VSEL_REG	0xBC
+
+#define RK817_BUCK2_CONFIG_REG		0xBD
+#define RK817_BUCK2_ON_VSEL_REG		0xBE
+#define RK817_BUCK2_SLP_VSEL_REG	0xBF
+
+#define RK817_BUCK3_CONFIG_REG		0xC0
+#define RK817_BUCK3_ON_VSEL_REG		0xC1
+#define RK817_BUCK3_SLP_VSEL_REG	0xC2
+
+#define RK817_BUCK4_CONFIG_REG		0xC3
+#define RK817_BUCK4_ON_VSEL_REG		0xC4
+#define RK817_BUCK4_SLP_VSEL_REG	0xC5
+
+#define RK817_LDO_ON_VSEL_REG(idx)	(0xcc + (idx) * 2)
+#define RK817_BOOST_OTG_CFG		(0xde)
+
+#define RK817_ID_MSB			0xed
+#define RK817_ID_LSB			0xee
+
+#define RK817_SYS_STS			0xf0
+#define RK817_SYS_CFG(i)		(0xf1 + (i))
+
+#define RK817_ON_SOURCE_REG		0xf5
+#define RK817_OFF_SOURCE_REG		0xf6
+
+/* INTERRUPT REGISTER */
+#define RK817_INT_STS_REG0		0xf8
+#define RK817_INT_STS_MSK_REG0		0xf9
+#define RK817_INT_STS_REG1		0xfa
+#define RK817_INT_STS_MSK_REG1		0xfb
+#define RK817_INT_STS_REG2		0xfc
+#define RK817_INT_STS_MSK_REG2		0xfd
+#define RK817_GPIO_INT_CFG		0xfe
+
+/* IRQ Definitions */
+#define RK817_IRQ_PWRON_FALL		0
+#define RK817_IRQ_PWRON_RISE		1
+#define RK817_IRQ_PWRON			2
+#define RK817_IRQ_PWMON_LP		3
+#define RK817_IRQ_HOTDIE		4
+#define RK817_IRQ_RTC_ALARM		5
+#define RK817_IRQ_RTC_PERIOD		6
+#define RK817_IRQ_VB_LO			7
+#define RK817_IRQ_PLUG_IN		(8 + 0)
+#define RK817_IRQ_PLUG_OUT		(8 + 1)
+#define RK817_IRQ_CHRG_TERM		(8 + 2)
+#define RK817_IRQ_CHRG_TIME		(8 + 3)
+#define RK817_IRQ_CHRG_TS		(8 + 4)
+#define RK817_IRQ_USB_OV		(8 + 5)
+#define RK817_IRQ_CHRG_IN_CLMP		(8 + 6)
+#define RK817_IRQ_BAT_DIS_ILIM		(8 + 7)
+#define RK817_IRQ_GATE_GPIO		(16 + 0)
+#define RK817_IRQ_TS_GPIO		(16 + 1)
+#define RK817_IRQ_CODEC_PD		(16 + 2)
+#define RK817_IRQ_CODEC_PO		(16 + 3)
+#define RK817_IRQ_CLASSD_MUTE_DONE	(16 + 4)
+#define RK817_IRQ_CLASSD_OCP		(16 + 5)
+#define RK817_IRQ_BAT_OVP		(16 + 6)
+#define RK817_IRQ_CHRG_BAT_HI		(16 + 7)
+#define RK817_IRQ_END			(RK817_IRQ_CHRG_BAT_HI + 1)
+
+/*
+ * rtc_ctrl 0xd
+ * same as 808, except bit4
+ */
+#define RK817_RTC_CTRL_RSV4		BIT(4)
+
+/* power config 0xb9 */
+#define RK817_BUCK3_FB_RES_MSK		BIT(6)
+#define RK817_BUCK3_FB_RES_INTER	BIT(6)
+#define RK817_BUCK3_FB_RES_EXT		0
+
+/* buck config 0xba */
+#define RK817_RAMP_RATE_OFFSET		6
+#define RK817_RAMP_RATE_MASK		(0x3 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_3MV_PER_US	(0x0 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_6_3MV_PER_US	(0x1 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_12_5MV_PER_US	(0x2 << RK817_RAMP_RATE_OFFSET)
+#define RK817_RAMP_RATE_25MV_PER_US	(0x3 << RK817_RAMP_RATE_OFFSET)
+
+/* sys_cfg1 0xf2 */
+#define RK817_HOTDIE_TEMP_MSK		(0x3 << 4)
+#define RK817_HOTDIE_85			(0x0 << 4)
+#define RK817_HOTDIE_95			(0x1 << 4)
+#define RK817_HOTDIE_105		(0x2 << 4)
+#define RK817_HOTDIE_115		(0x3 << 4)
+
+#define RK817_TSD_TEMP_MSK		BIT(6)
+#define RK817_TSD_140			0
+#define RK817_TSD_160			BIT(6)
+
+#define RK817_CLK32KOUT2_EN		BIT(7)
+
+/* sys_cfg3 0xf4 */
+#define RK817_SLPPIN_FUNC_MSK		(0x3 << 3)
+#define SLPPIN_NULL_FUN			(0x0 << 3)
+#define SLPPIN_SLP_FUN			(0x1 << 3)
+#define SLPPIN_DN_FUN			(0x2 << 3)
+#define SLPPIN_RST_FUN			(0x3 << 3)
+
+#define RK817_RST_FUNC_MSK		(0x3 << 6)
+#define RK817_RST_FUNC_SFT		(6)
+#define RK817_RST_FUNC_CNT		(3)
+#define RK817_RST_FUNC_DEV		(0) /* reset the dev */
+#define RK817_RST_FUNC_REG		(0x1 << 6) /* reset the reg only */
+
+#define RK817_SLPPOL_MSK		BIT(5)
+#define RK817_SLPPOL_H			BIT(5)
+#define RK817_SLPPOL_L			(0)
+
+/* gpio&int 0xfe */
+#define RK817_INT_POL_MSK		BIT(1)
+#define RK817_INT_POL_H			BIT(1)
+#define RK817_INT_POL_L			0
+#define RK809_BUCK5_CONFIG(i)		(RK817_BOOST_OTG_CFG + (i) * 1)
 
 enum {
 	BUCK_ILMIN_50MA,
@@ -319,17 +975,29 @@ enum {
 	BOOST_ILMIN_250MA,
 };
 
-enum {
-	RK808_ID = 0x0000,
-	RK818_ID = 0x8181,
+struct rk808_pin_info {
+	struct pinctrl *p;
+	struct pinctrl_state *reset;
+	struct pinctrl_state *power_off;
+	struct pinctrl_state *sleep;
 };
 
 struct rk808 {
-	struct i2c_client		*i2c;
-	struct regmap_irq_chip_data	*irq_data;
-	struct regmap			*regmap;
-	long				variant;
-	const struct regmap_config	*regmap_cfg;
-	const struct regmap_irq_chip	*regmap_irq_chip;
+	struct i2c_client *i2c;
+	struct regmap_irq_chip_data *irq_data;
+	struct regmap_irq_chip_data *battery_irq_data;
+	struct regmap *regmap;
+	long variant;
+	struct rk808_pin_info *pins;
 };
-#endif /* __LINUX_REGULATOR_RK808_H */
+
+enum {
+	RK805_ID = 0x8050,
+	RK808_ID = 0x0000,
+	RK809_ID = 0x8090,
+	RK816_ID = 0x8160,
+	RK817_ID = 0x8170,
+	RK818_ID = 0x8180,
+};
+
+#endif /* __LINUX_REGULATOR_rk808_H */
diff --git a/include/linux/platform_data/emuelec.h b/include/linux/platform_data/emuelec.h
new file mode 100644
index 000000000000..5398a0e82cfb
--- /dev/null
+++ b/include/linux/platform_data/emuelec.h
@@ -0,0 +1,19 @@
+#ifndef __EMUELEC_BOARD_H
+#define __EMUELEC_BOARD_H
+
+#include <linux/types.h>
+
+// #define EMUELEC_BOARD_GENERIC   0x00000000U
+// #define EMUELEC_BOARD_OGU       0x00000001U
+
+extern bool emuelec_is_ogu;
+
+// extern u32 emuelec_board_model;
+
+// bool __emuelec_board_is(u32 board);
+
+// #define emuelec_board_is_generic()  __emuelec_board_is(EMUELEC_BOARD_GENERIC)
+// #define emuelec_board_is_ogu()  __emuelec_board_is(EMUELEC_BOARD_OGU)
+
+
+#endif
\ No newline at end of file
diff --git a/include/linux/power/rk_usbbc.h b/include/linux/power/rk_usbbc.h
new file mode 100755
index 000000000000..45f7128b3a69
--- /dev/null
+++ b/include/linux/power/rk_usbbc.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK_USBBC_H
+#define __RK_USBBC_H
+
+/* USB Charger Types */
+enum bc_port_type{
+	USB_BC_TYPE_DISCNT = 0,
+	USB_BC_TYPE_SDP,
+	USB_BC_TYPE_DCP,
+	USB_BC_TYPE_CDP,
+	USB_BC_TYPE_UNKNOW,
+	USB_OTG_POWER_ON,
+	USB_OTG_POWER_OFF,
+	USB_BC_TYPE_MAX,
+};
+
+/***********************************
+ * USB Port Type
+ * 0 : Disconnect
+ * 1 : SDP - pc
+ * 2 : DCP - charger
+ * 3 : CDP - pc with big currect charge
+ ************************************/
+#ifdef CONFIG_DWC_OTG_310
+extern int dwc_otg_check_dpdm(bool wait);
+extern int rk_bc_detect_notifier_register(struct notifier_block *nb,
+					  enum bc_port_type *type);
+extern int rk_bc_detect_notifier_unregister(struct notifier_block *nb);
+#else
+static inline int dwc_otg_check_dpdm(bool wait) { return USB_BC_TYPE_DISCNT; }
+
+static inline int rk_bc_detect_notifier_register(struct notifier_block *nb,
+						 enum bc_port_type *type)
+{
+	return -EINVAL;
+}
+
+static inline int rk_bc_detect_notifier_unregister(struct notifier_block *nb)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/include/linux/rk_keys.h b/include/linux/rk_keys.h
new file mode 100755
index 000000000000..b839fe281756
--- /dev/null
+++ b/include/linux/rk_keys.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _RK_KEYS_H
+#define _RK_KEYS_H
+
+#ifdef CONFIG_INPUT_RK8XX_PWRKEY
+void rk_send_power_key(int state);
+void rk_send_wakeup_key(void);
+#else
+static inline void rk_send_power_key(int state) { }
+static inline void rk_send_wakeup_key(void) { }
+#endif
+
+#endif
diff --git a/lib/radix-tree.c b/lib/radix-tree.c
index 8e6d552c40dd..0a84035c6f17 100644
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@ -45,6 +45,7 @@ static unsigned long height_to_maxnodes[RADIX_TREE_MAX_PATH + 1] __read_mostly;
  * Radix tree node cache.
  */
 static struct kmem_cache *radix_tree_node_cachep;
+EXPORT_SYMBOL_GPL(radix_tree_node_cachep);
 
 /*
  * The radix tree is variable-height, so an insert operation not only has
@@ -329,6 +330,7 @@ static void radix_tree_node_rcu_free(struct rcu_head *head)
 
 	kmem_cache_free(radix_tree_node_cachep, node);
 }
+EXPORT_SYMBOL_GPL(radix_tree_node_rcu_free);
 
 static inline void
 radix_tree_node_free(struct radix_tree_node *node)
diff --git a/mm/cma.c b/mm/cma.c
index 1a9416a07efa..6256de96b7ff 100644
--- a/mm/cma.c
+++ b/mm/cma.c
@@ -646,6 +646,7 @@ struct page *cma_alloc(struct cma *cma, size_t count, unsigned int align)
 	pr_debug("%s(): returned %p\n", __func__, page);
 	return page;
 }
+EXPORT_SYMBOL(cma_alloc);
 
 /**
  * cma_release() - release allocated pages
@@ -685,3 +686,4 @@ bool cma_release(struct cma *cma, const struct page *pages, unsigned int count)
 	return true;
 }
 
+EXPORT_SYMBOL(cma_release);
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 89a19097435d..8e13205a222f 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -104,6 +104,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_PCM5102A
 	select SND_SOC_PCM512x_I2C if I2C
 	select SND_SOC_PCM512x_SPI if SPI_MASTER
+	select SND_SOC_RK817 if I2C
 	select SND_SOC_RT286 if I2C
 	select SND_SOC_RT298 if I2C
 	select SND_SOC_RT5514 if I2C
@@ -645,6 +646,11 @@ config SND_SOC_PCM512x_SPI
 	select SND_SOC_PCM512x
 	select REGMAP_SPI
 
+config SND_SOC_RK817
+	tristate "Rockchip RK817 CODEC"
+	depends on MFD_RK808
+	select REGMAP_I2C
+    
 config SND_SOC_RL6231
 	tristate
 	default y if SND_SOC_RT5514=y
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 0f32a08b5d85..26d365880b24 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -102,6 +102,7 @@ snd-soc-pcm5102a-objs := pcm5102a.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
+snd-soc-rk817-objs := rk817_codec.o
 snd-soc-rl6231-objs := rl6231.o
 snd-soc-rl6347a-objs := rl6347a.o
 snd-soc-rt286-objs := rt286.o
@@ -327,6 +328,7 @@ obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
+obj-$(CONFIG_SND_SOC_RK817)	+= snd-soc-rk817.o
 obj-$(CONFIG_SND_SOC_RL6231)	+= snd-soc-rl6231.o
 obj-$(CONFIG_SND_SOC_RL6347A)	+= snd-soc-rl6347a.o
 obj-$(CONFIG_SND_SOC_RT286)	+= snd-soc-rt286.o
diff --git a/sound/soc/codecs/rk817_codec.c b/sound/soc/codecs/rk817_codec.c
new file mode 100755
index 000000000000..f2b11eb79b0b
--- /dev/null
+++ b/sound/soc/codecs/rk817_codec.c
@@ -0,0 +1,1291 @@
+/*
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <sound/core.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include "rk817_codec.h"
+
+static int dbg_enable;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+/* For route */
+#define RK817_CODEC_PLAYBACK	1
+#define RK817_CODEC_CAPTURE	2
+#define RK817_CODEC_INCALL	4
+#define RK817_CODEC_ALL	(RK817_CODEC_PLAYBACK |\
+	RK817_CODEC_CAPTURE | RK817_CODEC_INCALL)
+
+/*
+ * DDAC L/R volume setting
+ * 0db~-95db,0.375db/step,for example:
+ * 0: 0dB
+ * 0x0a: -3.75dB
+ * 0x7d: -46dB
+ * 0xff: -95dB
+ */
+#define OUT_VOLUME	(0x03)
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#define RK817_DAC_VOLUME \
+	SOC_DOUBLE_R("Playback Volume", RK817_CODEC_DDAC_VOLL, RK817_CODEC_DDAC_VOLR, 0, 0xff, 1)
+static const DECLARE_TLV_DB_MINMAX(rk817_vol_tlv, -9500, -675);
+#endif
+
+/*
+ * DADC L/R volume setting
+ * 0db~-95db,0.375db/step,for example:
+ * 0: 0dB
+ * 0x0a: -3.75dB
+ * 0x7d: -46dB
+ * 0xff: -95dB
+ */
+#define CAPTURE_VOLUME	(0x0)
+
+#define CODEC_SET_SPK 1
+#define CODEC_SET_HP 2
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#define RK817_ADC_VOLUME \
+	SOC_DOUBLE_R("Record Volume", RK817_CODEC_DADC_VOLL, RK817_CODEC_DADC_VOLR, 0, 0xFF, 1)
+#endif
+
+
+struct rk817_codec_priv {
+	struct snd_soc_codec *codec;
+	struct regmap *regmap;
+	struct rk808 *rk817;
+	struct clk *mclk;
+
+	unsigned int stereo_sysclk;
+	unsigned int rate;
+
+	unsigned int spk_volume;
+	unsigned int hp_volume;
+	unsigned int capture_volume;
+
+	bool mic_in_differential;
+	bool pdmdata_out_enable;
+	bool use_ext_amplifier;
+	bool adc_for_loopback;
+
+	long int playback_path;
+	long int capture_path;
+
+	struct gpio_desc *spk_ctl_gpio;
+	struct gpio_desc *hp_ctl_gpio;
+	int spk_mute_delay;
+	int hp_mute_delay;
+};
+
+static const struct reg_default rk817_reg_defaults[] = {
+	{ RK817_CODEC_DTOP_VUCTL, 0x003 },
+	{ RK817_CODEC_DTOP_VUCTIME, 0x00 },
+	{ RK817_CODEC_DTOP_LPT_SRST, 0x00 },
+	{ RK817_CODEC_DTOP_DIGEN_CLKE, 0x00 },
+	{ RK817_CODEC_AREF_RTCFG0, 0x00 },
+	{ RK817_CODEC_AREF_RTCFG1, 0x06 },
+	{ RK817_CODEC_AADC_CFG0, 0xc8 },
+	{ RK817_CODEC_AADC_CFG1, 0x00 },
+	{ RK817_CODEC_DADC_VOLL, 0x00 },
+	{ RK817_CODEC_DADC_VOLR, 0x00 },
+	{ RK817_CODEC_DADC_SR_ACL0, 0x00 },
+	{ RK817_CODEC_DADC_ALC1, 0x00 },
+	{ RK817_CODEC_DADC_ALC2, 0x00 },
+	{ RK817_CODEC_DADC_NG, 0x00 },
+	{ RK817_CODEC_DADC_HPF, 0x00 },
+	{ RK817_CODEC_DADC_RVOLL, 0xff },
+	{ RK817_CODEC_DADC_RVOLR, 0xff },
+	{ RK817_CODEC_AMIC_CFG0, 0x70 },
+	{ RK817_CODEC_AMIC_CFG1, 0x00 },
+	{ RK817_CODEC_DMIC_PGA_GAIN, 0x66 },
+	{ RK817_CODEC_DMIC_LMT1, 0x00 },
+	{ RK817_CODEC_DMIC_LMT2, 0x00 },
+	{ RK817_CODEC_DMIC_NG1, 0x00 },
+	{ RK817_CODEC_DMIC_NG2, 0x00 },
+	{ RK817_CODEC_ADAC_CFG0, 0x00 },
+	{ RK817_CODEC_ADAC_CFG1, 0x07 },
+	{ RK817_CODEC_DDAC_POPD_DACST, 0x82 },
+	{ RK817_CODEC_DDAC_VOLL, 0x00 },
+	{ RK817_CODEC_DDAC_VOLR, 0x00 },
+	{ RK817_CODEC_DDAC_SR_LMT0, 0x00 },
+	{ RK817_CODEC_DDAC_LMT1, 0x00 },
+	{ RK817_CODEC_DDAC_LMT2, 0x00 },
+	{ RK817_CODEC_DDAC_MUTE_MIXCTL, 0xa0 },
+	{ RK817_CODEC_DDAC_RVOLL, 0xff },
+	{ RK817_CODEC_DDAC_RVOLR, 0xff },
+	{ RK817_CODEC_AHP_ANTI0, 0x00 },
+	{ RK817_CODEC_AHP_ANTI1, 0x00 },
+	{ RK817_CODEC_AHP_CFG0, 0xe0 },
+	{ RK817_CODEC_AHP_CFG1, 0x1f },
+	{ RK817_CODEC_AHP_CP, 0x09 },
+	{ RK817_CODEC_ACLASSD_CFG1, 0x69 },
+	{ RK817_CODEC_ACLASSD_CFG2, 0x44 },
+	{ RK817_CODEC_APLL_CFG0, 0x04 },
+	{ RK817_CODEC_APLL_CFG1, 0x00 },
+	{ RK817_CODEC_APLL_CFG2, 0x30 },
+	{ RK817_CODEC_APLL_CFG3, 0x19 },
+	{ RK817_CODEC_APLL_CFG4, 0x65 },
+	{ RK817_CODEC_APLL_CFG5, 0x01 },
+	{ RK817_CODEC_DI2S_CKM, 0x01 },
+	{ RK817_CODEC_DI2S_RSD, 0x00 },
+	{ RK817_CODEC_DI2S_RXCR1, 0x00 },
+	{ RK817_CODEC_DI2S_RXCR2, 0x17 },
+	{ RK817_CODEC_DI2S_RXCMD_TSD, 0x00 },
+	{ RK817_CODEC_DI2S_TXCR1, 0x00 },
+	{ RK817_CODEC_DI2S_TXCR2, 0x17 },
+	{ RK817_CODEC_DI2S_TXCR3_TXCMD, 0x00 },
+};
+
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+static const struct snd_kcontrol_new rk817_dac_controls[] = {
+	SOC_DOUBLE_R_RANGE_TLV("Playback Volume", RK817_CODEC_DDAC_VOLL,
+		RK817_CODEC_DDAC_VOLR, 0, 0x12, 0xff, 1, rk817_vol_tlv),
+	RK817_ADC_VOLUME
+};
+#endif
+
+static bool rk817_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case RK817_CODEC_DTOP_LPT_SRST:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rk817_codec_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case RK817_CODEC_DTOP_VUCTL:
+	case RK817_CODEC_DTOP_VUCTIME:
+	case RK817_CODEC_DTOP_LPT_SRST:
+	case RK817_CODEC_DTOP_DIGEN_CLKE:
+	case RK817_CODEC_AREF_RTCFG0:
+	case RK817_CODEC_AREF_RTCFG1:
+	case RK817_CODEC_AADC_CFG0:
+	case RK817_CODEC_AADC_CFG1:
+	case RK817_CODEC_DADC_VOLL:
+	case RK817_CODEC_DADC_VOLR:
+	case RK817_CODEC_DADC_SR_ACL0:
+	case RK817_CODEC_DADC_ALC1:
+	case RK817_CODEC_DADC_ALC2:
+	case RK817_CODEC_DADC_NG:
+	case RK817_CODEC_DADC_HPF:
+	case RK817_CODEC_DADC_RVOLL:
+	case RK817_CODEC_DADC_RVOLR:
+	case RK817_CODEC_AMIC_CFG0:
+	case RK817_CODEC_AMIC_CFG1:
+	case RK817_CODEC_DMIC_PGA_GAIN:
+	case RK817_CODEC_DMIC_LMT1:
+	case RK817_CODEC_DMIC_LMT2:
+	case RK817_CODEC_DMIC_NG1:
+	case RK817_CODEC_DMIC_NG2:
+	case RK817_CODEC_ADAC_CFG0:
+	case RK817_CODEC_ADAC_CFG1:
+	case RK817_CODEC_DDAC_POPD_DACST:
+	case RK817_CODEC_DDAC_VOLL:
+	case RK817_CODEC_DDAC_VOLR:
+	case RK817_CODEC_DDAC_SR_LMT0:
+	case RK817_CODEC_DDAC_LMT1:
+	case RK817_CODEC_DDAC_LMT2:
+	case RK817_CODEC_DDAC_MUTE_MIXCTL:
+	case RK817_CODEC_DDAC_RVOLL:
+	case RK817_CODEC_DDAC_RVOLR:
+	case RK817_CODEC_AHP_ANTI0:
+	case RK817_CODEC_AHP_ANTI1:
+	case RK817_CODEC_AHP_CFG0:
+	case RK817_CODEC_AHP_CFG1:
+	case RK817_CODEC_AHP_CP:
+	case RK817_CODEC_ACLASSD_CFG1:
+	case RK817_CODEC_ACLASSD_CFG2:
+	case RK817_CODEC_APLL_CFG0:
+	case RK817_CODEC_APLL_CFG1:
+	case RK817_CODEC_APLL_CFG2:
+	case RK817_CODEC_APLL_CFG3:
+	case RK817_CODEC_APLL_CFG4:
+	case RK817_CODEC_APLL_CFG5:
+	case RK817_CODEC_DI2S_CKM:
+	case RK817_CODEC_DI2S_RSD:
+	case RK817_CODEC_DI2S_RXCR1:
+	case RK817_CODEC_DI2S_RXCR2:
+	case RK817_CODEC_DI2S_RXCMD_TSD:
+	case RK817_CODEC_DI2S_TXCR1:
+	case RK817_CODEC_DI2S_TXCR2:
+	case RK817_CODEC_DI2S_TXCR3_TXCMD:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int rk817_codec_ctl_gpio(struct rk817_codec_priv *rk817,
+				int gpio, int level)
+{
+	if ((gpio & CODEC_SET_SPK) &&
+	    rk817->spk_ctl_gpio) {
+		gpiod_set_value(rk817->spk_ctl_gpio, level);
+		DBG("%s set spk clt %d\n", __func__, level);
+		msleep(rk817->spk_mute_delay);
+	}
+
+	if ((gpio & CODEC_SET_HP) &&
+	    rk817->hp_ctl_gpio) {
+		gpiod_set_value(rk817->hp_ctl_gpio, level);
+		DBG("%s set hp clt %d\n", __func__, level);
+		msleep(rk817->hp_mute_delay);
+	}
+
+	return 0;
+}
+
+static int rk817_reset(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, RK817_CODEC_DTOP_LPT_SRST, 0x40);
+	snd_soc_write(codec, RK817_CODEC_DDAC_POPD_DACST, 0x02);
+	snd_soc_write(codec, RK817_CODEC_DTOP_DIGEN_CLKE, 0x0f);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG0, 0x04);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG1, 0x58);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG2, 0x2d);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG3, 0x0c);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG4, 0xa5);
+	snd_soc_write(codec, RK817_CODEC_APLL_CFG5, 0x00);
+	snd_soc_write(codec, RK817_CODEC_DTOP_DIGEN_CLKE, 0x00);
+
+	return 0;
+}
+
+static struct rk817_reg_val_typ playback_power_up_list[] = {
+	{RK817_CODEC_AREF_RTCFG1, 0x40},
+	{RK817_CODEC_DDAC_POPD_DACST, 0x02},
+	{RK817_CODEC_DDAC_SR_LMT0, 0x02},
+	/* {RK817_CODEC_DTOP_DIGEN_CLKE, 0x0f}, */
+	/* APLL */
+	{RK817_CODEC_APLL_CFG0, 0x04},
+	{RK817_CODEC_APLL_CFG1, 0x58},
+	{RK817_CODEC_APLL_CFG2, 0x2d},
+	{RK817_CODEC_APLL_CFG3, 0x0c},
+	{RK817_CODEC_APLL_CFG4, 0xa5},
+	{RK817_CODEC_APLL_CFG5, 0x00},
+
+	{RK817_CODEC_DI2S_RXCMD_TSD, 0x00},
+	{RK817_CODEC_DI2S_RSD, 0x00},
+	/* {RK817_CODEC_DI2S_CKM, 0x00}, */
+	{RK817_CODEC_DI2S_RXCR1, 0x00},
+	{RK817_CODEC_DI2S_RXCMD_TSD, 0x20},
+	{RK817_CODEC_DTOP_VUCTIME, 0xf4},
+	{RK817_CODEC_DDAC_MUTE_MIXCTL, 0x00},
+
+	{RK817_CODEC_DDAC_VOLL, 0x0a},
+	{RK817_CODEC_DDAC_VOLR, 0x0a},
+};
+
+#define RK817_CODEC_PLAYBACK_POWER_UP_LIST_LEN \
+	ARRAY_SIZE(playback_power_up_list)
+
+static struct rk817_reg_val_typ playback_power_down_list[] = {
+	{RK817_CODEC_DDAC_MUTE_MIXCTL, 0x01},
+	{RK817_CODEC_ADAC_CFG1, 0x0f},
+	/* HP */
+	{RK817_CODEC_AHP_CFG0, 0xe0},
+	{RK817_CODEC_AHP_CP, 0x09},
+	/* SPK */
+	{RK817_CODEC_ACLASSD_CFG1, 0x69},
+};
+
+#define RK817_CODEC_PLAYBACK_POWER_DOWN_LIST_LEN \
+	ARRAY_SIZE(playback_power_down_list)
+
+static struct rk817_reg_val_typ capture_power_up_list[] = {
+	{RK817_CODEC_AREF_RTCFG1, 0x40},
+	{RK817_CODEC_DDAC_SR_LMT0, 0x02},
+	{RK817_CODEC_DADC_SR_ACL0, 0x02},
+	/* {RK817_CODEC_DTOP_DIGEN_CLKE, 0xff}, */
+	{RK817_CODEC_APLL_CFG0, 0x04},
+	{RK817_CODEC_APLL_CFG1, 0x58},
+	{RK817_CODEC_APLL_CFG2, 0x2d},
+	{RK817_CODEC_APLL_CFG3, 0x0c},
+	{RK817_CODEC_APLL_CFG4, 0xa5},
+	{RK817_CODEC_APLL_CFG5, 0x00},
+
+	/*{RK817_CODEC_DI2S_RXCMD_TSD, 0x00},*/
+	{RK817_CODEC_DI2S_RSD, 0x00},
+	/* {RK817_CODEC_DI2S_CKM, 0x00}, */
+	{RK817_CODEC_DI2S_RXCR1, 0x00},
+	{RK817_CODEC_DI2S_RXCMD_TSD, 0x20},
+	{RK817_CODEC_DTOP_VUCTIME, 0xf4},
+
+	{RK817_CODEC_DDAC_MUTE_MIXCTL, 0x00},
+	{RK817_CODEC_AADC_CFG0, 0x08},
+	{RK817_CODEC_AMIC_CFG0, 0x0f},
+	{RK817_CODEC_DI2S_TXCR3_TXCMD, 0x88},
+	{RK817_CODEC_DDAC_POPD_DACST, 0x02},
+	/* 0x29: -18db to 27db */
+	{RK817_CODEC_DMIC_PGA_GAIN, 0x99},
+};
+
+#define RK817_CODEC_CAPTURE_POWER_UP_LIST_LEN \
+	ARRAY_SIZE(capture_power_up_list)
+
+static struct rk817_reg_val_typ capture_power_down_list[] = {
+	{RK817_CODEC_AADC_CFG0, 0xc8},
+	{RK817_CODEC_AMIC_CFG0, 0x70},
+};
+
+#define RK817_CODEC_CAPTURE_POWER_DOWN_LIST_LEN \
+	ARRAY_SIZE(capture_power_down_list)
+
+static int rk817_codec_power_up(struct snd_soc_codec *codec, int type)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	int i;
+
+	DBG("%s : power up %s %s %s\n", __func__,
+	    type & RK817_CODEC_PLAYBACK ? "playback" : "",
+	    type & RK817_CODEC_CAPTURE ? "capture" : "",
+	    type & RK817_CODEC_INCALL ? "incall" : "");
+
+	if (type & RK817_CODEC_PLAYBACK) {
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    DAC_DIG_CLK_MASK, DAC_DIG_CLK_EN);
+		for (i = 0; i < RK817_CODEC_PLAYBACK_POWER_UP_LIST_LEN; i++) {
+			snd_soc_write(codec, playback_power_up_list[i].reg,
+				      playback_power_up_list[i].value);
+		}
+	}
+
+	if (type & RK817_CODEC_CAPTURE) {
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    ADC_DIG_CLK_MASK, ADC_DIG_CLK_EN);
+		for (i = 0; i < RK817_CODEC_CAPTURE_POWER_UP_LIST_LEN; i++) {
+			snd_soc_write(codec, capture_power_up_list[i].reg,
+				      capture_power_up_list[i].value);
+		}
+
+		if (rk817->mic_in_differential)
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+					    MIC_DIFF_MASK, MIC_DIFF_EN);
+		else
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+					    MIC_DIFF_MASK, MIC_DIFF_DIS);
+
+		if (rk817->pdmdata_out_enable)
+			snd_soc_update_bits(codec, RK817_CODEC_DI2S_CKM,
+					    PDM_EN_MASK, PDM_EN_ENABLE);
+
+		snd_soc_write(codec, RK817_CODEC_DADC_VOLL,
+			      rk817->capture_volume);
+		snd_soc_write(codec, RK817_CODEC_DADC_VOLR,
+			      rk817->capture_volume);
+	}
+
+	return 0;
+}
+
+static int rk817_codec_power_down(struct snd_soc_codec *codec, int type)
+{
+	int i;
+
+	DBG("%s : power down %s %s %s\n", __func__,
+	    type & RK817_CODEC_PLAYBACK ? "playback" : "",
+	    type & RK817_CODEC_CAPTURE ? "capture" : "",
+	    type & RK817_CODEC_INCALL ? "incall" : "");
+
+	/* mute output for pop noise */
+	if ((type & RK817_CODEC_PLAYBACK) ||
+	    (type & RK817_CODEC_INCALL)) {
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_ENABLE);
+	}
+
+	if (type & RK817_CODEC_CAPTURE) {
+		for (i = 0; i < RK817_CODEC_CAPTURE_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, capture_power_down_list[i].reg,
+				      capture_power_down_list[i].value);
+		}
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    ADC_DIG_CLK_MASK, ADC_DIG_CLK_DIS);
+	}
+
+	if (type & RK817_CODEC_PLAYBACK) {
+		for (i = 0; i < RK817_CODEC_PLAYBACK_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, playback_power_down_list[i].reg,
+				      playback_power_down_list[i].value);
+		}
+		snd_soc_update_bits(codec, RK817_CODEC_DTOP_DIGEN_CLKE,
+				    DAC_DIG_CLK_MASK, DAC_DIG_CLK_DIS);
+	}
+
+	if (type == RK817_CODEC_ALL) {
+		for (i = 0; i < RK817_CODEC_PLAYBACK_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, playback_power_down_list[i].reg,
+				      playback_power_down_list[i].value);
+		}
+		for (i = 0; i < RK817_CODEC_CAPTURE_POWER_DOWN_LIST_LEN; i++) {
+			snd_soc_write(codec, capture_power_down_list[i].reg,
+				      capture_power_down_list[i].value);
+		}
+		snd_soc_write(codec, RK817_CODEC_DTOP_DIGEN_CLKE, 0x00);
+		snd_soc_write(codec, RK817_CODEC_APLL_CFG5, 0x01);
+		snd_soc_write(codec, RK817_CODEC_AREF_RTCFG1, 0x06);
+	}
+
+	return 0;
+}
+
+/* For tiny alsa playback/capture/voice call path */
+static const char * const rk817_playback_path_mode[] = {
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	"OFF", "RCV", "SPK", "HP", "HP_NO_MIC", "BT", "SPK_HP", /* 0-6 */
+	"RING_SPK", "RING_HP", "RING_HP_NO_MIC", "RING_SPK_HP"}; /* 7-10 */
+#else
+	"OFF", "SPK", "HP", "SPK_HP"};
+#endif
+
+static const char * const rk817_capture_path_mode[] = {
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	"MIC OFF", "Main Mic", "Hands Free Mic", "BT Sco Mic"};
+
+static const char * const rk817_call_path_mode[] = {
+	"OFF", "RCV", "SPK", "HP", "HP_NO_MIC", "BT"}; /* 0-5 */
+
+static const char * const rk817_modem_input_mode[] = {"OFF", "ON"};
+#else
+	"MIC OFF", "Main Mic"};
+#endif
+
+static SOC_ENUM_SINGLE_DECL(rk817_playback_path_type,
+	0, 0, rk817_playback_path_mode);
+
+static SOC_ENUM_SINGLE_DECL(rk817_capture_path_type,
+	0, 0, rk817_capture_path_mode);
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+static SOC_ENUM_SINGLE_DECL(rk817_call_path_type,
+	0, 0, rk817_call_path_mode);
+
+static SOC_ENUM_SINGLE_DECL(rk817_modem_input_type,
+	0, 0, rk817_modem_input_mode);
+#endif
+
+static int rk817_playback_path_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s : playback_path %ld\n", __func__, rk817->playback_path);
+
+	ucontrol->value.integer.value[0] = rk817->playback_path;
+
+	return 0;
+}
+
+static int rk817_playback_path_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	long int pre_path;
+
+	if (rk817->playback_path == ucontrol->value.integer.value[0]) {
+		DBG("%s : playback_path is not changed!\n",
+		    __func__);
+		return 0;
+	}
+
+	pre_path = rk817->playback_path;
+	rk817->playback_path = ucontrol->value.integer.value[0];
+
+	DBG("%s : set playback_path %ld, pre_path %ld\n",
+	    __func__, rk817->playback_path, pre_path);
+
+	if (rk817->playback_path != OFF)
+		clk_prepare_enable(rk817->mclk);
+	else
+		clk_disable_unprepare(rk817->mclk);
+
+	switch (rk817->playback_path) {
+	case OFF:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		if (pre_path != OFF && (pre_path != HP_PATH &&
+			pre_path != HP_NO_MIC && pre_path != RING_HP &&
+			pre_path != RING_HP_NO_MIC)) {
+			rk817_codec_power_down(codec, RK817_CODEC_PLAYBACK);
+			if (rk817->capture_path == 0)
+				rk817_codec_power_down(codec, RK817_CODEC_ALL);
+		}
+		break;
+	case RCV:
+	case SPK_PATH:
+	case RING_SPK:
+#else
+		if (pre_path != OFF && (pre_path != HP_PATH)) {
+			rk817_codec_power_down(codec, RK817_CODEC_PLAYBACK);
+			if (rk817->capture_path == 0)
+				rk817_codec_power_down(codec, RK817_CODEC_ALL);
+		}
+		break;
+	case SPK_PATH:
+#endif
+		if (pre_path == OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_PLAYBACK);
+		if (!rk817->use_ext_amplifier) {
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+				      PWD_DACBIAS_ON | PWD_DACD_ON |
+				      PWD_DACL_ON | PWD_DACR_ON);
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		} else {
+			/* HP_CP_EN , CP 2.3V */
+			snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+			/* power on HP two stage opamp ,HP amplitude 0db */
+			snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+					  PWD_DACBIAS_ON | PWD_DACD_DOWN |
+					  PWD_DACL_ON | PWD_DACR_ON);
+			snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+						DACMT_ENABLE, DACMT_DISABLE);
+		}
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLL, rk817->spk_volume);
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLR, rk817->spk_volume);
+		break;
+	case HP_PATH:
+	case HP_NO_MIC:
+	case RING_HP:
+	case RING_HP_NO_MIC:
+#else
+		break;
+	case HP_PATH:
+#endif
+		if (pre_path == OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_PLAYBACK);
+		/* HP_CP_EN , CP 2.3V */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_DOWN |
+			      PWD_DACL_ON | PWD_DACR_ON);
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_DISABLE);
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLL, rk817->hp_volume);
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLR, rk817->hp_volume);
+		break;
+	case BT:
+		break;
+	case SPK_HP:
+	case RING_SPK_HP:
+#else
+		break;
+	case SPK_HP:
+#endif
+		if (pre_path == OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_PLAYBACK);
+
+		/* HP_CP_EN , CP 2.3V  */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_ON |
+			      PWD_DACL_ON | PWD_DACR_ON);
+
+		if (!rk817->use_ext_amplifier) {
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		}
+
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLL, rk817->hp_volume);
+		snd_soc_write(codec, RK817_CODEC_DDAC_VOLR, rk817->hp_volume);
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk817_capture_path_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s : capture_path %ld\n", __func__,
+	    rk817->capture_path);
+
+	ucontrol->value.integer.value[0] = rk817->capture_path;
+
+	return 0;
+}
+
+static int rk817_capture_path_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	long int pre_path;
+
+	if (rk817->capture_path == ucontrol->value.integer.value[0]) {
+		DBG("%s : capture_path is not changed!\n",
+		    __func__);
+		return 0;
+	}
+
+	pre_path = rk817->capture_path;
+	rk817->capture_path = ucontrol->value.integer.value[0];
+
+	DBG("%s : set capture_path %ld, pre_path %ld\n", __func__,
+	    rk817->capture_path, pre_path);
+
+	if (rk817->capture_path != MIC_OFF)
+		clk_prepare_enable(rk817->mclk);
+	else
+		clk_disable_unprepare(rk817->mclk);
+
+	switch (rk817->capture_path) {
+	case MIC_OFF:
+		if (pre_path != MIC_OFF)
+			rk817_codec_power_down(codec, RK817_CODEC_CAPTURE);
+		break;
+	case MAIN_MIC:
+		if (pre_path == MIC_OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_CAPTURE);
+
+		if (rk817->adc_for_loopback) {
+			/* don't need to gain when adc use for loopback */
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0, 0xf, 0x0);
+			snd_soc_write(codec, RK817_CODEC_DMIC_PGA_GAIN, 0x66);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0x00);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLR, 0x00);
+			break;
+		}
+		if (!rk817->mic_in_differential) {
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0xff);
+			snd_soc_update_bits(codec, RK817_CODEC_AADC_CFG0,
+					    ADC_L_PWD_MASK, ADC_L_PWD_EN);
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+					    PWD_PGA_L_MASK, PWD_PGA_L_EN);
+		}
+		break;
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	case HANDS_FREE_MIC:
+		if (pre_path == MIC_OFF)
+			rk817_codec_power_up(codec, RK817_CODEC_CAPTURE);
+
+		if (rk817->adc_for_loopback) {
+			/* don't need to gain when adc use for loopback */
+			snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0, 0xf, 0x0);
+			snd_soc_write(codec, RK817_CODEC_DMIC_PGA_GAIN, 0x66);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0x00);
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLR, 0x00);
+			break;
+		}
+		if (!rk817->mic_in_differential) {
+			snd_soc_write(codec, RK817_CODEC_DADC_VOLL, 0xff);
+			snd_soc_update_bits(codec, RK817_CODEC_AADC_CFG0,
+	 				    ADC_L_PWD_MASK, ADC_L_PWD_EN);
+	 		snd_soc_update_bits(codec, RK817_CODEC_AMIC_CFG0,
+	 				    PWD_PGA_L_MASK, PWD_PGA_L_EN);
+	 	}
+	 	break;
+	case BT_SCO_MIC:
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct snd_kcontrol_new rk817_snd_path_controls[] = {
+	SOC_ENUM_EXT("Playback Path", rk817_playback_path_type,
+		     rk817_playback_path_get, rk817_playback_path_put),
+
+	SOC_ENUM_EXT("Capture MIC Path", rk817_capture_path_type,
+		     rk817_capture_path_get, rk817_capture_path_put),
+};
+
+static int rk817_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	rk817->stereo_sysclk = freq;
+
+	DBG("%s : MCLK = %dHz\n", __func__, rk817->stereo_sysclk);
+
+	return 0;
+}
+
+static int rk817_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			     unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	unsigned int i2s_mst = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		i2s_mst |= RK817_I2S_MODE_SLV;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2s_mst |= RK817_I2S_MODE_MST;
+		break;
+	default:
+		dev_err(codec->dev, "%s : set master mask failed!\n",
+			__func__);
+		return -EINVAL;
+	}
+	DBG("%s : i2s %s mode\n", __func__,
+	    i2s_mst ? "master" : "slave");
+
+	snd_soc_update_bits(codec, RK817_CODEC_DI2S_CKM,
+			    RK817_I2S_MODE_MASK, i2s_mst);
+
+	return 0;
+}
+
+static int rk817_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+	unsigned int rate = params_rate(params);
+
+	DBG("%s : MCLK = %dHz, sample rate = %dHz\n",
+	    __func__, rk817->stereo_sysclk, rate);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		snd_soc_write(codec, RK817_CODEC_DI2S_RXCR2, VDW_RX_16BITS);
+		snd_soc_write(codec, RK817_CODEC_DI2S_TXCR2, VDW_TX_16BITS);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		snd_soc_write(codec, RK817_CODEC_DI2S_RXCR2, VDW_RX_24BITS);
+		snd_soc_write(codec, RK817_CODEC_DI2S_TXCR2, VDW_TX_24BITS);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk817_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s %d\n", __func__, mute);
+	if (mute)
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_ENABLE);
+	else
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_DISABLE);
+
+	if (mute) {
+		rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
+		rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 0);
+	} else {
+		switch (rk817->playback_path) {
+		case SPK_PATH:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		case RING_SPK:
+#endif
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 0);
+			break;
+		case HP_PATH:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		case HP_NO_MIC:
+		case RING_HP:
+		case RING_HP_NO_MIC:
+#endif
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 0);
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 1);
+			break;
+		case SPK_HP:
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+		case RING_SPK_HP:
+#endif
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_SPK, 1);
+			rk817_codec_ctl_gpio(rk817, CODEC_SET_HP, 1);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+#define RK817_PLAYBACK_RATES (SNDRV_PCM_RATE_8000 |\
+			      SNDRV_PCM_RATE_16000 |	\
+			      SNDRV_PCM_RATE_32000 |	\
+			      SNDRV_PCM_RATE_44100 |	\
+			      SNDRV_PCM_RATE_48000 |	\
+			      SNDRV_PCM_RATE_96000)
+
+#define RK817_CAPTURE_RATES (SNDRV_PCM_RATE_8000 |\
+			      SNDRV_PCM_RATE_16000 |	\
+			      SNDRV_PCM_RATE_32000 |	\
+			      SNDRV_PCM_RATE_44100 |	\
+			      SNDRV_PCM_RATE_48000 |	\
+			      SNDRV_PCM_RATE_96000)
+
+#define RK817_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
+			SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE |\
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_ops rk817_dai_ops = {
+	.hw_params	= rk817_hw_params,
+	.set_fmt	= rk817_set_dai_fmt,
+	.set_sysclk	= rk817_set_dai_sysclk,
+	.digital_mute	= rk817_digital_mute,
+};
+
+static struct snd_soc_dai_driver rk817_dai[] = {
+	{
+		.name = "rk817-hifi",
+		.id = RK817_HIFI,
+		.playback = {
+			.stream_name = "HiFi Playback",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = RK817_PLAYBACK_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.capture = {
+			.stream_name = "HiFi Capture",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = RK817_CAPTURE_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.ops = &rk817_dai_ops,
+	},
+	{
+		.name = "rk817-voice",
+		.id = RK817_VOICE,
+		.playback = {
+			.stream_name = "Voice Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = RK817_PLAYBACK_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Voice Capture",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = RK817_CAPTURE_RATES,
+			.formats = RK817_FORMATS,
+		},
+		.ops = &rk817_dai_ops,
+	},
+
+};
+
+static int rk817_suspend(struct snd_soc_codec *codec)
+{
+	rk817_codec_power_down(codec, RK817_CODEC_ALL);
+	return 0;
+}
+
+static int rk817_resume(struct snd_soc_codec *codec)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	rk817_codec_power_up(codec, RK817_CODEC_ALL);
+
+	DBG("[%s] playback path %ld, spk %d, hp %d\n", __func__,
+		rk817->playback_path,
+		rk817->spk_volume, rk817->hp_volume);
+
+	switch (rk817->playback_path) {
+	case OFF:
+		break;
+	case SPK_PATH:
+		if (!rk817->use_ext_amplifier) {
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+				      PWD_DACBIAS_ON | PWD_DACD_ON |
+				      PWD_DACL_ON | PWD_DACR_ON);
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		} else {
+			/* HP_CP_EN , CP 2.3V */
+			snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+			/* power on HP two stage opamp ,HP amplitude 0db */
+			snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+			/* power on dac ibias/l/r */
+			snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+					  PWD_DACBIAS_ON | PWD_DACD_DOWN |
+					  PWD_DACL_ON | PWD_DACR_ON);
+			snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+						DACMT_ENABLE, DACMT_DISABLE);
+		}
+		break;
+	case HP_PATH:
+		/* HP_CP_EN , CP 2.3V */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_DOWN |
+			      PWD_DACL_ON | PWD_DACR_ON);
+		snd_soc_update_bits(codec, RK817_CODEC_DDAC_MUTE_MIXCTL,
+				    DACMT_ENABLE, DACMT_DISABLE);
+		break;
+	case SPK_HP:
+		/* HP_CP_EN , CP 2.3V  */
+		snd_soc_write(codec, RK817_CODEC_AHP_CP, 0x11);
+		/* power on HP two stage opamp ,HP amplitude 0db */
+		snd_soc_write(codec, RK817_CODEC_AHP_CFG0, 0x80);
+
+		/* power on dac ibias/l/r */
+		snd_soc_write(codec, RK817_CODEC_ADAC_CFG1,
+			      PWD_DACBIAS_ON | PWD_DACD_ON |
+			      PWD_DACL_ON | PWD_DACR_ON);
+
+		if (!rk817->use_ext_amplifier) {
+			/* CLASS D mode */
+			snd_soc_write(codec, RK817_CODEC_DDAC_MUTE_MIXCTL, 0x10);
+			/* CLASS D enable */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG1, 0xa5);
+			/* restart CLASS D, OCPP/N */
+			snd_soc_write(codec, RK817_CODEC_ACLASSD_CFG2, 0xc4);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk817_probe(struct snd_soc_codec *codec)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s\n", __func__);
+
+	if (!rk817) {
+		dev_err(codec->dev, "%s : rk817 priv is NULL!\n",
+			__func__);
+		return -EINVAL;
+	}
+	rk817->codec = codec;
+	rk817->playback_path = OFF;
+	rk817->capture_path = MIC_OFF;
+
+	rk817_reset(codec);
+
+	snd_soc_add_codec_controls(codec, rk817_snd_path_controls,
+				   ARRAY_SIZE(rk817_snd_path_controls));
+	return 0;
+}
+
+/* power down chip */
+static int rk817_remove(struct snd_soc_codec *codec)
+{
+	struct rk817_codec_priv *rk817 = snd_soc_codec_get_drvdata(codec);
+
+	DBG("%s\n", __func__);
+
+	if (!rk817) {
+		dev_err(codec->dev, "%s : rk817 is NULL\n", __func__);
+		return 0;
+	}
+
+	rk817_codec_power_down(codec, RK817_CODEC_ALL);
+	mdelay(10);
+
+	return 0;
+}
+
+static struct regmap *rk817_get_regmap(struct device *dev)
+{
+	struct rk817_codec_priv *rk817 = dev_get_drvdata(dev);
+
+	return rk817->regmap;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_rk817 = {
+	.probe = rk817_probe,
+	.remove = rk817_remove,
+	.get_regmap = rk817_get_regmap,
+	.suspend = rk817_suspend,
+	.resume = rk817_resume,
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	.component_driver = {
+		.controls = rk817_dac_controls,
+		.num_controls = ARRAY_SIZE(rk817_dac_controls),
+	}
+#endif
+};
+
+static int rk817_codec_parse_dt_property(struct device *dev,
+					 struct rk817_codec_priv *rk817)
+{
+	struct device_node *node = dev->parent->of_node;
+	int ret;
+
+	DBG("%s()\n", __func__);
+
+	if (!node) {
+		dev_err(dev, "%s() dev->parent->of_node is NULL\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	node = of_get_child_by_name(dev->parent->of_node, "codec");
+	if (!node) {
+		dev_err(dev, "%s() Can not get child: codec\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	rk817->hp_ctl_gpio = devm_gpiod_get_optional(dev, "hp-ctl",
+						  GPIOD_OUT_LOW);
+	if (!IS_ERR_OR_NULL(rk817->hp_ctl_gpio)) {
+		DBG("%s : hp-ctl-gpio %d\n", __func__,
+		    desc_to_gpio(rk817->hp_ctl_gpio));
+	}
+
+	rk817->spk_ctl_gpio = devm_gpiod_get_optional(dev, "spk-ctl",
+						  GPIOD_OUT_LOW);
+	if (!IS_ERR_OR_NULL(rk817->spk_ctl_gpio)) {
+		DBG("%s : spk-ctl-gpio %d\n", __func__,
+		    desc_to_gpio(rk817->spk_ctl_gpio));
+	}
+
+	ret = of_property_read_u32(node, "spk-mute-delay-ms",
+				   &rk817->spk_mute_delay);
+	if (ret < 0) {
+		DBG("%s() Can not read property spk-mute-delay-ms\n",
+			__func__);
+		rk817->spk_mute_delay = 0;
+	}
+
+	ret = of_property_read_u32(node, "hp-mute-delay-ms",
+				   &rk817->hp_mute_delay);
+	if (ret < 0) {
+		DBG("%s() Can not read property hp-mute-delay-ms\n",
+		    __func__);
+		rk817->hp_mute_delay = 0;
+	}
+	DBG("spk mute delay %dms --- hp mute delay %dms\n",
+	    rk817->spk_mute_delay, rk817->hp_mute_delay);
+
+	ret = of_property_read_u32(node, "spk-volume", &rk817->spk_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property spk-volume\n", __func__);
+		rk817->spk_volume = OUT_VOLUME;
+	}
+	if (rk817->spk_volume < 3)
+		rk817->spk_volume = 3;
+
+	ret = of_property_read_u32(node, "hp-volume",
+				   &rk817->hp_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property hp-volume\n",
+		    __func__);
+		rk817->hp_volume = OUT_VOLUME;
+	}
+	if (rk817->hp_volume < 3)
+		rk817->hp_volume = 3;
+
+	ret = of_property_read_u32(node, "capture-volume",
+				   &rk817->capture_volume);
+	if (ret < 0) {
+		DBG("%s() Can not read property capture-volume\n",
+		    __func__);
+		rk817->capture_volume = CAPTURE_VOLUME;
+	}
+
+	rk817->mic_in_differential =
+			of_property_read_bool(node, "mic-in-differential");
+
+	rk817->pdmdata_out_enable =
+			of_property_read_bool(node, "pdmdata-out-enable");
+
+	rk817->use_ext_amplifier =
+			of_property_read_bool(node, "use-ext-amplifier");
+
+	rk817->adc_for_loopback =
+			of_property_read_bool(node, "adc-for-loopback");
+
+	return 0;
+}
+
+static const struct regmap_config rk817_codec_regmap_config = {
+	.name = "rk817-codec",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.reg_stride = 1,
+	.max_register = 0x4f,
+	.cache_type = REGCACHE_NONE,
+	.volatile_reg = rk817_volatile_register,
+	.writeable_reg = rk817_codec_register,
+	.readable_reg = rk817_codec_register,
+	.reg_defaults = rk817_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rk817_reg_defaults),
+};
+
+static int rk817_platform_probe(struct platform_device *pdev)
+{
+	struct rk808 *rk817 = dev_get_drvdata(pdev->dev.parent);
+	struct rk817_codec_priv *rk817_codec_data;
+	int ret;
+
+	DBG("%s\n", __func__);
+
+	if (!rk817) {
+		dev_err(&pdev->dev, "%s : rk817 is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	rk817_codec_data = devm_kzalloc(&pdev->dev,
+					sizeof(struct rk817_codec_priv),
+					GFP_KERNEL);
+	if (!rk817_codec_data)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, rk817_codec_data);
+
+	ret = rk817_codec_parse_dt_property(&pdev->dev, rk817_codec_data);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "%s() parse device tree property error %d\n",
+			__func__, ret);
+		goto err_;
+	}
+
+	rk817_codec_data->regmap = devm_regmap_init_i2c(rk817->i2c,
+					    &rk817_codec_regmap_config);
+	if (IS_ERR(rk817_codec_data->regmap)) {
+		ret = PTR_ERR(rk817_codec_data->regmap);
+		dev_err(&pdev->dev, "failed to allocate register map: %d\n",
+			ret);
+		goto err_;
+	}
+
+	rk817_codec_data->mclk = devm_clk_get(&pdev->dev, "mclk");
+	if (IS_ERR(rk817_codec_data->mclk)) {
+		dev_err(&pdev->dev, "Unable to get mclk\n");
+		ret = -ENXIO;
+		goto err_;
+	}
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_rk817,
+				     rk817_dai, ARRAY_SIZE(rk817_dai));
+	if (ret < 0) {
+		dev_err(&pdev->dev, "%s() register codec error %d\n",
+			__func__, ret);
+		goto err_;
+	}
+
+	return 0;
+err_:
+
+	return ret;
+}
+
+static int rk817_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+
+	return 0;
+}
+
+static void rk817_platform_shutdown(struct platform_device *pdev)
+{
+	struct rk817_codec_priv *rk817 = dev_get_drvdata(&pdev->dev);
+
+	DBG("%s\n", __func__);
+
+	rk817_codec_power_down(rk817->codec, RK817_CODEC_ALL);
+
+}
+
+static const struct of_device_id rk817_codec_dt_ids[] = {
+	{ .compatible = "rockchip,rk817-codec" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk817_codec_dt_ids);
+
+static struct platform_driver rk817_codec_driver = {
+	.driver = {
+		   .name = "rk817-codec",
+		   .of_match_table = rk817_codec_dt_ids,
+		   },
+	.probe = rk817_platform_probe,
+	.remove = rk817_platform_remove,
+	.shutdown = rk817_platform_shutdown,
+};
+
+module_platform_driver(rk817_codec_driver);
+
+MODULE_DESCRIPTION("ASoC RK817 codec driver");
+MODULE_AUTHOR("binyuan <kevan.lan@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/rk817_codec.h b/sound/soc/codecs/rk817_codec.h
new file mode 100755
index 000000000000..c1079dba45cb
--- /dev/null
+++ b/sound/soc/codecs/rk817_codec.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __RK817_CODEC_H__
+#define __RK817_CODEC_H__
+
+/* codec register */
+#define RK817_CODEC_BASE		0x0000
+
+#define RK817_CODEC_DTOP_VUCTL		(RK817_CODEC_BASE + 0x12)
+#define RK817_CODEC_DTOP_VUCTIME	(RK817_CODEC_BASE + 0x13)
+#define RK817_CODEC_DTOP_LPT_SRST	(RK817_CODEC_BASE + 0x14)
+#define RK817_CODEC_DTOP_DIGEN_CLKE	(RK817_CODEC_BASE + 0x15)
+#define RK817_CODEC_AREF_RTCFG0		(RK817_CODEC_BASE + 0x16)
+#define RK817_CODEC_AREF_RTCFG1		(RK817_CODEC_BASE + 0x17)
+#define RK817_CODEC_AADC_CFG0		(RK817_CODEC_BASE + 0x18)
+#define RK817_CODEC_AADC_CFG1		(RK817_CODEC_BASE + 0x19)
+#define RK817_CODEC_DADC_VOLL		(RK817_CODEC_BASE + 0x1a)
+#define RK817_CODEC_DADC_VOLR		(RK817_CODEC_BASE + 0x1b)
+#define RK817_CODEC_DADC_SR_ACL0	(RK817_CODEC_BASE + 0x1e)
+#define RK817_CODEC_DADC_ALC1		(RK817_CODEC_BASE + 0x1f)
+#define RK817_CODEC_DADC_ALC2		(RK817_CODEC_BASE + 0x20)
+#define RK817_CODEC_DADC_NG		(RK817_CODEC_BASE + 0x21)
+#define RK817_CODEC_DADC_HPF		(RK817_CODEC_BASE + 0x22)
+#define RK817_CODEC_DADC_RVOLL		(RK817_CODEC_BASE + 0x23)
+#define RK817_CODEC_DADC_RVOLR		(RK817_CODEC_BASE + 0x24)
+#define RK817_CODEC_AMIC_CFG0		(RK817_CODEC_BASE + 0x27)
+#define RK817_CODEC_AMIC_CFG1		(RK817_CODEC_BASE + 0x28)
+#define RK817_CODEC_DMIC_PGA_GAIN	(RK817_CODEC_BASE + 0x29)
+#define RK817_CODEC_DMIC_LMT1		(RK817_CODEC_BASE + 0x2a)
+#define RK817_CODEC_DMIC_LMT2		(RK817_CODEC_BASE + 0x2b)
+#define RK817_CODEC_DMIC_NG1		(RK817_CODEC_BASE + 0x2c)
+#define RK817_CODEC_DMIC_NG2		(RK817_CODEC_BASE + 0x2d)
+#define RK817_CODEC_ADAC_CFG0		(RK817_CODEC_BASE + 0x2e)
+#define RK817_CODEC_ADAC_CFG1		(RK817_CODEC_BASE + 0x2f)
+#define RK817_CODEC_DDAC_POPD_DACST	(RK817_CODEC_BASE + 0x30)
+#define RK817_CODEC_DDAC_VOLL		(RK817_CODEC_BASE + 0x31)
+#define RK817_CODEC_DDAC_VOLR		(RK817_CODEC_BASE + 0x32)
+#define RK817_CODEC_DDAC_SR_LMT0	(RK817_CODEC_BASE + 0x35)
+#define RK817_CODEC_DDAC_LMT1		(RK817_CODEC_BASE + 0x36)
+#define RK817_CODEC_DDAC_LMT2		(RK817_CODEC_BASE + 0x37)
+#define RK817_CODEC_DDAC_MUTE_MIXCTL	(RK817_CODEC_BASE + 0x38)
+#define RK817_CODEC_DDAC_RVOLL		(RK817_CODEC_BASE + 0x39)
+#define RK817_CODEC_DDAC_RVOLR		(RK817_CODEC_BASE + 0x3a)
+#define RK817_CODEC_AHP_ANTI0		(RK817_CODEC_BASE + 0x3b)
+#define RK817_CODEC_AHP_ANTI1		(RK817_CODEC_BASE + 0x3c)
+#define RK817_CODEC_AHP_CFG0		(RK817_CODEC_BASE + 0x3d)
+#define RK817_CODEC_AHP_CFG1		(RK817_CODEC_BASE + 0x3e)
+#define RK817_CODEC_AHP_CP		(RK817_CODEC_BASE + 0x3f)
+#define RK817_CODEC_ACLASSD_CFG1	(RK817_CODEC_BASE + 0x40)
+#define RK817_CODEC_ACLASSD_CFG2	(RK817_CODEC_BASE + 0x41)
+#define RK817_CODEC_APLL_CFG0		(RK817_CODEC_BASE + 0x42)
+#define RK817_CODEC_APLL_CFG1		(RK817_CODEC_BASE + 0x43)
+#define RK817_CODEC_APLL_CFG2		(RK817_CODEC_BASE + 0x44)
+#define RK817_CODEC_APLL_CFG3		(RK817_CODEC_BASE + 0x45)
+#define RK817_CODEC_APLL_CFG4		(RK817_CODEC_BASE + 0x46)
+#define RK817_CODEC_APLL_CFG5		(RK817_CODEC_BASE + 0x47)
+#define RK817_CODEC_DI2S_CKM		(RK817_CODEC_BASE + 0x48)
+#define RK817_CODEC_DI2S_RSD		(RK817_CODEC_BASE + 0x49)
+#define RK817_CODEC_DI2S_RXCR1		(RK817_CODEC_BASE + 0x4a)
+#define RK817_CODEC_DI2S_RXCR2		(RK817_CODEC_BASE + 0x4b)
+#define RK817_CODEC_DI2S_RXCMD_TSD	(RK817_CODEC_BASE + 0x4c)
+#define RK817_CODEC_DI2S_TXCR1		(RK817_CODEC_BASE + 0x4d)
+#define RK817_CODEC_DI2S_TXCR2		(RK817_CODEC_BASE + 0x4e)
+#define RK817_CODEC_DI2S_TXCR3_TXCMD	(RK817_CODEC_BASE + 0x4f)
+
+/* RK817_CODEC_DTOP_DIGEN_CLKE */
+#define ADC_DIG_CLK_MASK		(0xf << 4)
+#define ADC_DIG_CLK_SFT			4
+#define ADC_DIG_CLK_DIS			(0x0 << 4)
+#define ADC_DIG_CLK_EN			(0xf << 4)
+
+#define DAC_DIG_CLK_MASK		(0xf << 0)
+#define DAC_DIG_CLK_SFT			0
+#define DAC_DIG_CLK_DIS			(0x0 << 0)
+#define DAC_DIG_CLK_EN			(0xf << 0)
+
+/* RK817_CODEC_APLL_CFG5 */
+#define PLL_PW_DOWN			(0x01 << 0)
+#define PLL_PW_UP			(0x00 << 0)
+
+/* RK817_CODEC_DI2S_CKM */
+#define PDM_EN_MASK			(0x1 << 3)
+#define PDM_EN_SFT			3
+#define PDM_EN_DISABLE			(0x0 << 3)
+#define PDM_EN_ENABLE			(0x1 << 3)
+
+#define SCK_EN_ENABLE			(0x1 << 2)
+#define SCK_EN_DISABLE			(0x0 << 2)
+
+#define RK817_I2S_MODE_MASK		(0x1 << 0)
+#define RK817_I2S_MODE_SFT		0
+#define RK817_I2S_MODE_MST		(0x1 << 0)
+#define RK817_I2S_MODE_SLV		(0x0 << 0)
+
+/* RK817_CODEC_DDAC_MUTE_MIXCTL */
+#define DACMT_ENABLE			(0x1 << 0)
+#define DACMT_DISABLE			(0x0 << 0)
+
+/* RK817_CODEC_DI2S_RXCR2 */
+#define VDW_RX_24BITS			(0x17)
+#define VDW_RX_16BITS			(0x0f)
+/* RK817_CODEC_DI2S_TXCR2 */
+#define VDW_TX_24BITS			(0x17)
+#define VDW_TX_16BITS			(0x0f)
+
+/* RK817_CODEC_AHP_CFG1 */
+#define HP_ANTIPOP_ENABLE		(0x1 << 4)
+#define HP_ANTIPOP_DISABLE		(0x0 << 4)
+
+/* RK817_CODEC_ADAC_CFG1 */
+#define PWD_DACBIAS_MASK		(0x1 << 3)
+#define PWD_DACBIAS_SFT			3
+#define PWD_DACBIAS_DOWN		(0x1 << 3)
+#define PWD_DACBIAS_ON			(0x0 << 3)
+
+#define PWD_DACD_MASK			(0x1 << 2)
+#define PWD_DACD_SFT			2
+#define PWD_DACD_DOWN			(0x1 << 2)
+#define PWD_DACD_ON			(0x0 << 2)
+
+#define PWD_DACL_MASK			(0x1 << 1)
+#define PWD_DACL_SFT			1
+#define PWD_DACL_DOWN			(0x1 << 1)
+#define PWD_DACL_ON			(0x0 << 1)
+
+#define PWD_DACR_MASK			(0x1 << 0)
+#define PWD_DACR_SFT			0
+#define PWD_DACR_DOWN			(0x1 << 0)
+#define PWD_DACR_ON			(0x0 << 0)
+
+/* RK817_CODEC_AADC_CFG0 */
+#define ADC_L_PWD_MASK			(0x1 << 7)
+#define ADC_L_PWD_SFT			7
+#define ADC_L_PWD_DIS			(0x0 << 7)
+#define ADC_L_PWD_EN			(0x1 << 7)
+
+#define ADC_R_PWD_MASK			(0x1 << 6)
+#define ADC_R_PWD_SFT			6
+#define ADC_R_PWD_DIS			(0x0 << 6)
+#define ADC_R_PWD_EN			(0x1 << 6)
+
+/* RK817_CODEC_AMIC_CFG0 */
+#define MIC_DIFF_MASK			(0x1 << 7)
+#define MIC_DIFF_SFT			7
+#define MIC_DIFF_DIS			(0x0 << 7)
+#define MIC_DIFF_EN			(0x1 << 7)
+
+#define PWD_PGA_L_MASK			(0x1 << 5)
+#define PWD_PGA_L_SFT			5
+#define PWD_PGA_L_DIS			(0x0 << 5)
+#define PWD_PGA_L_EN			(0x1 << 5)
+
+#define PWD_PGA_R_MASK			(0x1 << 4)
+#define PWD_PGA_R_SFT			4
+#define PWD_PGA_R_DIS			(0x0 << 4)
+#define PWD_PGA_R_EN			(0x1 << 4)
+
+enum {
+	RK817_HIFI,
+	RK817_VOICE,
+};
+
+enum {
+	RK817_MONO = 1,
+	RK817_STEREO,
+};
+
+enum {
+	OFF,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	RCV,
+#endif
+	SPK_PATH,
+	HP_PATH,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	HP_NO_MIC,
+	BT,
+#endif
+	SPK_HP,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	RING_SPK,
+	RING_HP,
+	RING_HP_NO_MIC,
+	RING_SPK_HP,
+#endif
+};
+
+enum {
+	MIC_OFF,
+	MAIN_MIC,
+#ifndef CONFIG_ARCH_MESON64_ODROID_COMMON
+	HANDS_FREE_MIC,
+	BT_SCO_MIC,
+#endif
+};
+
+struct rk817_reg_val_typ {
+	unsigned int reg;
+	unsigned int value;
+};
+
+struct rk817_init_bit_typ {
+	unsigned int reg;
+	unsigned int power_bit;
+	unsigned int init_bit;
+};
+
+#endif /* __RK817_CODEC_H__ */
-- 
2.38.0

